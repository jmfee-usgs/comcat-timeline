require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
!function() {
  var d3 = {
    version: "3.5.17"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.transpose = function(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  };
  function d3_transposeLength(d) {
    return d.length;
  }
  d3.zip = function() {
    return d3.transpose(arguments);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: d3_nsXhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = d3_array(nodes);
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < ε2) {
      S = Math.log(w1 / w0) / ρ;
      i = function(t) {
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / ρ;
      i = function(t) {
        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      };
    }
    i.duration = S * 1e3;
    return i;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: null
      };
      scaleTo(+_);
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function() {
    d3_timer.apply(this, arguments);
  };
  function d3_timer(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
    return timer;
  }
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now(), timer = d3_timer_queueHead;
    while (timer) {
      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
      timer = timer.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.c) {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      } else {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value = +value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      if (F > 0) {
        if (φ < -halfπ + ε) φ = -halfπ + ε;
      } else {
        if (φ > halfπ - ε) φ = halfπ - ε;
      }
      var ρ = F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransformPop(s) {
    return s.length ? s.pop() + "," : "";
  }
  function d3_interpolateTranslate(ta, tb, s, q) {
    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
      var i = s.push("translate(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    }
  }
  function d3_interpolateRotate(ra, rb, s, q) {
    if (ra !== rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
  }
  function d3_interpolateSkew(wa, wb, s, q) {
    if (wa !== wb) {
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
  }
  function d3_interpolateScale(ka, kb, s, q) {
    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] !== 1 || kb[1] !== 1) {
      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
  }
  function d3_interpolateTransform(a, b) {
    var s = [], q = [];
    a = d3.transform(a), b = d3.transform(b);
    d3_interpolateTranslate(a.translate, b.translate, s, q);
    d3_interpolateRotate(a.rotate, b.rotate, s, q);
    d3_interpolateSkew(a.skew, b.skew, s, q);
    d3_interpolateScale(a.scale, b.scale, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        timer = null;
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) {
          alpha = x;
        } else {
          timer.c = null, timer.t = NaN, timer = null;
          event.end({
            type: "end",
            alpha: alpha = 0
          });
        }
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        timer = d3_timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = root.y = 0;
      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    return domain;
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(1, base * n / scale.ticks().length);
      return function(d) {
        var i = d / pow(Math.round(log(d)));
        if (i * base < base - .5) i *= base;
        return i <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var rc1 = rc, rc0 = rc;
        if (da < π) {
          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
        if (x1 != null) {
          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.length > 1 ? points.join("L") : points + "Z";
  }
  function d3_svg_lineLinearClosed(points) {
    return points.join("L") + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - halfπ;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, activeId, active;
      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
        active.timer.c = null;
        active.timer.t = NaN;
        if (--lock.count) delete lock[activeId]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id], time, timer, duration, ease, tweens;
    function schedule(elapsed) {
      var delay = transition.delay;
      timer.t = delay + time;
      if (delay <= elapsed) return start(elapsed - delay);
      timer.c = start;
    }
    function start(elapsed) {
      var activeId = lock.active, active = lock[activeId];
      if (active) {
        active.timer.c = null;
        active.timer.t = NaN;
        --lock.count;
        delete lock[activeId];
        active.event && active.event.interrupt.call(node, node.__data__, active.index);
      }
      for (var cancelId in lock) {
        if (+cancelId < id) {
          var cancel = lock[cancelId];
          cancel.timer.c = null;
          cancel.timer.t = NaN;
          --lock.count;
          delete lock[cancelId];
        }
      }
      timer.c = tick;
      d3_timer(function() {
        if (timer.c && tick(elapsed || 1)) {
          timer.c = null;
          timer.t = NaN;
        }
        return 1;
      }, 0, time);
      lock.active = id;
      transition.event && transition.event.start.call(node, node.__data__, i);
      tweens = [];
      transition.tween.forEach(function(key, value) {
        if (value = value.call(node, node.__data__, i)) {
          tweens.push(value);
        }
      });
      ease = transition.ease;
      duration = transition.duration;
    }
    function tick(elapsed) {
      var t = elapsed / duration, e = ease(t), n = tweens.length;
      while (n > 0) {
        tweens[--n].call(node, e);
      }
      if (t >= 1) {
        transition.event && transition.event.end.call(node, node.__data__, i);
        if (--lock.count) delete lock[id]; else delete node[ns];
        return 1;
      }
    }
    if (!transition) {
      time = inherit.time;
      timer = d3_timer(schedule, 0, time);
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        timer: timer,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = d3_array(arguments);
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (typeof define === "function" && define.amd) this.d3 = d3, define(d3); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
}();
},{}],2:[function(require,module,exports){
'use strict';

var _ACCORDION_OPTIONS,
    _ADD_ACCORDION_OPTIONS,
    _ACCORDION_CLOSED,
    _ACCORDION_TOGGLE,
    _ACCORDION_CONTENT;


_ACCORDION_OPTIONS = {
  accordions: null,
  el: null
};

_ADD_ACCORDION_OPTIONS = {
  toggleText: 'Details',
  toggleElement: 'span',
  content: 'Contents',
  classes: 'accordion-standard'
};

_ACCORDION_CLOSED = 'accordion-closed';
_ACCORDION_TOGGLE = 'accordion-toggle';
_ACCORDION_CONTENT = 'accordion-content';


/**
 * Copy properties from one or more objects onto another object.
 *
 * @param dst {Object}
 *        Destination object where properties are copied
 * @param varargs {Object...}
 *        Variable number of objects where properties are copied from.
 *        Objects earlier in the arguments list have their properties
 *        overridden by objects later in the arguments list.
 * @return dst.
 */
var _extend = function (dst) {
  for (var i=1, len=arguments.length; i<len; i++) {
    var o = arguments[i];
    for (var prop in o) {
      dst[prop] = o[prop];
    }
  }
  return dst;
};

var _onClick = function (evt) {
  var target = evt.target;

  if (target.classList.contains(_ACCORDION_TOGGLE)) {
    target.parentElement.classList.toggle(_ACCORDION_CLOSED);
  }
};


var Accordion = function (options) {
  var _this,
      _initialize,

      _el,
      _options;


  _this = {
    addAccordion: null,
    destroy: null
  };

  _initialize = function (options) {
    var i,
        len;

    _options = _extend({}, _ACCORDION_OPTIONS, options);
    _el = _options.el || document.createElement('section');
    _el.addEventListener('click', _onClick);

    if (options.accordions) {
      len = options.accordions.length;
      for (i = 0; i < len; i++) {
        _this.addAccordion(options.accordions[i]);
      }
    }
  };


  /*
   * this will build the markup for an accordion element
   */
  _this.addAccordion = function (options) {
    var accordion,
        title,
        content;

    options = _extend({}, _ADD_ACCORDION_OPTIONS, options);

    accordion = document.createElement('section');
    accordion.className = 'accordion ' + options.classes;

    title = document.createElement(options.toggleElement);
    title.className = _ACCORDION_TOGGLE;
    title.innerHTML = options.toggleText;
    accordion.appendChild(title);

    content = document.createElement('div');
    content.className = _ACCORDION_CONTENT;

    // Support legacy "contentText" if still present, but prefert "content"
    if (options.contentText) {
      content.innerHTML = options.contentText;
    } else {
      // Check if string content or DOM content
      if (typeof options.content === 'string') {
        content.innerHTML = options.content;
      } else {
        content.appendChild(options.content);
      }
    }

    accordion.appendChild(content);

    _el.appendChild(accordion);
  };

  _this.destroy = function () {
    _el.removeEventListener('click', _onClick);

    _el = null;
    _options = null;

    _this = null;
  };


  _initialize(options);
  options = null;
  return _this;
};

module.exports = Accordion;

},{}],3:[function(require,module,exports){
'use strict';



/**
 * Simulates a class list.
 *
 * If changes are made outside this object, resync using synchronize().
 */
var ClassList = function (el) {
  var _this,
      _initialize,
      // variables
      _classList,
      _syncValue,
      // methods
      _sync;


  _this = {};

  /**
   * Initialize ClassList.
   */
  _initialize = function () {
    _syncValue = null;
    _classList = [];
    _this.length = 0;

    _sync(true);
  };


  /**
   * Synchronize with element state.
   *
   * @param load {Boolean}
   *        when true, read state from element.
   *        otherwise, set element state.
   */
  _sync = function (load) {
    var value;

    if (load) {
      // read from element
      value = el.getAttribute('class');
      if (value === null) {
        _classList = [];
        _this.length = 0;
      } else {
        value = '' + value;
        _classList = value.split(' ');
        _this.length = _classList.length;
      }
    } else {
      // update element
      value = _classList.join(' ');
      el.setAttribute('class', value);
    }
    _syncValue = value;
  };

  /**
   * Add a class.
   *
   * @param className {String}
   *        class to add.
   */
  _this.add = function (className) {
    var pos;
    // load from element
    _sync(true);
    pos = _classList.indexOf(className);
    if (pos === -1) {
      _classList.push(className);
      _this.length++;
      // update element
      _sync(false);
    }
  };

  /**
   * Check if element has a class.
   *
   * @param className {String}
   *        class to add.
   * @return {Boolean}
   *         true if element list includes class.
   */
  _this.contains = function (className) {
    var pos;
    // load from element
    _sync(true);
    pos = _classList.indexOf(className);
    return (pos !== -1);
  };

  /**
   * Access a class.
   *
   * @param pos {String}
   *        index in list [0,ClassList.length-1].
   * @return className in list, or null if out of range.
   */
  _this.item = function (pos) {
    // load from element
    _sync(true);
    if (pos < 0 || pos >= _classList.length) {
      return null;
    }
    return _classList[pos];
  };

  /**
   * Remove a class.
   *
   * @param className {String}
   *        class to remove.
   */
  _this.remove = function (className) {
    var pos;
    // load from element
    _sync(true);
    pos = _classList.indexOf(className);
    if (pos !== -1) {
      _classList.splice(pos, 1);
      _this.length--;
      // update element
      _sync(false);
    }
  };

  /**
   * Toggle a class.
   *
   * Add is not in list, otherwise remove.
   *
   * @param className {String}
   *        class to add.
   */
  _this.toggle = function (className) {
    if (_this.has(className)) {
      _this.remove(className);
    } else {
      _this.add(className);
    }
  };


  _initialize();
  return _this;
};


/**
 * Add classList if element doesn't natively support classList.
 *
 * Some SVG implementations do not support classList.
 *
 * @param el {Element}
 *        element to polyfill.
 */
ClassList.polyfill = function (el) {
  if (!el.classList) {
    el.classList = ClassList(el);
  }
};


module.exports = ClassList;

},{}],4:[function(require,module,exports){
'use strict';

var d3 = require('d3'),
    ClassList = require('./ClassList'),
    D3SubView = require('d3/D3SubView'),
    Util = require('util/Util');


/**
 * Line view for a D3 plot.
 *
 * @param options {Object}
 *        options are passed to D3SubView.
 * @param options.data {Array<Array<Number>>}
 *        default [].
 *        array of arrays of x, y coordinates:
 *        [ [x0, y0], [x1, y1], ... ]
 * @param lineFormat {D3 Line}
 *        default d3.svg.line().
 * @param pointRadius {Number}
 *        default 5.
 *        radius for points.
 * @param showLine {Boolean}
 *        default true.
 *        whether to plot line.
 * @param showPoints {Boolean}
 *        default true.
 *        whether to plot points.
 */
var D3LineView = function (options) {
  var _this,
      _initialize,
      // variables
      _el,
      _legend,
      _legendLine,
      _legendPoint,
      _legendText,
      _line,
      _lineFormat,
      _x,
      _y,
      // methods
      _getX,
      _getY;


  _this = D3SubView(options);

  /**
   * Initialize view.
   */
  _initialize = function (options) {
    _this.model.set(Util.extend({
      data: [],
      pointRadius: 5,
      showLine: true,
      showPoints: true,
      showLegendPoint: true,
    }, options, _this.model.get()), {silent: true});

    ClassList.polyfill(_this.el);
    _this.el.classList.add('D3LineView');
    _el = d3.select(_this.el);

    if (_this.legend) {
      ClassList.polyfill(_this.legend);
      _this.legend.classList.add('D3LineView');
      _legend = d3.select(_this.legend);
      _legendLine = _legend.append('path')
          .attr('class', 'line');
      _legendText = _legend.append('text')
          .attr('class', 'text');
    } else {
      _legend = null;
      _legendLine = null;
      _legendText = null;
    }

    _line = _el.append('path')
        .attr('class', 'line')
        .attr('clip-path', 'url(#plotAreaClip)');

    _lineFormat = options.lineFormat || d3.svg.line();
    _lineFormat.x(_this.getScaleX);
    _lineFormat.y(_this.getScaleY);
  };

  /**
   * Convert a data coordinate to a plot coordinate.
   *
   * @param d {Array<Number>}
   *        data point.
   * @return {Number} x plot coordinate.
   */
  _this.getScaleX = function (d) {
    return _x(d[0]);
  };

  /**
   * Convert a data coordinate to a plot coordinate.
   *
   * @param d {Array<Number>}
   *        data point.
   * @return {Number} y plot coordinate.
   */
  _this.getScaleY = function (d) {
    return _y(d[1]);
  };

  /**
   * Convert an x data coordinate from a data object.
   *
   * @param d {Array<Number>}
   *        data point.
   * @return {Number} x plot coordinate.
   */
  _getX = function (d) {
    return d[0];
  };

  /**
   * Get a y data coordinate from a data object.
   *
   * @param d {Array<Number>}
   *        data point.
   * @return {Number} y plot coordinate.
   */
  _getY = function (d) {
    return d[1];
  };

  /**
   * Destroy view.
   */
  _this.destroy = Util.compose(function () {
    var points;

    if (_el) {
      // remove point event listeners
      points = _el.selectAll('.point')
          .on('mouseout', null)
          .on('mouseover', null);
      _el = null;
    }

    if (_legend) {
      _legendLine = null;
      _legendText = null;
    }

    _line = null;
    _lineFormat = null;

    _x = null;
    _y = null;
    _this = null;
  }, _this.destroy);

  /**
   * Format x value for tooltip.
   *
   * @param x {Number}
   *        value to format.
   * @return {String}
   *         formatted number.
   */
  _this.formatX = function (x) {
    return x;
  };

  /**
   * Format y value for tooltip.
   *
   * @param y {Number}
   *        value to format.
   * @return {String}
   *         formatted number.
   */
  _this.formatY = function (y) {
    return y;
  };

  /**
   * X extent for view.
   *
   * @return {Array<Number>}
   *         x extent for view.
   */
  _this.getXExtent = function () {
    return d3.extent(_this.model.get('data'), _getX);
  };

  /**
   * Y extent for view.
   *
   * @return {Array<Number>}
   *         y extent for view.
   */
  _this.getYExtent = function () {
    return d3.extent(_this.model.get('data'), _getY);
  };

  /**
   * Point mouseout event handler.
   */
  _this.onPointOut = function () {
    var point;

    point = d3.event.target;
    ClassList.polyfill(point);
    point.classList.remove('mouseover');

    // clear previous tooltip
    _this.view.showTooltip(null, null);
  };

  /**
   * Point mouseover event handler.
   *
   * @param coords {Array<Number>}
   *        x, y coordinate of point.
   */
  _this.onPointOver = function (coords) {
    var point;

    point = d3.event.target;
    ClassList.polyfill(point);
    point.classList.add('mouseover');

    _this.view.showTooltip(coords, [
      {text: _this.model.get('label')},
      [
        {class: 'label', text: _this.view.model.get('xLabel') + ': '},
        {class: 'value', text: _this.formatX(_getX(coords))}
      ],
      [
        {class: 'label', text: _this.view.model.get('yLabel') + ': '},
        {class: 'value', text: _this.formatY(_getY(coords))}
      ]
    ]);
  };

  _this.plotPoints = function (points) {
    points.enter()
        .append('svg:circle')
        .attr('class', 'point')
        .on('mouseout', _this.onPointOut)
        .on('mouseover', _this.onPointOver);

    points.attr('r', _this.model.get('pointRadius'))
        .attr('cx', _this.getScaleX)
        .attr('cy', _this.getScaleY);

    points.exit()
        .on('mouseout', null)
        .on('mouseover', null)
        .remove();
  };

  /**
   * Render sub view.
   * Element has already been attached to view.
   */
  _this.render = function () {
    var data,
        points;

    data = _this.model.get('data');
    _x = _this.view.model.get('xAxisScale');
    _y = _this.view.model.get('yAxisScale');

    // update legend
    if (_this.legend) {
      _legendLine.attr('d', 'M0,-3L25,-3');

      _legendPoint = _legend.selectAll('.point');
      if (!_this.model.get('showLegendPoint')) {
        _legendPoint.remove();
      } else {
        if (_legendPoint.empty()) {
          _legendPoint = _legend.append('svg:circle')
              .attr('class', 'point');
        }

        _legendPoint
            .attr('r', _this.model.get('pointRadius'))
            .attr('cx', 12.5)
            .attr('cy', -3);
      }

      _legendText
          .text(_this.model.get('label'))
          .attr('dx', 30);
    }

    // update line
    if (data.length === 0 || !_this.model.get('showLine')) {
      _line.attr('d', null);
    } else {
      _line.attr('d', _lineFormat(data));
    }

    // update points
    points = _el.selectAll('.point')
        .data(data);
    if (!_this.model.get('showPoints')) {
      points.remove();
    } else {
      _this.plotPoints(points);
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = D3LineView;

},{"./ClassList":3,"d3":1,"d3/D3SubView":5,"util/Util":"util/Util"}],5:[function(require,module,exports){
'use strict';

var d3 = require('d3'),
    ClassList = require('./ClassList'),
    Util = require('util/Util'),
    View = require('mvc/View');


var ID_SEQUENCE = 0;


/**
 * Sub view for a D3 plot.
 *
 * Manages mouseover, mouseout, click events for view.
 * mouseover and mouseout toggle a "mouseover" class on view.
 * click triggers "click" event.
 *
 * When added to a D3View, "click" event triggers "select" in collection.
 * D3View calls onSelect, onDeselect methods when collection selection changes.
 *
 * Subclasses should override at least getXExtent(), getYExtent(), render(view).
 *
 * @param options {Object}
 *        all options are passed to View.
 * @param options.el {SVGElement}
 *        default svg:g.
 * @param options.legend {SVGElement}
 *        default svg:g.
 *        set to null for no legend.
 * @param options.className {String}
 *        default null.
 *        class added to el and legend.
 */
var D3SubView = function (options) {
  var _this,
      _initialize,
      // variables
      _el,
      _legend;


  _this = View(Util.extend({
    el: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
  }, options));

  /**
   * Initialize view.
   */
  _initialize = function (options) {
    options = Util.extend({
      className: null,
      legend: document.createElementNS('http://www.w3.org/2000/svg', 'g')
    }, options);

    // ensure views have a unique id
    _this.id = options.id || (ID_SEQUENCE++);
    _this.view = options.view;

    // reference to view from element
    _this.el.view = _this;

    ClassList.polyfill(_this.el);
    _el = d3.select(_this.el);
    _el.on('click', _this.onClick);
    _el.on('mouseout', _this.onMouseOut);
    _el.on('mouseover', _this.onMouseOver);

    _this.legend = options.legend;
    if (_this.legend) {
      ClassList.polyfill(_this.legend);
      _legend = d3.select(_this.legend);
      _legend.on('click', _this.onClick);
      _legend.on('mouseout', _this.onMouseOut);
      _legend.on('mouseover', _this.onMouseOver);
    }

    if (options.className) {
      _this.el.classList.add(options.className);
      if (_this.legend) {
        _this.legend.classList.add(options.className);
      }
    }
  };

  /**
   * Destroy view.
   */
  _this.destroy = Util.compose(function () {
    if (_this === null) {
      // already destroyed
      return;
    }

    if (_el) {
      _el.on('click', null);
      _el.on('mouseout', null);
      _el.on('mouseover', null);
      _el = null;
    }
    if (_this.legend) {
      _legend.on('click', null);
      _legend.on('mouseout', null);
      _legend.on('mouseover', null);
      _legend = null;
    }

    _this.el.view = null;
    _this = null;
  }, _this.destroy);

  /**
   * X extent for view.
   *
   * @return {Array<Number>}
   *         x extent for view.
   */
  _this.getXExtent = function () {
    return [];
  };

  /**
   * Y extent for view.
   *
   * @return {Array<Number>}
   *         y extent for view.
   */
  _this.getYExtent = function () {
    return [];
  };

  /**
   * Click event handler.
   */
  _this.onClick = function () {
    _this.trigger('click');
  };

  /**
   * Deselect event handler.
   */
  _this.onDeselect = function () {
    _this.el.classList.remove('selected');
    if (_this.legend) {
      _this.legend.classList.remove('selected');
    }
  };

  /**
   * Mouseout event handler.
   */
  _this.onMouseOut = function () {
    _this.el.classList.remove('mouseover');
    if (_this.legend) {
      _this.legend.classList.remove('mouseover');
    }
  };

  /**
   * Mouseover event handler.
   */
  _this.onMouseOver = function () {
    _this.el.classList.add('mouseover');
    if (_this.legend) {
      _this.legend.classList.add('mouseover');
    }
  };

  /**
   * Select event handler.
   */
  _this.onSelect = function () {
    _this.el.classList.add('selected');
    if (_this.legend) {
      _this.legend.classList.add('selected');
    }
  };

  /**
   * Render sub view.
   * Element has already been attached to view.
   */
  _this.render = function () {
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = D3SubView;

},{"./ClassList":3,"d3":1,"mvc/View":"mvc/View","util/Util":"util/Util"}],6:[function(require,module,exports){
'use strict';


/**
 * Format text content.
 *
 * @param el {D3Element}
 *        tooltip container element.
 * @param data {Array<Object|Array>}
 *        data passed to showTooltip.
 *        this implementation expects objects (or arrays of objects):
 *        obj.class {String} class attribute for text|tspan.
 *        obj.text {String} content for text|tspan.
 */
var _formatText = function (el, data) {
  var y;

  // add content to tooltip
  data = data.map(function (line) {
    var text = el.append('text');
    if (typeof line.forEach === 'function') {
      // array of components:
      line.forEach(function (l) {
        text.append('tspan').attr('class', l.class || '').text(l.text);
      });
    } else {
      text.attr('class', line.class || '').text(line.text);
    }
    return text;
  });
  // position lines in tooltip
  y = 0;
  data.forEach(function (line) {
    var bbox = line.node().getBBox();
    y += bbox.height;
    line.attr('y', y);
  });
};

/**
 * Persistently tries to get the bounding box for the given element.
 *
 * @param element {SVGText}
 *      The element for which to get the bounding box.
 * @return {Object}
 *      A bounding box object with x, y, width, height attributes
 */
var _getBBox = function (element) {
  var bbox;

  try {
    bbox = element.getBBox();
  } catch (e) {
    // Ignore
  }

  if (!bbox) {
    try {
      bbox = element.getBoundingClientRect();
    } catch (e) {
      // Ignore
    }
  }

  if (!bbox) {
    bbox = {x: 0, y: 0, width: 0, height: 0};
  }

  return bbox;
};

/**
 * Pad an extent.
 *
 * @param extent {Array<Number>}
 *        first entry should be minimum.
 *        last entry should be maximum.
 * @param amount {Number}
 *        percentage of range to pad.
 *        For example: 0.05 = +/- 5% of range.
 * @return {Array<Number>}
 *         padded extent.
 */
var _padExtent = function (extent, amount) {
  var start = extent[0],
      end = extent[extent.length - 1],
      range = end - start,
      pad = range * amount;
  return [start - pad, end + pad];
};

/**
 * Pad a log based extent.
 *
 * Similar to _padExtent(), but padding occurs in log space.
 *
 * @param extent {Array<Number>}
 *        first entry should be minimum.
 *        last entry should be maximum.
 * @param amount {Number}
 *        percentage of range to pad.
 *        For example: 0.05 = +/- 5% of range.
 * @return {Array<Number>}
 *         padded extent.
 */
var _padLogExtent = function (extent, amount) {
  var base,
      baseLog,
      end,
      start;

  // convert min/max to base 10
  base = 10;
  baseLog = Math.log(base);
  start = Math.log(extent[0]) / baseLog;
  end = Math.log(extent[extent.length - 1]) / baseLog;
  extent = _padExtent([start, end], amount);
  return [Math.pow(base, extent[0]), Math.pow(base, extent[extent.length - 1])];
};


var D3Util = {
  formatText: _formatText,
  getBBox: _getBBox,
  padExtent: _padExtent,
  padLogExtent: _padLogExtent
};


module.exports = D3Util;

},{}],7:[function(require,module,exports){
'use strict';

var d3 = require('d3'),
    Collection = require('mvc/Collection'),
    D3Util = require('./D3Util'),
    Util = require('util/Util'),
    View = require('mvc/View');


/**
 * View for a D3 plot.
 *
 * @param options {Object}
 *        options are passed to View.
 * @param options.clickToSelect {Boolean}
 *        default true.
 *        when true, clicking a view causes it to be selected in the
 *        views collection.
 * @param options.height {Number}
 *        default 480.
 *        overall (viewbox) height of svg element.
 * @param options.legendPosition {String}
 *        default 'topleft'.
 *        one of (topright|topleft|bottomright|bottomleft).
 *        position of legend element.
 * @param options.marginBottom {Number}
 *        default 0.
 * @param options.marginLeft {Number}
 *        default 0.
 * @param options.marginRight {Number}
 *        default 0.
 * @param options.marginTop {Number}
 *        default 0.
 * @param options.paddingBottom {Number}
 *        default 80.
 * @param options.paddingLeft {Number}
 *        default 80.
 * @param options.paddingRight {Number}
 *        default 20.
 * @param options.paddingTop {Number}
 *        default 50.
 * @param options.title {String}
 *        title for plot.
 * @param options.tooltipOffset {Number}
 *        default 10.
 *        x/y distance from tooltip coordinate.
 * @param options.tooltipPadding {Number}
 *        default 5.
 *        padding around tooltip content.
 * @param options.width {Number}
 *        default 640.
 *        width of svg viewBox.
 * @param options.xAxisFormat {Function|String}
 *        default null.
 *        x axis tickFormat.
 * @param options.xAxisPadding {Number}
 *        default 0.05.
 *        pad extents by this ratio.
 *        For example:  0.05 pads the x axis extent by 5% of the range.
 * @param options.xAxisScale {d3.scale}
 *        default d3.scale.linear().
 * @param options.xAxisTicks {Function(extent)|Array<Number>}
 *        default null.
 *        x axis tick values.
 * @param optoins.xExtent {Array<Number>}
 *        default null.
 *        explicit x extent for graph, default is auto.
 * @param options.xLabel {String}
 *        label for x axis.
 * @param options.yAxisFormat {Function|String}
 *        default null.
 *        y axis tickFormat.
 * @param options.yAxisPadding {Number}
 *        default 0.05.
 *        pad extents by this ratio.
 *        For example:  0.05 pads the y axis extent by 5% of the range.
 * @param options.yAxisScale {d3.scale}
 *        default d3.scale.linear().
 * @param options.yAxisTicks {Function(extent)|Array<Number>}
 *        default null.
 *        y axis tick values.
 * @param optoins.yExtent {Array<Number>}
 *        default null.
 *        explicit y extent for graph, default is auto.
 * @param options.yLabel {String}
 *        label for y axis.
 */
var D3View = function (options) {
  var _this,
      _initialize,
      // variables
      _firstRender,
      _innerFrame,
      _legend,
      _margin,
      _outerFrame,
      _padding,
      _plotArea,
      _plotAreaClip,
      _plotTitle,
      _svg,
      _tooltip,
      _xAxis,
      _xAxisEl,
      _xAxisLabel,
      _xEl,
      _yAxis,
      _yAxisEl,
      _yAxisLabel,
      _yEl;


  _this = View(options);

  /**
   * Initialize view.
   */
  _initialize = function (options) {
    var el;

    options = options || {};
    _firstRender = true;

    _this.model.set(Util.extend({
      clickToSelect: true,
      height: 480,
      legendPosition: 'topright',
      legendOffset: 20,
      marginBottom: 0,
      marginLeft: 0,
      marginRight: 0,
      marginTop: 0,
      paddingBottom: 80,
      paddingLeft: 80,
      paddingRight: 20,
      paddingTop: 50,
      pointRadius: 3,
      title: '',
      tooltipOffset: 10,
      tooltipPadding: 5,
      width: 640,
      xAxisFormat: null,
      xAxisPadding: 0.05,
      xAxisScale: d3.scale.linear(),
      xAxisTicks: null,
      xExtent: null,
      xLabel: '',
      yAxisFormat: null,
      yAxisPadding: 0.05,
      yAxisScale: d3.scale.linear(),
      yAxisTicks: null,
      yExtent: null,
      yLabel: ''
    }, options), {silent: true});

    el = _this.el;
    el.classList.add('D3View');
    el.innerHTML =
          '<svg xmlns="http://www.w3.org/2000/svg">' +
            '<defs>' +
              '<clipPath id="plotAreaClip">' +
                '<rect x="0" y="0"></rect>' +
              '</clipPath>' +
            '</defs>' +
            '<g class="margin">' +
              '<rect class="outer-frame"></rect>' +
              '<text class="plot-title" text-anchor="middle"></text>' +
              '<g class="padding">' +
                '<rect class="inner-frame"></rect>' +
                '<g class="legend"></g>' +
                '<g class="x">' +
                  '<g class="axis"></g>' +
                  '<text class="label" text-anchor="middle"></text>' +
                '</g>' +
                '<g class="y">' +
                  '<g class="axis"></g>' +
                  '<text class="label" text-anchor="middle"' +
                      ' transform="rotate(-90)"></text>' +
                '</g>' +
                '<g class="plot"></g>' +
                '<g class="tooltip"></g>' +
              '</g>' +
            '</g>' +
          '</svg>';

    _svg = el.querySelector('svg');
    _plotAreaClip = _svg.querySelector('#plotAreaClip > rect');
    _outerFrame = _svg.querySelector('.outer-frame');
    _innerFrame = _svg.querySelector('.inner-frame');
    _margin = _svg.querySelector('.margin');
    _plotTitle = _margin.querySelector('.plot-title');
    _padding = _margin.querySelector('.padding');
    _legend = _padding.querySelector('.legend');
    _xEl = _padding.querySelector('.x');
    _xAxisEl = _xEl.querySelector('.axis');
    _xAxisLabel = _xEl.querySelector('.label');
    _yEl = _padding.querySelector('.y');
    _yAxisEl = _yEl.querySelector('.axis');
    _yAxisLabel = _yEl.querySelector('.label');
    _plotArea = _padding.querySelector('.plot');
    _tooltip = _padding.querySelector('.tooltip');

    _this.views = Collection([]);
    _this.views.on('add', _this.onAdd);
    _this.views.on('deselect', _this.onDeselect);
    _this.views.on('remove', _this.onRemove);
    _this.views.on('reset', _this.onReset);
    _this.views.on('select', _this.onSelect);

    _xAxis = d3.svg.axis().orient('bottom').outerTickSize(0);
    _yAxis = d3.svg.axis().orient('left').outerTickSize(0);
  };


  /**
   * Destroy view.
   */
  _this.destroy = Util.compose(function () {
    if (_this === null) {
      // already destroyed
      return;
    }

    _this.views.off();
    _this.views.destroy();

    _this.views = null;
    _innerFrame = null;
    _legend = null;
    _margin = null;
    _outerFrame = null;
    _padding = null;
    _plotArea = null;
    _plotAreaClip = null;
    _plotTitle = null;
    _svg = null;
    _tooltip = null;
    _xAxis = null;
    _xAxisEl = null;
    _xAxisLabel = null;
    _xEl = null;
    _yAxis = null;
    _yAxisEl = null;
    _yAxisLabel = null;
    _yEl = null;
    _this = null;
  }, _this.destroy);

  _this.getLegendClass = function (/*data, index, scope*/) {
    return 'legend-content';
  };

  /**
   * Views collection add handler.
   *
   * @param views {Array<D3SubView>}
   *        views that were added.
   */
  _this.onAdd = function (views, dontrender) {
    views.forEach(function (view) {
      view._d3view_onclick = function () {
        _this.onClick(view);
      };
      view.on('click', view._d3view_onclick);
    });
    if (!dontrender) {
      _this.render();
    }
  };

  /**
   * Called when a view is clicked.
   *
   * @param view {D3SubView}
   *        view that was clicked.
   */
  _this.onClick = function (view) {
    if (_this.model.get('clickToSelect')) {
      _this.views.select(view);
    }
  };

  /**
   * Views collection select handler.
   *
   * @param view {D3SubView}
   *        view that was selected.
   */
  _this.onDeselect = function (view) {
    view.onDeselect();
  };

  /**
   * Views collection remove handler.
   *
   * @param views {Array<D3SubView>}
   *        views that were removed.
   */
  _this.onRemove = function (views, dontrender) {
    views.forEach(function (view) {
      view.off('click', view._d3view_onclick);
      view._d3view_onclick = null;
    });
    if (!dontrender) {
      _this.render();
    }
  };

  /**
   * Views collection reset handler.
   */
  _this.onReset = function () {
    var el,
        toRemove = [];
    // call onRemove for all existing views.
    while (_plotArea.firstChild) {
      // detach view
      el = _plotArea.firstChild;
      _plotArea.removeChild(el);
      // call remove to clean up
      toRemove.push(el.view);
    }
    _this.onRemove(toRemove);
    // call onAdd for all views
    _this.onAdd(_this.views.data());
  };

  /**
   * Views collection select handler.
   *
   * @param view {D3SubView}
   *        view that was selected.
   */
  _this.onSelect = function (view) {
    view.onSelect();
  };

  /**
   * Render view.
   *
   * @param changed {Object}
   *        default is _this.model.get.
   *        list of properties that have changed.
   */
  _this.render = function (changed) {
    var height,
        innerWidth,
        innerHeight,
        legendPosition,
        legendX,
        legendY,
        marginBottom,
        marginLeft,
        marginRight,
        marginTop,
        options,
        outerHeight,
        outerWidth,
        paddingBottom,
        paddingLeft,
        paddingRight,
        paddingTop,
        width,
        xAxisScale,
        xAxisTicks,
        xExtent,
        yAxisScale,
        yAxisTicks,
        yExtent;


    options = _this.model.get();
    if (_firstRender || !changed) {
      changed = options;
      _firstRender = false;
    }

    // all options
    xAxisScale = options.xAxisScale;
    yAxisScale = options.yAxisScale;
    // these are used for label positioning
    paddingBottom = options.paddingBottom;
    paddingLeft = options.paddingLeft;

    if (changed.hasOwnProperty('title')) {
      _plotTitle.textContent = options.title;
      _plotTitle.setAttribute('y', D3Util.getBBox(_plotTitle).height);
    }
    if (changed.hasOwnProperty('xLabel')) {
      _xAxisLabel.textContent = options.xLabel;
    }
    if (changed.hasOwnProperty('yLabel')) {
      _yAxisLabel.textContent = options.yLabel;
    }

    if (changed.hasOwnProperty('width') ||
        changed.hasOwnProperty('height') ||
        changed.hasOwnProperty('legendPosition') ||
        changed.hasOwnProperty('marginBottom') ||
        changed.hasOwnProperty('marginLeft') ||
        changed.hasOwnProperty('marginRight') ||
        changed.hasOwnProperty('marginTop') ||
        changed.hasOwnProperty('paddingBottom') ||
        changed.hasOwnProperty('paddingLeft') ||
        changed.hasOwnProperty('paddingRight') ||
        changed.hasOwnProperty('paddingTop')) {
      width = options.width;
      height = options.height;
      marginBottom = options.marginBottom;
      marginLeft = options.marginLeft;
      marginRight = options.marginRight;
      marginTop = options.marginTop;
      paddingRight = options.paddingRight;
      paddingTop = options.paddingTop;
      // adjust based on margin/padding
      outerWidth = width - marginLeft - marginRight;
      outerHeight = height - marginTop - marginBottom;
      innerWidth = outerWidth - paddingLeft - paddingRight;
      innerHeight = outerHeight - paddingTop - paddingBottom;
      // update elements
      _this.el.style.paddingBottom = (100 * height / width) + '%';
      _svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);
      _svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      _plotAreaClip.setAttribute('width', innerWidth);
      _plotAreaClip.setAttribute('height', innerHeight);
      _margin.setAttribute('transform',
          'translate(' + marginLeft + ',' + marginTop + ')');
      _outerFrame.setAttribute('height', outerHeight);
      _outerFrame.setAttribute('width', outerWidth);
      _plotTitle.setAttribute('x', outerWidth / 2);
      _padding.setAttribute('transform',
          'translate(' + paddingLeft + ',' + paddingTop + ')');
      _innerFrame.setAttribute('width', innerWidth);
      _innerFrame.setAttribute('height', innerHeight);
      _xEl.setAttribute('transform',
          'translate(0,' + innerHeight + ')');
      // update axes range and position
      xAxisScale.range([0, innerWidth]);
      yAxisScale.range([innerHeight, 0]);
      _xAxisLabel.setAttribute('x', innerWidth / 2);
      _yAxisLabel.setAttribute('x', -innerHeight / 2);

      legendPosition = options.legendPosition;
      legendX = 0;
      legendY = 0;
      if (legendPosition === 'topright') {
        legendX = innerWidth;
      } else if (legendPosition === 'bottomleft') {
        legendY = innerHeight;
      } else if (legendPosition === 'bottomright') {
        legendX = innerWidth;
        legendY = innerHeight;
      } // else 'topleft'
      _legend.setAttribute('transform',
          'translate(' + legendX + ',' + legendY + ')');
    }

    // update axes extent
    xExtent = _this.getPlotXExtent();
    xAxisScale.domain(xExtent);
    yExtent = _this.getPlotYExtent(xExtent);
    yAxisScale.domain(yExtent);

    // redraw axes
    _xAxis.scale(xAxisScale);
    _xAxis.tickFormat(options.xAxisFormat);
    xAxisTicks = options.xAxisTicks;
    if (typeof xAxisTicks === 'function') {
      xAxisTicks = xAxisTicks(xExtent);
    }
    _xAxis.tickValues(xAxisTicks);

    _yAxis.scale(yAxisScale);
    _yAxis.tickFormat(options.yAxisFormat);
    yAxisTicks = options.yAxisTicks;
    if (typeof yAxisTicks === 'function') {
      yAxisTicks = yAxisTicks(yExtent);
    }
    _yAxis.tickValues(yAxisTicks);

    d3.select(_xAxisEl).call(_xAxis);
    d3.select(_yAxisEl).call(_yAxis);

    // update label positions based on axes size
    _xAxisLabel.setAttribute('y',
        paddingBottom - D3Util.getBBox(_xAxisLabel).height);
    _yAxisLabel.setAttribute('y',
        D3Util.getBBox(_yAxisLabel).height - paddingLeft);

    // now render views
    _this.renderViews();
  };

  /**
   * Re-render sub-views.
   */
  _this.renderViews = function () {
    var bbox,
        legendContent,
        legendOffset,
        legendPosition,
        legendX,
        legendY;

    // clear plot area
    Util.empty(_plotArea);
    Util.empty(_legend);
    legendContent = d3.select(_legend)
        .append('g')
        .attr('class', _this.getLegendClass).node();

    // add views to plot area
    legendY = 0;
    _this.views.data().forEach(function (view, index) {
      // add elements
      _plotArea.appendChild(view.el);
      view.el.setAttribute('data-index', index);
      if (view.legend) {
        legendContent.appendChild(view.legend);
        view.legend.setAttribute('data-index', index);
      }
      // render elements
      view.render(_this);
      // position legend
      if (view.legend) {
        bbox = D3Util.getBBox(view.legend);
        legendY += bbox.height;
        view.legend.setAttribute('transform',
            'translate(0,' + legendY  + ')');
      }
    });

    // position legend content.
    bbox = D3Util.getBBox(legendContent);
    legendOffset = _this.model.get('legendOffset');
    legendPosition = _this.model.get('legendPosition');
    legendX = legendOffset;
    legendY = legendOffset;
    if (legendPosition === 'topright') {
      legendX = -(legendOffset + bbox.width);
    } else if (legendPosition === 'bottomleft') {
      legendY = -(legendOffset + bbox.height);
    } else if (legendPosition === 'bottomright') {
      legendX = -(legendOffset + bbox.width);
      legendY = -(legendOffset + bbox.height);
    } // else 'topleft'
    legendContent.setAttribute('transform',
        'translate(' + legendX + ',' + legendY + ')');
  };

  /**
   * Get the plot x extent, including padding.
   *
   * @return {Array<Number>} x extents.
   */
  _this.getPlotXExtent = function () {
    var xAxisPadding,
        xAxisScale,
        xExtent;

    xExtent = _this.getXExtent();
    xAxisPadding = _this.model.get('xAxisPadding');
    if (xAxisPadding) {
      xAxisScale = _this.model.get('xAxisScale');
      xExtent = (typeof xAxisScale.base === 'function' ?
            D3Util.padLogExtent : D3Util.padExtent)(xExtent, xAxisPadding);
    }

    return xExtent;
  };

  /**
   * Get the plot y extent, including padding.
   *
   * @param xExtent {Array<Number>}
   *        xExtent is passed to _this.getYExtent().
   * @return {Array<Number>} y extents.
   */
  _this.getPlotYExtent = function (xExtent) {
    var yAxisPadding,
        yAxisScale,
        yExtent;

    yExtent = _this.getYExtent(xExtent);
    yAxisPadding = _this.model.get('yAxisPadding');
    if (yAxisPadding) {
      yAxisScale = _this.model.get('yAxisScale');
      yExtent = (typeof yAxisScale.base === 'function' ?
            D3Util.padLogExtent : D3Util.padExtent)(yExtent, yAxisPadding);
    }

    return yExtent;
  };

  /**
   * Get the data x extent.
   *
   * @return {Array<Number>} x extents.
   */
  _this.getXExtent = function () {
    var xExtent;

    xExtent = _this.model.get('xExtent');
    if (xExtent === null) {
      xExtent = [];
      _this.views.data().forEach(function (view) {
        xExtent = xExtent.concat(view.getXExtent());
      });
      xExtent = d3.extent(xExtent);
    }

    return xExtent;
  };

  /**
   * Get the data y extent, including padding.
   *
   * @param xExtent {Array<Number>}
   *        x extent, in case y extent is filtered based on x extent.
   * @return {Array<Number>} x extents.
   */
  _this.getYExtent = function (/* xExtent */) {
    var yExtent;

    yExtent = _this.model.get('yExtent');
    if (yExtent === null) {
      yExtent = [];
      _this.views.data().forEach(function (view) {
        yExtent = yExtent.concat(view.getYExtent());
      });
      yExtent = d3.extent(yExtent);
    }

    return yExtent;
  };

  /**
   * Show a tooltip on the graph.
   *
   * @param coords {Array<x, y>}
   *        coordinate for origin of tooltip.
   * @param data {Array<Object|Array>}
   *        tooltip content, passed to formatTooltip.
   */
  _this.showTooltip = function (coords, data) {
    var bbox,
        content,
        offset,
        options,
        outline,
        padding,
        tooltip,
        tooltipBbox,
        x,
        y;

    tooltip = d3.select(_tooltip);
    // clear tooltip
    tooltip.selectAll('*').remove();
    if (!coords || !data) {
      return;
    }

    options = _this.model.get();
    offset = options.tooltipOffset;
    padding = options.tooltipPadding;
    // create tooltip content
    outline = tooltip.append('rect').attr('class', 'tooltip-outline');
    content = tooltip.append('g').attr('class', 'tooltip-content');
    D3Util.formatText(content, data);
    // position tooltip outline
    bbox = D3Util.getBBox(tooltip.node());
    outline.attr('width', bbox.width + 2 * padding)
        .attr('height', bbox.height + 2 * padding);
    content.attr('transform', 'translate(' + padding + ',0)');

    // position tooltip on graph
    // center of point
    x = options.xAxisScale(coords[0]);
    y = options.yAxisScale(coords[1]);
    // box rendering inside
    bbox = D3Util.getBBox(_innerFrame);
    // box being rendered
    tooltipBbox = D3Util.getBBox(_tooltip);
    // keep tooltip in graph area
    if (x + tooltipBbox.width > bbox.width) {
      x = x - tooltipBbox.width - offset;
    } else {
      x = x + offset;
    }
    if (y + tooltipBbox.height > bbox.height) {
      y = y - tooltipBbox.height - offset;
    } else {
      y = y + offset;
    }
    // set position
    _tooltip.setAttribute('transform',
        'translate(' + x + ',' + y + ')');
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = D3View;

},{"./D3Util":6,"d3":1,"mvc/Collection":32,"mvc/View":"mvc/View","util/Util":"util/Util"}],8:[function(require,module,exports){
/* global L */
/**
 * Copyright (c) 2012, Smartrak, David Leaver
 * Leaflet.utfgrid is an open-source JavaScript library that provides utfgrid
 * interaction on leaflet powered maps.
 *
 * https://github.com/danzel/Leaflet.utfgrid
 */

// 04/11/13 -- EMM: This is an AMD'd (require.js) version of the original
//                  source.
'use strict';


L.Util.ajax = function (url, cb) {
  // the following is from JavaScript: The Definitive Guide
  // and https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest_in_IE6
  if (window.XMLHttpRequest === undefined) {
    window.XMLHttpRequest = function () {
      /*global ActiveXObject:true */
      try {
        return new ActiveXObject('Microsoft.XMLHTTP');
      }
      catch  (e) {
        throw new Error('XMLHttpRequest is not supported');
      }
    };
  }
  var response, request = new XMLHttpRequest();
  request.open('GET', url);
  request.onreadystatechange = function () {
    /*jshint evil: true */
    if (request.readyState === 4 && request.status === 200) {
      if (window.JSON) {
        response = JSON.parse(request.responseText);
      } else {
        response = eval('(' + request.responseText + ')');
      }
      cb(response);
    }
  };
  request.send();
};

L.UtfGrid = L.Class.extend({
  includes: L.Mixin.Events,
  options: {
    subdomains: 'abc',

    minZoom: 0,
    maxZoom: 18,
    tileSize: 256,

    resolution: 4,

    useJsonP: true,
    pointerCursor: true
  },

  //The thing the mouse is currently on
  _mouseOn: null,

  initialize: function (url, options) {
    L.Util.setOptions(this, options);

    this._url = url;
    this._cache = {};

    //Find a unique id in window we can use for our callbacks
    //Required for jsonP
    var i = 0;
    while (window['lu' + i]) {
      i++;
    }
    this._windowKey = 'lu' + i;
    window[this._windowKey] = {};

    var subdomains = this.options.subdomains;
    if (typeof this.options.subdomains === 'string') {
      this.options.subdomains = subdomains.split('');
    }
  },

  onAdd: function (map) {
    this._map = map;
    this._container = this._map._container;

    this._update();

    var zoom = this._map.getZoom();

    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      return;
    }

    map.on('click', this._click, this);
    map.on('mousemove', this._move, this);
    map.on('moveend', this._update, this);
  },

  onRemove: function () {
    var map = this._map;
    map.off('click', this._click, this);
    map.off('mousemove', this._move, this);
    map.off('moveend', this._update, this);
  },

  _click: function (e) {
    this.fire('click', this._objectForEvent(e));
  },
  _move: function (e) {
    var on = this._objectForEvent(e);

    if (on.data !== this._mouseOn) {
      if (this._mouseOn) {
        this.fire('mouseout', { latlng: e.latlng, data: this._mouseOn });
        if (this.options.pointerCursor) {
          this._container.style.cursor = '';
        }
      }
      if (on.data) {
        this.fire('mouseover', on);
        if (this.options.pointerCursor) {
          this._container.style.cursor = 'pointer';
        }
      }

      this._mouseOn = on.data;
    } else if (on.data) {
      this.fire('mousemove', on);
    }
  },

  _objectForEvent: function (e) {
    var map = this._map,
        point = map.project(e.latlng),
        tileSize = this.options.tileSize,
        resolution = this.options.resolution,
        x = Math.floor(point.x / tileSize),
        y = Math.floor(point.y / tileSize),
        gridX = Math.floor((point.x - (x * tileSize)) / resolution),
        gridY = Math.floor((point.y - (y * tileSize)) / resolution),
      max = map.options.crs.scale(map.getZoom()) / tileSize;

    x = (x + max) % max;
    y = (y + max) % max;

    var data = this._cache[map.getZoom() + '_' + x + '_' + y];
    if (!data) {
      return { latlng: e.latlng, data: null };
    }

    var idx = this._utfDecode(data.grid[gridY].charCodeAt(gridX)),
        key = data.keys[idx],
        result = data.data[key];

    if (!data.data.hasOwnProperty(key)) {
      result = null;
    }

    return { latlng: e.latlng, data: result};
  },

  //Load up all required json grid files
  //TODO: Load from center etc
  _update: function () {

    var bounds = this._map.getPixelBounds(),
        zoom = this._map.getZoom(),
        tileSize = this.options.tileSize;

    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      return;
    }

    var nwTilePoint = new L.Point(
        Math.floor(bounds.min.x / tileSize),
        Math.floor(bounds.min.y / tileSize)),
      seTilePoint = new L.Point(
        Math.floor(bounds.max.x / tileSize),
        Math.floor(bounds.max.y / tileSize)),
        max = this._map.options.crs.scale(zoom) / tileSize;

    //Load all required ones
    for (var x = nwTilePoint.x; x <= seTilePoint.x; x++) {
      for (var y = nwTilePoint.y; y <= seTilePoint.y; y++) {

        var xw = (x + max) % max, yw = (y + max) % max;
        var key = zoom + '_' + xw + '_' + yw;

        if (!this._cache.hasOwnProperty(key)) {
          this._cache[key] = null;

          if (this.options.useJsonP) {
            this._loadTileP(zoom, xw, yw);
          } else {
            this._loadTile(zoom, xw, yw);
          }
        }
      }
    }
  },

  _loadTileP: function (zoom, x, y) {
    var head = document.getElementsByTagName('head')[0],
        key = zoom + '_' + x + '_' + y,
        functionName = 'lu_' + key,
        wk = this._windowKey,
        self = this;

    var url = L.Util.template(this._url, L.Util.extend({
      s: L.TileLayer.prototype._getSubdomain.call(this, { x: x, y: y }),
      z: zoom,
      x: x,
      y: y,
      cb: wk + '.' + functionName
    }, this.options));

    var script = document.createElement('script');
    script.setAttribute('type', 'text/javascript');
    script.setAttribute('src', url);

    window[wk][functionName] = function (data) {
      self._cache[key] = data;
      delete window[wk][functionName];
      head.removeChild(script);
    };

    head.appendChild(script);
  },

  _loadTile: function (zoom, x, y) {
    var url = L.Util.template(this._url, L.Util.extend({
      s: L.TileLayer.prototype._getSubdomain.call(this, { x: x, y: y }),
      z: zoom,
      x: x,
      y: y
    }, this.options));

    var key = zoom + '_' + x + '_' + y;
    var self = this;
    L.Util.ajax(url, function (data) {
      self._cache[key] = data;
    });
  },

  _utfDecode: function (c) {
    if (c >= 93) {
      c--;
    }
    if (c >= 35) {
      c--;
    }
    return c - 32;
  }
});


L.utfGrid = function (url, options) {
  return new L.UtfGrid(url, options);
};


module.exports = L.UtfGrid;

},{}],9:[function(require,module,exports){
/* global L */
'use strict';


/**
 * Simple extension to control in order to align generated markup with
 * HazDev template styles.
 *
 */
var HazDevLayers = L.Control.Layers.extend({
  _addItem: function (obj) {
    var checked,
        container,
        fragment,
        input,
        label;

    fragment = document.createDocumentFragment();
    label = document.createElement('label');
    checked = this._map.hasLayer(obj.layer);

    if (obj.overlay) {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.className = 'leaflet-control-layers-selector';
      input.defaultChecked = checked;
    } else {
      input = this._createRadioElement('leaflet-base-layers', checked);
    }

    input.layerId = L.stamp(obj.layer);
    input.id = 'leaflet-layer-control-selector-' + input.layerId;

    L.DomEvent.on(input, 'click', this._onInputClick, this);


    label.innerHTML = obj.name;
    label.setAttribute('for', input.id);

    fragment.appendChild(input);
    fragment.appendChild(label);

    container = obj.overlay ? this._overlaysList : this._baseLayersList;
    container.appendChild(fragment);

    return fragment;
  }
});


L.Control.HazDevLayers = HazDevLayers;

L.control.hazDevLayers = function (baseLayers, overlays, options) {
  return new HazDevLayers(baseLayers, overlays, options);
};


module.exports = L.control.hazDevLayers;

},{}],10:[function(require,module,exports){
/* global L */
'use strict';


// Copyright 2012 Ardhi Lukianto
// https://github.com/ardhi/Leaflet.MousePosition
var MousePosition = L.Control.extend({
  options: {
    position: 'bottomright',
    separator: ' : ',
    emptyString: 'Unavailable',
    lngFirst: false,
    numDigits: 3,
    lngFormatter: function(n) { return [Math.abs(n).toFixed(3), '&deg;',
            (n<0?'W':'E')].join(''); },
    latFormatter: function(n) { return [Math.abs(n).toFixed(3), '&deg;',
            (n<0?'S':'N')].join(''); }
  },

  onAdd: function (map) {
    this._container = L.DomUtil.create('div',
        'leaflet-control-background leaflet-control-mouseposition');
    L.DomEvent.disableClickPropagation(this._container);
    map.on('mousemove', this._onMouseMove, this);
    this._container.innerHTML=this.options.emptyString;
    return this._container;
  },

  onRemove: function (map) {
    map.off('mousemove', this._onMouseMove);
  },

  _onMouseMove: function (e) {
    var lng = L.Util.formatNum(e.latlng.lng, this.options.numDigits);
    // need to correct for rollover of map if user scrolls
    if(lng >= 0) {
      lng=((lng+180)%360)-180;
    } else {
      lng=(((lng+180)+(Math.ceil(Math.abs(lng+180)/360)*360))%360)-180;
    }
    var lat = L.Util.formatNum(e.latlng.lat, this.options.numDigits);
    if (this.options.lngFormatter) {
      lng = this.options.lngFormatter(lng);
    }
    if (this.options.latFormatter) {
      lat = this.options.latFormatter(lat);
    }
    var value = this.options.lngFirst ?
            lng + this.options.separator + lat :
            lat + this.options.separator + lng;
    this._container.innerHTML = value;
  }
});


L.Control.MousePosition = MousePosition;

L.control.mousePosition = function (options) {
  return new MousePosition(options);
};


module.exports = L.control.mousePosition;

},{}],11:[function(require,module,exports){
/* global L */
'use strict';


var Xhr = require('util/Xhr');


/**
 * A Leaflet GeoJSON layer that loads its data asynchronously after the layer
 * is added to the map (in onAdd).
 *
 * @param options {Object}
 *        all options are passed to L.GeoJSON.
 * @param options.url {String}
 *        url containing data to load.
 */
var AsynchronousGeoJson = L.GeoJSON.extend({

  initialize: function (options) {
    this._url = options.url;
    this._data = null;

    L.GeoJSON.prototype.initialize.call(this, [], options);
  },

  onAdd: function (map) {
    var _this;

    if (this._data === null) {
      // flag that data is being loaded
      this._data = 'loading';
      // scope for Xhr callbacks
      _this = this;
      Xhr.ajax({
        url: this._url,
        success: function (data) {
          // parse if needed
          data = (typeof data === 'string' ? JSON.parse(data) : data);
          // flag that data is loaded
          _this._data = data;
          // add data to layer (and map if layer still visible)
          _this.addData(data);
        },
        error: function () {
          // failed to load, clear loading in case re-added
          _this._data = null;
        }
      });
    }

    // always add layer, data added asynchronously
    L.GeoJSON.prototype.onAdd.call(this, map);
  }

});


L.AsynchronousGeoJson = AsynchronousGeoJson;

L.asynchronousGeoJSON = function (options) {
  return new AsynchronousGeoJson(options);
};


module.exports = L.asynchronousGeoJson;

},{"util/Xhr":"util/Xhr"}],12:[function(require,module,exports){
'use strict';


var TileProvider = require('leaflet/layer/TileProvider'),
    Util = require('util/Util');


var _CARTODB,
    _DEFAULTS,
    _ESRI,
    _PROVIDER_INFO;


_CARTODB = 'cartodb';
_ESRI = 'esri';
_PROVIDER_INFO = {};

_DEFAULTS = {
  provider: _ESRI
};

_PROVIDER_INFO[_CARTODB] = {
  url: 'https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}@2x.png',
  options: {
    subdomains: 'abcd',
    attribution: '<a href="https://www.openstreetmap.org/copyright">' +
        'OpenStreetMap</a> &copy; <a href="https://cartodb.com/attributions">' +
        'CartoDB</a>'
  }
};

_PROVIDER_INFO[_ESRI] = {
  url: 'https://{s}.arcgisonline.com/ArcGIS/rest/services/' +
      'Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}.jpg',
  options: {
    subdomains: ['server', 'services'],
    attribution: 'Sources: Esri, DeLorme, HERE, MapmyIndia,  &copy; ' +
        'OpenStreetMap contributors, and the GIS community'
  }
};


/**
* Factory for Grayscale base layer.
*/
var Grayscale = function (options) {
  try {
    return TileProvider.create(
      _PROVIDER_INFO,
      Util.extend({}, _DEFAULTS, options)
    );
  } catch (e) {
    return TileProvider.create(
      _PROVIDER_INFO,
      _DEFAULTS
    );
  }
};


Grayscale.CARTODB = _CARTODB;
Grayscale.ESRI = _ESRI;


module.exports = Grayscale;

},{"leaflet/layer/TileProvider":19,"util/Util":"util/Util"}],13:[function(require,module,exports){
/* global L */
'use strict';

var Util = require('util/Util');


var _HISTORIC_SEISMICITY_URL = 'https://earthquake.usgs.gov/arcgis/rest' +
    '/services/eq/catalog_2015/MapServer/tile/{z}/{y}/{x}';


/**
 * Historic seismicity layer.
 *
 *
 * @param options {Object}
 *     Any options that could be provided to an L.tileLayer
 */
var HistoricSeismicity = function (options) {
  options = Util.extend({
    tileUrl: _HISTORIC_SEISMICITY_URL
  }, options);

  return L.tileLayer(options.tileUrl, options);
};


module.exports = HistoricSeismicity;

},{"util/Util":"util/Util"}],14:[function(require,module,exports){
/* global L */
'use strict';


var UtfGrid = require('leaflet/UtfGrid'),
    Util = require('util/Util');


var CLASSES = 'leaflet-mouseover-tooltip';


L.MouseOverLayer = L.LayerGroup.extend({

  _initialized: false, // Flag to tell if constructor has finished

  /**
   * @param options {Object}
   *      tileUrl: URL to image tiles
   *      dataUrl: URL to UtfGrid tiles (requires callback={cb})
   *      tileOpts: Options to be used on L.TileLayer for image tiles
   *      dataOpts: Options to be used on L.UtfGrid for grid tiles
   *      tiptext: Template string to be used for auto-tooltipping on hover
   */
  initialize: function (options) {

    // Create the two layers
    this._tileLayer = new L.TileLayer(options.tileUrl, options.tileOpts);
    this._dataLayer = new UtfGrid(options.dataUrl, options.dataOpts);

    if (typeof options.tiptext === 'string') {
      this._tiptext = options.tiptext;
      this._tooltip = L.DomUtil.create('span', CLASSES);
      this.on('mouseover', this._onMouseOver, this);
      this.on('mouseout', this._onMouseOut, this);
    }

    // Call parent constructor
    L.LayerGroup.prototype.initialize.call(this, []);
    this.addLayer(this._tileLayer);
    if (!Util.isMobile()) {
  this.addLayer(this._dataLayer);
    }

    this._initialized = true;
  },

  // --------------------------------------------------
  // Delegate event handling to the data layer
  // --------------------------------------------------

  on: function () {
    UtfGrid.prototype.on.apply(this._dataLayer, arguments);
  },

  off: function () {
    UtfGrid.prototype.off.apply(this._dataLayer, arguments);
  },

  // --------------------------------------------------
  // Override these methods inherited from LayerGroup
  // --------------------------------------------------

  onAdd: function (map) {
    L.LayerGroup.prototype.onAdd.apply(this, arguments);

    if (this._tooltip) {
      map.getPanes().popupPane.appendChild(this._tooltip);
    }
  },

  onRemove: function () {
    L.LayerGroup.prototype.onRemove.apply(this, arguments);

    if (this._tooltip && this._tooltip.parentNode) {
      this._tooltip.parentNode.removeChild(this._tooltip);
    }
  },

  // --------------------------------------------------
  // Suppress these methods inherited from LayerGroup
  // --------------------------------------------------

  addLayer: function () {
    if (!this._initialized) {
      L.LayerGroup.prototype.addLayer.apply(this, arguments);
    } else {
      try {console.log('MouseOverLayer::addLayer - Immutable object');}
      catch (e) { /* Ignore */ }
    }
  },
  removeLayer: function () {
    if (!this._initialized) {
      L.LayerGroup.prototype.removeLayer.apply(this, arguments);
    } else {
      try {console.log('MouseOverLayer::removeLayer - Immutable object');}
      catch (e) { /* Ignore */ }
    }
  },
  clearLayers: function () {
    if (!this._initialized) {
      L.LayerGroup.prototype.clearLayers.apply(this, arguments);
    } else {
      try {console.log('MouseOverLayer::clearLayers - Immutable object');}
      catch (e) { /* Ignore */ }
    }
  },

  // --------------------------------------------------
  // Auto hover tooltip helper methods
  // --------------------------------------------------

  _onMouseOver: function (evt) {
    // Update text
    this._tooltip.innerHTML = L.Util.template(this._tiptext, evt.data);

    // Update position
    L.DomUtil.setPosition(this._tooltip, this._map.latLngToLayerPoint(
        evt.latlng));

    // Show the tooltip
    this._tooltip.style.display = 'block';
  },

  _onMouseOut: function () {
    // Hide the tooltip
    this._tooltip.style.display = '';
  }
});


L.mouseOverLayer = function (options) {
  return new L.MouseOverLayer(options);
};


module.exports = L.mouseOverLayer;

},{"leaflet/UtfGrid":8,"util/Util":"util/Util"}],15:[function(require,module,exports){
'use strict';


var TileProvider = require('leaflet/layer/TileProvider'),
    Util = require('util/Util');

var _DEFAULTS,
    _ESRI,
    _MAPQUEST,
    _PROVIDER_INFO;

_ESRI = 'esri';
_MAPQUEST = 'mapquest';
_PROVIDER_INFO = {};

_DEFAULTS = {
  provider: _ESRI
};

_PROVIDER_INFO[_ESRI] = {
  url: 'https://{s}.arcgisonline.com/ArcGIS/rest/services/' +
      'World_Imagery/MapServer/tile/{z}/{y}/{x}',
  options: {
    subdomains: ['server', 'services'],
    attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, ' +
        'USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the ' +
        'GIS User Community'
  }
};

_PROVIDER_INFO[_MAPQUEST] = {
  url: 'https://otile{s}-s.mqcdn.com/tiles/1.0.0/sat/{z}/{x}/{y}.jpg',
  options: {
    subdomains: '1234',
    attribution: 'Data, imagery and map information provided by MapQuest,' +
        ' <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>' +
        ' and contributors,' +
        ' <a href="https://wiki.openstreetmap.org/wiki/Legal_FAQ#3a.' +
        '_I_would_like_to_use_OpenStreetMap_maps.' +
        '_How_should_I_credit_you.3F">' +
        'ODbL</a>'
  }
};


/**
* Factory for Satellite base layer.
*/
var Satellite = function (options) {
  try {
    return TileProvider.create(
      _PROVIDER_INFO,
      Util.extend({}, _DEFAULTS, options)
    );
  } catch (e) {
    return TileProvider.create(
      _PROVIDER_INFO,
      _DEFAULTS
    );
  }
};


Satellite.ESRI = _ESRI;
Satellite.MAPQUEST = _MAPQUEST;


module.exports = Satellite;

},{"leaflet/layer/TileProvider":19,"util/Util":"util/Util"}],16:[function(require,module,exports){
'use strict';


var TileProvider = require('leaflet/layer/TileProvider'),
    Util = require('util/Util');


var _DEFAULTS,
    _ESRI,
    _MAPQUEST,
    _PROVIDER_INFO;


_ESRI = 'esri';
_MAPQUEST = 'mapquest';
_PROVIDER_INFO = {};

_DEFAULTS = {
  provider: _ESRI
};

_PROVIDER_INFO[_ESRI] = {
  url: 'https://{s}.arcgisonline.com/ArcGIS/rest/services/' +
      'World_Street_Map/MapServer/tile/{z}/{y}/{x}',
  options: {
    subdomains: ['server', 'services'],
    attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, ' +
        'Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, ' +
        'Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the ' +
        'GIS User Community'
  }
};

_PROVIDER_INFO[_MAPQUEST] = {
  url: 'https://otile{s}.mqcdn.com/tiles/1.0.0/osm/{z}/{x}/{y}.jpg',
  options: {
    subdomains: '1234',
    attribution: 'Data, imagery and map information provided by MapQuest,' +
        ' <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>' +
        ' and contributors,' +
        ' <a href="https://wiki.openstreetmap.org/wiki/' +
        'Legal_FAQ#3a._I_would_like_to_use_OpenStreetMap_maps.' +
        '_How_should_I_credit_you.3F">' +
        'ODbL</a>'
  }
};


/**
* Factory for Street base layer.
*/
var Street = function (options) {
  try {
    return TileProvider.create(
      _PROVIDER_INFO,
      Util.extend({}, _DEFAULTS, options)
    );
  } catch (e) {
    return TileProvider.create(
      _PROVIDER_INFO,
      _DEFAULTS
    );
  }
};


Street.ESRI = _ESRI;
Street.MAPQUEST = _MAPQUEST;


module.exports = Street;

},{"leaflet/layer/TileProvider":19,"util/Util":"util/Util"}],17:[function(require,module,exports){
/* global L */
'use strict';


var _PLATES_URL = 'https://earthquake.usgs.gov/basemap/tiles/plates';


var TectonicPlates = function (options) {
  options = options || {};

  return L.tileLayer(_PLATES_URL + '/{z}/{x}/{y}.png', options);
};


L.tectonicPlates = TectonicPlates;

module.exports = TectonicPlates;

},{}],18:[function(require,module,exports){
'use strict';


var TileProvider = require('leaflet/layer/TileProvider'),
    Util = require('util/Util');


var _DEFAULTS,
    _ESRI,
    _NATGEO,
    _PROVIDER_INFO;


_ESRI = 'esri';
_NATGEO = 'natgeo';
_PROVIDER_INFO = {};

_DEFAULTS = {
  provider: _ESRI
};

_PROVIDER_INFO[_ESRI] = {
  url: 'https://{s}.arcgisonline.com/ArcGIS/rest/services/' +
      'World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
  options: {
    subdomains: ['server', 'services'],
    attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, ' +
        'Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, ' +
        'Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the ' +
        'GIS User Community'
  }
};

_PROVIDER_INFO[_NATGEO] = {
  url: 'https://{s}.arcgisonline.com/arcgis/rest/services/' +
      'NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}',
  options: {
    subdomains: ['server', 'services'],
    attribution: 'Content may not reflect National Geographic\'s ' +
          'current map policy. Sources: National Geographic, Esri, ' +
          'DeLorme, HERE, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, ' +
          'GEBCO, NOAA, increment P Corp.'
  }
};



/**
 * Factory for Terrain base layer.
 */
var Terrain = function (options) {
  try {
    return TileProvider.create(
      _PROVIDER_INFO,
      Util.extend({}, _DEFAULTS, options)
    );
  } catch (e) {
    return TileProvider.create(
      _PROVIDER_INFO,
      _DEFAULTS
    );
  }
};


Terrain.ESRI = _ESRI;
Terrain.NATGEO = _NATGEO;


module.exports = Terrain;

},{"leaflet/layer/TileProvider":19,"util/Util":"util/Util"}],19:[function(require,module,exports){
/* global L */
'use strict';


var Util = require('util/Util');


/**
 * This class provides a static builder to create TileLayers based on provider
 * info. For clarity, several "types" of maps ("Grayscale", "Terrain", etc...)
 * have their own subclass which essentially just calls the create method
 * implemented here.
 *
 */
var TileProvider = {
  /**
   * Creates a new L.TileLayer based on a map of provider info and
   * user-specified options.
   *
   * @param infoMap {Object}
   *     A map of provider info keyed by provider name.
   *
   * @param options {Object}
   *     User-specified configuration options for an L.tileLayer. Must also
   *     include a "provider" key whose value points to a known provider name
   *     in the infoMap.
   *
   * @throws {Error}
   *     If the infoMap does not contain the user-specified options.provider.
   *
   * @return {L.TileLayer}
   *     A new L.TileLayer based on the configured information.
   */
  create: function (infoMap, options) {
    var layerOptions,
        layerUrl,
        provider;

    provider = infoMap[options.provider];
    layerUrl = provider.url;
    layerOptions = Util.extend({}, provider.options, options);

    if (layerOptions.hasOwnProperty('provider')) {
      delete layerOptions.provider;
    }

    return L.tileLayer(layerUrl, layerOptions);
  }
};


module.exports = TileProvider;

},{"util/Util":"util/Util"}],20:[function(require,module,exports){
/* global L */
'use strict';


var MouseOverLayer = require('leaflet/layer/MouseOverLayer'),
    Util = require('util/Util');


var _FAULTS_URL = 'https://earthquake.usgs.gov/basemap/tiles/faults';


var UsFault = function (options) {
  options = Util.extend({
    tileUrl: _FAULTS_URL + '/{z}/{x}/{y}.png',
    dataUrl: _FAULTS_URL + '/{z}/{x}/{y}.grid.json?callback={cb}',
    tiptext: '{NAME}'
  }, options);

  return MouseOverLayer(options);
};


L.usFault = UsFault;

module.exports = UsFault;

},{"leaflet/layer/MouseOverLayer":14,"util/Util":"util/Util"}],21:[function(require,module,exports){
'use strict';

/**
 * Utility class to get the confidence for a location.
 * Confidence for a location is 1 to 5.
 */
var ConfidenceCalculator = {

  /**
   * Compute Confidence given latitude and longitude. Latitude and longitude
   * must be strings to keep accuracy.
   * Confidence is based on the number of digits past the decimal.
   *
   * @params latititude {String}
   * @params longitude {String}
   *
   */
  computeFromCoordinates: function (latitude, longitude) {
    if (typeof latitude !== 'string' || typeof longitude !== 'string') {
      return ConfidenceCalculator.NOT_COMPUTED;
    }

    var latitudePieces = latitude.split('.'),
        longitudePieces = longitude.split('.'),
        minDecimals;

    if (latitudePieces.length === 1 || longitudePieces.length === 1) {
      minDecimals = 0;
    } else {
      minDecimals = Math.min(latitudePieces[1].length,
          longitudePieces[1].length);
    }


    if (minDecimals >= 5) {
      return ConfidenceCalculator.HIGH_CONFIDENCE;
    } else if (minDecimals >= 4) {
      return ConfidenceCalculator.ABOVE_AVERAGE_CONFIDENCE;
    } else if (minDecimals >= 3) {
      return ConfidenceCalculator.AVERAGE_CONFIDENCE;
    } else if (minDecimals >= 2) {
      return ConfidenceCalculator.BELOW_AVERAGE_CONFIDENCE;
    } else if (minDecimals >= 1) {
      return ConfidenceCalculator.LOW_CONFIDENCE;
    } else if (minDecimals >= 0) {
      return ConfidenceCalculator.NO_CONFIDENCE;
    } else {
      return ConfidenceCalculator.NOT_COMPUTED;
    }

  },

  /**
   * Compute Confidence given a zoom level.
   * @params zoom {number} indicates the zoom level of the map.
   */
  computeFromPoint: function (zoom) {
    if (zoom > 16) {
      return ConfidenceCalculator.HIGH_CONFIDENCE;
    } else if (zoom > 12) {
      return ConfidenceCalculator.ABOVE_AVERAGE_CONFIDENCE;
    } else if (zoom > 8) {
      return ConfidenceCalculator.AVERAGE_CONFIDENCE;
    } else if (zoom > 4) {
      return ConfidenceCalculator.BELOW_AVERAGE_CONFIDENCE;
    } else {
      return ConfidenceCalculator.LOW_CONFIDENCE;
    }
  },

  /**
   * returns rounded value based on confidence value.
   *
   * @param  {string | number} value
   *           value to be rounded
   * @param  {number} confidence
   *           confidence value
   * @return {number} rounded value
   *
   */
  roundLocation: function (value, confidence) {
    var rounded,
        decimals = confidence;

    if (confidence === ConfidenceCalculator.NOT_COMPUTED) {
      decimals = 0;
    }

    rounded = parseFloat(value).toFixed(decimals);
    return parseFloat(rounded);
  },

  /**
   * Compute zoom level given a confidence.
   * @params confidence {number} indicates the confidence level
   */
  computeZoomFromConfidence: function (confidence) {
    if (confidence === ConfidenceCalculator.HIGH_CONFIDENCE) {
      return 16;
    } else if( confidence === ConfidenceCalculator.ABOVE_AVERAGE_CONFIDENCE) {
      return 13;
    } else if( confidence === ConfidenceCalculator.AVERAGE_CONFIDENCE) {
      return 9;
    } else if( confidence === ConfidenceCalculator.BELOW_AVERAGE_CONFIDENCE) {
      return 5;
    } else if( confidence === ConfidenceCalculator.LOW_CONFIDENCE) {
      return 1;
    } else {
      return 1;
    }
  },

  computeZoomFromGeocode: function (result) {
    var confidence = this.computeFromGeocode(result);
    return this.computeZoomFromConfidence(confidence);
  },

  /**
   * Compute Confidence given a accuracy in meters.
   * used by GeoLocate.
   * @params accuracy {number} indicates the accuracy in meters at 95%
   *         confidence.
   */
  computeFromGeolocate: function (accuracy) {
    if (accuracy > 100000) {
      return ConfidenceCalculator.LOW_CONFIDENCE;
    } else if (accuracy > 10000) {
      return ConfidenceCalculator.BELOW_AVERAGE_CONFIDENCE;
    } else if (accuracy > 1000) {
      return ConfidenceCalculator.AVERAGE_CONFIDENCE;
    } else if (accuracy > 100) {
      return ConfidenceCalculator.ABOVE_AVERAGE_CONFIDENCE;
    } else {
      return ConfidenceCalculator.HIGH_CONFIDENCE;
    }
  },

  /**
   * Compute Confidence given a geocode result location with an extent.
   *
   * @params geocodeLocation {object}
   *      an esri response via the ArcGIS REST API
   *
   * @see https://developers.arcgis.com/en/features/geocoding/
   */
  computeFromGeocode: function (geocodeLocation) {
    var confidence,
        extent,
        max;

    extent = geocodeLocation.extent;

    // find the largest dimension of the extent
    if (extent) {
      max = Math.max(Math.abs(extent.xmax - extent.xmin),
          Math.abs(extent.ymax - extent.ymin));

      // calculate confidence based on the location's extent
      if (max < 0.001) {
        confidence = ConfidenceCalculator.HIGH_CONFIDENCE;
      } else if (max < 0.01) {
        confidence = ConfidenceCalculator.ABOVE_AVERAGE_CONFIDENCE;
      } else if (max < 0.1) {
        confidence = ConfidenceCalculator.AVERAGE_CONFIDENCE;
      } else if (max < 1) {
        confidence = ConfidenceCalculator.BELOW_AVERAGE_CONFIDENCE;
      } else if (max < 10) {
        confidence = ConfidenceCalculator.LOW_CONFIDENCE;
      } else if (max >= 10) {
        confidence = ConfidenceCalculator.NO_CONFIDENCE;
      }
    }

    if (!(confidence === ConfidenceCalculator.HIGH_CONFIDENCE ||
        confidence === ConfidenceCalculator.ABOVE_AVERAGE_CONFIDENCE ||
        confidence === ConfidenceCalculator.AVERAGE_CONFIDENCE ||
        confidence === ConfidenceCalculator.BELOW_AVERAGE_CONFIDENCE ||
        confidence === ConfidenceCalculator.LOW_CONFIDENCE ||
        confidence === ConfidenceCalculator.NO_CONFIDENCE)) {
      // confidence did not match any value, bail
      confidence = ConfidenceCalculator.NOT_COMPUTED;
    }

    return confidence;
  }
};

// ----------------------------------------------------------------------
// Public Static Variables
// ----------------------------------------------------------------------

/** Constant used to indicate high degree of confidence. */
ConfidenceCalculator.HIGH_CONFIDENCE = 5;

/** Constant used to indicate above average confidence. */
ConfidenceCalculator.ABOVE_AVERAGE_CONFIDENCE = 4;

/** Constant used to indicate moderate degree of confidence. */
ConfidenceCalculator.AVERAGE_CONFIDENCE = 3;

/** Constant used to indicate below average confidence. */
ConfidenceCalculator.BELOW_AVERAGE_CONFIDENCE = 2;

/** Constant used to indicate low degree of confidence. */
ConfidenceCalculator.LOW_CONFIDENCE = 1;

/** Constant used to indicate very low degree of confidence. */
ConfidenceCalculator.NO_CONFIDENCE = 0;

/**
 * Constant used to indicate confidence was not computed or an error occurred
 * while computing the confidence
 */
ConfidenceCalculator.NOT_COMPUTED = -1;


module.exports = ConfidenceCalculator;

},{}],22:[function(require,module,exports){
/* global L */
'use strict';

var ConfidenceCalculator = require('locationview/ConfidenceCalculator');


var CLASS_NAME = 'location-coordinate-control',
    CLASS_ENABLED = 'location-control-enabled',
    CLASS_INPUT = 'expandable',
    CLASS_SUBMIT = 'location-control-submit';

var METHOD = 'coordinate';

var DEFAULTS = {
  'method': METHOD,
  'position': 'topleft',
  'defaultEnabled': false,
  'iconClass': 'location-control-icon',
  'helpText': 'Enter Coordinates',
  'infoText': '<b>Enter coordinates</b>, latitude and longitude.'
};

var CoordinateControl =  L.Control.extend({
  includes: L.Mixin.Events,

  initialize: function (options) {
    L.Util.setOptions(this, L.Util.extend({}, DEFAULTS, options));
  },

  onAdd: function (map) {
    var options = this.options,
        stop = L.DomEvent.stopPropagation,
        container,
        toggle,
        control;

    container = document.createElement('div');
    container.classList.add('location-control');
    container.classList.add(CLASS_NAME);
    container.innerHTML = [
      '<a class="', options.iconClass, '"></a>',
      '<span class="help">', options.helpText, '</span>',
      '<div class="', CLASS_INPUT, '">',
        '<input name="latitude" title="latitude" class="latitude" ',
            'placeholder="Latitude" />',
        '<input name="longitude" title="longitude" class="longitude" ',
            'placeholder="Longitude" />',
        '<button type="search" class="', CLASS_SUBMIT, '">Search</button>',
      '</div>'
    ].join('');

    toggle = container.querySelector('a');
    control = container.querySelector('.' + CLASS_INPUT);

    this._container = container;
    this._toggle = toggle;
    this._control = control;
    this._latitude = control.querySelector('.latitude');
    this._longitude = control.querySelector('.longitude');
    this._submit = container.querySelector('.' + CLASS_SUBMIT);
    this._map = map;

    if (this.options.defaultEnabled) {
      this.enable();
    }


    L.DomEvent.addListener(toggle, 'click', this.toggle, this);
    // Bind to a submit button click
    L.DomEvent.addListener(this._submit, 'click', this._onSubmit, this);
    // Bind event for the "enter" key
    L.DomEvent.addListener(control, 'keypress', this._onKeyPress, this);
    // stops map from zooming on double click
    L.DomEvent.addListener(container, 'click', stop);
    L.DomEvent.addListener(container, 'dblclick', stop);
    L.DomEvent.addListener(container, 'keydown', stop);
    L.DomEvent.addListener(container, 'keyup', stop);
    L.DomEvent.addListener(container, 'keypress', stop);
    L.DomEvent.addListener(container, 'mousedown', stop);
    L.DomEvent.addListener(this._longitude, 'touchstart', stop);
    L.DomEvent.addListener(this._latitude, 'touchstart', stop);

    return container;
  },

  toggle: function () {
    // if options is not defined, then toggle the control
    if (L.DomUtil.hasClass(this._container, CLASS_ENABLED)) {
      this.disable();
    } else {
      this.enable();
    }
  },

  enable: function () {
    L.DomUtil.addClass(this._container, CLASS_ENABLED);
    this._latitude.focus();
    this.fire('enabled');
  },

  disable: function () {
    L.DomUtil.removeClass(this._container, CLASS_ENABLED);

    this.fire('disabled');
  },

  onRemove: function () {
    var stop = L.DomEvent.stopPropagation,
        container = this._container,
        toggle = this._toggle,
        control = this._control;

    L.DomEvent.removeListener(toggle, 'click', this.toggle);
    L.DomEvent.removeListener(this._submit, 'click', this._onSubmit);
    L.DomEvent.removeListener(control, 'keypress', this._onKeyPress);
    L.DomEvent.removeListener(container, 'click', stop);
    L.DomEvent.removeListener(container, 'dblclick', stop);
    L.DomEvent.removeListener(container, 'keydown', stop);
    L.DomEvent.removeListener(container, 'keyup', stop);
    L.DomEvent.removeListener(container, 'keypress', stop);
    L.DomEvent.removeListener(container, 'mousedown', stop);
    L.DomEvent.removeListener(this._longitude, 'touchstart', stop);
    L.DomEvent.removeListener(this._latitude, 'touchstart', stop);

    this._map = null;
    this._control = null;
    this._toggle = null;
    this._container = null;
    this._latitude = null;
    this._longitude = null;
    this._submit = null;
  },

  setLocation: function (location, options) {
    if (location === null) {
      // reset location
      this._latitude.value = '';
      this._longitude.value = '';
    } else {
      // update lat/lon inputs
      this._latitude.value = ConfidenceCalculator.
          roundLocation(location.latitude, location.confidence);
      this._longitude.value = ConfidenceCalculator.
          roundLocation(location.longitude, location.confidence);
    }
    if (!(options && options.silent)) {
      this.fire('location', {'location': location});
    }
  },

  _onSubmit: function () {
    var latitude = this._latitude.value,
        longitude = this._longitude.value,
        location = this._getCoordinateLocation(latitude, longitude);

    // fire a location change
    this.setLocation(location);
    this._latitude.blur();
    this._longitude.blur();
  },

  _getCoordinateLocation: function (latitude, longitude) {
    var confidence = ConfidenceCalculator.
            computeFromCoordinates(latitude, longitude);

    return {
      'place': null,
      'longitude': parseFloat(longitude),
      'latitude': parseFloat(latitude),
      'method': METHOD,
      'confidence': confidence
    };
  },

  _onKeyPress: function (keyPress) {
    if(keyPress.keyCode === 13) {
      this._onSubmit();
    }
  }

});

// expose the coordinate control method type
CoordinateControl.METHOD = METHOD;


module.exports = CoordinateControl;

},{"locationview/ConfidenceCalculator":21}],23:[function(require,module,exports){
/* global L */
'use strict';

var Geocoder = require('locationview/Geocoder');


var CLASS_NAME = 'location-geocode-control',
    CLASS_ENABLED = 'location-control-enabled',
    CLASS_INPUT = 'expandable',
    CLASS_SUBMIT = 'location-control-submit';

var METHOD = 'geocode';

var DEFAULT_OPTIONS = {
  method: METHOD,
  position: 'topleft',
  defaultLocation: null,
  defaultEnabled: false,
  iconClass: 'location-control-icon',
  helpText: 'Search for Address',
  infoText: '<b>Search</b> for a location using an <b>address</b>.'
};

var GeocodeControl = L.Control.extend({
  includes: L.Mixin.Events,

  initialize: function (options) {
    L.Util.setOptions(this, L.Util.extend({}, DEFAULT_OPTIONS, options));
    this._geocoder = new Geocoder();
    this._geocodeSuccess = this._geocodeSuccess.bind(this);
    this._geocodeError = this._geocodeError.bind(this);
  },

  setLocation: function (location, options) {
    this._location = location;

    if (!location || !location.hasOwnProperty('place')) {
      this._address.value = '';
    } else {
      this._address.value = location.place;
    }

    if (!(options && options.silent)) {
      this.fire('location', {'location': location});
    }
  },

  getLocation: function () {
    return this._location;
  },

  onAdd: function (map) {
    var options = this.options,
        stop = L.DomEvent.stopPropagation,
        container,
        control,
        toggle;

    container = document.createElement('div');
    container.classList.add('location-control');
    container.classList.add(CLASS_NAME);
    container.innerHTML = [
      '<a class="', options.iconClass, '"></a>',
      '<span class="help">', options.helpText, '</span>',
      '<div class="', CLASS_INPUT, '">',
        '<input name="address" title="address" class="address" ',
            'placeholder="Address"/>',
        '<button type="search" class="', CLASS_SUBMIT, '">Search</button>',
      '</div>'
    ].join('');

    toggle = container.querySelector('a');
    control = container.querySelector('.' + CLASS_INPUT);

    this._container = container;
    this._toggle = toggle;
    this._control = control;
    this._address = control.querySelector('.address');
    this._submit = container.querySelector('.' + CLASS_SUBMIT);
    this._map = map;

    L.DomEvent.addListener(this._address, 'keyup', this._onKeyUp, this);
    L.DomEvent.addListener(this._submit, 'click', this._onSearchClick, this);
    L.DomEvent.addListener(toggle, 'click', this.toggle, this);
    L.DomEvent.addListener(container, 'click', stop);
    L.DomEvent.addListener(container, 'dblclick', stop);
    L.DomEvent.addListener(container, 'keydown', stop);
    L.DomEvent.addListener(container, 'keyup', stop);
    L.DomEvent.addListener(container, 'keypress', stop);
    L.DomEvent.addListener(container, 'mousedown', stop);
    L.DomEvent.addListener(this._address, 'touchstart', stop);

    return container;
  },

  onRemove: function () {
    var stop = L.DomEvent.stopPropagation,
        container = this._container,
        toggle = this._toggle;

    L.DomEvent.removeListener(this._address, 'keyup', this._onKeyUp);
    L.DomEvent.removeListener(this._submit, 'click', this._onSearchClick);
    L.DomEvent.removeListener(toggle, 'click', this.toggle);
    L.DomEvent.removeListener(container, 'click', stop);
    L.DomEvent.removeListener(container, 'dblclick', stop);
    L.DomEvent.removeListener(container, 'keydown', stop);
    L.DomEvent.removeListener(container, 'keyup', stop);
    L.DomEvent.removeListener(container, 'keypress', stop);
    L.DomEvent.removeListener(container, 'mousedown', stop);
    L.DomEvent.removeListener(this._address, 'touchstart', stop);
  },

  _doGeocode: function (textAddress) {
    this._setLoading(true);
    this._geocoder.forward(textAddress,
        this._geocodeSuccess, this._geocodeError);
  },

  _onKeyUp: function (keyEvent) {
    if (keyEvent.keyCode === 13 && this._address.value !== '') {
      this._doGeocode(this._address.value);
    }
  },

  _onSearchClick: function (/*clickEvent*/) {
    if (this._address.value !== '') {
      this._doGeocode(this._address.value);
    }
  },

  toggle: function (/*clickEvent*/) {
    if (L.DomUtil.hasClass(this._container, CLASS_ENABLED)) {
      this.disable();
    } else {
      this.enable();
    }
  },

  enable: function () {
    L.DomUtil.addClass(this._container, CLASS_ENABLED);
    this._address.focus();

    this.fire('enabled');
  },

  disable: function () {
    L.DomUtil.removeClass(this._container, CLASS_ENABLED);

    this.fire('disabled');
  },

  _geocodeSuccess: function (loc) {
    this._setLoading(false);
    this.setLocation(loc);
    this._address.blur();
  },

  _geocodeError: function (statusCode, statusMessage) {
    this._setLoading(false);
    this.fire('locationError', {
      code: statusCode,
      message: statusMessage
    });
  },

  _setLoading: function (loading) {
    if (loading) {
      L.DomUtil.addClass(this._container, 'loading');
      this._address.disabled = true;
      this._submit.disabled = true;
    } else {
      L.DomUtil.removeClass(this._container, 'loading');
      this._address.disabled = false;
      this._submit.disabled = false;
      this._address.focus();
    }
  }
});

module.exports = GeocodeControl;

},{"locationview/Geocoder":24}],24:[function(require,module,exports){
'use strict';


var ConfidenceCalculator = require('locationview/ConfidenceCalculator'),
    Util = require('util/Util');


// Static incrementor for uniqueness
var GEOCODE_REQUEST_ID = 0;
var METHOD_GEOCODE = 'geocode';

// Forward and reverse Url should conform to ESRI API
var DEFAULTS = {
  // API endpoint for forward geocode searches
  forwardUrl: 'https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/find',

   // Radial distance in meters for revserse geocode searches
  reverseRadius: 5000,

  // API endpoint for reverse geocode searches
  reverseUrl: 'https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode',
};


/**
 * Creates a new geocoder object.
 *
 * @param options {Object}
 *      Configuration options. See DEFAULTS for details.
 *      {forwardUrl} and/or {reverseUrl}.
 */
var Geocoder = function (params) {
  var _this,
      _initialize,

      _forwardUrl,
      _reverseRadius,
      _reverseUrl,

      _buildLocationResult,
      _buildPlaceName,
      _getCallbackName;


  _this = {};

  _initialize = function (params) {
    params = Util.extend({}, DEFAULTS, params);

    _forwardUrl = params.forwardUrl;
    _reverseUrl = params.reverseUrl;
    _reverseRadius = params.reverseRadius;
  };


  /**
   * Private static method.
   *
   * Creates a {location} object from the given {geocodeResponse} and
   * {originalRequest}.
   *
   * @param geocodeResponse {Object}
   *      The first location object returned by the JSONP request.
   * @param originalRequest {Object}
   *      The parameters used to create the original JSONP request.
   *
   * @return {Object}
   *      A location object for use with LocationView and LocationControl
   *      components.
   */
  _buildLocationResult = function (geocodeResponse, originalRequest) {
    var location,
        providedLocation,
        result;

    location = {
      method: METHOD_GEOCODE,
      place: null,
      latitude: null,
      longitude: null,
      confidence: null
    };

    if (originalRequest.location) {
      // reverse lookup
      result = geocodeResponse.address;
      providedLocation = originalRequest.location.split(',');

      location.place = result.Match_addr;
      location.latitude = geocodeResponse.location.y;
      location.longitude = geocodeResponse.location.x;
      location.confidence = ConfidenceCalculator.computeFromCoordinates(
          providedLocation[1], providedLocation[0]);
    } else {
      // forward lookup
      result = geocodeResponse.locations[0];

      location.place = originalRequest.text || result.name;
      location.latitude = result.feature.geometry.y;
      location.longitude = result.feature.geometry.x;
      location.confidence = ConfidenceCalculator.computeFromGeocode(result);
    }

    return location;
  };

  /**
   *
   * @param responseLocation {Object}
   *      A location object returned from the geocoding api
   *
   * @return {String}
   *      A placename
   */
  _buildPlaceName = function (responseLocation) {
    var placename;

    placename = [];

    if (responseLocation.street) {
      placename.push(responseLocation.street);
    }

    if (responseLocation.adminArea5) {
      placename.push(responseLocation.adminArea5);
    }

    if (responseLocation.adminArea3) {
      placename.push(responseLocation.adminArea3);
    }

    if (responseLocation.postalCode) {
      placename.push(responseLocation.postalCode);
    }

    return placename.join(', ');
  };

  /**
   * Private static method.
   *
   * Computes a unique string suitable for use in creating a new global
   * callback method.
   *
   * @return {String}
   *      A unique string.
   */
  _getCallbackName = function () {
    var callback = 'geocode_' + (new Date()).getTime() + '_' +
        GEOCODE_REQUEST_ID;

    GEOCODE_REQUEST_ID += 1;
    return callback;
  };


  /**
   * Performs asynchronous forward geocode requests.
   *
   * @param addressString {String}
   *      The address string to geocode.
   * @param successCallback {Function}
   *      The callback method to execute on success. This callback should expect
   *      a {location} object as its singal parameter.
   * @param errorCallback {Function}
   *      The callback method to execute on error. This callback should expect
   *      {statusCode} and {statusMessage} parameters.
   */
  _this.forward = _this.geocode = function (addressString, successCallback,
      errorCallback) {
    var request = {
      text: addressString
    };

    _this.submitRequest(request, _forwardUrl, successCallback, errorCallback);
  };

  /**
   * Performs asynchronous reverse geocode requests.
   *
   * @param latitude {String}
   *      The latitude of the coordinate to reverse geocode.
   * @param longitude {String}
   *      The longitude of the coordinate to reverse geocode.
   * @param successCallback {Function}
   *      The callback method to execute on success. This callback should expect
   *      a {location} object as its singal parameter.
   * @param errorCallback {Function}
   *      The callback method to execute on error. This callback should expect
   *      {statusCode} and {statusMessage} parameters.
   */
  _this.reverse = _this.reverseGeocode = function (latitude, longitude,
      successCallback, errorCallback) {
    var request = {
      location: '' + longitude + ',' + latitude,
      distance: _reverseRadius
    };

    _this.submitRequest(request, _reverseUrl, successCallback, errorCallback);
  };

  /**
   * Private method.
   *
   * Executes the JSONP request. Called internally by {forward} and {reverse}
   * methods.
   *
   * @param params {Object}
   *      Parameters for the request.
   * @param url {String}
   *      The webservice URL against which to perform the request.
   * @param successCallback {Function}
   *      The callback method to execute on success. This callback should expect
   *      a {location} object as its singal parameter.
   * @param errorCallback {Function}
   *      The callback method to execute on error. This callback should expect
   *      {statusCode} and {statusMessage} parameters.
   */
  _this.submitRequest = function (params, url, successCallback, errorCallback) {

    var script = document.createElement('script'),
        insertAt = document.querySelector('script'),
        request = ['f=pjson'],
        callbackName = _getCallbackName(),
        key = null, cleanup = null, cleanedUp = false;


    request.push('callback=' + callbackName);
    request.push('f=pjson');

    // build up the full request URL based on the input parameters
    for (key in params) {
      request.push(key + '=' + params[key]);
    }

    // callback method used to clean up memory following the JSONP response
    cleanup = function () {
      if (cleanedUp) {
        return;
      }

      window[callbackName] = null;
      delete window[callbackName];

      script.parentNode.removeChild(script);
      script = null;

      cleanedUp = true;
    };

    // JSONP callback method (attached to global window)
    window[callbackName] = function (response) {
      var error;

      if (( // failed forward lookup
            !response.hasOwnProperty('locations') ||
            response.locations.length === 0
          ) &&
          // failed reverse lookup
          !response.hasOwnProperty('address')) {    // failed reverse lookup
        error = response.error || {};

        // Failure
        errorCallback(error.code || 404,
            (error.details && error.details.length) ? error.details[0] :
                error.message || 'No location found.');
      } else {
        // Success I guess...
        successCallback(_buildLocationResult(response, params));
        cleanup();
      }

    };

    // fire off the JSONP request
    script.src = url + '?' + request.join('&');
    script.onLoad = cleanup;
    script.onError = cleanup;
    insertAt.parentNode.insertBefore(script, insertAt);
  };


  _initialize(params);
  params = null;
  return _this;
};


module.exports = Geocoder;

},{"locationview/ConfidenceCalculator":21,"util/Util":"util/Util"}],25:[function(require,module,exports){
/* global L */
'use strict';


var ConfidenceCalculator = require('locationview/ConfidenceCalculator');


var CLASS_NAME = 'location-geolocation-control';
var METHOD = 'geolocation';
var ENABLED_CLASS = 'location-control-enabled';


var DEFAULTS = {
  'method': METHOD,
  'geolocation': navigator.geolocation,
  'position': 'topleft',
  'iconClass': 'location-control-icon',
  'helpText': 'Use Current Location',
  'infoText': 'Attempt to automatically locate my <b>current location</b>.'
};



/**
 * @params geolocation {object} optional api to replace navigator.geolocation
 *         should have a getCurrentPosition call.
 */
var GeolocationControl = L.Control.extend({
  includes: L.Mixin.Events,

  initialize: function (options) {
    L.Util.setOptions(this, L.Util.extend({}, DEFAULTS, options));
    this._geolocateSuccess = this._geolocateSuccess.bind(this);
    this._geolocateError = this._geolocateError.bind(this);
  },

  onAdd: function (map) {
    var options = this.options,
        stop = L.DomEvent.stopPropagation,
        container,
        toggle;

    container = document.createElement('div');
    container.classList.add('location-control');
    container.classList.add(CLASS_NAME);
    container.innerHTML = [
      '<a class="', options.iconClass, '"></a>',
      '<span class="help">', options.helpText, '</span>'
    ].join('');

    toggle = container.querySelector('a');

    this._map = map;
    this._container = container;
    this._toggle = toggle;

    L.DomEvent.addListener(toggle, 'click', this.toggle, this);
    L.DomEvent.addListener(container, 'click', stop);
    L.DomEvent.addListener(container, 'dblclick', stop);
    L.DomEvent.addListener(container, 'keydown', stop);
    L.DomEvent.addListener(container, 'keyup', stop);
    L.DomEvent.addListener(container, 'keypress', stop);
    L.DomEvent.addListener(container, 'mousedown', stop);

    return container;
  },

  onRemove: function () {
    var stop = L.DomEvent.stopPropagation,
        container = this._container,
        toggle = this._toggle;

    L.DomEvent.removeListener(toggle, 'click', this.toggle);
    L.DomEvent.removeListener(container, 'click', stop);
    L.DomEvent.removeListener(container, 'dblclick', stop);
    L.DomEvent.removeListener(container, 'keydown', stop);
    L.DomEvent.removeListener(container, 'keyup', stop);
    L.DomEvent.removeListener(container, 'keypress', stop);
    L.DomEvent.removeListener(container, 'mousedown', stop);
    this._container = null;
    this._toggle = null;
    this._map = null;
  },

  doGeolocate: function () {
    var geolocation = this.options.geolocation;

    this._container.classList.add(ENABLED_CLASS);

    if (geolocation) {
      geolocation.getCurrentPosition(this._geolocateSuccess,
        this._geolocateError);
    } else {
      this._geolocateError({
        code: 0,
        message: 'Geolocation not supported'
      });
    }

    this.fire('enabled');
  },

  _geolocateSuccess: function (position) {
    this._container.classList.remove(ENABLED_CLASS);

    this.setLocation({
        place: null,
        latitude: position.coords.latitude,
        longitude: position.coords.longitude,
        method: METHOD,
        confidence: ConfidenceCalculator.computeFromGeolocate(
          position.coords.accuracy)
    });
  },

  _geolocateError: function (error) {
    this._container.classList.remove(ENABLED_CLASS);

    this.fire('locationError', error);
  },

  setLocation: function (location, options) {
    // API method, this control has nothing to do
    if (!(options && options.silent)) {
      this.fire('location', {'location': location});
    }
  },

  toggle: function (clickEvent) {
    this.enable();
    L.DomEvent.stop(clickEvent);
  },

  enable: function () {
    this.doGeolocate();
  },

  disable: function () {
    // API method, this control has nothing to do
  }

});


GeolocationControl.METHOD = METHOD;


module.exports = GeolocationControl;

},{"locationview/ConfidenceCalculator":21}],26:[function(require,module,exports){
/* global L */
'use strict';


var ConfidenceCalculator = require('locationview/ConfidenceCalculator'),
    CoordinateControl = require('locationview/CoordinateControl'),
    GeocodeControl = require('locationview/GeocodeControl'),
    GeolocationControl = require('locationview/GeolocationControl'),
    PointControl = require('locationview/PointControl');


var CLASS_NAME = 'location-location-control',
    CLASS_ENABLED = CLASS_NAME + '-enabled';


var DEFAULTS = {
  'location': null,
  'position': 'bottomleft',
  'el': null,
  'iconClass': CLASS_NAME + '-icon location-control-icon',
  'helpText': 'Show Location Options'
};

var LOCATION_DEFAULTS = {
  'place': null,
  'latitude': 0,
  'longitude': 0,
  'method': 'unspecified',
  'confidence': ConfidenceCalculator.NOT_COMPUTED
};


var LocationControl = L.Control.extend({
  includes: L.Mixin.Events,

  initialize: function (options) {
    var controls;

    options = L.Util.extend({}, DEFAULTS, options);
    L.Util.setOptions(this, options);

    this._el = this.options.el || document.body;
    this._location = this.options.location;

    controls = [];
    if (options.includeGeolocationControl) {
      controls.push(options.geolocationControl || new GeolocationControl());
    }
    if (options.includeGeocodeControl) {
      controls.push(options.geocodeControl || new GeocodeControl());
    }
    if (options.includeCoordinateControl) {
      controls.push(options.coordinateControl || new CoordinateControl());
    }
    if (options.includePointControl) {
      controls.push(options.pointControl || new PointControl());
    }
    this._controls = controls;
  },

  _eachControl: function (callback) {
    var controls = this._controls,
        control,
        i, len;

    for (i = 0, len = controls.length; i < len; i++) {
      control = controls[i];
      callback(control, i, controls);
    }
  },

  onAdd: function (map) {
    var options = this.options,
        stop = L.DomEvent.stopPropagation,
        container,
        toggle,
        details;

    this._map = map;
    this._enabled = null;

    this._eachControl(function (control) {
      map.addControl(control);
      control.on('location', this.setLocation, this);
      control.on('locationError', this._onLocationError, this);
      control.on('enabled', this._onControlEnabled, this);
    }.bind(this));
    this.on('enabled', this._onControlEnabled, this);

    // Create Information Control (i) button
    container = document.createElement('div');
    container.classList.add('location-control');
    container.classList.add(CLASS_NAME);
    container.innerHTML = [
      '<a class="', options.iconClass, '">i</a>',
      '<span class="help">', options.helpText, '</span>',
    ].join('');
    toggle = container.querySelector('a');

    this._container = container;
    this._toggle = toggle;

    // create overlay with control information
    this._createInformationMenu();
    details = this._details;
    this._el.appendChild(details);


    L.DomEvent.addListener(toggle, 'click', this.toggle, this);
    L.DomEvent.addListener(details, 'click', stop);
    L.DomEvent.addListener(details, 'dblclick', stop);
    L.DomEvent.addListener(details, 'keydown', stop);
    L.DomEvent.addListener(details, 'keyup', stop);
    L.DomEvent.addListener(details, 'keypress', stop);
    L.DomEvent.addListener(details, 'mousedown', stop);
    L.DomEvent.addListener(container, 'click', stop);
    L.DomEvent.addListener(container, 'dblclick', stop);
    L.DomEvent.addListener(container, 'keydown', stop);
    L.DomEvent.addListener(container, 'keyup', stop);
    L.DomEvent.addListener(container, 'keypress', stop);
    L.DomEvent.addListener(container, 'mousedown', stop);

    return container;
  },

  onRemove: function (map) {
    var stop = L.DomEvent.stopPropagation,
        container = this._container,
        toggle = this._toggle,
        details = this._details;

    this._eachControl(function (control) {
      map.removeControl(control);
      control.off('location', this.setLocation, this);
      control.off('locationError', this._onLocationError, this);
      control.off('enabled', this._onControlEnabled, this);
    }.bind(this));
    this.off('enabled', this._onControlEnabled, this);

    L.DomEvent.removeListener(toggle, 'click', this.toggle);
    L.DomEvent.removeListener(details, 'click', stop);
    L.DomEvent.removeListener(details, 'dblclick', stop);
    L.DomEvent.removeListener(details, 'keydown', stop);
    L.DomEvent.removeListener(details, 'keyup', stop);
    L.DomEvent.removeListener(details, 'keypress', stop);
    L.DomEvent.removeListener(details, 'mousedown', stop);
    L.DomEvent.removeListener(container, 'click', stop);
    L.DomEvent.removeListener(container, 'dblclick', stop);
    L.DomEvent.removeListener(container, 'keydown', stop);
    L.DomEvent.removeListener(container, 'keyup', stop);
    L.DomEvent.removeListener(container, 'keypress', stop);
    L.DomEvent.removeListener(container, 'mousedown', stop);

    this._el.removeChild(details);
    this._details = null;
    this._container = null;
    this._toggle = null;
    this._map = null;
  },

  /**
   * Create a help/info menu with detailed descriptions of each control
   *
   * @return {[type]} [description]
   */
  _createInformationMenu: function () {
    var stop = L.DomEvent.stopPropagation,
        panel,
        list;

    panel = document.createElement('div');
    panel.classList.add('information-list-mask');
    panel.innerHTML = '<ul class="information-list"></ul>';
    list = panel.querySelector('.information-list');

    this._eachControl(function (control, index) {
      var controlOptions = control.options,
          controlEl = control.__infoEl;

      if (!controlEl) {
        controlEl = document.createElement('li');
        controlEl.setAttribute('data-index', index);
        controlEl.innerHTML = [
          '<span title="', controlOptions.helpText, '"',
              ' class="location-control-icon ',
              controlOptions.iconClass, '-', controlOptions.method,
              '"></span>',
          '<p>', controlOptions.infoText, '</p>'
        ].join('');
        L.DomEvent.addListener(controlEl, 'click', control.enable, control);
        control.__infoEl = controlEl;
      }

      list.appendChild(controlEl);
    });

    // create div for information menu
    this._details = panel;

    // stop interaction with map when the information menu is visible
    L.DomEvent.on(panel, 'mousedown', stop);
    L.DomEvent.on(panel, 'dblclick', stop);
    L.DomEvent.on(panel, 'wheel', stop);
  },

  toggle: function () {
    if (!this._el.classList.contains(CLASS_ENABLED)) {
      this.enable();
    } else {
      this.disable();
    }
  },

  enable: function () {
    this._el.classList.add(CLASS_ENABLED);

    this.fire('enabled');
  },

  disable: function () {
    this._el.classList.remove(CLASS_ENABLED);

    this.fire('disabled');
  },

  _onControlEnabled: function (e) {
    var target = null;

    if (e) {
      target = e.target;
    }

    this._eachControl(function (control) {
      if (control !== target) {
        control.disable();
      }
    });

    if (target !== this) {
      // hide details
      this.disable();
    }
  },

  setLocation: function (e, options) {
    var zoomLevel,
        location = e;

    if (e) {
      if (e.type === 'location') {
        location = e.location;
      }
    }

    if (location !== null) {
      location = {
        place: location.place || LOCATION_DEFAULTS.place,
        latitude: location.latitude || LOCATION_DEFAULTS.latitude,
        longitude: location.longitude || LOCATION_DEFAULTS.longitude,
        confidence: location.confidence || LOCATION_DEFAULTS.confidence,
        method: location.method || LOCATION_DEFAULTS.method
      };
    }

    this._location = location;
    this._eachControl(function (control) {
      control.setLocation(location, {'silent': true});
    });

    if (location) {
      zoomLevel = ConfidenceCalculator.computeZoomFromConfidence(
          location.confidence);
      // do not zoom the user out
      if (zoomLevel < this._map._zoom) {
        zoomLevel = this._map._zoom;
      }

      // center the map on the new point
      this._centerMapOnPoint(location, zoomLevel);

    } else {
      // enable the location control
      this.enable();
    }

    if (!(options && options.silent)) {
      this.fire('location', {'location':location});
    }
  },

  getLocation: function () {
    return this._location;
  },

  /**
   * Check to see if point is currently visible with map bounds.
   * If the point is within the map bounds do not pan the map.
   * Center when the new location is not visible or the map
   * is being zoomed-in.
   *
   * @param  {object} location, leaflet location object
   * @param  {integer} newZoomLevel, current map zoom level
   *
   */
  _centerMapOnPoint: function (location, newZoomLevel) {
    var centerMap = false,
        oldZoomLevel = this._map._zoom,
        mapBounds = this._map.getBounds(),
        newLocation = [location.latitude, location.longitude];

    if (!mapBounds.contains(newLocation) || newZoomLevel > oldZoomLevel) {
      centerMap = true;
    }

    if (centerMap) {
      this._map.setView({
          lon: location.longitude,
          lat: location.latitude
        },
        newZoomLevel
      );
    }

    return centerMap;
  },

  _onLocationError: function (error) {
    // TODO, make this better
    window.alert(error.message);
  }

});

module.exports = LocationControl;

},{"locationview/ConfidenceCalculator":21,"locationview/CoordinateControl":22,"locationview/GeocodeControl":23,"locationview/GeolocationControl":25,"locationview/PointControl":28}],27:[function(require,module,exports){
/* global L */
'use strict';


var Events = require('util/Events'),
    LocationControl = require('locationview/LocationControl'),
    ModalView = require('mvc/ModalView'),
    Util = require('util/Util');


var DEFAULTS = {
  autoOpen: false,
  includePointControl: true,       // Manages location via pin on map
  includeCoordinateControl: true,  // Manages location via lat/lng input
  includeGeocodeControl: true,     // Manages location via address input
  includeGeolocationControl:       // Manages location via auto-detect (W3C)
      navigator && 'geolocation' in navigator,
  callback: function (/*location*/) {}
};


/**
 * Helper method to get URLs for any ArcGIS Online map tiles.
 *
 * @param serviceName {String}
 *        The name of the map tile service for which to return a URL template.
 *
 * @return {String}
 *         The service URL template for use in an L.TileLayer.
 */
var __get_arcgisonline_url = function (serviceName) {
  var urlPrefix = '//server.arcgisonline.com/ArcGIS/rest/services/',
      urlSuffix = '/MapServer/tile/{z}/{y}/{x}';

  return urlPrefix + serviceName + urlSuffix;
};


/**
 * @constructor
 * Creates a new LocationView.
 *
 * @param params {Object}
 *        An object containing configuration params. See DEFAULTS for
 *        detailed documentation on what can be specified.
 */
var LocationView = function (params) {
  var _this,
      _initialize,

      _callback,
      _includeCoordinateControl,
      _includeGeocodeControl,
      _includeGeolocationControl,
      _includePointControl,
      _locationControl,
      _map,
      _mapContainer,
      _modal,

      _createMap,
      _createModal,
      _onLocation;


  _this = Events();

  _initialize = function () {
    params = Util.extend({}, DEFAULTS, params || {});

    _callback = params.callback;
    _includePointControl = params.includePointControl;
    _includeGeolocationControl = params.includeGeolocationControl;
    _includeGeocodeControl = params.includeGeocodeControl;
    _includeCoordinateControl = params.includeCoordinateControl;

    _createMap();   // Defines this._map as a Leaflet map
    _createModal(); // Defines this._modal as a ModalView

    if (params.autoOpen) {
      _this.show();
    }

    params = null;
  };

  /**
   * @PrivateInitializer
   * Called during construction. Creates and initializes the map component.
   *
   * Defines:
   *      _map {L.Map}
   *      _mapContainer {DomElement}
   *      _locationControl {LocationControl}
   *
   */
  _createMap = function () {
    var layerControl = new L.Control.Layers();

    _mapContainer = document.createElement('div');
    _mapContainer.classList.add('locationview-map');

    _map = new L.Map(_mapContainer, {
      zoomControl: !Util.isMobile(),
      attributionControl: false
    });

    _map.fitBounds([[70.0, -170.0], [-50.0, 170.0]]);

    layerControl.addBaseLayer(new L.TileLayer(
        __get_arcgisonline_url('NatGeo_World_Map'))
        .addTo(_map), 'Topography');
    layerControl.addBaseLayer(new L.TileLayer(
        __get_arcgisonline_url('Canvas/World_Light_Gray_Base')), 'Grayscale');
    layerControl.addBaseLayer(new L.TileLayer(
        __get_arcgisonline_url('World_Imagery')), 'Satellite');

    // TODO :: Use a real location control
    _locationControl = new LocationControl({
      el: _mapContainer,
      includePointControl: _includePointControl,
      includeCoordinateControl: _includeCoordinateControl,
      includeGeocodeControl: _includeGeocodeControl,
      includeGeolocationControl: _includeGeolocationControl
    });
    _locationControl.enable();
    _map.addControl(layerControl);          // Layer switcher
    _map.addControl(_locationControl); // Methods to set locations
  };

  /**
   * @PrivateInitializer
   * Called during construction. Creates and initializes the modal component.
   *
   * Defines:
   *      this._modal {ModalView}
   *
   */
  _createModal = function () {
    _modal = new ModalView(_mapContainer, {
      title: 'Specify a Location',
      classes: ['locationview'],
      buttons: [
        {
          text: 'Use this Location',
          classes: ['locationview-button'],
          callback: function () {
            _callback(_locationControl.getLocation());
            _modal.hide();
          }
        }
      ]
    });
    _locationControl.on('location', _onLocation);
    /* Called initially to disable the button if you enter the location view
     * with no location information, or enable it if location information exists
     */
    _onLocation();
  };


  /**
   * @PrivateInitializer
   * Toggles the "Use this Location" button in the footer of the modal view to
   * to be disabled when the location is null and enabled otherwise.
   *
   */
  _onLocation = function (e) {
    var button = _modal.el.querySelector('.locationview-button'),
        location;

    if (e) {
      if (e.type === 'location') {
        location = e.location;
      }
    }

    _this.trigger('location', location);

    if (location) {
      button.disabled = false;
      button.innerHTML = 'Use this Location';
      button.classList.add('locationview-button-enabled');
      button.classList.remove('locationview-button-disabled');
    } else {
      button.disabled = true;
      button.innerHTML = 'No Location Selected';
      button.classList.add('locationview-button-disabled');
      button.classList.remove('locationview-button-enabled');
    }
  };


  /**
   * @APIMethod
   * Hides the LocationView.
   *
   */
  _this.hide = function () {
    _modal.hide();
  };

  /**
   * @APIMethod
   * Shows the LocationView. If no options are specified, there is no default
   * location displayed and the map will show roughly one instance of the
   * entire world.
   *
   * @param options {Object}
   *        Configuration options for default extent and location when the
   *        LocationView is shown.
   *
   *        extent {Array{Array{Number}}}
   *             An array defining the map extent. The first element of this
   *             array is an array containing numbers representing the
   *             latitude and longitude of the top-left corner of the extent.
   *             The second element of this array is an array containing
   *             numbers representing the latitude and longitude of the bottom
   *             right corner of the extent.
   *        location {Object}
   *             A location object to use as the starting location. This
   *             location will be displayed initially and also returned if the
   *             user does not change it. If null, any previously set location
   *             is cleared.
   */
  _this.show = function (options) {
    _modal.show();
    _this.updateMap(options);
  };

  /**
   * @APIMethod
   * Sets initial map display when showing the map.
   *
   * @param options {Object}
   *        Options for setting initial map display properties when showing
   *        the location view. See LocationView.show for more details.
   */
  _this.updateMap = function (options) {
    options = options || {};
    _map.invalidateSize();

    if (options.hasOwnProperty('location')) {
      _locationControl.setLocation(options.location);
      _locationControl.disable();
    }

    if (options.hasOwnProperty('extent')) {
      _map.fitBounds(options.extent);
    }
  };


  _initialize();
  return _this;
};


module.exports = LocationView;

},{"locationview/LocationControl":26,"mvc/ModalView":37,"util/Events":"util/Events","util/Util":"util/Util"}],28:[function(require,module,exports){
/* global L */
'use strict';

var ConfidenceCalculator = require('locationview/ConfidenceCalculator');


var CLASS_NAME = 'location-point-control';
var CLASS_ENABLED = 'location-control-enabled';
var CLASS_LOCATION = CLASS_NAME + '-active';
var METHOD = 'point';

var DEFAULT_OPTIONS = {
  method: METHOD,
  position: 'topleft',
  defaultLocation: null,
  defaultEnabled: false,
  iconClass: 'location-control-icon',
  helpText: 'Drop Pin',
  infoText: '<b>Drop pin</b> on the map to specify a location.'
};


var PointControl = L.Control.extend({
  includes: L.Mixin.Events,

  initialize: function (options) {
    options = L.Util.extend({}, DEFAULT_OPTIONS, options);
    L.Util.setOptions(this, options);

    this._isEnabled = options.defaultEnabled;
    this._marker = new L.Marker([0, 0], {draggable: true});
    this._marker.bindPopup();
    this.setLocation(options.defaultLocation);
  },

  setLocation: function (location, options) {
    var map = this._map,
        marker = this._marker;

    if (location !== null) {
      // update marker
      marker.setLatLng(new L.LatLng(location.latitude, location.longitude));
      marker.setPopupContent(this._formatLocation(location));
      // add marker
      if (map && !marker._map) {
        marker.addTo(map);
      }
    } else {
      // clear popup content
      marker.setPopupContent('');
      // remove marker
      if (map && marker._map) {
        map.removeLayer(marker);
      }
    }

    if (!(options && options.hasOwnProperty('silent') && options.silent)) {
      this.fire('location', {'location': location});
    }
  },

  getLocation: function () {
    if (!this._marker._map) {
      return null;
    }
    return this._createPointLocation(this._marker.getLatLng());
  },

  onAdd: function (map) {
    var options = this.options,
        stop = L.DomEvent.stopPropagation,
        container,
        toggle;

    container = document.createElement('div');
    container.classList.add('location-control');
    container.classList.add(CLASS_NAME);
    container.innerHTML = [
      '<a class="', options.iconClass, '"></a>',
      '<span class="help">', options.helpText, '</span>'
    ].join('');

    toggle = container.querySelector('a');

    this._map = map;
    this._container = container;
    this._toggle = toggle;

    // If enabled, bind map click handlers
    if (this.options.defaultEnabled) {
      this.enable();
    }

    // Enable/disable control if user clicks on it
    L.DomEvent.addListener(toggle, 'click', this.toggle, this);
    L.DomEvent.addListener(container, 'click', stop);
    L.DomEvent.addListener(container, 'dblclick', stop);
    L.DomEvent.addListener(container, 'keydown', stop);
    L.DomEvent.addListener(container, 'keyup', stop);
    L.DomEvent.addListener(container, 'keypress', stop);
    L.DomEvent.addListener(container, 'mousedown', stop);
    this._marker.on('dragend', this._onDragEnd, this);

    return container;
  },

  onRemove: function (map) {
    var stop = L.DomEvent.stopPropagation,
        container = this._container,
        toggle = this._toggle;

    if (this._isEnabled) {
      this.disable();
    }

    L.DomEvent.removeListener(toggle, 'click', this.toggle);
    L.DomEvent.removeListener(container, 'click', stop);
    L.DomEvent.removeListener(container, 'dblclick', stop);
    L.DomEvent.removeListener(container, 'keydown', stop);
    L.DomEvent.removeListener(container, 'keyup', stop);
    L.DomEvent.removeListener(container, 'keypress', stop);
    L.DomEvent.removeListener(container, 'mousedown', stop);
    this._marker.off('dragend', this._onDragEnd, this);

    map.removeLayer(this._marker);

    this._map = null;
    this._container = null;
    this._toggle = null;
  },

  _bindMapEventHandlers: function () {
    this._map.on('click', this._onClick, this);
    this._map.on('boxzoomstart', this._onBoxZoomStart, this);
  },

  _unbindMapEventHandlers: function () {
    this._map.off('click', this._onClick, this);
    this._map.off('boxzoomstart', this._onBoxZoomStart, this);
  },

  /**
   * Map event listener. This listener is only active when this control is
   * enabled. The _{un}bindMapEventHandlers methods will add and remove the
   * listener that activates this method call.
   *
   * @param mouseEvent {MouseEvent}
   */
  _onClick: function (mouseEvent) {
    if (this._boxZoomStarted === true) {
      this._boxZoomStarted = false;
      return;
    }
    this.setLocation(this._createPointLocation(mouseEvent.latlng));
  },

  _onDragEnd: function () {
    this.setLocation(this._createPointLocation(this._marker.getLatLng()));
  },

  _onBoxZoomStart: function () {
    this._boxZoomStarted = true;
  },

  _createPointLocation: function (latlng) {
    return {
      place: null,
      latitude: latlng.lat,
      longitude: latlng.lng,
      method: METHOD,
      confidence: this._computeConfidence()
    };
  },

  _computeConfidence: function () {
    return ConfidenceCalculator.computeFromPoint(this._map.getZoom());
  },

  toggle: function (clickEvent) {
    if (this._isEnabled) {
      this.disable();
    } else {
      this.enable();
    }
    L.DomEvent.stop(clickEvent);
  },

  enable: function () {
    var mapContainer = this._map.getContainer();

    L.DomUtil.addClass(this._container, CLASS_ENABLED);
    L.DomUtil.addClass(mapContainer, CLASS_LOCATION);

    this._bindMapEventHandlers();
    this._isEnabled = true;
    this._boxZoomStarted = false;

    this.fire('enabled');
  },

  disable: function () {
    var mapContainer = this._map ? this._map.getContainer() : null;

    L.DomUtil.removeClass(this._container, CLASS_ENABLED);
    L.DomUtil.removeClass(mapContainer, CLASS_LOCATION);

    this._unbindMapEventHandlers();
    this._isEnabled = false;

    this.fire('disabled');
  },

  _formatLocation: function (location) {
    var lat = location.latitude,
        lng = location.longitude,
        confidence = location.confidence,
        place = location.place,
        latStr = (lat < 0.0) ? '&deg;S' : '&deg;N',
        lngStr = (lng < 0.0) ? '&deg;W' : '&deg;E',
        buf = [];

    lat = ConfidenceCalculator.roundLocation(Math.abs(lat), confidence);
    lng = ConfidenceCalculator.roundLocation(Math.abs(lng), confidence);

    if (place !== null) {
      buf.push('<p>', place, '</p>');
    }
    buf.push(lat, latStr, ', ', lng, lngStr);
    return buf.join('');
  }
});

module.exports = PointControl;

},{"locationview/ConfidenceCalculator":21}],29:[function(require,module,exports){
'use strict';

var Util = require('util/Util'),
    View = require('mvc/View');


// Default values used by constructor.
var _DEFAULTS = {
  // label - The question being asked
  label: null,
  // multiSelect - false = radio buttons, true = or checkboxes, radio is default
  multiSelect: false,
  // selectedAnswer - Any answers that should be selected by default
  selectedAnswer: null,
  // answers - Array of answers, each with attributes:
  //      value - The "value" for the input
  //      label - The answer to show the user
  //      otherValue - Optional extra value for more info
  //      otherLabel - Question to ask associate with otherValue
  answers: null
};

var _ID_SEQUENCE = 0;


// ----------------------------------------------------------------------
// Initialization Methods
// ----------------------------------------------------------------------

/**
 * Class: QuestionView
 * Creates a new QuestionView.
 *
 * @param options {Object}
 *        An object containing configuration options. See _DEFAULTS above for
 *        detailed documentation on what can be specified.
 */
var QuestionView = function (options) {
  var _this,
      _initialize,

      _answerIndex,
      _answerList,
      _options,

      _addAnswer,
      _addAnswers,
      _onBlur,
      _onChange;


  _this = View(options);
  /**
   * @constructor
   *
   */
  _initialize = function (options) {
    var section = document.createElement('section');

    _options = Util.extend({}, _DEFAULTS, options);
    _answerIndex = [];

    section.classList.add('question');

    section.appendChild(_addAnswers());

    _this.setAnswers(_options.selectedAnswer);

    _this.el.innerHTML = '';
    _this.el.appendChild(section);
  };


  /**
   * Wrap a single answer in appropriate html.
   *
   * @param answer {Object}
   *        qId {Integer} Unique identifier for the question
   *        ul {Document.Element} Container element for the answers
   *
   * @return String
   *         Contains an answer wrapped in appropriate HTML.
   *
   */
  _addAnswer = function (answer, qId, ul) {
    var _label = answer.label,
        _otherLabel = answer.otherLabel,
        _otherValue = answer.otherValue,
        _value = answer.value,
        answerId = 'answer-' + (++_ID_SEQUENCE),
        inputType = (_options.multiSelect ? 'checkbox' : 'radio'),
        li = document.createElement('li'),
        label = document.createElement('label'),
        input = document.createElement('input'),
        answerText = document.createTextNode(_label);

    input.type = inputType;
    input.name = qId;
    input.id = answerId;
    input.value = _value;

    label.setAttribute('for', answerId);
    label.classList.add('answer');
    label.appendChild(answerText);

    li.appendChild(input);
    li.appendChild(label);

    if (typeof _otherLabel === 'string') {
      var textbox = document.createElement('input');
      textbox.type = 'text';
      textbox.name = qId + '-other';
      textbox.id = answerId + '-other';
      textbox.value = _otherValue;
      textbox.classList.add('question-other');
      textbox.placeholder = _otherLabel;
      li.appendChild(textbox);
    }
    ul.appendChild(li);
  };

  /**
   * Add all answers to the list of answers.
   *
   * @return String
   *         Contains a list of answer options wrapped in appropriate HTML.
   *
   */
  _addAnswers = function () {
    var answers = _options.answers,
        answerElement,
        questionId = 'question-' + (++_ID_SEQUENCE),
        legend = document.createElement('legend'),
        ul = document.createElement('ul'),
        answerIndex = _answerIndex,
        answer,
        i,
        len;

    ul.classList.add('question-answers');
    _answerList = document.createElement('fieldset');
    _answerList.name = questionId;
    legend.textContent = options.label;
    _answerList.appendChild(legend);

    if (answers !== null) {
      for (i=0, len=answers.length; i<len; i++) {
        _addAnswer(answers[i], questionId, ul);
      }
      _answerList.appendChild(ul);

      // Keep track of answers with array of answer objects.
      for (i=0, len=answers.length; i<len; i++) {
        answer = answers[i];

        answerIndex[answer.value] = i;
      }

      answerElement = _answerList.getElementsByTagName('li');
      for (i=0, len=answerElement.length; i<len; i++) {
        var inputs = answerElement[i].getElementsByTagName('input');
        inputs[0].addEventListener('change', _onChange);
        if (inputs[1] !== undefined) {
          inputs[1].addEventListener('blur', _onBlur);
        }
      }
    }

    return _answerList;
  };

  /**
   * Event listener for "other" inputs.
   * Text boxes.
   *      If the value in the text box changes, save the change.
   *
   */
  _onBlur = function (ev) {
    var _target = ev.target,
        answers = _options.answers,
        answerElement = _answerList.getElementsByTagName('li'),
        i,
        len = answerElement.length;

    for (i=0; i<len; i++) {
      var inputs = answerElement[i].getElementsByTagName('input');
      if (inputs[1] === _target) {
        if (answers[i].otherValue !== _target.value) {
          answers[i].otherValue = _target.value;
          _this.trigger('change', _this);
        }
        break;
      }
    }
  };

  /**
   * Event listener for "other" inputs.
   * Radio buttons & check boxes.
   *       Enable or disable text boxes associated with "other".
   *       Put focus in text box when associated radio/checkbox is selected.
   *
   */
  _onChange = function (ev) {
    var _target = ev.target,
        answerElement = _answerList.getElementsByTagName('li'),
        i,
        len = answerElement.length,
        checked;

    for (i=0; i<len; i++) {
      var inputs = answerElement[i].getElementsByTagName('input');
      // If there is an "other" input textbox
      if (inputs[1] !== undefined) {
        checked = inputs[0].checked;
        inputs[1].disabled = !checked;
        // If the "other" input checkbox for this textbox is target
        if (inputs[0] === _target && checked) {
          inputs[1].focus();
          inputs[1].setSelectionRange(0, inputs[1].value.length);
        }
      }
    }
    _this.trigger('change', _this);
  };


// ----------------------------------------------------------------------
// Public Methods
// ----------------------------------------------------------------------


  /**
   * Clear all answers.
   *       Uncheck all check boxes and radio buttons.
   *       Disable all text boxes for "other" fields.
   */
  _this.clearAnswers = function () {
    var answerElement = _answerList.getElementsByTagName('li'),
        i,
        len = answerElement.length;

    for (i=0; i<len; i++) {
      var inputs = answerElement[i].getElementsByTagName('input');
      inputs[0].checked = false;
      // If there is an "other" input textbox
      if (inputs[1] !== undefined) {
        inputs[1].disabled = true;
      }
    }
  };

  /**
   * Clean up event listeners, remove list of answers
   *
   */
  _this.destroy = function () {
    var answerElement = _answerList.getElementsByTagName('li'),
        i,
        len = answerElement.length;

    _answerList = null;
    for (i=0; i<len; i++) {
      var inputs = answerElement[i].getElementsByTagName('input');
      inputs[0].removeEventListener('change', _onChange);
      if (inputs[1] !== undefined) {
        inputs[1].removeEventListener('blur', _onBlur);
      }
      inputs = null;
    }
    answerElement = null;
  };

  /**
   * Return list of answers.
   *
   * @return {Object|Array}
   *         Null if no answers are selected
   *         An object containing a single answer if only 1 is selected
   *         An array of answer objects if there is more than 1
   */
  _this.getAnswers = function () {
    var currentAnswer = [],
        answerElement = _answerList.getElementsByTagName('li'),
        checkedAnswer,
        i,
        len = answerElement.length;

    for (i=0; i<len; i++) {
      var inputs = answerElement[i].getElementsByTagName('input');
      if (inputs[0].checked) {
        if (inputs[1] !== undefined) {
          checkedAnswer = {
            value: inputs[0].value,
            label: answerElement[i].innerText,
            otherValue: inputs[1].value,
            otherLabel: inputs[1].placeholder
          };
        } else {
          checkedAnswer = {
            value: inputs[0].value,
            label: answerElement[i].innerText
          };
        }
        currentAnswer.push(
          checkedAnswer
        );
      }
    }

    if (currentAnswer.length === 0) {
      return null;
    } else if (_options.multiSelect) {
      return currentAnswer;
    } else {
      return currentAnswer[0];
    }
  };

  /**
   * Sets input.checked on input elements.
   * Assumes a string for the "value" of a single answer.
   *
   * @param {String}
   *        The "value" of the selected answer.
   */
  _this.selectAnswers = function (answer) {
    var inputs;

    if (typeof answer !== 'undefined') {
      inputs = answer.getElementsByTagName('input');
      if (inputs[0]) {
        inputs[0].checked = true;
        // If there is an "other" input textbox
        if (inputs[1] !== undefined) {
          inputs[1].disabled = false;
        }
      }
    }
  };

  /**
   * Finds all of the selected answers.
   * Calls selectAnswer with each of them.
   *
   * Assumes a string for the value of a single answer if multiSelect:false
   * Assumes an array of answer values if multiSelect:true
   *
   * @param {String|Array}
   *        A string containing the "value" of the selected answer.
   *        The list of currently selected answers as strings.
   */
  _this.setAnswers = function (selectedAnswer) {
    var answerElement,
        answer,
        i,
        len;

    if (_answerList !== null) {
      answerElement = _answerList.getElementsByTagName('li');

      // Make sure everything is unchecked first
      _this.clearAnswers();

      if (selectedAnswer === null) {
        return;
      }

      if (typeof selectedAnswer === 'string') {
        answer = answerElement[_answerIndex[selectedAnswer]];
        _this.selectAnswers(answer);
      } else {  // Array of strings
        for (i=0, len=selectedAnswer.length; i<len; i++) {
          answer = answerElement[_answerIndex[selectedAnswer[i]]];
          _this.selectAnswers(answer);
        }
      }
    }
  };

  _initialize(options);
  options = null;
  return _this;
};

module.exports = QuestionView;

},{"mvc/View":"mvc/View","util/Util":"util/Util"}],30:[function(require,module,exports){
'use strict';

var Vector = require('./Vector');


// static methods that operate on arrays
var __col,
    __diagonal,
    __get,
    __identity,
    __index,
    __jacobi,
    __multiply,
    __row,
    __set,
    __stringify,
    __transpose;


/**
 * Extract a column from this matrix.
 *
 * @param data {Array<Number>}
 *        matrix data.
 * @param m {Number}
 *        number of rows.
 * @param n {Number}
 *        number of columns.
 * @param col {Number}
 *        index of column, in range [0,n)
 * @throws Error if column out of range.
 * @return {Array<Number>} column elements.
 */
__col = function (data, m, n, col) {
  var row,
      values = [];
  if (col < 0 || col >= n) {
    throw new Error('column ' + col + ' out of range [0,' + n + ')');
  }
  if (n === 1) {
    // only one column in matrix
    return data;
  }
  values = [];
  for (row = 0; row < m; row++) {
    values.push(data[__index(m, n, row, col)]);
  }
  return values;
};

/**
 * Get array of elements on the diagonal.
 *
 * @param data {Array<Number>}
 *        matrix data.
 * @param m {Number}
 *        number of rows.
 * @param n {Number}
 *        number of columns.
 * @return {Array<Number>} elements on the diagonal.
 */
__diagonal = function (data, m, n) {
  var len = Math.min(m, n),
      diag = [],
      i;
  for (i = 0; i < len; i++) {
    diag.push(data[__index(m, n, i, i)]);
  }
  return diag;
};

/**
 * Get the value of an element of this matrix.
 *
 * @param data {Array<Number>}
 *        matrix data.
 * @param m {Number}
 *        number of rows.
 * @param n {Number}
 *        number of columns.
 * @param row {Number}
 *        row of element, in range [0,m)
 * @param col {Number}
 *        column of element, in range [0,n)
 * @throws Error if row or col are out of range.
 * @return {Number} value.
 */
__get = function (data, m, n, row, col) {
  return data[__index(m, n, row, col)];
};

/**
 * Create an identity Matrix.
 *
 * @param n {Number}
 *        number of rows and columns.
 * @return identity matrix of size n.
 */
__identity = function (n) {
  var values = [],
      row,
      col;
  for (row = 0; row < n; row++) {
    for (col = 0; col < n; col++) {
      values.push((row === col) ? 1 : 0);
    }
  }
  return values;
};

/**
 * Get the index of an element of this matrix.
 *
 * @param data {Array<Number>}
 *        matrix data.
 * @param m {Number}
 *        number of rows.
 * @param n {Number}
 *        number of columns.
 * @param row {Number}
 *        row of element, in range [0,m)
 * @param col {Number}
 *        column of element, in range [0,n)
 * @return {Number} index.
 */
__index = function (m, n, row, col) {
  return n * row + col;
};

/**
 * Jacobi eigenvalue algorithm.
 *
 * Ported from:
 *     http://users-phys.au.dk/fedorov/nucltheo/Numeric/now/eigen.pdf
 *
 * An iterative method for eigenvalues and eigenvectors,
 * only works on symmetric matrices.
 *
 * @param data {Array<Number>}
 *        matrix data.
 * @param m {Number}
 *        number of rows.
 * @param n {Number}
 *        number of columns.
 * @param maxRotations {Number}
 *        maximum number of rotations.
 *        Optional, default 100.
 * @return {Array<Vector>} array of eigenvectors, magnitude is eigenvalue.
 */
__jacobi = function (data, m, n, maxRotations) {
  var a,
      aip,
      aiq,
      api,
      app,
      app1,
      apq,
      aqi,
      aqq,
      aqq1,
      c,
      changed,
      e,
      i,
      ip,
      iq,
      p,
      phi,
      pi,
      q,
      qi,
      rotations,
      s,
      v,
      vector,
      vectors,
      vip,
      viq;

  if (m !== n) {
    throw new Error('Jacobi only works on symmetric, square matrices');
  }

  // set a default max
  maxRotations = maxRotations || 100;
  a = data.slice(0);
  e = __diagonal(data, m, n);
  v = __identity(n);
  rotations = 0;

  do {
    changed = false;

    for (p=0; p<n; p++) {
      for (q=p+1; q<n; q++) {
        app = e[p];
        aqq = e[q];
        apq = a[n * p + q];
        phi = 0.5 * Math.atan2(2 * apq, aqq - app);
        c = Math.cos(phi);
        s = Math.sin(phi);
        app1 = c * c * app - 2 * s * c * apq + s * s * aqq;
        aqq1 = s * s * app + 2 * s * c * apq + c * c * aqq;

        if (app1 !== app || aqq1 !== aqq) {
          changed = true;
          rotations++;

          e[p] = app1;
          e[q] = aqq1;
          a[n * p + q] = 0;

          for (i = 0; i < p; i++) {
            ip = n * i + p;
            iq = n * i + q;
            aip = a[ip];
            aiq = a[iq];
            a[ip] = c * aip - s * aiq;
            a[iq] = c * aiq + s * aip;
          }
          for (i = p + 1; i < q; i++) {
            pi = n * p + i;
            iq = n * i + q;
            api = a[pi];
            aiq = a[iq];
            a[pi] = c * api - s * aiq;
            a[iq] = c * aiq + s * api;
          }
          for (i = q + 1; i < n; i++) {
            pi = n * p + i;
            qi = n * q + i;
            api = a[pi];
            aqi = a[qi];
            a[pi] = c * api - s * aqi;
            a[qi] = c * aqi + s * api;
          }
          for (i = 0; i < n; i++) {
            ip = n * i + p;
            iq = n * i + q;
            vip = v[ip];
            viq = v[iq];
            v[ip] = c * vip - s * viq;
            v[iq] = c * viq + s * vip;
          }
        }
      }
    }
  } while (changed && (rotations < maxRotations));

  if (changed) {
    throw new Error('failed to converge');
  }

  vectors = [];
  for (i = 0; i < n; i++) {
    // i-th vector is i-th column
    vector = Vector(__col(v, m, n, i));
    vector.eigenvalue = e[i];
    vectors.push(vector);
  }

  return vectors;
};

/**
 * Multiply this matrix by another matrix.
 *
 * @param data1 {Array<Number>}
 *        first matrix data.
 * @param m1 {Number}
 *        number of rows in first matrix.
 * @param n1 {Number}
 *        number of columns in first matrix.
 * @param data2 {Array<Number>}
 *        second matrix data.
 * @param m2 {Number}
 *        number of rows in second matrix.
 * @param n2 {Number}
 *        number of columns in second matrix.
 * @throws Error if n1 !== m2
 * @return result of multiplication (original matrix is unchanged).
 */
__multiply = function (data1, m1, n1, data2, m2, n2) {
  var col,
      col2,
      row,
      row1,
      values;

  if (n1 !== m2) {
    throw new Error('wrong combination of rows and cols');
  }
  values = [];
  for (row = 0; row < m1; row++) {
    row1 = __row(data1, m1, n1, row);
    for (col = 0; col < n2; col++) {
      col2 = __col(data2, m2, n2, col);
      // result is dot product
      values.push(Vector.dot(row1, col2));
    }
  }
  return values;
};

/**
 * Extract a row from this matrix.
 *
 * @param data {Array<Number>}
 *        matrix data.
 * @param m {Number}
 *        number of rows.
 * @param n {Number}
 *        number of columns.
 * @param row {Number}
 *        index of row, in range [0,m)
 * @throws Error if row out of range.
 * @return {Array<Number>} row elements.
 */
__row = function (data, m, n, row) {
  var col,
      values;
  if (row < 0 || row >= m) {
    throw new Error('row ' + row + ' out of range [0,' + m + ')');
  }
  values = [];
  for (col = 0; col < n; col++) {
    values.push(data[__index(m, n, row, col)]);
  }
  return values;
};

/**
 * Set the value of an element of this matrix.
 *
 * NOTE: this method modifies the contents of this matrix.
 *
 * @param data {Array<Number>}
 *        matrix data.
 * @param m {Number}
 *        number of rows.
 * @param n {Number}
 *        number of columns.
 * @param row {Number}
 *        row of element, in range [0,m)
 * @param col {Number}
 *        column of element, in range [0,n)
 * @param value {Number}
 *        value to set.
 * @throws Error if row or col are out of range.
 */
__set = function (data, m, n, row, col, value) {
  data[__index(m, n, row, col)] = value;
};

/**
 * Display matrix as a string.
 *
 * @param data {Array<Number>}
 *        matrix data.
 * @param m {Number}
 *        number of rows.
 * @param n {Number}
 *        number of columns.
 * @return {String} formatted matrix.
 */
__stringify = function (data, m, n) {
  var lastRow = m - 1,
      lastCol = n - 1,
      buf = [],
      row,
      col;

  buf.push('[');
  for (row = 0; row < m; row++) {
    for (col = 0; col < n; col++) {
      buf.push(
          data[n * row + col],
          (col !== lastCol || row !== lastRow) ? ', ' : '');
    }
    if (row !== lastRow) {
      buf.push('\n ');
    }
  }
  buf.push(']');
  return buf.join('');
};

/**
 * Transpose this matrix.
 *
 * @param data {Array<Number>}
 *        matrix data.
 * @param m {Number}
 *        number of rows.
 * @param n {Number}
 *        number of columns.
 * @return transposed matrix (original matrix is unchanged).
 */
__transpose = function (data, m, n) {
  var values = [],
      row,
      col;
  for (col = 0; col < n; col++) {
    for (row = 0; row < m; row++) {
      values.push(data[__index(m, n, row, col)]);
    }
  }
  return values;
};


/**
 * Construct a new Matrix object.
 *
 * If m and n are omitted, Matrix is assumed to be square and
 * data length is used to compute size.
 *
 * If m or n are omitted, data length is used to compute omitted value.
 *
 * @param data {Array}
 *        matrix data.
 * @param m {Number}
 *        number of rows.
 * @param n {Number}
 *        number of columns.
 */
var Matrix = function (data, m, n) {
  var _this,
      _initialize,
      // variables
      _data,
      _m,
      _n;


  _this = {};

  _initialize = function (data, m, n) {
    _data = data;
    _m = m;
    _n = n;

    if (m && n) {
      // done
      return;
    }

    // try to compute size based on data
    if (!m && !n) {
      var side = Math.sqrt(data.length);
      if (side !== parseInt(side, 10)) {
        throw new Error('matrix m,n unspecified, and matrix not square');
      }
      _m = side;
      _n = side;
    } else if (!m) {
      _m = data.length / n;
      if (_m !== parseInt(_m, 10)) {
        throw new Error('wrong number of data elements');
      }
    } else if (!n) {
      _n = data.length / m;
      if (_n !== parseInt(_n, 10)) {
        throw new Error('wrong number of data elements');
      }
    }
  };

  /**
   * Add matrices.
   *
   * @param that {Matrix}
   *        matrix to add.
   * @throws Error if dimensions do not match.
   * @return result of addition (original matrix is unchanged).
   */
  _this.add = function (that) {
    if (_m !== that.m() || n !== that.n()) {
      throw new Error('matrices must be same size');
    }
    return Matrix(Vector.add(_data, that.data()), _m, _n);
  };

  /**
   * Get a column from this matrix.
   *
   * @param col {Number}
   *        zero-based column index.
   * @return {Array<Number>} array containing elements from column.
   */
  _this.col = function (col) {
    return __col(_data, _m, _n, col);
  };

  /**
   * Access the wrapped array.
   */
  _this.data = function () {
    return _data;
  };

  /**
   * Get the diagonal from this matrix.
   *
   * @return {Array<Number>} array containing elements from diagonal.
   */
  _this.diagonal = function () {
    return __diagonal(_data, _m, _n);
  };

  /**
   * Get a value from this matrix.
   *
   * @param row {Number}
   *        zero-based index of row.
   * @param col {Number}
   *        zero-based index of column.
   * @return {Number} value at (row, col).
   */
  _this.get = function (row, col) {
    return __get(_data, _m, _n, row, col);
  };

  /**
   * Compute the eigenvectors of this matrix.
   *
   * NOTE: Matrix should be 3x3 and symmetric.
   *
   * @param maxRotations {Number}
   *        default 100.
   *        maximum number of iterations.
   * @return {Array<Vector>} eigenvectors.
   *         Magnitude of each vector is eigenvalue.
   */
  _this.jacobi = function (maxRotations) {
    return __jacobi(_data, _m, _n, maxRotations);
  };

  /**
   * Get the number of rows in matrix.
   *
   * @return {Number}
   *         number of rows.
   */
  _this.m = function () {
    return _m;
  };

  /**
   * Multiply matrices.
   *
   * @param that {Matrix}
   *        matrix to multiply.
   * @return {Matrix} result of multiplication.
   */
  _this.multiply = function (that) {
    return Matrix(__multiply(_data, _m, _n, that.data(), that.m(), that.n()),
        // use that.N
        _m, that.n());
  };

  /**
   * Get number of columns in matrix.
   *
   * @return {Number} number of columns.
   */
  _this.n = function () {
    return _n;
  };

  /**
   * Multiply each element by -1.
   *
   * @return {Matrix} result of negation.
   */
  _this.negative = function () {
    return Matrix(Vector.multiply(_data, -1), _m, _n);
  };

  /**
   * Get a row from this matrix.
   *
   * @param row {Number}
   *        zero-based index of row.
   * @return {Array<Number>} elements from row.
   */
  _this.row = function (row) {
    return __row(_data, _m, _n, row);
  };

  /**
   * Set a value in this matrix.
   *
   * @param row {Number}
   *        zero-based row index.
   * @param col {Number}
   *        zero-based column index.
   * @param value {Number}
   *        value to set.
   */
  _this.set = function (row, col, value) {
    __set(_data, _m, _n, row, col, value);
  };

  /**
   * Subtract another matrix from this matrix.
   *
   * @param that {Matrix}
   *        matrix to subtract.
   * @throws Error if dimensions do not match.
   * @return result of subtraction (original matrix is unchanged).
   */
  _this.subtract = function (that) {
    if (_m !== that.m() || n !== that.n()) {
      throw new Error('matrices must be same size');
    }
    return Matrix(Vector.subtract(_data, that.data()), _m, _n);
  };

  /**
   * Display matrix as a string.
   *
   * @return {String} formatted matrix.
   */
  _this.toString = function () {
    return __stringify(_data, _m, _n);
  };

  /**
   * Transpose matrix.
   *
   * Columns become rows, and rows become columns.
   *
   * @return {Matrix} result of transpose.
   */
  _this.transpose = function () {
    return Matrix(__transpose(_data, _m, _n),
        // swap M and N
        _n, _m);
  };

  _initialize(data, m, n);
  data = null;
  return _this;
};


// expose static methods.
Matrix.col = __col;
Matrix.diagonal = __diagonal;
Matrix.get = __get;
Matrix.identity = __identity;
Matrix.index = __index;
Matrix.jacobi = __jacobi;
Matrix.multiply = __multiply;
Matrix.row = __row;
Matrix.set = __set;
Matrix.stringify = __stringify;
Matrix.transpose = __transpose;


module.exports = Matrix;

},{"./Vector":31}],31:[function(require,module,exports){
'use strict';


// static methods that operate on arrays
var __add,
    __angle,
    __azimuth,
    __cross,
    __dot,
    __equals,
    __magnitude,
    __multiply,
    __plunge,
    __unit,
    __rotate,
    __subtract,
    __x,
    __y,
    __z;


/**
 * Add two vectors.
 *
 * @param v1 {Array<Number>}
 *        the first vector.
 * @param v2 {Array<Number>}
 *        the second vector.
 * @return {Array<Number>}
 *         result of addition.
 * @throws {Error} when vectors are different lengths.
 */
__add = function (v1, v2) {
  var i,
      v;
  if (v1.length !== v2.length) {
    throw new Error('vectors must be same length');
  }
  v = [];
  for (i = 0; i < v1.length; i++) {
    v.push(v1[i] + v2[i]);
  }
  return v;
};


/**
 * Compute the angle between two vectors.
 *
 * @param v1 {Array<Number>}
 *        the first vector.
 * @param v2 {Array<Number>}
 *        the second vector.
 * @return {Number}
 *         angle between vectors in radians.
 */
__angle = function (v1, v2) {
  return Math.acos(__dot(v1, v2) / (__magnitude(v1) * __magnitude(v2)));
};

/**
 * Compute the azimuth of a vector.
 *
 * @param v1 {Array<Number>}
 *        the first vector.
 * @param v2 {Array<Number>}
 *        the second vector.
 * @return {Number}
 *         angle between vectors in radians.
 */
__azimuth = function (v1) {
  if (v1.length < 2) {
    throw new Error('azimuth requires at least 2 dimensions');
  }
  if (v1[0] === 0 && v1[1] === 0) {
    // if vector is zero, or vertical, azimuth is zero.
    return 0;
  }
  return (Math.PI / 2) - Math.atan2(v1[1], v1[0]);
};

/**
 * Compute vector cross product.
 *
 * Note: only computes cross product in 3 dimensions.
 *
 * @param v1 {Array<Number>}
 *        the first vector.
 * @param v2 {Array<Number>}
 *        the second vector.
 * @return {Array<Number>}
 *         the 3 dimensional cross product.
 *         the resulting vector follows the right-hand rule: if the fingers on
 *         your right hand point to v1, and you close your hand to get to v2,
 *         the resulting vector points in the direction of your thumb.
 */
__cross = function (v1, v2) {
  if (v1.length !== v2.length || v1.length < 3) {
    throw new Error('cross product requires at least 3 dimensions');
  }
  return [
    v1[1] * v2[2] - v2[1] * v1[2],
    v1[2] * v2[0] - v2[2] * v1[0],
    v1[0] * v2[1] - v2[0] * v1[1]
  ];
};

/**
 * Compute vector dot product.
 *
 * @param v1 {Array<Number}
 *        the first vector.
 * @param v2 {Array<Number>}
 *        the second vector.
 * @return {Number}
 *         the dot product.
 */
__dot = function (v1, v2) {
  var i,
      sum;
  sum = 0;
  for (i = 0; i < v1.length; i++) {
    sum += v1[i] * v2[i];
  }
  return sum;
};

/**
 * Check if two vectors are equal.
 *
 * @param v1 {Array<Number>}
 *        the first vector.
 * @param v2 {Array<Number>}
 *        the second vector.
 * @return {Boolean}
 *         true if vectors are same length and all elements are equal.
 */
__equals = function (v1, v2) {
  var i;
  if (v1.length !== v2.length) {
    return false;
  }
  for (i = 0; i < v1.length; i++) {
    if (v1[i] !== v2[i]) {
      return false;
    }
  }
  return true;
};

/**
 * Compute length of vector.
 *
 * @param v1 {Array<Number>}
 *        vector.
 * @return {Number}
 *         magnitude of vector.
 */
__magnitude = function (v1) {
  var i,
      sum;
  sum = 0;
  for (i = 0; i < v1.length; i++) {
    sum += v1[i] * v1[i];
  }
  return Math.sqrt(sum);
};

/**
 * Multiply vector by a constant.
 *
 * @param v1 {Array<Number>}
 *        vector to multiply.
 * @param n {Number}
 *        number to multiply by.
 * @return {Array<Number}
 *         result of multiplication.
 */
__multiply = function (v1, n) {
  var i,
      v;

  v = [];
  for (i = 0; i < v1.length; i++) {
    v.push(v1[i] * n);
  }
  return v;
};

/**
 * Compute angle from plane z=0 to vector.
 *
 * @param v {Array<Number>}
 *        the vector.
 * @return {Number}
 *         angle from plane z=0 to vector.
 *         angle is positive when z > 0, negative when z < 0.
 */
__plunge = function (v) {
  if (v.length < 3) {
    throw new Error('__azimuth: vector must have at least 3 dimensions');
  }
  return Math.asin(v[2] / __magnitude(v));
};

/**
 * Rotate a vector around an axis.
 *
 * From "6.2 The normalized matrix for rotation about an arbitrary line",
 *      http://inside.mines.edu/~gmurray/ArbitraryAxisRotation/
 *
 * @param v1 {Array<Number>}
 *        the "point" to rotate.
 * @param axis {Array<Number>}
 *        direction vector of rotation axis.
 * @param theta {Number}
 *        angle of rotation in radians.
 * @param origin {Array<Number>}
 *        default [0, 0, 0].
 *        origin of axis of rotation.
 */
__rotate = function (v1, axis, theta, origin) {
  var a,
      au,
      av,
      aw,
      b,
      bu,
      bv,
      bw,
      c,
      cu,
      cv,
      cw,
      cosT,
      sinT,
      u,
      uu,
      ux,
      uy,
      uz,
      v,
      vv,
      vx,
      vy,
      vz,
      w,
      ww,
      wx,
      wy,
      wz,
      x,
      y,
      z;

  origin = origin || [0, 0, 0];
  a = origin[0];
  b = origin[1];
  c = origin[2];
  u = axis[0];
  v = axis[1];
  w = axis[2];
  x = v1[0];
  y = v1[1];
  z = v1[2];

  cosT = Math.cos(theta);
  sinT = Math.sin(theta);
  au = a * u;
  av = a * v;
  aw = a * w;
  bu = b * u;
  bv = b * v;
  bw = b * w;
  cu = c * u;
  cv = c * v;
  cw = c * w;
  uu = u * u;
  ux = u * x;
  uy = u * y;
  uz = u * z;
  vv = v * v;
  vx = v * x;
  vy = v * y;
  vz = v * z;
  ww = w * w;
  wx = w * x;
  wy = w * y;
  wz = w * z;

  return [
    (a * (vv + ww) - u * (bv + cw - ux - vy - wz)) * (1 - cosT) +
        x * cosT + (-cv + bw - wy + vz) * sinT,
    (b * (uu + ww) - v * (au + cw - ux - vy - wz)) * (1 - cosT) +
        y * cosT + (cu - aw + wx - uz) * sinT,
    (c * (uu + vv) - w * (au + bv - ux - vy - wz)) * (1 - cosT) +
        z * cosT + (-bu + av - vx + uy) * sinT
  ];
};

/**
 * Subtract two vectors.
 *
 * @param v1 {Array<Number>}
 *        the first vector.
 * @param v2 {Array<Number>}
 *        the vector to subtract.
 * @return {Array<Number>}
 *         result of subtraction.
 * @throws {Error} when vectors are different lengths.
 */
__subtract = function (v1, v2) {
  var i,
      v;

  if (v1.length !== v2.length) {
    throw new Error('__subtract: vectors must be same length');
  }
  v = [];
  for (i = 0; i < v1.length; i++) {
    v.push(v1[i] - v2[i]);
  }
  return v;
};

/**
 * Convert vector to length 1.
 *
 * Same as __multiply(v1, 1 / __magnitude(v1))
 *
 * @param v1 {Array<Number>}
 *        the vector.
 * @return {Array<Number>}
 *         vector converted to length 1.
 * @throws {Error} if vector magnitude is 0.
 */
__unit = function (v1) {
  var mag = __magnitude(v1);
  if (mag === 0) {
    throw new Error('__unit: cannot convert zero vector to unit vector');
  }
  return __multiply(v1, 1 / mag);
};

/**
 * Get, and optionally set, the x component of a vector.
 *
 * @param v {Array<Number>}
 *        the vector.
 * @param value {Number}
 *        default undefined.
 *        when defined, set x component.
 * @return {Number}
 *         the x component.
 */
__x = function (v, value) {
  if (typeof value === 'number') {
    v[0] = value;
  }
  return v[0];
};

/**
 * Get, and optionally set, the y component of a vector.
 *
 * @param v {Array<Number>}
 *        the vector.
 * @param value {Number}
 *        default undefined.
 *        when defined, set y component.
 * @return {Number}
 *         the y component.
 */
__y = function (v, value) {
  if (typeof value === 'number') {
    v[1] = value;
  }
  return v[1];
};

/**
 * Get, and optionally set, the z component of a vector.
 *
 * @param v {Array<Number>}
 *        the vector.
 * @param value {Number}
 *        default undefined.
 *        when defined, set z component.
 * @return {Number}
 *         the z component.
 */
__z = function (v, value) {
  if (typeof value === 'number') {
    v[2] = value;
  }
  return v[2];
};


/**
 * A vector object that wraps an array.
 *
 * This is a convenience object to call the static methods on the wrapped array.
 * Only the methods x(), y(), and z() modify data; other methods return new
 * Vector objects without modifying the existing object.
 *
 * @param data {Array<Number>}
 *        array to wrap.
 */
var Vector = function (data) {
  var _this,
      _initialize,
      // variables
      _data;

  if (data && typeof data.data === 'function') {
    // copy existing object
    data = data.data().slice(0);
  }


  _this = {
    _isa_vector: true
  };

  _initialize = function (data) {
    _data = data;
  };

  /**
   * Add two vectors.
   *
   * @param that {Vector|Array<Number>}
   *        vector to add.
   * @return {Vector}
   *         result of addition.
   */
  _this.add = function (that) {
    that = (that._isa_vector ? that.data() : that);
    return Vector(__add(_data, that));
  };

  /**
   * Compute angle between vectors.
   *
   * @param that {Vector|Array<Number>}
   *        vector to compute angle between.
   * @return {Number} angle between vectors in radians.
   */
  _this.angle = function (that) {
    that = (that._isa_vector ? that.data() : that);
    return __angle(_data, that);
  };

  /**
   * Compute azimuth of this vector.
   *
   * @return {Number} azimuth of this vector in radians.
   */
  _this.azimuth = function () {
    return __azimuth(_data);
  };

  /**
   * Compute the cross product between vectors.
   *
   * @param that {Vector|Array<Number>}
   *        the vector to cross.
   * @return {Vector} result of the cross product.
   */
  _this.cross = function (that) {
    that = (that._isa_vector ? that.data() : that);
    return Vector(__cross(_data, that));
  };

  /**
   * Access the wrapped array.
   *
   * @return {Array<Number>}
   *         the wrapped array.
   */
  _this.data = function () {
    return _data;
  };

  /**
   * Compute dot product between vectors.
   *
   * @param that {Vector|Array<Number>}
   *        vector to dot.
   * @return {Number} result of dot product.
   */
  _this.dot = function (that) {
    that = (that._isa_vector ? that.data() : that);
    return __dot(_data, that);
  };

  /**
   * Check if two vectors are equal.
   *
   * @param that {Vector|Array<Number>}
   *        vector to compare.
   * @return {Boolean} true if equal, false otherwise.
   */
  _this.equals = function (that) {
    that = (that._isa_vector ? that.data() : that);
    return __equals(_data, that);
  };

  /**
   * Compute length of this vector.
   *
   * @return {Number} length of vector.
   *         Square root of the sum of squares of all components.
   */
  _this.magnitude = function () {
    return __magnitude(_data);
  };

  /**
   * Multiply this vector by a number.
   *
   * @param n {Number}
   *        number to multiply.
   * @return {Vector} result of multiplication.
   */
  _this.multiply = function (n) {
    return Vector(__multiply(_data, n));
  };

  /**
   * Same as multiply(-1).
   */
  _this.negative = function () {
    return _this.multiply(-1);
  };

  /**
   * Compute plunge of this vector.
   *
   * Plunge is the angle between this vector and the plane z=0.
   *
   * @return {Number} plunge in radians.
   *         positive when z>0, negative when z<0.
   */
  _this.plunge = function () {
    return __plunge(_data);
  };

  /**
   * Rotate this vector around an arbitrary axis.
   *
   * @param axis {Vector|Array<Number>}
   *        direction of axis of rotation.
   * @param theta {Number}
   *        angle of rotation in radians.
   * @param origin {Vector|Array<Number>}
   *        origin of axis of rotation.
   * @return {Vector} result of rotation.
   */
  _this.rotate = function (axis, theta, origin) {
    axis = (axis._isa_vector ? axis.data() : axis);
    origin = (origin && origin._isa_vector ? origin.data() : origin);
    return Vector(__rotate(_data, axis, theta, origin));
  };

  /**
   * Subtract another vector.
   *
   * @param that {Vector|Array<Number>}
   *        vector to subtract.
   * @return {Vector} result of subtraction.
   */
  _this.subtract = function (that) {
    that = (that._isa_vector ? that.data() : that);
    return Vector(__subtract(_data, that));
  };

  /**
   * Convert vector to string.
   *
   * @return {String} wrapped array converted to string.
   */
  _this.toString = function () {
    return '' + _data;
  };

  /**
   * Convert this vector to length 1.
   *
   * @return {Vector} vector / |vector|.
   */
  _this.unit = function () {
    return Vector(__unit(_data));
  };

  /**
   * Get or set x component.
   *
   * @param value {Number}
   *        when defined, set x component to value.
   * @return {Number} x component value.
   */
  _this.x = function (value) {
    return __x(_data, value);
  };

  /**
   * Get or set y component.
   *
   * @param value {Number}
   *        when defined, set y component to value.
   * @return {Number} y component value.
   */
  _this.y = function (value) {
    return __y(_data, value);
  };

  /**
   * Get or set z component.
   *
   * @param value {Number}
   *        when defined, set z component to value.
   * @return {Number} z component value.
   */
  _this.z = function (value) {
    return __z(_data, value);
  };


  _initialize(data);
  data = null;
  return _this;
};


// expose static methods
Vector.add = __add;
Vector.angle = __angle;
Vector.azimuth = __azimuth;
Vector.cross = __cross;
Vector.dot = __dot;
Vector.magnitude = __magnitude;
Vector.multiply = __multiply;
Vector.plunge = __plunge;
Vector.rotate = __rotate;
Vector.subtract = __subtract;
Vector.unit = __unit;
Vector.x = __x;
Vector.y = __y;
Vector.z = __z;


module.exports = Vector;

},{}],32:[function(require,module,exports){
'use strict';
/**
 * A Lightweight collection, inspired by backbone.
 *
 * Lazily builds indexes to avoid overhead until needed.
 */

var Events = require('../util/Events'),
    Util = require('../util/Util');


/**
 * Create a new Collection.
 *
 * @param data {Array}
 *      When omitted a new array is created.
 */
var Collection = function (data) {

  var _this,
      _initialize,

      _data,
      _ids,
      _selected,

      _isSilent;


  _this = Events();

  _initialize = function () {
    _data = data || [];
    _ids = null;
    _selected = null;

    data = null;
  };

  /**
   * Whether "silent" option is true.
   *
   * @param options {Object}
   * @param options.silent {Boolean}
   *        default false.
   * @return {Boolean} true if options.silent is true.
   */
  _isSilent = function (options) {
    return options && options.silent === true;
  };

  /**
   * Add objects to the collection.
   *
   * Calls wrapped array.push, and clears the id cache.
   *
   * @param {Object…}
   *      a variable number of objects to append to the collection.
   * @deprecated see #addAll()
   */
  _this.add = function () {
    _this.addAll(Array.prototype.slice.call(arguments, 0));
  };

  /**
   * Add objects to the collection.
   *
   * Calls wrapped array.push, and clears the id cache.
   *
   * @param toadd {Array<Object>}
   *        objects to be added to the collection.
   */
   _this.addAll = function (toadd, options) {
     _data.push.apply(_data, toadd);
     _ids = null;
     if (!_isSilent(options)) {
       _this.trigger('add', toadd);
     }
   };

  /**
   * Get the wrapped array.
   *
   * @return
   *      the wrapped array.
   */
  _this.data = function () {
    return _data;
  };

  /**
   * Deselect current selection.
   */
  _this.deselect = function (options) {
    if (_selected !== null) {
      var oldSelected = _selected;
      _selected = null;
      if (!_isSilent(options)) {
        _this.trigger('deselect', oldSelected);
      }
    }
  };

  /**
   * Free the array and id cache.
   *
   * @param options {Object}
   *        passed to #deselect().
   */
  _this.destroy = Util.compose(function (options) {
    _data = null;
    _ids = null;
    _selected = null;
    if (!_isSilent(options)) {
      _this.trigger('destroy');
    }
    return options;
  }, _this.destroy);

  /**
   * Get an object in the collection by ID.
   *
   * Uses getIds(), so builds map of ID to INDEX on first access O(N).
   * Subsequent access should be O(1).
   *
   * @param id {Any}
   *      if the collection contains more than one object with the same id,
   *      the last element with that id is returned.
   */
  _this.get = function (id) {
    var ids = _this.getIds();

    if (ids.hasOwnProperty(id)) {
      // use cached index
      return _data[ids[id]];
    } else {
      return null;
    }
  };

  /**
   * Get a map from ID to INDEX.
   *
   * @param force {Boolean}
   *      rebuild the map even if it exists.
   */
  _this.getIds = function (force) {
    var i = 0,
        len = _data.length,
        id;

    if (force || _ids === null) {
      // build up ids first time through
      _ids = {};

      for (; i < len; i++) {
        id = _data[i].id;

        if (_ids.hasOwnProperty(id)) {
          throw 'model with duplicate id "' + id + '" found in collection';
        }

        _ids[id] = i;
      }
    }

    return _ids;
  };

  /**
   * Get the currently selected object.
   */
  _this.getSelected = function () {
    return _selected;
  };

  /**
   * Remove objects from the collection.
   *
   * This method calls array.splice to remove item from array.
   * Reset would be faster if modifying large chunks of the array.
   *
   * @param o {Object}
   *      object to remove.
   * @deprecated see #removeAll()
   */
  _this.remove = function (/* o */) {
    // trigger remove event
    _this.removeAll(Array.prototype.slice.call(arguments, 0));
  };

  /**
   * Remove objects from the collection.
   *
   * Reset is faster if modifying large chunks of the array.
   *
   * @param toremove {Array<Object>}
   *        objects to remove.
   * @param options {Object}
   * @param options.silent {Boolean}
   *        default false.
   *        whether to trigger events (false), or not (true).
   */
  _this.removeAll = function (toremove, options) {
    var i,
        len = toremove.length,
        indexes = [],
        ids = _this.getIds(),
        o;

    // select indexes to be removed
    for (i = 0; i < len; i++) {
      o = toremove[i];

      // clear current selection if being removed
      if (o === _selected) {
        _this.deselect();
      }

      // add to list to be removed
      if (ids.hasOwnProperty(o.id)) {
        indexes.push(ids[o.id]);
      } else {
        throw 'removing object not in collection';
      }
    }

    // remove in descending index order
    indexes.sort(function(a,b) { return a-b; });

    for (i = indexes.length-1; i >= 0; i--) {
      _data.splice(indexes[i], 1);
    }

    // reset id cache
    _ids = null;

    if (!_isSilent(options)) {
      // trigger remove event
      _this.trigger('remove', toremove);
    }
  };

  /**
   * Replace the wrapped array with a new one.
   */
  _this.reset = function (data, options) {
    // check for existing selection
    var selectedId = null;
    if (_selected !== null) {
      selectedId = _selected.id;
    }

    // free array and id cache
    _data = null;
    _ids = null;
    _selected = null;

    // set new array
    _data = data || [];

    // notify listeners
    if (!options || options.silent !== true) {
      _this.trigger('reset', data);
    }

    // reselect if there was a previous selection
    if (selectedId !== null) {
      var selected = _this.get(selectedId);
      if (selected !== null) {
        options = Util.extend({}, options, {'reset': true});
        _this.select(selected, options);
      }
    }
  };

  /**
   * Select an object in the collection.
   *
   * @param obj {Object}
   *      object in the collection to select.
   * @throws exception
   *      if obj not in collection.
   */
  _this.select = function (obj, options) {
    // no selection
    if (obj === null) {
      _this.deselect();
      return;
    }
    // already selected
    if (obj === _selected) {
      return;
    }
    // deselect previous selection
    if (_selected !== null) {
      _this.deselect(options);
    }

    if (obj === _this.get(obj.id)) {
      // make sure it's part of this collection…
      _selected = obj;
      if (!options || options.silent !== true) {
        _this.trigger('select', _selected, options);
      }
    } else {
      throw 'selecting object not in collection';
    }
  };

  /**
   * Utility method to select collection item using its id.
   *
   * Selects matching item if it exists, otherwise clears any selection.
   *
   * @param id {?}
   *        id of item to select.
   * @param options {Object}
   *        options passed to #select() or #deselect().
   */
  _this.selectById = function (id, options) {
    var obj = _this.get(id);
    if (obj !== null) {
      _this.select(obj, options);
    } else {
      _this.deselect(options);
    }
  };

  /**
   * Sorts the data.
   *
   * @param method {Function}
   *        javascript sort method.
   * @param options {Object}
   *        passed to #reset()
   */
  _this.sort = function (method, options) {
    _data.sort(method);

    // "reset" to new sort order
    _this.reset(_data, options);
  };

  /**
   * Override toJSON method to serialize only collection data.
   */
  _this.toJSON = function () {
    var json = _data.slice(0),
        item,
        i,
        len;

    for (i = 0, len = json.length; i < len; i++) {
      item = json[i];
      if (typeof item === 'object' &&
          item !== null &&
          typeof item.toJSON === 'function') {
        json[i] = item.toJSON();
      }
    }

    return json;
  };


  _initialize();
  return _this;
};

module.exports = Collection;

},{"../util/Events":"util/Events","../util/Util":"util/Util"}],33:[function(require,module,exports){
'use strict';

var Util = require('../util/Util'),
    View = require('./View');


var _DEFAULTS = {
  // classname added to select box
  className: 'collection-selectbox',
  includeBlankOption: false,
  blankOption: {
    text: 'Please select&hellip;',
    value: '-1'
  },

  // callback to format each collection item
  format: function (item) {
    return item.id;
  },

  // whether to render during initialize
  renderNow: true
};

/**
 * Create a new CollectionSelectBox to select a collection item.
 *
 * @param params {Object}
 * @param params.format {Function(Object)}
 *        callback function to format select box items.
 * @param params.className {String}
 *        Default 'collection-selectbox'.
 *        Class name for select box.
 * @param params.collection {Collection}
 *        the collection to display.
 *        NOTE: the collection should have an existing selection;
 *        otherwise, the first item in the select box will be selected
 *        in the UI and not in the collection.
 * @see mvc/View
 */
var CollectionSelectBox = function (params) {
  var _this,
      _initialize,

      _blankOption,
      _collection,
      _format,
      _getValidOptions,
      _includeBlankOption,
      _selectBox,

      _createBlankOption,
      _defaultGetValidOptions,
      _onChange,
      _onSelect;


  params = Util.extend({}, _DEFAULTS, params);
  _this = View(params);

  /**
   * @constructor
   *
   */
  _initialize = function (params) {
    var el;

    el = _this.el;

    _blankOption = params.blankOption;
    _collection = params.collection;
    _format = params.format;
    _getValidOptions = params.getValidOptions || _defaultGetValidOptions;
    _includeBlankOption = params.includeBlankOption;

    // reuse or create select box
    if (el.nodeName === 'SELECT') {
      _selectBox = el;
    } else {
      _selectBox = el.appendChild(document.createElement('select'));
    }
    _selectBox.classList.add(params.className);

    // bind to events on the collection
    _collection.on('add', _this.render);
    _collection.on('remove', _this.render);
    _collection.on('reset', _this.render);
    _collection.on('select', _onSelect);
    _collection.on('deselect', _onSelect);

    // bind to events on this._selectBox
    _selectBox.addEventListener('change', _onChange);

    // populate select box
    if (params.renderNow) {
      _this.render();
    }
  };

  _createBlankOption = function () {
    return [
    '<option ',
        'value="', _blankOption.value, '">',
      _blankOption.text,
    '</option>'
    ].join('');
  };

  _defaultGetValidOptions = function () {
    return _collection.data().map(function (o) { return o.id; });
  };

  /**
   * Handle selectbox change events.
   */
  _onChange = function () {
    var value;

    value = _selectBox.value;

    if (_includeBlankOption && value === _blankOption.value) {
      _collection.deselect();
    } else {
      _collection.selectById(value);
    }
  };

  /**
   * Handle collection select events.
   */
  _onSelect = function () {
    var selected,
        validOptions;

    selected = _collection.getSelected();
    validOptions = _getValidOptions();

    if (selected) {
      if (validOptions.indexOf(selected.id) === -1) {
        _collection.deselect();
      } else {
        _selectBox.value = selected.id;
      }
    } else if (_includeBlankOption) {
      _selectBox.value = _blankOption.value;
    }
  };


  /**
   * Destroy CollectionSelectBox.
   */
  _this.destroy = Util.compose(function () {
    _collection.off('add', _this.render);
    _collection.off('remove', _this.render);
    _collection.off('reset', _this.render);
    _collection.off('select', _onSelect);
    _collection.off('deselect', _onSelect);

    _selectBox.removeEventListener('change', _onChange);

    _blankOption = null;
    _collection = null;
    _format = null;
    _getValidOptions = null;
    _includeBlankOption = null;
    _selectBox = null;

    _createBlankOption = null;
    _defaultGetValidOptions = null;
    _onChange = null;
    _onSelect = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Update select box items.
   */
  _this.render = function () {
    var data,
        i,
        id,
        len,
        markup,
        selected,
        validOptions;

    data = _collection.data();
    markup = [];
    selected = _collection.getSelected();

    if (_includeBlankOption === true) {
      markup.push(_createBlankOption());
    }

    validOptions = _getValidOptions();

    for (i = 0, len = data.length; i < len; i++) {
      id = data[i].id;

      markup.push('<option value="' + id + '"' +
          (selected === data[i] ? ' selected="selected"' : '') +
          (validOptions.indexOf(id) === -1 ? ' disabled="disabled"' : '') +
          '>' + _format(data[i]) + '</option>');
    }

    _selectBox.innerHTML = markup.join('');
    _onSelect();
  };


  _initialize(params);
  params = null;
  return _this;
};

module.exports = CollectionSelectBox;

},{"../util/Util":"util/Util","./View":"mvc/View"}],34:[function(require,module,exports){
'use strict';

var Util = require('../util/Util'),
    View = require('./View');


var _DEFAULTS = {
  // class name for table
  className: 'collection-table',
  // click on table rows to trigger select in collection
  clickToSelect: false,
  // columns of data to display
  columns: [
    //{
      // class name for header and data cells
      //   className: '',
      // header content for column
      //   title: '',
      // format function for data cells
      //   format: function (item) { return ''; }
      // whether column is header for its row
      //   header: false
    //}
  ],
  emptyMarkup: 'No data to display',
  // whether to render after initialization
  renderNow: true
};


/**
 * Create a CollectionTable to display a collection.
 *
 * @param params {Object}
 * @param params.collection {Collection}
 *        Collection to display.
 * @param params.columns {Array<Object>}
 *        Array of column objects defining display.
 *        Each object should have these properties:
 *        - className {String} class name for header and data cells.
 *        - title {String} markup for header cell.
 *        - format {Function(item)} function to format data cell.
 *        - header {Boolean} default false.
 *          whether column is row header and should use th scope=row (true),
 *          or a regular data cell and should use td (false).
 * @param params.clickToSelect {Boolean}
 *        Default false.  Whether clicking on table rows should select
 *        the corresponding collection item.
 * @see mvc/View
 */
var CollectionTable = function (params) {
  var _this,
      _initialize,

      _className,
      _clickToSelect,
      _collection,
      _columns,
      _emptyMarkup,

      _onClick,
      _onSelect;


  params = Util.extend({}, _DEFAULTS, params);
  _this = View(params);

  _initialize = function () {
    _className = params.className;
    _clickToSelect = params.clickToSelect;
    _collection = params.collection;
    _columns = params.columns;
    _emptyMarkup = params.emptyMarkup;

    // respond to collection events
    _collection.on('add', _this.render);
    _collection.on('remove', _this.render);
    _collection.on('reset', _this.render);
    _collection.on('select', _onSelect);
    _collection.on('deselect', _onSelect);

    // add click handler
    if (_clickToSelect) {
      _this.el.addEventListener('click', _onClick);
    }

    if (params.renderNow) {
      _this.render();
    }
  };


  /**
   * Handle table click events.
   * Listener is only added when options.clickToSelect is true.
   */
  _onClick = function (e) {
    var target = e.target,
        row = Util.getParentNode(target, 'TR', _this.el);

    if (row !== null) {
      if (row.parentNode.nodeName.toUpperCase() === 'TBODY') {
        _collection.selectById(row.getAttribute('data-id'));
      }
    }
  };

  /**
   * Handle collection select and deselect events.
   */
  _onSelect = function () {
    var el = _this.el,
        selected;

    // remove previous selection
    selected = el.querySelector('.selected');
    if (selected) {
      selected.classList.remove('selected');
    }

    // set new selection
    selected = _collection.getSelected();
    if (selected) {
      selected = el.querySelector('[data-id="' + selected.id + '"]');
      selected.classList.add('selected');
    }
  };


  /**
   * Undo initialization and free references.
   */
  _this.destroy = Util.compose(function () {

    _collection.off('add', _this.render);
    _collection.off('remove', _this.render);
    _collection.off('reset', _this.render);
    _collection.off('select', _onSelect);
    _collection.off('deselect', _onSelect);
    _collection = null;

    if (_clickToSelect) {
      _this.el.removeEventListener('click', _onClick);
    }
    _clickToSelect = null;
  }, _this.destroy);

  /**
   * Render the view.
   */
  _this.render = function () {
    var c,
        cLen,
        column,
        data,
        i,
        id,
        iLen,
        item,
        markup;

    data = _collection.data();
    markup = [];

    if (data.length === 0) {
      _this.el.innerHTML = _emptyMarkup;
      return;
    }

    markup.push('<table class="', _className, '"><thead>');
    for (c = 0, cLen = _columns.length; c < cLen; c++) {
      column = _columns[c];
      markup.push('<th class="' + column.className + '">' +
          column.title + '</th>');
    }
    markup.push('</thead><tbody>');
    for (i = 0, iLen = data.length; i < iLen; i++) {
      item = data[i];
      id = ('' + item.id).replace(/"/g, '&quot;');
      markup.push('<tr data-id="' + id + '">');
      for (c = 0, cLen = _columns.length; c < cLen; c++) {
        column = _columns[c];
        markup.push('<' + (column.header ? 'th scope="row"' : 'td') +
            ' class="' + column.className + '">' +
            column.format(item) + '</td>');
      }
      markup.push('</tr>');
    }
    markup.push('</tbody></table>');

    _this.el.innerHTML = markup.join('');
  };


  _initialize();
  return _this;
};

module.exports = CollectionTable;
},{"../util/Util":"util/Util","./View":"mvc/View"}],35:[function(require,module,exports){
'use strict';


var CollectionTable = require('./CollectionTable'),
    DownloadView = require('./DownloadView'),
    SortView = require('./SortView'),
    Util = require('../util/Util'),
    View = require('./View');


/**
 * Create a new DataTable to display a collection.
 *
 * @param params {Object}
 *        all params except "el" are passed to CollectionTable.
 * @param params.sorts {Array<Object>}
 *        sort objects used by SortView.
 * @param params.formatDownload {Function(Collection)}
 *        Optional, default is Tab Separated Values.
 * @param params.columns {Array<Object>}
 *        column objects used by CollectionTable.
 * @param params.columns[X].downloadFormat {Function(Object)}
 *        Optional, default is column.format.
 *        Function used to format a column value for download.
 *        Used by DataTable._formatDownload.
 * @param params.columns[X].downloadTitle {string}
 *        Optional, default is column.title.
 *        column title value for download.
 *        Used by DataTable._formatDownload.
 * @see CollectionTable
 * @see SortView
 * @see DownloadView
 */
var DataTable = function (params) {
  var _this,
      _initialize,

      _collection,
      _collectionTable,
      _columns,
      _downloadButton,
      _downloadView,
      _sorts,
      _sortView,

      _formatDownload;


  _this = View(params);

  /**
   * Initialize the DataTable.
   */
  _initialize = function () {
    var el,
        tools;

    el = _this.el;
    el.innerHTML = '<div class="datatable-tools"></div>' +
        '<div class="datatable-data"></div>';
    el.classList.add('datatable');
    tools = el.querySelector('.datatable-tools');

    _collection = params.collection;
    _columns = params.columns;

    // sort
    _sorts = params.sorts;
    if (_sorts) {
      _sortView = new SortView({
        collection: _collection,
        sorts: _sorts,
        defaultSort: params.defaultSort
      });
      tools.appendChild(_sortView.el);
    }

    // data
    _collectionTable = new CollectionTable(
        Util.extend({}, params, {
          el: el.querySelector('.datatable-data')
        }));

    // download
    _downloadView = new DownloadView({
      collection: _collection,
      help: params.help || 'Copy then paste into a spreadsheet application',
      format: params.formatDownload || _formatDownload
    });

    _downloadButton = document.createElement('button');
    _downloadButton.innerHTML = 'Download';
    _downloadButton.className = 'download';
    _downloadButton.addEventListener('click', _downloadView.show);
    tools.appendChild(_downloadButton);


    params = null;
  };


  /**
   * Callback used to format downloads.
   * This implementation outputs Tab Separated Values.
   */
  _formatDownload = function (collection) {
    var c,
        cLen,
        content,
        column,
        data,
        format,
        i,
        iLen,
        item,
        row;

    content = [];
    data = collection.data();
    row = [];

    for (c = 0, cLen = _columns.length; c < cLen; c++) {
      column = _columns[c];
      row.push(column.downloadTitle || column.title);
    }
    content.push(row.join('\t'));

    for (i = 0, iLen = data.length; i < iLen; i++) {
      item = data[i];
      row = [];
      for (c = 0, cLen = _columns.length; c < cLen; c++) {
        column = _columns[c];
        format = column.downloadFormat || column.format;
        row.push(format(item));
      }
      content.push(row.join('\t'));
    }

    return content.join('\n');
  };


  /**
   * Destroy the DataTable.
   */
  _this.destroy = Util.compose(function () {
    if (_sortView) {
      _sortView.destroy();
      _sortView = null;
    }

    _downloadButton.removeEventListener('click', _downloadView.show);
    _downloadButton = null;

    _downloadView.destroy();
    _downloadView = null;

    _collectionTable.destroy();
    _collectionTable = null;
  }, _this.destroy);


  _initialize();
  return _this;
};

module.exports = DataTable;

},{"../util/Util":"util/Util","./CollectionTable":34,"./DownloadView":36,"./SortView":38,"./View":"mvc/View"}],36:[function(require,module,exports){
'use strict';

var ModalView = require('./ModalView'),
    Util = require('../util/Util'),
    View = require('./View');


var _DEFAULTS = {
  // title of modal dialog.
  title: 'Download',
  // markup to describe download content.
  help: '',
  // callback function to format collection for download.
  format: function (collection) {
    return JSON.stringify(collection);
  }
};


/**
 * Create a DownloadView.
 *
 * @param options {Object}
 * @param options.title {String}
 *        Default 'Download'.
 *        Modal dialog title.
 * @param options.format {Function(Collection)}
 *        Default JSON.stringify.
 *        function to format collection for download.
 * @see mvc/View
 */
var DownloadView = function (params) {
  var _this,
      _initialize,

      _collection,
      _format,
      _modal,
      _textarea,
      _title;


  params = Util.extend({}, _DEFAULTS, params);
  _this = View(params);

  /**
   * Initialize the download view.
   */
  _initialize = function () {
    var el = _this.el;

    _collection = params.collection;
    _format = params.format;
    _title = params.title;

    el.className = 'download-view';
    el.innerHTML = '<div class="help">' + params.help + '</div>' +
        '<textarea class="download" readonly="readonly"></textarea>';
    _textarea = el.querySelector('.download');

    params = null;
  };

  /**
   * Destroy the download view.
   */
  _this.destroy = Util.compose(function () {
    if (_modal) {
      // TODO: hide first?
      _modal.destroy();
      _modal = null;
    }

    _collection = null;
    _format = null;
    _textarea = null;
  }, _this.destroy);

  /**
   * Format collection for download.
   */
  _this.render = function () {
    _textarea.value = _format(_collection);
  };

  /**
   * Show the download view, calls render before showing modal.
   */
  _this.show = function () {
    if (!_modal) {
      _modal = new ModalView(_this.el, {
        title: _title
      });
    }

    _this.render();
    _modal.show();
    _textarea.select();
  };

  _initialize();
  return _this;
};

module.exports = DownloadView;
},{"../util/Util":"util/Util","./ModalView":37,"./View":"mvc/View"}],37:[function(require,module,exports){
'use strict';
/**
 * Generic class for modal dialog views. Modal dialogs present a blocking
 * interface to the user and require user-interaction in order to be closed
 * (i.e. clicking a button etc...).
 *
 * It is important to note that while the interface appears blocked while a
 * modal dialog is open, Javascript continues to execute in the background.
 *
 * Only one modal dialog can be visible at any given time.
 *
 * If a second modal dialog is opened while the first modal dialog is still
 * visible, the first modal dialog is hidden and the second is shown. Upon
 * closing the second modal dialog, the first modal dialog is re-shown (unless
 * the "clear" method is passed to the hide method). This process continues in a
 * last-in, first-out (stack) ordering until all modal dialogs are closed.
 *
 */

var Util = require('../util/Util'),
    View = require('./View');


var __INITIALIZED__ = false,
    _DIALOG_STACK = null,
    _FOCUS_STACK = null,
    _MASK = null,
    _DEFAULTS = {
      closable: true, // Should modal box include little "X' in corner
      destroyOnHide: false,
      title: document.title + ' Says...'
    };

var _static_initialize = function () {
  // Create the dialog stack
  _DIALOG_STACK = [];

  // Create the focus stack
  _FOCUS_STACK = [];

  // Create the modal mask
  _MASK = document.createElement('div');
  _MASK.classList.add('modal');

  __INITIALIZED__ = true;
};

// Note: "this" is a reference to the buttom DOM element and has all the
//       proper attributes set on it such that the implementation below is
//       correct. It does *not* need to use _this (also it's a static method).
var _buttonCallback = function (evt) {
  if (this.info && this.info.callback &&
      typeof this.info.callback === 'function') {
    this.info.callback(evt, this.modal||{});
  }
};

/**
 * Pulls the next element off the focus stack and attempts to set the
 * focus to it.
 *
 */
var _focusNext = function () {
  var node;

  node = _FOCUS_STACK.pop();

  if (node && node instanceof Node && node.focus) {
    node.focus();
  }
};

var ModalView = function (message, params) {
  var _this,
      _initialize,

      _buttons,
      _classes,
      _closable,
      _closeButton,
      _content,
      _destroyOnHide,
      _footer,
      _message,
      _title,
      _titleEl,

      _createButton,
      _createViewSkeleton,
      _onKeyDown,
      _onModalClick;


  params = Util.extend({}, _DEFAULTS, params);
  _this = View(params);

  _initialize = function () {

    _buttons = params.buttons;
    _classes = params.classes;
    _closable = params.closable;
    _destroyOnHide = params.destroyOnHide;
    _message = message;
    _title = params.title;

    _this.el.modal = _this;

    _createViewSkeleton();
    _this.render();

    if (!__INITIALIZED__) {
      _static_initialize();
    }

    params = null;
  };


  _createButton = function (info) {
    var i,
        len,
        button = document.createElement('button'),
        buttonInfo;

    buttonInfo = Util.extend({}, {
      classes: [],
      text: 'Click Me',
      title: '',
      callback: function () {}
    }, info);

    for (i = 0, len = buttonInfo.classes.length; i < len; i++) {
      button.classList.add(buttonInfo.classes[i]);
    }

    button.innerHTML = buttonInfo.text;

    if (buttonInfo.title !== '') {
      button.setAttribute('title', buttonInfo.title);
    }

    button.modal = _this;
    button.info = buttonInfo;

    if (buttonInfo.callback) {
      button.addEventListener('click', _buttonCallback);
    }

    return button;
  };

  _createViewSkeleton = function () {
    var header, i, len;

    Util.empty(_this.el);
    _this.el.classList.add('modal-dialog');

    // Add custom classes to the view
    if (_classes && _classes.length > 0) {
      for (i = 0, len = _classes.length; i < len; i++) {
        _this.el.classList.add(_classes[i]);
      }
    }

    if (_title) {
      header = _this.el.appendChild(document.createElement('header'));
      header.classList.add('modal-header');

      _titleEl = header.appendChild(document.createElement('h3'));
      _titleEl.setAttribute('tabIndex', '-1');
      _titleEl.classList.add('modal-title');


      if (_closable) {
        _closeButton = header.appendChild(document.createElement('span'));
        _closeButton.classList.add('modal-close-link');
        _closeButton.classList.add('material-icons');
        _closeButton.setAttribute('title', 'Close');
        _closeButton.innerHTML = 'close';
        _closeButton.addEventListener('click', _this.hide);
      }
    }  else {
      _this.el.classList.add('no-header');
    }

    _content = _this.el.appendChild(document.createElement('section'));
    _content.setAttribute('tabIndex', '-1');
    _content.classList.add('modal-content');

    if (_buttons && _buttons.length) {
      _footer = _this.el.appendChild(document.createElement('footer'));
      _footer.classList.add('modal-footer');
    } else {
      _this.el.classList.add('no-footer');
    }
  };

  /**
   * This method is bound to the ModalView instance using the
   * Function.prototype.bind method, thus the reference to "this" is correct
   * even though this is a keydown event handler.
   *
   * @param event {KeyEvent}
   *      The event that triggered this call.
   */
  _onKeyDown = function (event) {
    if (event.keyCode === 27) {
      _this.hide();
    }
  };


  _onModalClick = function (event) {
    if (event.target.className === 'modal') {
      _this.hide();
    }
  };

  /**
   * Remove event listeners and free references.
   *
   * You should call hide first.
   */
  _this.destroy = function () {
    var button;

    _MASK.removeEventListener('click', _this.hide);

    if (_buttons && _buttons.length) {
      while (_footer.childNodes.length > 0) {
        button = _footer.firstChild;
        button.removeEventListener('click', _buttonCallback);
        _footer.removeChild(button);
      }
    }

    if (_closeButton) {
      _closeButton.removeEventListener('click', _this.hide);
      _closeButton = null;
    }

    delete _this.el.modal;

    _footer = null;
    _titleEl = null;
    _content = null;
    _destroyOnHide = null;
    _this.el = null;
    _onModalClick = null;
  };

  _this.hide = function (clearAll) {
    var isVisible;

    isVisible = (_this.el.parentNode === _MASK);

    if (clearAll === true) {
      // Remove any/all dialogs attached to _MASK
      Util.empty(_MASK);

      // Clear stack of previous dialogs to return user to normal application.
      _DIALOG_STACK.splice(0, _DIALOG_STACK.length);

      // Clear all but last focus element
      _FOCUS_STACK.splice(1, _FOCUS_STACK.length);

      _focusNext();

      if (isVisible) { // Or rather, was visible
        _this.trigger('hide', _this);

        if (_destroyOnHide) {
          _this.destroy();
        }
      }
    } else if (isVisible) {
      // This modal is currently visible
      _this.el.parentNode.removeChild(_this.el);

      // Check if any other dialogs exist in stack, if so, show it
      if (_DIALOG_STACK.length > 0) {
        _DIALOG_STACK.pop().show();
      }

      _focusNext();
      _this.trigger('hide', _this);

      if (_destroyOnHide) {
        _this.destroy();
      }
    }

    if (!_MASK.firstChild && _MASK.parentNode) {
      // No more dialogs, remove the _MASK
      _MASK.parentNode.removeChild(_MASK);
      _MASK.removeEventListener('click', _onModalClick);

      document.body.classList.remove('backgroundScrollDisable');
      window.removeEventListener('keydown', _onKeyDown);
    }

    return _this;
  };

  _this.render = function (message) {
    var m = message || _message,
        button = null,
        buttons = _buttons || [],
        i, len = buttons.length;

    // Set the modal dialog content
    Util.empty(_content);

    if (typeof m === 'string') {
      _content.innerHTML = m;
    } else if (typeof m === 'function') {
      return _this.render(m(_this));
    } else if (m instanceof Node) {
      _content.appendChild(m);
    }

    // Set the modal dialog title
    if (_title) {
      _titleEl.innerHTML = _title;
    }

    // Clear any old footer content
    if (_buttons && _buttons.length) {
      while (_footer.childNodes.length > 0) {
        button = _footer.firstChild;
        Util.removeEvent(button, 'click', _buttonCallback);
        _footer.removeChild(button);
      }
    }

    // Set new footer content
    for (i = 0; i < len; i++) {
      _footer.appendChild(_createButton(buttons[i]));
    }

    _this.trigger('render', _this);
    return _this;
  };

  _this.setMessage = function (message) {
    _message = message;

    _this.trigger('message', _this);
    return _this;
  };

  _this.setOptions = function (params, extend) {
    if (extend) {
      params = Util.extend({}, {
        buttons: _buttons,
        classes: _classes,
        closable: _closable,
        message: _message,
        title: _title
      }, params);
    }

    _buttons = params.buttons;
    _classes = params.classes;
    _closable = params.closable;
    _message = message;
    _title = params.title;

    _this.trigger('options', _this);
    return _this;
  };

  _this.show = function () {
    var oldChild = null;

    // For accessibility, focus the top of this new dialog
    _FOCUS_STACK.push(document.activeElement || false);

    // Mask already has a dialog in it, add to dialog stack and continue
    while (_MASK.firstChild) {
      oldChild = _MASK.firstChild;
      if (oldChild.modal) {
        _DIALOG_STACK.push(oldChild.modal);
      }
      _MASK.removeChild(oldChild);
    }

    // Add this dialog to the mask
    _MASK.appendChild(_this.el);
    _MASK.addEventListener('click', _onModalClick);

    // Show the mask if not yet visible
    if (!_MASK.parentNode) {
      document.body.appendChild(_MASK);
      document.body.classList.add('backgroundScrollDisable');
      window.addEventListener('keydown', _onKeyDown);
    }


    if (_title) {
      _titleEl.focus();
    } else {
      _content.focus();
    }

    _this.trigger('show', _this);
    return _this;
  };

  _initialize();
  return _this;
};

module.exports = ModalView;

},{"../util/Util":"util/Util","./View":"mvc/View"}],38:[function(require,module,exports){
'use strict';

var Collection = require('./Collection'),
    CollectionSelectBox = require('./CollectionSelectBox'),
    Util = require('../util/Util'),
    View = require('./View');

/**
 * Construct a SortView.
 *
 * Sort objects can specify a custom sort function (sort),
 * or a value to be sorted (sortBy) and sort order (descending).
 *
 * @param options {Object}
 * @param options.sorts {Array<Object>}
 *        array of sort objects, with properties:
 *        - id {String|Number} unique identifier for sort
 *        - title {String} display name for sort
 *        And:
 *        - sort {Function(a, b)} sorting function.
 *        Or:
 *        - sortBy {Function(Object)} return value for sorting.
 *        - descending {Boolean} default false, whether to
 *          sort ascending (true) or descending (false).
 * @param options.defaultSort {ID}
 *        Optional.
 *        If specified, should match "id" of a sort object.
 * @see mvc/View
 */
var SortView = function (params) {
  var _this,
      _initialize,

      _collection,
      _selectView,
      _sortCollection,

      _getSortFunction,
      _onSelect;


  _this = View(params);

  /**
   * Initialize the SortView.
   */
  _initialize = function () {
    var el = _this.el;

    _collection = params.collection;

    el.innerHTML = '<label>Sort by <select></select></label>';
    el.classList.add('sortview');

    _sortCollection = new Collection(params.sorts);
    _sortCollection.on('select', _onSelect, this);

    // initial sort order
    if (params.defaultSort) {
      _sortCollection.select(_sortCollection.get(params.defaultSort));
    } else {
      _sortCollection.select(_sortCollection.data()[0]);
    }

    _selectView = new CollectionSelectBox({
      el: el.querySelector('select'),
      collection: _sortCollection,
      format: function (item) {
        return item.title;
      }
    });

    params = null;
  };


  /**
   * Convert a sortBy function to a sort function.
   *
   * @param sortBy {Function(Object)}
   *        function that returns sort key.
   * @param descending {Boolean}
   *        Default false.
   *        Whether to sort ascending (false) or descending (true).
   * @return {Function(a, b)} sort function.
   */
  _getSortFunction = function (sortBy, descending) {
    var cache = {};

    return function (a, b) {
      var aval = cache[a.id],
          bval = cache[b.id],
          tmp;

      if (!aval) {
        aval = cache[a.id] = sortBy(a);
      }
      if (!bval) {
        bval = cache[b.id] = sortBy(b);
      }

      if (descending) {
        // swap comparison order
        tmp = bval;
        bval = aval;
        aval = tmp;
      }

      if (aval < bval) {
        return -1;
      } else if (aval > bval) {
        return 1;
      } else {
        return 0;
      }
    };
  };

  /**
   * Handle sort collection select event.
   */
  _onSelect = function () {
    var selected = _sortCollection.getSelected(),
        sort;

    if (selected) {
      sort = selected.sort;
      if (!sort) {
        sort = _getSortFunction(selected.sortBy, selected.descending);
      }
      _collection.sort(sort);
    }
  };


  /**
   * Destroy the SortView.
   */
  _this.destroy = Util.compose(function () {
    _sortCollection.off('select', _onSelect, this);
    _sortCollection = null;
    _collection = null;
    _selectView.destroy();
  }, _this.destroy);


  _initialize();
  return _this;
};

module.exports = SortView;
},{"../util/Util":"util/Util","./Collection":32,"./CollectionSelectBox":33,"./View":"mvc/View"}],39:[function(require,module,exports){
'use strict';

var XmlUtil = require('quakeml/XmlUtil'),
    QuakemlEvent = require('quakeml/QuakemlEvent');


/**
 * Create a new Quakeml object.
 *
 * @param options {Object}
 * @param options.xml {String|XMLDocument}
 *        quakeml xml to parse.
 *        If a string, options.xml is parsed using DOMParser.
 * @param options.eventElement {String}
 *        Default 'event'.
 *        The event element inside eventParameters to find.
 *        The first matching element is parsed during _initialize.
 */
var Quakeml = function (options) {
  var _this,
      _initialize,

      _event,
      _updated,
      _quakeml;


  _this = Object.create({});

  /**
   * Initialize the quakeml object.
   */
  _initialize = function (options) {
    var ev,
        eventElement = options.eventElement || 'event',
        eventParameters,
        json,
        quakeml;

    json = XmlUtil.xmlToJson(options.xml);
    quakeml = json['q:quakeml'];
    eventParameters = quakeml.eventParameters;
    ev = eventParameters[eventElement];
    if (typeof ev === 'undefined') {
      throw new Error('Event element ' + eventElement + ' not found');
    }

    _quakeml = quakeml;
    _updated = eventParameters.creationInfo.creationTime;
    _event = QuakemlEvent((Array.isArray(ev) ? ev[0] : ev));
  };


  /**
   * @return {Array<Object>} magnitudes parsed from event element.
   */
  _this.getMagnitudes = function () {
    return _event.getMagnitudes();
  };

  /**
   * @return {Array<Object>} origins parsed from event element.
   */
  _this.getOrigins = function () {
    return _event.getOrigins();
  };

  /**
   * @return {Element} event element from quakeml message.
   */
  _this.getQuakemlEvent = function () {
    return _event.getEvent();
  };

    /**
   * @return {String} iso8601 timestamp when quakeml message was updated.
   */
  _this.getUpdated = function () {
    return _updated;
  };

  _initialize(options);
  options=null;
  return _this;

};


module.exports = Quakeml;

},{"quakeml/QuakemlEvent":40,"quakeml/XmlUtil":41}],40:[function(require,module,exports){
'use strict';

/**
 * Convert an object to an array if needed.
 *
 * @param obj {Any}
 * @return {Array}
 *         if obj is an Object, either
 *           obj, if obj is already an array,
 *           otherwise, [obj]
 *         otherwise, [].
 */
var _array = function (obj) {
  if (Array.isArray(obj)) {
    return obj;
  } else if (typeof obj === 'object' && obj !== null) {
    return [obj];
  } else {
    return [];
  }
};

/**
 * Copy properties from source objects onto dest.
 *
 * @param dest {Object}
 *        destination for copied properties.
 * @param varargs {Object, ...}
 *        source objects, processed in argument order from left to right.
 *        all properties are copied from the source object to dest.
 * @return {Object} dest, after copying source object properties.
 */
var _extend = function (dest /*, varargs */) {
  var src,
      i,
      key;
  for (i = 1; i < arguments.length; i++) {
    src = arguments[i];
    if (typeof src === 'object' && src !== null) {
      for (key in src) {
        dest[key] = src[key];
      }
    }
  }
  return dest;
};

/**
 * Build a lookup index for objects, based on (unique) property value.
 *
 * For Example:
 *     _index([{id: 'a'}, {id: 'b'}], 'id')
 * would return
 *    {
 *      'a': {id: 'a'},
 *      'b': {id: 'b'}
 *    }
 *
 * @param objs {Array<Object>}
 *        objects to index
 * @param key {String}
 *        property to index.
 * @param index {Object}
 *        optional, existing index to extend.
 * @return {Object} indexed data.
 */
var _index = function (objs, key, index) {
  var i,
      len,
      obj;
  index = index || {};
  if (objs) {
    if (!Array.isArray(objs)) {
      objs = [objs];
    }
    for (i = 0, len = objs.length; i < len; i++) {
      obj = objs[i];
      index[obj[key]] = obj;
    }
  }
  return index;
};


/**
 * Construct a new Quakeml Event.
 *
 * @param ev {Element}
 *        Quakeml event(like) element
 */
var QuakemlEvent = function (ev) {
  var _this,
      _initialize,

      _amplitudeIndex,
      _catalog,
      _ev,
      _magnitudes,
      _origins,
      _pickIndex,
      _preferredMagnitudeID,
      _preferredOriginID,
      _stationMagnitudeIndex,

      _parseArrivals,
      _parseOrigins,
      _parseMagnitudeContributions,
      _parseMagnitudes;


  _this = Object.create({});

  /**
   * Initialize this event, by parsing origins and magnitudes.
   */
  _initialize = function (ev) {
    _ev = ev;
    _catalog = _ev['catalog:eventSource'];
    _preferredOriginID = _ev.preferredOriginID || null;
    _preferredMagnitudeID = _ev.preferredMagnitudeID || null;

    _pickIndex = _index(_ev.pick, 'publicID');
    _amplitudeIndex = _index(_ev.amplitude, 'publicID');
    _stationMagnitudeIndex = _index(_ev.stationMagnitude, 'publicID');

    _origins = _parseOrigins(_array(_ev.origin));
    _magnitudes = _parseMagnitudes(_array(_ev.magnitude));
    ev = null;
  };

  /**
   * Parse an array of arrival elements.
   *
   * @param arrivals {Array<Element>}
   *        array of quakeml arrival elements.
   * @return {Array<Object>} parsed arrival objects.
   */
  _parseArrivals = function (arrivals) {
    var a,
        arrival,
        parsed = [],
        pickIndex = _pickIndex;

    for (a = 0; a < arrivals.length; a++) {
      arrival = _extend({}, arrivals[a]);
      if (typeof arrival.pickID === 'string') {
        arrival.pick = pickIndex[arrival.pickID] || null;
      } else {
        arrival.pick = null;
      }
      parsed.push(arrival);
    }
    return parsed;
  };

  /**
   * Parse an array of stationMagnitudeContribution elements.
   *
   * @param contributions {Array<Element>}
   *        array of quakeml stationMagnitudeContribution elements.
   * @return {Array<Object>} parsed stationMagnitudeContribution objects.
   */
  _parseMagnitudeContributions = function (contributions) {
    var amplitudeIndex = _amplitudeIndex,
        c,
        contribution,
        parsed = [],
        stationMagnitude,
        stationMagnitudeIndex = _stationMagnitudeIndex;

    for (c = 0; c < contributions.length; c++) {
      contribution = _extend({}, contributions[c]);
      stationMagnitude = _extend({},
          stationMagnitudeIndex[contribution.stationMagnitudeID]);
      contribution.stationMagnitude = stationMagnitude;
      if (typeof stationMagnitude.amplitudeID === 'string') {
        stationMagnitude.amplitude = _extend({},
            amplitudeIndex[stationMagnitude.amplitudeID]);
      }
      parsed.push(contribution);
    }
    return parsed;
  };

  /**
   * Parse and array of magnitude elements.
   *
   * @param magnitudes {Array<Element>}
   *        array of quakeml magnitude elements.
   * @return {Array<Object>} parsed magnitude objects.
   */
  _parseMagnitudes = function (magnitudes) {
    var m,
        magnitude,
        parsed = [],
        preferredMagnitudeID = _preferredMagnitudeID;

    for (m = 0; m < magnitudes.length; m++) {
      magnitude = _extend({}, magnitudes[m]);
      magnitude.isPreferred = (preferredMagnitudeID === magnitude.publicID);
      magnitude.contributions = _parseMagnitudeContributions(
          _array(magnitude.stationMagnitudeContribution));
      delete magnitude.stationMagnitudeContribution;
      if (magnitude.isPreferred) {
        parsed.unshift(magnitude);
      } else {
        parsed.push(magnitude);
      }
    }
    return parsed;
  };

  /**
   * Parse an array of origin elements.
   *
   * @param origins {Array<Element>}
   *        array of quakeml origin elements.
   * @return {Array<Object>} parsed origin objects.
   */
  _parseOrigins = function (origins) {
    var o,
        origin,
        parsed = [],
        preferredOriginID = _preferredOriginID;

    for (o = 0; o < origins.length; o++) {
      origin = _extend({}, origins[o]);
      origin.isPreferred = (preferredOriginID === origin.publicID);
      origin.arrivals = _parseArrivals(_array(origin.arrival));
      delete origin.arrival;
      if (origin.isPreferred) {
        parsed.unshift(origin);
      } else {
        parsed.push(origin);
      }
    }
    return parsed;
  };

  /**
   * @return {Object} quakeml event element as json object.
   */
  _this.getEvent = function () {
    return _ev;
  };

  /**
   * @return {Array<Object>} magnitudes parsed from event.
   */
  _this.getMagnitudes = function () {
    return _magnitudes;
  };

  /**
   * @return {Array<Object>} origins parsed from event.
   */
  _this.getOrigins = function () {
    return _origins;
  };

  _initialize(ev);
  ev = null;
  return _this;

};

module.exports = QuakemlEvent;

},{}],41:[function(require,module,exports){
'use strict';


var XmlUtil = {

  /**
   * Convert simple xml to a json object.
   * Does not work well for mixed content (text/elements).
   */
  xmlToJson: function (xml) {
    // based on http://davidwalsh.name/convert-xml-json
    var obj = {},
        children = [],
        attrs,
        attr,
        nodes,
        node,
        nodeName,
        nodeValue,
        i,
        len;

    if (typeof xml === 'string') {
      xml = new DOMParser().parseFromString(xml, 'text/xml');
    }

    if (xml.nodeType === 3) {
      return xml.nodeValue;
    }

    if (xml.nodeType === 1) {
      attrs = xml.attributes;
      for (i = 0, len = attrs.length; i < len; i++) {
        attr = attrs.item(i);
        obj[attr.nodeName] = attr.nodeValue;
      }
    }

    if (xml.hasChildNodes()) {
      nodes = xml.childNodes;
      for(i = 0, len = nodes.length; i < len; i++) {
        node = nodes.item(i);
        nodeName = node.nodeName;
        nodeValue = XmlUtil.xmlToJson(node);
        children.push(nodeValue);
        if (typeof(obj[nodeName]) === 'undefined') {
          obj[nodeName] = nodeValue;
        } else {
          if (typeof(obj[nodeName].push) === 'undefined') {
            obj[nodeName] = [obj[nodeName]];
          }
          obj[nodeName].push(nodeValue);
        }
      }
    }

    // clean up '#text' nodes
    if (children.length === 1 &&
        obj['#text'] &&
        Object.keys(obj).length === 1) {
      return obj['#text'];
    }

    return obj;
  }

};


module.exports = XmlUtil;

},{}],"core/AccordionView":[function(require,module,exports){
'use strict';

var Accordion = require('accordion/Accordion'),
    Util = require('util/Util'),
    View = require('mvc/View');


var _DEFAULTS = {
  classes: 'accordion-standard',
  destroyView: true,
  expanded: false,
  toggleElement: 'h3',
  toggleText: 'Show more'
};


/**
 * Wrap a view in an accordion.
 *
 * Any of these options can be changed later by updating this view's model.
 *
 * @param options {Object}
 * @param options.classes {String}
 *     passed to Accordion as classes option.
 * @param options.destroyView {Boolean}
 *     whether to destroy wrapped view when this view is destroyed.
 *     default true.
 * @param options.expanded {Boolean}
 *     whether accordion should be expanded by default.
 *     default false.
 * @param options.toggleElement {String}
 *     passed to Accordion as toggleElement option.
 *     default 'h3'.
 * @param options.toggleText {String}
 *     passed to Accordion as toggleText option.
 *     default 'Show more'.
 */
var AccordionView = function (options) {
  var _this,
      _initialize,

      _accordion;


  _this = View(options);

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);

    _this.model.set({
      classes: options.classes,
      destroyView: options.destroyView,
      expanded: options.expanded,
      toggleElement: options.toggleElement,
      toggleText: options.toggleText,
      view: options.view
    }, {silent: true});
  };


  _this.destroy = Util.compose(function () {
    if (_this === null) {
      return;
    }

    if (_accordion) {
      // clean up previous render
      _accordion.destroy();
      _accordion = null;
    }

    if (_this.model.get('destroyView')) {
      _this.model.get('view').destroy();
    }

    _this.el.removeEventListener('click', _this.onClick);
    _this = null;
  }, _this.destroy);

  /**
   * Click handler called when accordion is clicked.
   */
  _this.onClick = function () {
    var view;

    // render view
    view = _this.model.get('view');
    view.render();

    // remove listener
    _this.el.removeEventListener('click', _this.onClick);
  };

  /**
   * Render accordion, and set up click handler to render wrapped view.
   */
  _this.render = function () {
    var classes,
        expanded,
        model,
        toggleElement,
        toggleText,
        view;

    if (_accordion) {
      // clean up previous render
      _accordion.destroy();
      _accordion = null;
      _this.el.removeEventListener('click', _this.onClick);
    }

    model = _this.model.get();
    classes = model.classes;
    expanded = model.expanded;
    toggleElement = model.toggleElement;
    toggleText = model.toggleText;
    view = model.view;

    if (!expanded) {
      classes = classes + ' accordion-closed';
    }

    // create accordion
    _accordion = Accordion({
      el: _this.el,
      accordions: [{
        classes: classes,
        content: view.el,
        toggleElement: toggleElement,
        toggleText: toggleText
      }]
    });

    if (expanded) {
      view.render();
    } else {
      _this.el.addEventListener('click', _this.onClick);
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = AccordionView;

},{"accordion/Accordion":2,"mvc/View":"mvc/View","util/Util":"util/Util"}],"core/Attribution":[function(require,module,exports){
'use strict';


var Collection = require('mvc/Collection'),
    Product = require('pdl/Product'),
    Util = require('util/Util'),
    Xhr = require('util/Xhr');


var _CONTRIBUTOR_LINK_CLASS = 'contributor-link';
var _CONTRIBUTOR_LIST_CLASS = 'contributor-list';
var _CONTRIBUTOR_REFERENCE_CLASS = 'contributor-reference';
var _CONTRIBUTOR_DATA_ATTRIBUTE = 'data-id';

var _DEFAULTS = {};


var Attribution = function (options) {
  var _this,
      _initialize,
      // variables
      _contributors,
      _sourceMap,
      _whenReady,
      // methods
      _formatContributorLink,
      _formatContributorList,
      _formatContributorReference,
      _onError,
      _onSuccess,
      _onReady,
      _sortByName;


  _this = {};

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);

    _contributors = [];
    _sourceMap = null;
    _whenReady = [];
  };


  /**
   * Get contributor link.
   *
   * @param id {String}
   *        contributor code.
   * @return {String} formatted link to contributor, or title if contributor
   *         does not have a url.
   */
  _formatContributorLink = function (id) {
    var contributor,
        title,
        url;

    title = null;
    url = null;

    if (id !== null) {
      id = id.toUpperCase();
      contributor = _this.getContributor(id);

      if (contributor) {
        title = contributor.title;
        url = contributor.url;
      }

      if (!title) {
        title = id;
      }
    }

    if (url) {
      return '<a href="' + url + '">' + title + '</a>';
    } else {
      return title;
    }
  };

  /**
   * Format list of contributors.
   *
   * @return {String} formatted list of contributors.
   */
  _formatContributorList = function () {
    var listMarkup = [];

    for (var i = 0; i < _contributors.length; i++) {
      listMarkup.push('<li>' +
          _this.getContributorLink(_contributors[i]) +
          '</li>');
    }

    return listMarkup.join('');
  };

  /**
   * Format contributor reference.
   *
   * Uses abbreviation if contributor has title.
   * Adds superscript with position of contributor in contributors list.
   *
   * @param id {String}
   *        contributor id.
   * @return {String} formatted contributor reference.
   */
  _formatContributorReference = function (id) {
    var buf,
        contributor,
        listPosition,
        title,
        url;

    buf = [];
    title = null;
    url = null;

    if (id !== null) {
      id = id.toUpperCase();
      contributor = _this.getContributor(id);

      if (contributor) {
        title = contributor.title;
        url = contributor.url;
      }

      listPosition = _contributors.indexOf(id.toLowerCase()) + 1;

      if (title) {
        buf.push('<abbr title="' + title + '">');
      }

      buf.push(id);

      if (listPosition > 0) {
        // found in list
        buf.push('<sup>' + listPosition + '</sup>');
      }

      if (title) {
        buf.push('</abbr>');
      }
    }

    return buf.join('');
  };

  /**
   * Attribution load error handler.
   */
  _onError = function () {
    _sourceMap = Collection([]);
    _onReady();
  };

  /**
   * Call any registered callbacks after data loads.
   */
  _onReady = function () {
    _whenReady.forEach(function (callback) {
      callback();
    });
    _whenReady = [];
  };

  /**
   * Attribution load success handler.
   *
   * @param data {Array<Object>}
   */
  _onSuccess = function (data) {
    _sourceMap = Collection(data);
    _this.render();
    _onReady();
  };

  /**
   * Sort function for contributors.
   *
   * @param a {String}
   *        first contributor code.
   * @param b {String}
   *        second contributor code.
   * @return -1, when a before b;
   *         0, when equal;
   *         1, when a after b.
   */
  _sortByName = function (a, b) {
    var aName,
        bName;

    aName = _this.getName(a);
    bName = _this.getName(b);

    if (aName < bName) {
      return -1;
    } else if (aName > bName) {
      return 1;
    } else {
      return 0;
    }
  };

  /**
   * Get a contributor by id.
   *
   * @return {Object}
   *         contributor object, with at least properties "id", "title", "url".
   *         title and url are null when contributor not found.
   */
  _this.getContributor = function (id) {
    var contributor;

    contributor = null;
    id = id.toLowerCase();

    if (_sourceMap !== null) {
      contributor = _sourceMap.get(id);

      // TODO: contributor aliases
      // this requires some additional thought,
      // because sourceMap isn't necessarily set to detect duplicates
    }

    return contributor;
  };

  /**
   * Get list of contributors.
   *
   * @return {Array<String>}
   *         list of contributor codes.
   */
  _this.getContributors = function () {
    return _contributors;
  };

  /**
   * Return formatted html list of contributors
   * (as set by #setContributors(Array)).
   *
   * @return {String} html markup for list.
   */
  _this.getContributorList = function () {
    return '<ol class="contributors ' + _CONTRIBUTOR_LIST_CLASS + '">' +
        _formatContributorList() +
        '</ol>';
  };

  /**
   * Get formatted html for link to contributor.
   *
   * @param id {String}
   *        contributor code.
   * @return {String} html.
   */
  _this.getContributorLink = function (id) {
    return '<span class="' + _CONTRIBUTOR_LINK_CLASS + '"' +
        ' ' + _CONTRIBUTOR_DATA_ATTRIBUTE + '="' + id + '">' +
        _formatContributorLink(id) +
        '</span>';
  };

  /**
   * Get formatted html for reference to contributor.
   * References position as returned by getContributorList.
   *
   * @param id {String}
   *        contributor code.
   * @return {String} html markup for reference to contributor.
   */
  _this.getContributorReference = function (id) {
    return '<span class="' + _CONTRIBUTOR_REFERENCE_CLASS + '"' +
        ' ' + _CONTRIBUTOR_DATA_ATTRIBUTE + '="' + id + '">' +
        _formatContributorReference(id) +
        '</span>';
  };

  /**
   * Get the formatted name for a contributor.
   *
   * @param id {String}
   *        contributor code
   * @return {String}
   *         name for contributor.
   */
  _this.getName = function (id) {
    var contributor,
        title;

    contributor = _this.getContributor(id);
    id = id.toUpperCase();
    title = null;
    if (contributor) {
      title = contributor.title;
    }

    if (title) {
      return title + ' (' + id + ')';
    } else {
      return id;
    }
  };

  /**
   * Finds all the relevant attribution to provide for a given product.
   *
   * @param product {Product}
   *     The product for which to generate attribution.
   *
   * @return {String}
   *     Attribution markup for the given product.
   */
  _this.getProductAttribution = function (product) {
    var source,
        sources,
        type;

    sources = {}; // Keep a unique list

    type = Product.getBaseType(product.get('type'));

    // Put product.source on first
    source = product.get('source');
    sources[source] = _this.getContributorReference(source);

    // Add in additional sources based on product type

    if (type === 'origin' || type === 'phase-data') {
      // Look for origin-source property and magnitude-source property and
      // add them as contributors if new ids
      source = product.getProperty('origin-source');
      source = source ? source.toLowerCase() : null;
      if (source && !sources.hasOwnProperty(source)) {
        sources[source] = _this.getContributorReference(source);
      }

      source = product.getProperty('magnitude-source');
      source = source ? source.toLowerCase() : null;
      if (source && !sources.hasOwnProperty(source)) {
        sources[source] = _this.getContributorReference(source);
      }
    } else if (type === 'focal-mechanism' || type === 'moment-tensor') {
      // Look for beachball-source property and add it as contributor if new id
      source = product.getProperty('beachball-source');
      source = source ? source.toLowerCase() : null;
      if (source && !sources.hasOwnProperty(source)) {
        sources[source] = _this.getContributorReference(source);
      }
    }

    return Object.keys(sources).reduce(function (previous, current) {
          return previous + sources[current];
        }, '');
  };

  /**
   * Set list of contributors.
   *
   * @param contributors {Array<String>}
   *        list of contributors.
   */
  _this.setContributors = function (contributors) {
    var el;

    // copy
    _contributors = contributors.slice(0);
    // convert to lower case
    _contributors = contributors.map(function (s) {
      return s.toLowerCase();
    });
    // sort
    _contributors.sort(_sortByName);

    // update contributor list (if it exists)
    el = document.querySelector('.' + _CONTRIBUTOR_LIST_CLASS);
    if (el) {
      el.innerHTML = _formatContributorList();
    }
  };

  /**
   * Load a contributor list.
   */
  _this.load = function (url) {
    Xhr.ajax({
      url: url,
      error: _onError,
      success: _onSuccess
    });
  };

  /**
   * Re-render contributor links and references.
   */
  _this.render = function () {
    var els;

    els = Array.prototype.slice.call(
        document.querySelectorAll('.' + _CONTRIBUTOR_LINK_CLASS), 0);
    els.forEach(function (link) {
      var id;
      id = link.getAttribute(_CONTRIBUTOR_DATA_ATTRIBUTE);
      if (id) {
        link.innerHTML = _formatContributorLink(id);
      }
    });

    els = Array.prototype.slice.call(
        document.querySelectorAll('.' + _CONTRIBUTOR_REFERENCE_CLASS), 0);
    els.forEach(function (ref) {
      var id;
      id = ref.getAttribute(_CONTRIBUTOR_DATA_ATTRIBUTE);
      if (id) {
        ref.innerHTML = _formatContributorReference(id);
      }
    });
  };

  /**
   * Call a callback, possibly waiting for attribution data to load.
   *
   * @param callback {Function}
   *        function that is called (with no arguments) once attribution data
   *        has loaded (or failed to load).
   */
  _this.whenReady = function (callback) {
    if (_sourceMap === null) {
      // save callback for when ready
      _whenReady.push(callback);
    } else {
      // ready now
      callback();
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = Attribution();

},{"mvc/Collection":32,"pdl/Product":"pdl/Product","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"core/BasicPinView":[function(require,module,exports){
'use strict';


var Attribution = require('core/Attribution'),
    Module = require('core/Module'),
    ProductView = require('core/ProductView'),
    Util = require('util/Util');


var _DEFAULTS = {
  module: {ID: '', TITLE: 'Module Title'}
};


/**
 * This class provides a base class from which others can inherit. It
 * defines a simple API for creating custom "pins" for the executive summary
 * section of the event pages. This class extends a ProductView.
 *
 * Each pin is composed of a header, content, and footer section. The
 * header contains, by convention, the product title that links to the product
 * details. The footer contains, by convention, contributor information for
 * the product. The content is much more free-form and is typically the
 * part that is overridden by implementing sub-classes.
 *
 *
 * @param options {Object}
 *     See constructor documentation for details.
 *
 *
 * @see BasicPinView#renderPinContent
 * @see BasicPinView#renderPinFooter
 * @see BasicPinView#renderPinHeader
 *
 */
var BasicPinView = function (options) {
  var _this,
      _initialize,

      _onClick;


  options = Util.extend({}, _DEFAULTS, options);
  _this = ProductView(options);

  /**
   * Initializes the skeleton layout and stores references to DOM containers
   * for subsequent rendring.
   *
   *
   * @param options {Object}
   *     Configuration options for this view, in addition to what is supported
   *     in a standard ProductView, you may provide...
   * @param options.module {Module}
   *     An object containing an "ID" and "TITLE" property. The ID property is
   *     used to create a link to the product page and the TITLE property is
   *     used as the link text.
   *
   */
  _initialize = function (options) {
    _this.module = options.module || Module;

    _this.el.innerHTML = [
      '<article class="pin-view">',
        '<header class="pin-header"></header>',
        '<section class="pin-content"></section>',
        '<footer class="pin-footer"></footer>',
      '</article>'
    ].join('');

    _this.header = _this.el.querySelector('.pin-header');
    _this.content = _this.el.querySelector('.pin-content');
    _this.footer = _this.el.querySelector('.pin-footer');

    _this.header.classList.add(_this.module.ID + '-pin-header');
    _this.content.classList.add(_this.module.ID + '-pin-content');
    _this.footer.classList.add(_this.module.ID + '-pin-footer');

    _this.el.addEventListener('click', _onClick);
  };


  /**
   * Called when _this.el is clicked
   *
   */
  _onClick = function (e) {
    _this.onClick(e);
  };


  _this.getLinkUrl = function () {
    return '#' + _this.module.ID;
  };

  /**
   * Handle a click on _this.el
   *
   * @param e {MouseEvent}
   *     A MouseEvent object
   */
  _this.onClick = function (e) {
    _this.redirect(_this.getLinkUrl());
    if (e && typeof e.preventDefault === 'function') {
      e.preventDefault();
    }
  };

  /**
   * Update window.location
   *
   */
  _this.redirect = function (url) {
    window.location = url;
  };

  /**
   * Frees resources associated with this view.
   *
   */
  _this.destroy = Util.compose(function () {
    if (_this === null) {
      return;
    }

    _this.el.removeEventListener('click', _onClick);

    _onClick = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Render the header, content, and footer sections of this pin.
   *
   * @return {BasicPinView}
   *     Returns a reference to this view for method chaining...
   *
   */
  _this.render = function () {
    _this.renderPinHeader();
    _this.renderPinContent();
    _this.renderPinFooter();

    return _this;
  };

  /**
   * @APIMethod
   *
   * Render the content section of the pin. Implementing sub-classes will
   * likely want to override this method.
   *
   */
  _this.renderPinContent = function () {
    _this.content.innerHTML = 'Pin Content';
  };

  /**
   * @APIMethod
   *
   * Render the footer section of the pin.
   *
   */
  _this.renderPinFooter = function () {
    _this.footer.innerHTML = 'Contributed by ' +
        Attribution.getProductAttribution(_this.model);
  };

  /**
   * @APIMethod
   *
   * Render the header section of the pin.
   *
   */
  _this.renderPinHeader = function () {
    var display;

    // Use module ID and TITLE to create a link
    display = _this.module.TITLE;

    _this.header.innerHTML = [
      '<a href="', _this.getLinkUrl(), '">', display, '</a>'
    ].join('');
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = BasicPinView;

},{"core/Attribution":"core/Attribution","core/Module":"core/Module","core/ProductView":"core/ProductView","util/Util":"util/Util"}],"core/ContentView":[function(require,module,exports){
'use strict';

var Util = require('util/Util'),
    View = require('mvc/View'),
    Xhr = require('util/Xhr');


/**
 * View for a specific Content.
 *
 * @param options {Object}
 *     all options are passed to mvc/View.
 */
var ContentView = function (options) {
  var _this,

      _xhr;

  _this = View(options);

  _this.destroy = Util.compose(function () {
    if (_xhr) {
      _xhr.abort();
      _xhr = null;
    }
    _this = null;
  }, _this.destroy);

  /**
   * Asynchronous method to fetch the data associated with _this.model {Content}
   * object. This method proceeds asynchronously regardless of whether
   * _this.model users `bytes` or `url` data. On success the _this.onSuccess
   * callback is invoked, on error, the _this.onError callback is invoked.
   *
   */
  _this.fetchData = function () {
    var data;

    data = _this.model.get('bytes');
    if (data !== null) {
      // force async
      setTimeout(function () {
        if (!_this) {
          // view was destroyed before next tick
          // simulate async abort
          return;
        }
        _this.onSuccess(data, null);
      }, 0);
    } else {
      _xhr = Xhr.ajax({
        url: _this.model.get('url'),
        success: _this.onSuccess,
        error: _this.onError,
        done: function () {
          _xhr = null;
        }
      });
    }
  };

  /**
   *
   * @param status {String}
   *      A description of the error that occurred.
   * @param xhr {XMLHttpRequest} Optional. Default undefined.
   *      The original request that lead to the error.
   */
  _this.onError = function (status/*, xhr*/) {
    _this.el.innerHTML = status;
  };

  /**
   * @APIMethod
   *
   * This method is called when data is successfully fetched from _this.model
   * {Content} object. It should complete the render of the fetched data
   * into _this.el container.
   *
   * @param data {String|JSON}
   *     The data for _this.model {Content} object.
   * @param xhr {XMLHttpRequest} Optional.
   *     The XMLHttpRequest object used to fetch the data. If _this.model
   *     uses `bytes` data, this parameter is `null`.
   */
  _this.onSuccess = function (data/*, xhr*/) {
    _this.el.innerHTML = data;
  };

  /**
   * Called when the model changes. Initially sets a loading message then starts
   * the data fetch process to render the actual content. Relies on browser
   * caches to avoid duplicate HTTP overhead.
   *
   */
  _this.render = function () {
    _this.el.innerHTML = '<p>Loading content&hellip;</p>';
    _this.fetchData();
  };


  options = null;
  return _this;
};


module.exports = ContentView;

},{"mvc/View":"mvc/View","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"core/CooperatorLogo":[function(require,module,exports){
'use strict';

var Util = require('util/Util');


var _DEFAULTS = {
  cooperator: null,
  el: null
};


/**
 * Class to manage cooperator logo.
 *
 * @param options {Object}
 * @param options.cooperator {Object}
 *        optional, default null.
 *        see #setCooperator(cooperator)
 * @param options.el {Element}
 *        optional, default document.querySelector('.cooperators').
 *        if no element found, creates and attempts to add to "site-header".
 */
var CooperatorLogo = function (options) {
  var _this,
      _initialize;


  _this = {};

  _initialize = function (options) {
    var el;

    options = Util.extend({}, _DEFAULTS, options);

    // use configured element, or fall back to template element.
    el = options.el || document.querySelector('.cooperators');
    if (!el) {
      // if template element doesn't exist, create and add to site-header
      el = document.createElement('div');
      el.classList.add('cooperators');
      try {
        document.querySelector('.site-header').appendChild(el);
      } catch (e) {
        // ignore, maybe not in template
      }
    }
    _this.el = el;

    _this.setCooperator(options.cooperator);
  };

  /**
   * Clear existing cooperator list, and replace with specified  cooperator.
   *
   * @param cooperator {Object}
   *        when null, clears cooperator list and returns.
   * @param cooperator.logo {String}
   *        url for cooperator logo.
   * @param cooperator.title {String}
   *        title for cooperator.
   * @param cooperator.url {String}
   *        Optional, when omitted logo will not be linked.
   *        url for link to cooperator.
   */
  _this.setCooperator = function (cooperator) {
    var el,
        img,
        logo,
        title,
        url;

    // remove existing contributor
    Util.empty(_this.el);

    // validate new contributor
    if (!cooperator || !cooperator.logo || !cooperator.title) {
      return;
    }

    logo = cooperator.logo;
    title = cooperator.title;
    url = cooperator.url;

    // create logo
    img = document.createElement('img');
    img.setAttribute('src', logo);
    img.setAttribute('alt', 'in cooperation with ' + title);
    el = img;

    // wrap in link if applicable
    if (url) {
      el = document.createElement('a');
      el.setAttribute('href', url);
      el.appendChild(img);
    }

    // add cooperator class
    el.classList.add('cooperator');

    // add to cooperators section
    _this.el.appendChild(el);
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = CooperatorLogo;
},{"util/Util":"util/Util"}],"core/DownloadView":[function(require,module,exports){
'use strict';


var ContentView = require('core/ContentView'),
    Formatter = require('core/Formatter'),
    Product = require('pdl/Product');


var _NO_CONTENT_MESSAGE = 'No download content available.';


/**
 * This class extends the {ContentView} class and is specifically used
 * for rendering "contents.xml" for a given product. The `options.model` should
 * be of type {Content}.
 *
 *
 * @param options {Object}
 *     An object containing configuration options for this view.
 *
 * @param options.product {Product}
 *     The product for which to render contents.xml.
 * @param options.formatter {Formatter}
 *     The formatter object to use for formatting intrinsic values.
 */
var DownloadView = function (options) {
  var _this,
      _initialize,

      _formatter,
      _product;

  options = options || {};
  _this = ContentView(options);

  /**
   * @Constructor
   *
   * Initializes the view. See class level documentation for details.
   */
  _initialize = function (options) {
    _product = options.product || Product();

    _this.el.classList.add('download-view');
    _formatter = options.formatter || Formatter();
  };


  /**
   * Renders the default error message. Called if an error occurs during the
   * data fetch.
   *
   */
  _this.onError = function (/*status, xhr*/) {
    _this.el.innerHTML = _NO_CONTENT_MESSAGE;
  };

  /**
   * Renders the list of downloads. Called when data is successfully fetched.
   *
   */
  _this.onSuccess = function (responseText, xhr) {
    try {
      _this.el.innerHTML = '<ul class="no-style">' +
        _this.parse(xhr.responseXML).map(_this.renderFile).join('') +
      '</ul>';
    } catch (e) {
      _this.onError('Failed to render content.');
    }
  };

  /**
   * Parses an XMLDocument `data` into an array of file data structures.
   *
   * @param data {XMLDocument}
   *     The data fetched from the server, in XML format.
   */
  _this.parse = function (data) {
    return Array.prototype.map.call(
        data.querySelectorAll('contents > file'), _this.parseFile);
  };

  /**
   * Parse an XMLElement into a structured data object representing a file.
   *
   * @param file {XMLElement}
   *     The file element to parse.
   *
   * @return {Object}
   *     A file object with the following keys:
   *     - `id` {String}
   *     - `title` {String}
   *     - `caption` {String}
   *     - `formats` {Array}
   */
  _this.parseFile = function (file) {
    var caption,
        content,
        el,
        els,
        format,
        formats,
        href,
        i,
        id,
        len,
        title,
        type;

    if (file.getAttribute('refid')) {
      throw new Error('file element with refid');
    }

    id = file.getAttribute('id');
    title = file.getAttribute('title');
    caption = file.querySelector('caption');
    caption = (caption ? caption.textContent : null);
    formats = [];

    els = file.querySelectorAll('format');
    for (i = 0, len = els.length; i < len; i++) {
      el = els[i];
      href = el.getAttribute('href');
      type = el.getAttribute('type');

      try {
        format = {
          href: href,
          type: type,
          url: null,
          length: 0
        };

        content = _product.getContent(href);

        format.url = content.get('url');
        format.length = content.get('length');
      } catch (e) {
        if (console && console.log) {
          console.log(e.stack);
        }
      } finally {
        formats.push(format);
      }
    }

    return {
      id: id,
      title: title,
      caption: caption,
      formats: formats
    };
  };

  /**
   * Creates markup representing the give file object.
   *
   * @param file {Object}
   *     The file object to render.
   *
   * @return {String}
   *     The markup representing the given file object.
   */
  _this.renderFile = function (file) {
    return [
      '<li class="download-file">',
        '<span class="download-title">', file.title ,'</span>',
        '<span class="download-caption">', file.caption, '</span>',
        '<ul class="download-formats">',
          file.formats.map(_this.renderFormat).join(''),
        '</ul>',
      '</li>'
    ].join('');
  };

  /**
   * Creates markup representing the give format object.
   *
   * @param format {Object}
   *     The format object to render.
   *
   * @return {String}
   *     The markup representing the given format object.
   */
  _this.renderFormat = function (format) {
    var extension,
        size;

    extension = format.href.split('.').slice(-1).join('').toUpperCase();
    size = _formatter.fileSize(format.length);

    return [
      '<li class="format">',
        '<a href="', format.url, '" ',
            'title="', extension, ' (', format.href, ')">',
          extension, ' (', size, ')',
        '</a>',
      '</li>'
    ].join('');
  };


  _initialize(options);
  options = null;
  return _this;
};


DownloadView.NO_CONTENT_MESSAGE = _NO_CONTENT_MESSAGE;

module.exports = DownloadView;

},{"core/ContentView":"core/ContentView","core/Formatter":"core/Formatter","pdl/Product":"pdl/Product"}],"core/EventPage":[function(require,module,exports){
'use strict';


var Attribution = require('core/Attribution'),
    CatalogEvent = require('pdl/CatalogEvent'),
    CooperatorLogo = require('core/CooperatorLogo'),
    DYFIFormModule = require('dyfi/DYFIFormModule'),
    DYFIModule = require('dyfi/DYFIModule'),
    Events = require('util/Events'),
    ExecutiveSummaryModule = require('general/ExecutiveSummaryModule'),
    FiniteFaultModule = require('finite-fault/FiniteFaultModule'),
    FocalMechanismModule = require('focal-mechanism/FocalMechanismModule'),
    Formatter = require('core/Formatter'),
    ImpactSummaryModule = require('impact/ImpactSummaryModule'),
    InteractiveMapModule = require('map/InteractiveMapModule'),
    Model = require('mvc/Model'),
    MomentTensorModule = require('moment-tensor/MomentTensorModule'),
    NearbySeismicity = require('core/NearbySeismicity'),
    OafModule = require('oaf/OafModule'),
    OriginModule = require('origin/OriginModule'),
    PAGERModule = require('losspager/PAGERModule'),
    RegionalInfoModule = require('general/RegionalInfoModule'),
    ScientificSummaryModule = require('scientific/ScientificSummaryModule'),
    ShakeMapModule = require('shakemap/ShakeMapModule'),
    Util = require('util/Util'),
    WaveformModule = require('waveform/WaveformModule');


var _DEFAULTS = {
  'event': null, // CatalogEvent
  'config': {
  },
  'defaultModule': ExecutiveSummaryModule.ID,
  'modules': [
    // Overview
    [
      ExecutiveSummaryModule,
      InteractiveMapModule,
      RegionalInfoModule
    ],
    // Impact
    [
      ImpactSummaryModule,
      DYFIFormModule,
      DYFIModule,
      ShakeMapModule,
      PAGERModule
    ],
    // Technical
    [
      ScientificSummaryModule,
      OriginModule,
      MomentTensorModule,
      FocalMechanismModule,
      FiniteFaultModule,
      WaveformModule,
      OafModule
    ]
  ],
  'redirects': {
    // Overview
    'general_summary': ExecutiveSummaryModule.ID,
    'general_map': InteractiveMapModule.ID,
    // Impact
    'impact_summary': ImpactSummaryModule.ID,
    'impact_tellus': DYFIFormModule.ID,
    'impact_dyfi': DYFIModule.ID,
    'impact_shakemap': ShakeMapModule.ID,
    'impact_pager': PAGERModule.ID,
    // Technical
    'scientific_summary': ScientificSummaryModule.ID,
    'scientific_origin': OriginModule.ID,
    'scientific_moment-tensor': MomentTensorModule.ID,
    'scientific_focal-mechanism': FocalMechanismModule.ID,
    'scientific_finite-fault': FiniteFaultModule.ID,
    'scientific_waveforms': WaveformModule.ID
  }
};

var EventPage = function (options) {
  var _this,
      _initialize,

      _config,
      _currentModule,
      _el,
      _event,
      _formatter,
      _hasPrevious,
      _model,
      _modules,
      _navEl,
      _redirects,

      _createNavItem,
      _initializeModules,
      _onHashChange,
      _parseHash,
      _parseLegacyHash;


  _this = Events();

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);
    _redirects = options.redirects;

    _event = options.event || CatalogEvent();
    _config = options.config || {};
    _config.defaultModule = _config.defaultModule || options.defaultModule;
    _config.modules = options.modules || [];

    _formatter = options.formatter || Formatter();
    // whether event page has previously rendered any content
    _hasPrevious = false;

    _this.updateContributors();
    if (_config.hasOwnProperty('ATTRIBUTION_URL')) {
      Attribution.load(_config.ATTRIBUTION_URL);
    }

    _el = options.el || document.createElement('div');
    _navEl = options.nav || document.createElement('nav');

    _this.header = _el.querySelector('.event-header') ||
        document.createElement('div');
    _this.content = _el.querySelector('.event-content') ||
        document.createElement('div');
    _this.footer = _el.querySelector('.event-footer') ||
        document.createElement('div');

    _model = Model({
      'event': _event,
      'config': _config
    });

    // Creates the mapping for later
    _initializeModules();
    _this.renderHeader();
    Attribution.whenReady(_this.onAttributionReady);

    // render module
    Events.on('back', 'onBack', _this);
    Events.on('hashchange', _onHashChange);
    _onHashChange();
  };

  _createNavItem = function (module, isHeader) {
    var link,
        navItem;

    if (isHeader) {
      navItem = document.createElement('header');
      link = navItem.appendChild(document.createElement('a'));
    } else {
      navItem = document.createElement('a');
      link = navItem;
    }

    link.setAttribute('class', 'module-' + module.ID + '-nav');
    link.setAttribute('href', '#' + module.ID);
    link.innerHTML = module.TITLE;

    return navItem;
  };

  /**
   * Builds an navigation for current _event as well as a map of
   * moduleId => module.
   *
   */
  _initializeModules = function () {
    var group,
        i,
        j,
        module,
        modules,
        moduleGroups,
        numGroups,
        numModules,
        types;

    _modules = {};

    types = (_event ? Object.keys(_event.getProducts()) : []);
    moduleGroups = _config.modules;
    numGroups = moduleGroups.length;

    Util.empty(_navEl);

    // Add navigation link to return to Latest Earthquakes
    _this.createMapLink(_navEl);

    for (i = 0; i < numGroups; i++) {
      modules = moduleGroups[i];
      group = null;

      numModules = modules.length;
      for (j = 0; j < numModules; j++) {
        module = modules[j];

        _modules[module.ID] = module;

        if (_this.moduleHasContent(module, types)) {
          if (!group) {
            group = document.createElement('section');
            group.appendChild(_createNavItem(module, true));
          } else {
            group.appendChild(_createNavItem(module));
          }

        }
      }
      if (group) {
        _navEl.appendChild(group);
      }

      group = null;
    }

    // Add navigation link to download event KML
    _this.createKmlLink(_navEl);

    // Add search nearby seismicity link
    _this.createSearchNearbySeismicityLink(_navEl);
  };

  /**
   * Adds KML Link to the bottom of the navigation.
   * @params el {DOMElement}
   *    The element to add the links to.
   */
  _this.createKmlLink = function(el) {
    var link,
        kmlURL;

    if (_event && _config.KML_STUB) {
      kmlURL = _config.KML_STUB.replace('%s',
          _event.getEventId());

      link = document.createElement('a');
      link.setAttribute('class', 'kml-download');
      link.setAttribute('href', kmlURL);
      link.innerHTML = 'Download Event KML';
      el.appendChild(link);
    }
  };

  /**
   * Adds Latest Earthquakes Link to the top of the navigation.
   * @params el {DOMElement}
   *    The element to add the links to.
   */
  _this.createMapLink = function(el) {
    var link;

    if (!_this.isScenarioMode()) {
      link = document.createElement('a');
      link.setAttribute('class', 'latest-earthquakes');
      link.setAttribute('href', '/earthquakes/map/');
      link.innerHTML = 'Latest Earthquakes';
      link.classList.add('up-one-level');
      el.appendChild(link);
    }
  };

  /**
   * Create search nearby seismicity link.
   *
   * @param el {DOMElement}
   *     element to add link to.
   */
  _this.createSearchNearbySeismicityLink = function (el) {
    var link,
        nearbySeismicity,
        url;

    if (_event && !_this.isScenarioMode()) {
      nearbySeismicity = NearbySeismicity();
      url = nearbySeismicity.getNearbySeismicityLink(_event.getSummary());
      nearbySeismicity.destroy();

      link = document.createElement('a');
      link.setAttribute('class', 'search-nearby-seismicity');
      link.setAttribute('href', url);
      link.innerHTML = 'Search Nearby Seismicity';
      el.appendChild(link);
    }
  };


  /**
   * Unbind event listeners and free references.
   */
  _this.destroy = Util.compose(function () {
    if (!_this) {
      return;
    }

    // render module
    Events.off('back', 'onBack', _this);
    Events.off('hashchange', _onHashChange);

    if (_currentModule) {
      _currentModule.destroy();
    }

    if (_model) {
      _model.destroy();
    }

    // functions
    _createNavItem = null;
    _initializeModules = null;
    _onHashChange = null;
    _parseHash = null;
    _parseLegacyHash = null;

    // variables
    _config = null;
    _currentModule = null;
    _el = null;
    _event = null;
    _formatter = null;
    _hasPrevious = false;
    _model = null;
    _modules = null;
    _navEl = null;
    _this = null;
  }, _this.destroy);

  /**
   * Called when attribution information has been loaded,
   * Updates the contributor logo in the header and
   * the contributor list in the banner.
   */
  _this.onAttributionReady = function () {
    var preferredOrigin;

    // Contributor logo in banner
    preferredOrigin = _event ? _event.getPreferredOriginProduct() : null;
    if (preferredOrigin) {
      CooperatorLogo({
        cooperator: Attribution.getContributor(preferredOrigin.get('source'))
      });
    }

    // Add Contributor list in footer
    _this.renderFooter();
  };

  /**
   * Loops over each product and checks for source information. Creates a
   * unique list of contributors and then sets this list on the
   * Attribution so we have a complete list.
   *
   */
  _this.updateContributors = function () {
    var allProducts,
        products,
        product,
        source,
        sources,
        type,
        i,
        length;

    allProducts = _event ? _event.getProducts() : {};
    sources = {};

    for (type in allProducts) {
      products = allProducts[type];
      length = products.length;

      for (i = 0; i < length; i++) {
        product = products[i];


        // check product source
        source = product.get('source');
        if (source) {
          source = source.toLowerCase();

          if (source !== 'admin' && !sources.hasOwnProperty(source)) {
            sources[source] = true;
          }
        }

        source = product.getProperty('origin-source');
        if (source) {
          source = source.toLowerCase();
          if (!sources.hasOwnProperty(source)) {
            sources[source] = source;
          }
        }
        source = product.getProperty('magnitude-source');
        if (source) {
          source = source.toLowerCase();
          if (!sources.hasOwnProperty(source)) {
            sources[source] = source;
          }
        }
        source = product.getProperty('beachball-source');
        if (source) {
          source = source.toLowerCase();
          if (!sources.hasOwnProperty(source)) {
            sources[source] = source;
          }
        }
      }
    }

    Attribution.setContributors(Object.keys(sources));
  };

  /**
   * Check whether event page is in scenario mode.
   *
   * @return {Boolean}
   *     true, when event page is configured to be in scenario mode;
   *     false, otherwise.
   */
  _this.isScenarioMode = function () {
    return (_config.SCENARIO_MODE === true);
  };

  /**
   * Check whether a module has content.
   *
   * If `module` defines a static hasContent method, defer to module.
   * Otherwise, `module` should define a static TYPES property with a list
   * of "base" product types; if event page is in scenario mode, automatically
   * adds "-scenario" suffix to base type.
   *
   * @param module {Module}
   *     the module to check.
   * @param productTypes {Array<String>}
   *     array of product types associated with current event.
   * @return {Boolean}
   *     true, if module should be included in navigation;
   *     false, otherwise.
   */
  _this.moduleHasContent = function (module, productTypes) {
    var i,
        isScenarioMode,
        len,
        type;

    if (module.hasOwnProperty('hasContent') &&
        typeof module.hasContent === 'function') {
      return module.hasContent(_model);
    } else if (module.hasOwnProperty('TYPES') && Array.isArray(module.TYPES)) {
      len = module.TYPES.length;
      isScenarioMode = _this.isScenarioMode();

      for (i = 0; i < len; i++) {
        type = module.TYPES[i];
        if (isScenarioMode) {
          type += '-scenario';
        }

        if (productTypes.indexOf(type) !== -1) {
          return true;
        }
      }
    }

    return false;
  };

  /**
   * Back event listener.
   *
   * Called in response to `back` event on global Events object.
   */
  _this.onBack = function () {
    if (_hasPrevious) {
      // there is a previous module to render
      window.history.back();
    } else {
      window.location.hash = '#' + _config.defaultModule;
    }
  };

  /**
   * Update model and module based on current url.
   *
   * If current url is unexpected/unknown, loads default module.
   * Triggers a render of current module.
   */
  _onHashChange = function () {
    var clearSettings,
        currentNav,
        hash,
        lastNav,
        modelParams,
        module,
        params,
        redirect;

    // parse urls of format "#module?params" where params is in query string format
    hash = _parseHash(window.location.hash || '');
    module = hash.module;
    params = hash.params;

    // verify module is known, otherwise load default (from "config")
    if (!_modules.hasOwnProperty(module)) {
      hash = _parseLegacyHash(window.location.hash || '');
      module = hash.module;
      params = hash.params;

      if (_modules.hasOwnProperty(module)) {
        redirect = '#' + hash.redirect;
      } else {
        redirect = '#' + _config.defaultModule;
      }

      try {
        // Replace the "bad" url so users can go back before the redirect
        window.location.replace(redirect);
      } catch (e) {
        window.location = redirect;
      }

      return;
    }

    if (_currentModule) {
      // can navigate backwards using window.history
      _hasPrevious = true;

      // if current module is different than requested, destroy current module
      if (_currentModule.ID !== module) {
        // Clear these so defaults are invoked
        clearSettings = {};
        clearSettings[_currentModule.ID] = {};
        _model.set(clearSettings, {silent: true});

        _currentModule.destroy();
        _currentModule = null;
      }
    }

    // if no current module, create module with model and module content element
    if (!_currentModule) {
      _currentModule = _modules[module]({
        el: _this.content,
        formatter: _formatter,
        model: _model
      });
    }

    // update module params
    params = Util.extend({}, params);
    modelParams = {};
    modelParams[module] = params;
    // this triggers a render of _currentModule
    _model.set(modelParams);

    // update navigation
    currentNav = _navEl.querySelector('.module-' + _currentModule.ID + '-nav');
    lastNav = _navEl.querySelector('.current-module');
    if (currentNav !== lastNav) {
      if (lastNav) {
        lastNav.classList.remove('current-module');
      }
      currentNav.classList.add('current-module');
    }

    // notify that page was rendered
    _this.trigger('render');

    // scroll to top of page
    window.scroll(0,0);
  };

  /**
   * Parse the module and module parameters from a hash fragment.
   *
   * @param hash {String}
   *        the hash fragment to parse.
   *        e.g. "#module?param1=value1&param2=value2"
   * @return {Object}
   *         module {String} name of module.
   *         params {Object} module parameters.
   */
  _parseHash = function (hash) {
    var module,
        params,
        parts;

    hash = hash.replace('#', '');
    parts = hash.split('?');
    module = parts[0];
    params = {};
    if (parts.length > 1) {
      // rejoin any remaining parts using ?, then split parameters on &
      parts = parts.slice(1).join('?').split('&');
      // parse each parameter
      parts.forEach(function (param) {
        var name,
            parts,
            value;
        // parameter and value are separated by =
        parts = param.split('=');
        name = decodeURIComponent(parts[0]);
        // value may include =, so slice and rejoin
        value = decodeURIComponent(parts.slice(1).join('='));
        params[name] = value;
      });
    }
    return {
      'module': module,
      'params': params
    };
  };

  /**
   * Parse the module and module parameters from a hash fragment.
   *
   * @param hash {String}
   *        the hash fragment to parse.
   * @return {Object}
   *         module {String} name of module.
   *         params {Object} module parameters.
   *         redirect {Object} redirect parameters.
   */
  _parseLegacyHash = function (hash) {
    var module,
        params,
        parts,
        redirect;

    hash = hash.replace('#', '');
    params = {};
    parts = hash.split(':');
    module = parts[0];

    if (_redirects.hasOwnProperty(module)) {
      module = _redirects[module];
    }

    redirect = module;

    if (parts.length > 1) {
      parts = parts.slice(1).join(':').split('_');

      if (parts[0]) {
        params.source = parts[0];
        redirect += '?source=' + parts[0];
      }

      if (parts[1]) {
        params.code = parts[1];
        redirect += '&code=' + parts[1];
      }
    }

    return {
      'module': module,
      'params': params,
      'redirect': redirect
    };
  };

  _this.renderFooter = function () {
    var contributors,
        markup;

    contributors = Attribution.getContributors();
    markup = [];

    if (contributors && contributors.length !== 0) {
      markup.push(
        '<h3>Contributors</h3>',
        Attribution.getContributorList()
      );
    }

    markup.push(
      '<h3>Additional Information</h3>',
      '<ul>'
    );

    if (_this.isScenarioMode()) {
      markup.push('<li><a href="/scenarios/">Earthquake Scenarios</a></li>');
    } else {
      markup.push(
        '<li>',
          '<a href="/data/comcat/">',
            'ANSS Comprehensive Earthquake Catalog (ComCat) Documentation',
          '</a>',
        '</li>');
    }

    markup.push(
      '<li>',
        '<a href="/data/comcat/data-eventterms.php">',
          'Technical terms used on event pages',
        '</a>',
      '</li>',
      '</ul>');

    _this.footer.innerHTML = markup.join('');
  };

  /**
   * Render event page header content.
   *
   */
  _this.renderHeader = function () {
    // Event page header content is generated on server. Do not modify it here.
  };


  _initialize(options);
  options = null;
  return _this;
};

module.exports = EventPage;

},{"core/Attribution":"core/Attribution","core/CooperatorLogo":"core/CooperatorLogo","core/Formatter":"core/Formatter","core/NearbySeismicity":"core/NearbySeismicity","dyfi/DYFIFormModule":"dyfi/DYFIFormModule","dyfi/DYFIModule":"dyfi/DYFIModule","finite-fault/FiniteFaultModule":"finite-fault/FiniteFaultModule","focal-mechanism/FocalMechanismModule":"focal-mechanism/FocalMechanismModule","general/ExecutiveSummaryModule":"general/ExecutiveSummaryModule","general/RegionalInfoModule":"general/RegionalInfoModule","impact/ImpactSummaryModule":"impact/ImpactSummaryModule","losspager/PAGERModule":"losspager/PAGERModule","map/InteractiveMapModule":"map/InteractiveMapModule","moment-tensor/MomentTensorModule":"moment-tensor/MomentTensorModule","mvc/Model":"mvc/Model","oaf/OafModule":"oaf/OafModule","origin/OriginModule":"origin/OriginModule","pdl/CatalogEvent":"pdl/CatalogEvent","scientific/ScientificSummaryModule":"scientific/ScientificSummaryModule","shakemap/ShakeMapModule":"shakemap/ShakeMapModule","util/Events":"util/Events","util/Util":"util/Util","waveform/WaveformModule":"waveform/WaveformModule"}],"core/Formatter":[function(require,module,exports){
'use strict';

var Util = require('util/Util');


// default options
var _DEFAULTS = {
  // decimal places for depth
  depthDecimals: 1,
  // decimal places for distance
  distanceDecimals: 1,
  // content when a value is missing
  empty: '&ndash;',
  // size abbreviations for [bytes, kilobytes, megabytes, gigabytes]
  fileSizes: [' B', ' KB', ' MB', ' GB'],
  // decimal places for latitude/longitude
  locationDecimals: 3,
  // decimal places for magnitude
  magnitudeDecimals: 1
};


var _MILES_PER_KILOMETER = 0.621371;

var _MMI_ARRAY = ['I', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII',
    'IX', 'X', 'XI', 'XII'];

var _MMI_COLORS = [
  '#FFFFFF',  // I
  '#FFFFFF',  // I
  '#ACD8E9',  // II
  '#ACD8E9',  // III
  '#83D0DA',  // IV
  '#7BC87F',  // V
  '#F9F518',  // VI
  '#FAC611',  // VII
  '#FA8A11',  // VIII
  '#F7100C',  // IX
  '#C80F0A',  // X
  '#C80F0A',  // XI
  '#C80F0A'   // XII
];


/**
 * Construct a new Formatter.
 *
 * @param options {Object}
 *        formatter options.
 */
var Formatter = function (options) {
  var _this,
      _initialize,

      _depthDecimals,
      _distanceDecimals,
      _empty,
      _fileSizes,
      _locationDecimals,
      _magnitudeDecimals;

  _this = {};

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);

    _depthDecimals = options.depthDecimals;
    _distanceDecimals = options.distanceDecimals;
    _empty = options.empty;
    _fileSizes = options.fileSizes;
    _locationDecimals = options.locationDecimals;
    _magnitudeDecimals = options.magnitudeDecimals;
  };


  _this.angle = function (angle, decimals) {
    var value;

    if (!angle && angle !== 0) {
      return _empty;
    }

    if (typeof decimals === 'number') {
      value = Number(angle).toFixed(decimals);
    } else {
      value = Math.round(angle);
    }

    return value + '&deg;';
  };

  /**
   * Converts azimuth to a back azimuth (opposite direction).
   *
   * @param azimuth {Number}
   *    azimuth to format
   * @return {Number}
   *    formatted azimuth
   */
  _this.backAzimuth = function(azimuth) {
    if (azimuth >= 180) {
      azimuth = azimuth - 180;
    } else if (azimuth < 180) {
      azimuth = azimuth + 180;
    }

    return azimuth;
  };

  /**
   * Convert azimuth in degree's into compass points.
   * @param azimuth {number}
   *    azimuth to format
   * @return {String}
   *    compass direction
   */
  _this.compassWinds = function(azimuth) {
    var fullwind = 22.5,
        directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE',
            'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW', 'N'];

    // if direction is already in compass points
    if (directions.indexOf(azimuth) > -1) {
      return azimuth;
    }

    return directions[(Math.round((azimuth%360)/fullwind))];
  };

  /**
   * Format a UTC date.
   *
   * @param date {Date}
   *        date to format.
   * @return {String}
   *         formatted date.
   */
  _this.date = function (date) {
    var year,
        month,
        day;

    if (!date || typeof date.getTime !== 'function') {
      return _empty;
    }

    year = date.getUTCFullYear();
    month = date.getUTCMonth() + 1;
    day = date.getUTCDate();

    if (month < 10) {
      month = '0' + month;
    }
    if (day < 10) {
      day = '0' + day;
    }

    return year + '-' + month + '-' + day;
  };

  /**
   * Format a date and time.
   *
   * @param stamp {Date|Number}
   *        Date or millisecond epoch timstamp to format.
   * @param minutesOffset {Number}
   *        UTC offset in minutes.  0 for UTC.
   * @param includeMilliseconds {Boolean}
   *        default false.
   *        whether to output milliseconds.
   * @return {String}
   *         formatted date.
   */
  _this.datetime = function (stamp, minutesOffset, includeMilliseconds) {
    var milliOffset,
        date;

    if (!stamp && stamp !== 0) {
      return _empty;
    } else if (typeof stamp.getTime === 'function') {
      // allow Date objects
      stamp = stamp.getTime();
    }

    minutesOffset = minutesOffset || 0;
    milliOffset = minutesOffset * 60 * 1000;
    date = new Date(stamp + milliOffset);

    return _this.date(date) + ' ' + _this.time(date, includeMilliseconds) +
        ' (UTC' + _this.timezoneOffset(minutesOffset) + ')';
  };

  /**
   * Format a depth.
   *
   * @param depth {Number}
   *        depth to format
   * @param units {String}
   *        Optional.
   *        depth units, if any.
   * @param error {Number}
   *        Optional.
   *        depth error, if any.
   * @return {String} formatted string.
   */
  _this.depth = function (depth, units, error) {
    if (!depth && depth !== 0) {
      return _empty;
    }
    return _this.number(depth, _depthDecimals, _empty, units) +
        _this.uncertainty(error, _depthDecimals, '');
  };

  /**
   * Format a distance (like km or mi).
   *
   * @param distance {Number}
   *     The distance for format.
   * @param units {String}
   *     The units for this distance.
   *
   * @return {String}
   *     A formatted distance string.
   */
  _this.distance = function (distance, units) {
    return _this.number(distance, _distanceDecimals, _empty, units);
  };

  /**
   * Formats DYFI location
   *
   * @param {response}
   *        dyfi response
   *
   * @return {string}
   *         formatted DYFI location
   */
  _this.dyfiLocation = function (response) {
    var country,
        location,
        region,
        zip;

    country = response.country;
    location = response.name;
    region = response.state;
    zip = response.zip;

    return '<span class="dyfi-response-location">' + location + ', ' +
        region + '&nbsp;' + zip + '<br /><small>' + country + '</small></span>';
  };

  /**
   * Format file size using human friendly sizes.
   *
   * @param bytes {Number}
   *        bytes to format.
   * @return {String} formatted string.
   */
  _this.fileSize = function (bytes) {
    var sizeIndex;

    if (!bytes && bytes !== 0) {
      return _empty;
    }

    sizeIndex = 0;
    bytes = Number(bytes);
    while (bytes >= 1024) {
      bytes = bytes / 1024;
      sizeIndex++;
    }
    if (sizeIndex > 0) {
      bytes = bytes.toFixed(1);
    } else {
      bytes = bytes.toFixed(0);
    }
    return bytes + _fileSizes[sizeIndex];
  };

  /**
   * Format an intensity value.
   *
   * @param intensity {Number}
   *     numeric intensity value.
   * @param text {String}
   *     default ''.
   *     content added following the formatted intensity value.
   * @return {String}
   *     formatted intensity.
   */
  _this.intensity = function (intensity, text) {
    var romanNumeral;

    romanNumeral = _this.mmi(intensity);
    text = text || '';

    return '<span class="mmi mmi' + romanNumeral + '">' +
        '<span class="roman"><strong>' + romanNumeral + '</strong></span>' +
        text +
        '</span>';
  };

  /**
   * Convert kilometers to miles.
   *
   * @param km {Number}
   *        kilometers.
   * @return {Number}
   *         miles.
   */
  _this.kmToMi = function (km) {
    if (!km) {
      return km;
    }
    return (km * _MILES_PER_KILOMETER);
  };

  /**
   * Format a latitude
   * @param latitude {Number}
   *        the latitude.
   * @return {String} formatted string.
   */
  _this.latitude = function (latitude) {
    var latDir;

    if (!latitude && latitude !== 0) {
      return _empty;
    }
    latDir = (latitude >= 0 ? 'N' : 'S');

    // already have sign information, abs before rounding
    latitude = Math.abs(latitude);

    // round to configured number of decimals
    if (typeof _locationDecimals === 'number') {
      latitude = latitude.toFixed(_locationDecimals);
    }

    return latitude + '&deg;' + latDir;
  };

  /**
   * Left pads the source string with the pad string until the source string
   * is at least `length` in length. If the source length is already greater
   * than or equal to the desired length, the original source is returned.
   *
   * @param source {String}
   *     The string to pad
   * @param length {Integer}
   *     The desired length
   * @param pad {String} Optional. Default ' ' (single space)
   *     The padding to add to the beginning of the source string until the
   *     desired length is met. Should be a single rendered character.
   *
   * @return {String}
   *     A string padded out to the desired length with the given pad.
   */
  _this.leftPad = function (source, length, pad) {
    var i,
        padLength,
        padding;

    padLength = length - source.length;
    padding = [];

    if (padLength < 1) {
      return source;
    }

    for (i = 0; i < padLength; i++) {
      padding[i] = pad;
    }


    return padding.join('') + source;
  };

  /**
   * Format a latitude and longitude.
   *
   * @param latitude {Number}
   *        the latitude.
   * @param longitude {Number}
   *        the longitude.
   * @return {String} formatted string.
   */
  _this.location = function (latitude, longitude) {
    return _this.latitude(latitude) + '&nbsp;' +
        _this.longitude(longitude);
  };

  /**
   * Format a longitude
   * @param longitude {Number}
   *        the longitude.
   * @return {String} formatted string.
   */
  _this.longitude = function (longitude) {
    var lonDir;

    if (!longitude && longitude !== 0) {
      return _empty;
    }
    lonDir = (longitude >= 0 ? 'E' : 'W');

    // already have sign information, abs before rounding
    longitude = Math.abs(longitude);

    // round to configured number of decimals
    if (typeof _locationDecimals === 'number') {
      longitude = longitude.toFixed(_locationDecimals);
    }

    return longitude + '&deg;' + lonDir;
  };

  /**
   * Format a magnitude.
   *
   * @param magnitude {Number}
   *        magnitude to format.
   * @param type {String}
   *        Optional.
   *        magnitude type.
   * @param error {Number}
   *        Optional.
   *        magnitude error.
   * @return {String} formatted string.
   */
  _this.magnitude = function (magnitude, type, error) {
    return _this.number(magnitude, _magnitudeDecimals, _empty, type) +
        _this.uncertainty(error, _magnitudeDecimals, '');
  };

  /**
   * Translate mmi to a roman numeral
   *
   * @params mmi {number}
   *         Modified Mercal Intensity
   * @params empty {string}
   *         The string to return if mmi is out of range
   *
   * @returns {string}
   *          The Roman Numeral cooresponding to the mmi.
   */
  _this.mmi = function (mmi, empty) {
    mmi = Math.round(mmi);

    return _MMI_ARRAY[mmi] || empty || _empty;
  };

  /**
   * Get the color associated with a given MMI
   *
   * @params mmi {number}
   *    Modified Mercal Intensity.
   * @return {string}
   *    Color Code.
   */
  _this.mmiColor = function (mmi) {
    mmi = Math.round(mmi);
    return _MMI_COLORS[mmi] || null;
  };

  /**
   * Format a number.
   *
   * @param value {Number}
   *        number to format.
   * @param decimals {Number}
   *        Optional, default does not round.
   *        number of decimal places to round.
   * @param empty {Any}
   *        Optional, default none.
   *        value to return if value is empty.
   * @param units {String}
   *        Optional, default none.
   *        units of value.
   * @return {String} formatted string.
   */
  _this.number = function (value, decimals, empty, units) {
    if (!value && value !== 0) {
      return empty || _empty;
    }
    if (typeof decimals === 'number') {
      value = Number(value).toFixed(decimals);
    }
    if (units) {
      value += ' ' + units;
    }
    return value;
  };

  /**
   * Put commas into a number for display.
   *
   * @param x {Number}
   *        number to format.
   *
   * @param empty {Any}
   *        Optional, default none.
   *        value to return if value is empty.
   */
  _this.numberWithCommas = function (x, empty) {
    if (!x && x !== 0) {
      return empty || _empty;
    }

    var parts = x.toString().split('.');

    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');

    return parts.join('.');
  };

  /**
   * Format a UTC time.
   *
   * @param date {Date}
   *        date to format.
   * @param includeMilliseconds {Boolean}
   *        default false.
   *        whether to output milliseconds.
   * @return {String}
   *         formatted time.
   */
  _this.time = function (date, includeMilliseconds) {
    var hours,
        minutes,
        seconds,
        milliseconds;

    if (!date || typeof date.getTime !== 'function') {
      return _empty;
    }

    hours = date.getUTCHours();
    minutes = date.getUTCMinutes();
    seconds = date.getUTCSeconds();
    milliseconds = '';

    if (hours < 10) {
      hours = '0' + hours;
    }
    if (minutes < 10) {
      minutes = '0' + minutes;
    }
    if (seconds < 10) {
      seconds = '0' + seconds;
    }
    if (includeMilliseconds) {
      milliseconds = date.getUTCMilliseconds();
      if (milliseconds < 10) {
        milliseconds = '.00' + milliseconds;
      } else if (milliseconds < 100) {
        milliseconds = '.0' + milliseconds;
      } else {
        milliseconds = '.' + milliseconds;
      }
    }

    return hours + ':' + minutes + ':' + seconds + milliseconds;
  };

  /**
   * Format a UTC timezone offset.
   *
   * @param offset {Number}
   *        UTC offset in minutes.  0 for UTC.
   * @return {String}
   *         formatted timezone offset, or '' when offset is 0.
   */
  _this.timezoneOffset = function (offset) {
    var hours,
        minutes,
        sign;

    if (!offset || offset === 0) {
      return '';
    } else if (offset < 0) {
      sign = '-';
      offset *= -1;
    } else {
      sign = '+';
    }

    hours = parseInt(offset / 60, 10);
    minutes = parseInt(offset % 60, 10);

    if (hours < 10) {
      hours = '0' + hours;
    }
    if (minutes < 10) {
      minutes = '0' + minutes;
    }

    return sign + hours + ':' + minutes;
  };

  /**
   * Format an uncertainty.
   *
   * @param error {Number}
   *        uncertainty to format.
   * @param decimals {Number}
   *        Optional, default does not round.
   *        number of decimal places to round.
   * @param empty {Any}
   *        Optional, default none.
   *        value to return if error is empty.
   * @param units {String}
   *        Optional, default none.
   *        units of error.
   * @return {String} formatted string.
   */
  _this.uncertainty = function (error, decimals, empty, units) {
    if (!error && error !== 0) {
      return empty;
    }
    error = _this.number(error, decimals, null, units);
    return '<span class="uncertainty">&plusmn; ' + error + '</span>';
  };


  _initialize(options);
  options = null;
  return _this;
};


Formatter.MILES_PER_KILOMETER = _MILES_PER_KILOMETER;


module.exports = Formatter;

},{"util/Util":"util/Util"}],"core/LinkProductView":[function(require,module,exports){
'use strict';

var ProductView = require('core/ProductView'),
    Util = require('util/Util');


/**
 * View to display a link product.
 *
 * Uses product properties `text` and `url`.
 *
 * @param options {Object}
 *     passed to ProductView.
 */
var LinkProductView = function (options) {
  var _this;

  _this = ProductView(options);


  /**
   * Render link into this view's element.
   */
  _this.render = function () {
    var el,
        product,
        text,
        url;

    product = _this.model;
    text = product.getProperty('text');
    url = product.getProperty('url');

    if (url) {
      el = document.createElement('a');
      el.setAttribute('href', url);
    } else {
      el = document.createElement('span');
    }
    el.classList.add(product.get('type'));

    if (text) {
      el.innerHTML = text;
    } else {
      el.innerHTML = 'No link text available';
    }

    Util.empty(_this.el);
    _this.el.appendChild(el);
  };


  return _this;
};


module.exports = LinkProductView;

},{"core/ProductView":"core/ProductView","util/Util":"util/Util"}],"core/Module":[function(require,module,exports){
'use strict';

var AccordionView = require('core/AccordionView'),
    Attribution = require('core/Attribution'),
    DownloadView = require('core/DownloadView'),
    Formatter = require('core/Formatter'),
    Product = require('pdl/Product'),
    Util = require('util/Util'),
    View = require('mvc/View');

var _ID,
    _TITLE,
    _TYPES,

    _hasContent;


// Note: These should be overridden by each implementing sub-class.
_ID = 'module';
_TITLE = 'Default Module';
_TYPES = [];

_hasContent = function (/*eventPageModel*/) {
  return true;
};

var _DEFAULTS = {

};


var Module = function (options) {
  var _this,
      _initialize,

      _accordionView,
      _formatter;


  options = Util.extend({}, _DEFAULTS, options);
  _this = View(options);

  _initialize = function (options) {
    var el;

    _this.ID = _ID;
    _this.TITLE = _TITLE;
    _formatter = options.formatter || Formatter();

    el = _this.el;
    el.innerHTML =
      '<div class="module-header"></div>' +
      '<div class="module-content"></div>' +
      '<div class="module-footer"></div>';

    // references to sections for subclass access
    _this.header = el.querySelector('.module-header');
    _this.content = el.querySelector('.module-content');
    _this.footer = el.querySelector('.module-footer');
  };

  /**
   * Free references.
   */
  _this.destroy = Util.compose(function () {
    if (_accordionView) {
      // clean up any previous footer
      _accordionView.destroy();
      _accordionView = null;
    }

    _formatter = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Get a product from the event based on module parameters and event config.
   *
   * Uses module parameters "source", "code", and optionally "updateTime".
   * If "updateTime" is omitted, the latest version from "source" and "code" is
   * returned.  If no product matching "source" and "code" is found, returns
   * preferred product.
   *
   * @param type {String}
   *     product base type.
   *     event configuration determines whether or not to add a scenario suffix.
   * @return {Product}
   *     matching product, or null if not found.
   */
  _this.getProduct = function (type) {
    var code,
        ev,
        params,
        product,
        source,
        updateTime;

    ev = _this.model.get('event');
    params = _this.model.get(_this.ID) || {};
    type = Product.getFullType(type, _this.model.get('config'));
    source = params.source || null;
    code = params.code || null;
    updateTime = params.updateTime || null;
    product = null;

    if (ev && source !== null && code !== null) {
      product = ev.getProductById(type, source, code, updateTime);
    }
    if (ev && product === null) {
      product = ev.getPreferredProduct(type);
    }
    return product;
  };

  /**
   * Get all products of a specific type. If the config.SCENARIO_MODE, then
   * get the -scenario variant of the specified type.
   *
   * @param type {String}
   *     The base type of products to get.
   *
   * @return {Array}
   *     An array of the matching type of product. This might be an empty array.
   */
  _this.getProducts = function (type) {
    var catalogEvent;

    catalogEvent = _this.model.get('event');
    type = Product.getFullType(type, _this.model.get('config'));

    if (catalogEvent) {
      return catalogEvent.getProducts(type);
    } else {
      return [];
    }
  };

  /**
   * Get a product footer. Generalized footer includes only the Downloads.
   *
   */
  _this.getProductFooter = function (options) {
    var content,
        el;

    if (_accordionView) {
      // clean up any previous footer
      _accordionView.destroy();
      _accordionView = null;
    }

    content = options.product.getContent('contents.xml');
    if (content) {
      el = document.createElement('div');

      _this.downloadView = DownloadView({
        model: content,
        product: options.product,
        formatter: _formatter
      });

      _accordionView = AccordionView({
        classes: 'accordion-standard accordion-page-downloads',
        el: el,
        toggleElement: 'h3',
        toggleText: 'Downloads',
        view: _this.downloadView
      });
      _accordionView.render();
    }

    return el;
  };

  /**
   * Get a product header.
   *
   * @param options {Object}
   * @param options.product {Product}
   *     product to summarize.
   * @param options.summaryModule {Module}
   *     default null.
   *     include link to module with all versions of `product`.
   */
  _this.getProductHeader = function (options) {
    var buf,
        el,
        ev,
        numProducts,
        preferred,
        product,
        reviewed,
        type,
        summaryModule;

    product = options.product;
    summaryModule = options.summaryModule;

    buf = [];
    ev = _this.model.get('event');
    type = options.type || product.get('type');
    // can't use var type because it breaks the prefered setting when it uses
    // options.type
    preferred = (ev.getPreferredProduct(product.get('type')) === product);
    reviewed = product.isReviewed();

    if (summaryModule) {
      numProducts = ev.getProducts(type).length;
      buf.push('<a class="back-to-summary-link"' +
          ' href="#'  + summaryModule.ID + '">');
      if (numProducts > 1) {
        buf.push('View alternative ' + _this.TITLE.toLowerCase() + 's' +
            ' (' + numProducts + ' total)');
      } else {
        buf.push('Back to ' + summaryModule.TITLE);
      }
      buf.push('</a>');
    }

    buf.push('<small class="attribution">' +
        'Contributed by ' + Attribution.getProductAttribution(product) +
        ' last updated ' + _formatter.datetime(product.get('updateTime')) +
        '</small>');

    buf.push('<ul class="quality-statements no-style">');
    if (preferred) {
      buf.push('<li class="preferred">' +
          'The data below are the most preferred data available' +
          '</li>');
    } else {
      buf.push('<li class="unpreferred">' +
          'The data below are <strong>NOT</strong>' +
          ' the most preferred data available' +
          '</li>');
    }
    if (reviewed === true) {
      buf.push('<li class="reviewed">' +
          'The data below have been reviewed by a scientist' +
          '</li>');
    } else if (reviewed === false) {
      // only claim product is unreviewed if review-status property was set.
      buf.push('<li class="unreviewed">' +
          'The data below have <strong>NOT</strong>' +
          ' been reviewed by a scientist.' +
          '</li>');
    }
    buf.push('</ul>');

    el = document.createElement('div');
    el.classList.add('product-header');
    el.innerHTML = buf.join('');
    return el;
  };

  /**
   * Render module content.
   */
  _this.render = function () {
    _this.header.innerHTML = '<h3>Module Header</h3>';
    _this.content.innerHTML = '<h3>Module Content</h3>';
    _this.footer.innerHTML = '<h3>Module Footer</h3>';
  };


  _initialize(options);
  options = null;
  return _this;
};


Module.ID = _ID;
Module.TITLE = _TITLE;
Module.TYPES = _TYPES;

Module.hasContent = _hasContent;


module.exports = Module;

},{"core/AccordionView":"core/AccordionView","core/Attribution":"core/Attribution","core/DownloadView":"core/DownloadView","core/Formatter":"core/Formatter","mvc/View":"mvc/View","pdl/Product":"pdl/Product","util/Util":"util/Util"}],"core/NearbySeismicity":[function(require,module,exports){
'use strict';


var Util = require('util/Util');


var _DEFAULTS = {
  mapUrl: '/earthquakes/map/',
  radius: 250
};

var _KM_PER_DEGREE = 111.12;


var NearbySeismicity = function (options) {
  var _this,
      _initialize,

      _mapUrl,
      _radius;


  _this = {};

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);

    _mapUrl = options.mapUrl;
    _radius = options.radius;
  };


  _this.destroy = function () {
    _mapUrl = null;
    _radius = null;

    _initialize = null;
    _this = null;
  };

  /**
   * Generate a link to map/list based on search parameters.
   * @param options {Object}
   * @param options.eventid {String}
   *     event to select in map/list interface.
   *     default null.
   * @param options.params {Object}
   *     api parameters as object properties and values.
   */
  _this.getLatestEarthquakesLink = function (options) {
    var eventid,
        id,
        mapPosition,
        params,
        settings,
        url;

    eventid = options.eventid || null;
    params = options.params;

    id = eventid || ('' + new Date().getTime());
    mapPosition = _this.getMapPosition(params);

    // map/list url settings
    settings = {
      // do not auto update searches
      autoUpdate: false,
      // terrain basemap
      basemap: 'terrain',
      // selected event
      event: eventid,
      // feed needs to match search id
      feed: id,
      // center view based on point and radius
      mapposition: mapPosition,
      // search options
      search: {
        id: id,
        isSearch: true,
        // TODO: use a different name?
        name: 'Search Results',
        params: params
      }
    };

    url = _mapUrl + '#' + encodeURIComponent(JSON.stringify(settings));

    return url;
  };

  /**
   * Compute map position based on parameters.
   *
   * @param params {Object}
   *     search api parameters.
   * @return {Array<Array>}
   *     array representing map extent.
   */
  _this.getMapPosition = function (params) {
    var latitude,
        longitude,
        mapPosition,
        maxLatitude,
        maxLongitude,
        maxRadiusKm,
        minLatitude,
        minLongitude,
        radiusDegrees;

    // set defaults
    maxLatitude = params.maxlatitude || 85;
    maxLongitude = params.maxlongitude || 180;
    minLatitude = params.minlatitude || -85;
    minLongitude = params.minlongitude || -180;

    // compute based on radius search
    latitude = params.latitude;
    longitude = params.longitude;
    maxRadiusKm = params.maxradiuskm;
    if ((latitude || latitude === 0) &&
        (longitude || longitude === 0) &&
        (maxRadiusKm || maxRadiusKm === 0)) {
      radiusDegrees = maxRadiusKm / _KM_PER_DEGREE;
      maxLatitude = latitude + radiusDegrees;
      maxLongitude = longitude + radiusDegrees;
      minLatitude = latitude - radiusDegrees;
      minLongitude = longitude - radiusDegrees;
    }

    // format extent
    mapPosition = [
      [minLatitude, minLongitude],
      [maxLatitude, maxLongitude]
    ];

    return mapPosition;
  };

  /**
   * Convenience method that chains
   * getLatestEarthquakesLink with getNearbySeismicityParams.
   *
   * @param summary {Object}
   *     event summary object, as returned by CatalogEvent#getSummary().
   * @return {String}
   *     url to display nearby seismicity in map/list.
   */
  _this.getNearbySeismicityLink = function (summary) {
    var params;

    params = _this.getNearbySeismicityParams(summary);
    return _this.getLatestEarthquakesLink({
      eventid: summary.id,
      params: params
    });
  };

  /**
   * Get nearby seismicity API search parameters for an event.
   *
   * @param summary {Object}
   *     event summary object, as returned by CatalogEvent#getSummary().
   * @return {Object}
   *     object with search parameters
   */
  _this.getNearbySeismicityParams = function (summary) {
    var endtime,
        latitude,
        longitude,
        magnitude,
        minmagnitude,
        params,
        threeWeeks,
        starttime,
        time;

    latitude = summary.latitude;
    longitude = summary.longitude;
    magnitude = summary.magnitude;
    time = summary.time;

    if (!latitude || !longitude || !time) {
      return false;
    }

    minmagnitude = 1;
    if (magnitude !== null) {
      minmagnitude = Math.max(Math.floor(magnitude) - 3, 1);
    }

    threeWeeks = 3 * 7 * 24 * 60 * 60 * 1000;
    time = new Date(time).getTime();
    starttime = new Date(time - threeWeeks).toISOString();
    endtime = new Date(time + threeWeeks).toISOString();

    params = {
      endtime: endtime,
      latitude: latitude,
      longitude: longitude,
      maxradiuskm: _radius,
      minmagnitude: minmagnitude,
      starttime: starttime
    };

    return params;
  };


  _initialize(options);
  options = null;
  return _this;
};


NearbySeismicity.KM_PER_DEGREE = _KM_PER_DEGREE;


module.exports = NearbySeismicity;

},{"util/Util":"util/Util"}],"core/ProductView":[function(require,module,exports){
'use strict';

var Product = require('pdl/Product'),
    View = require('mvc/View');


/**
 * View for a specific Product.
 *
 * @param options {Object}
 *     all options are passed to mvc/View.
 */
var ProductView = function (options) {
  var _this;

  // Make sure the model used for this view is a pdl/Product
  options = options || {};
  options.model = options.model || Product();

  _this = View(options);

  options = null;
  return _this;
};


module.exports = ProductView;

},{"mvc/View":"mvc/View","pdl/Product":"pdl/Product"}],"core/SummaryModule":[function(require,module,exports){
'use strict';


var LinkProductView = require('core/LinkProductView'),
    Module = require('core/Module'),
    Product = require('pdl/Product'),
    TextProductView = require('core/TextProductView'),
    Util = require('util/Util');


var _DEFAULTS = {

};


/**
 * Abstract module to serve as an extension point for summary-level modules.
 *
 */
var SummaryModule = function (options) {
  var _this,
      _initialize;


  options = Util.extend({}, _DEFAULTS, options);
  _this = Module(options);

  _initialize = function (/*options*/) {
    _this.clearLinks(true);
    _this.clearTexts(true);
  };


  /**
   * Destroys the views in the given views array and potentially re-initializes
   * the views array to an empty array.
   *
   * @param views {Array}
   *     An array of views to clear.
   */
  _this.clearViews = function (views) {
    if (views) {
      views.forEach(function (view) {
        view.destroy();
      });
    }
  };

  /**
   * Clears the views associated with link products.
   *
   * @param init {Boolean} Optional. Default false.
   *     Flag whether to re-initialize the views array. By default the views
   *     array is set to null, if true, initializes views array to empty array.
   *
   * @see #_this.clearViews
   */
  _this.clearLinks = function (init) {
    _this.clearViews(_this.linkViews);

    if (init) {
      _this.linkViews = [];
    } else {
      _this.linkViews = null;
    }
  };

  /**
   * Clears the views associated with text products.
   *
   * @param init {Boolean} Optional. Default false.
   *     Flag whether to re-initialize the views array. By default the views
   *     array is set to null, if true, initializes views array to empty array.
   *
   * @see #_this.clearViews
   */
  _this.clearTexts = function (init) {
    _this.clearViews(_this.textViews, init);

    if (init) {
      _this.textViews = [];
    } else {
      _this.textViews = null;
    }
  };

  /**
   * Helper method for creating a simple TR DOM element potentially with a
   * "preferred" class on it.
   *
   * @param preferred {Boolean}
   *     True if the "preferred" class should be added. False otherwise.
   *
   * @return {DOMElement}
   *     A TR DOM Element.
   */
  _this.createRow = function (preferred) {
    var row;

    row = document.createElement('tr');

    if (preferred) {
      row.classList.add('preferred');
    }

    return row;
  };

  /**
   * Helper method for creating a summary section for a type of product.
   *
   * @param products {Array}
   *     An array of {Product}s to summarize.
   * @param title {String}
   *     The header text to label this summary section.
   * @param labels {Array}
   *     An array of {String}s to use a column header text.
   * @param callback {Function}
   *     A callback function to execute for each product. This callback function
   *     should return a TR DOM element. The callback function expects a
   *     {Product} as its first parameter and an index {Number} as it's second
   *     parameter.
   *
   * @return {DocumentFragment}
   *     A document fragment containing the section summary, this could be
   *     empty if no products or labels are provided.
   */
  _this.createSummary = function (products, title, labels, callback) {
    var fragment,
        header,
        table,
        tbody,
        thead,
        wrapper;

    fragment = document.createDocumentFragment();

    if (products.length && labels.length) {
      header = fragment.appendChild(document.createElement('h3'));
      wrapper = fragment.appendChild(document.createElement('div'));
      table = wrapper.appendChild(document.createElement('table'));
      thead = table.appendChild(document.createElement('thead'));
      tbody = table.appendChild(document.createElement('tbody'));

      header.innerHTML = title;

      wrapper.classList.add('horizontal-scrolling');
      table.classList.add('table-summary');

      thead.innerHTML = '<tr><th scope="col">' +
          labels.join('</th><th scope="col">') + '</th></tr>';

      tbody.appendChild(products.reduce(function (fragment, product, index) {
        fragment.appendChild(callback(product, index));
        return fragment;
      }, document.createDocumentFragment()));
    }

    return fragment;
  };

  /**
   * Free resources associated with this module.
   *
   */
  _this.destroy = Util.compose(function () {
    if (_this === null) {
      return; // Already destroyed
    }

    _this.clearLinks();
    _this.clearTexts();

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Generates markup for a catalog column in the summary table. This includes
   * a link to the product details page as well as a preferred checkbox if
   * appropriate.
   *
   * @param module {Module}
   *     The module for which to generate the link.
   * @param product {Product}
   *     The product for which to generate the link.
   * @param preferred {Boolean}
   *     True if the current product is preferred, false otherwise.
   *
   * @return {String}
   *     The markup for the link to the product details page.
   */
  _this.getCatalogMarkup = function (module, product, preferred) {
    var markup,
        type;

    markup = [];
    type = Product.getBaseType(product.get('type'));

    if (preferred) {
      markup.push('<abbr title="Preferred ' + type +
        '" class="material-icons">check</abbr>');
    }

    markup.push('<a href="#' + module.ID + '?source=' + product.get('source') +
        '&amp;code=' + product.get('code') + '">' +
      (product.getProperty('eventsource') || 'N/A').toUpperCase() +
    '</a>');

    return markup.join('');
  };

  /**
   * Creates visualization for link products. Delegates to the
   * {LinkProductView}.
   *
   * @param products {Array}
   *     An array of products to generate visualizations for.
   *
   * @return {DocumentFragment}
   *     A fragment containing the markup for each text product.
   */
  _this.getLinks = function (products) {
    var fragment,
        list;

    fragment = document.createDocumentFragment();

    if (products.length) {
      fragment.appendChild(_this.getLinksHeader());
      list = fragment.appendChild(document.createElement('ul'));

      products.forEach(function (product) {
        var view;

        view = LinkProductView({
          el: list.appendChild(document.createElement('li')),
          model: product
        });
        view.render();

        _this.linkViews.push(view);
      });
    }

    return fragment;
  };

  /**
   * APIMethod.
   *
   * Implementing classes should override this method.
   *
   * @return {DOMElement}
   *     A header to label the links section for this {SummaryModule}. If no
   *     header is desired, return an empty {DocumentFragment}.
   */
  _this.getLinksHeader = function () {
    var header;

    header = document.createElement('h3');
    header.innerHTML = 'Related Links';

    return header;
  };

  /**
   * Creates visualization for text products. Delegates to the
   * {TextProductView}.
   *
   * @param products {Array}
   *     An array of products to generate visualizations for.
   *
   * @return {DocumentFragment}
   *     A fragment containing the markup for each text product.
   */
  _this.getTexts = function (products) {
    var fragment;

    fragment = document.createDocumentFragment();

    products.forEach(function (product) {
      var view;

      view = TextProductView({
        el: fragment.appendChild(document.createElement('div')),
        model: product
      });
      view.render();

      _this.textViews.push(view);
    });

    return fragment;
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = SummaryModule;

},{"core/LinkProductView":"core/LinkProductView","core/Module":"core/Module","core/TextProductView":"core/TextProductView","pdl/Product":"pdl/Product","util/Util":"util/Util"}],"core/TextProductView":[function(require,module,exports){
'use strict';

var ContentView = require('core/ContentView'),
    ProductView = require('core/ProductView'),
    Util = require('util/Util');


var _DEFAULTS = {
  contentPath: ''
};


var TextProductView = function (options) {
  var _this,
      _initialize,

      _content,
      _contentView;


  options = Util.extend({}, _DEFAULTS, options);
  _this = ProductView(options);

  /**
   * Constructor
   *
   * Initializes the view. Checks the configured `contentPath` (empty string
   * by default). If it exists, creates a {ContentView} to which future
   * rendering is delegated.
   *
   * @param options {Object}
   *     Confiuguration options for this view. In addition to options specified
   *     in {ProductView}, this may include the following:
   *
   * @param options.contentPath {String} Optional. Default ''.
   *     The path for the content to render for this TextProductView.
   *
   * @see mvc/View
   */
  _initialize = function (options) {
    _this.el.classList.add(_this.model.get('type'));
    _this.el.classList.add('text-product');

    _content = _this.model.getContent(options.contentPath);

    if (_content) {
      _contentView = ContentView({
        el: _this.el,
        model: _content
      });

      _contentView.onSuccess = _this.onSuccess;
      _contentView.onError = _this.onError;
    }
  };


  /**
   * Frees resources associated with this view. In particular, if a
   * {ContentView} was created, it is destroyed.
   *
   */
  _this.destroy = Util.compose(function () {
    if (_contentView) {
      _contentView.destroy();
    }

    _content = null;
    _contentView = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Callback method if the content fails to fetch its data. Displays a
   * basic error message.
   *
   */
  _this.onError = function () {
    _this.el.innerHTML =
        '<p class="alert error">No text content to render.</p>';
  };

  /**
   * Callback method when the content successfully fetches its data. Displays
   * the result in `_this.el` but replaces paths to relative resources based
   * on other content in `_this.model`.
   *
   * @param data {String}
   *     The data to render.
   */
  _this.onSuccess = function (data) {
    _this.el.innerHTML = _this.replaceRelativePaths(data,
        _this.model.get('contents').data());
  };

  /**
   * If {Content} was found during initialization, delegates to the created
   * {ContentView}, otherwise displays the stock error message.
   *
   * @see ContentView#render
   * @see TextProductView#onError
   */
  _this.render = function () {
    _this.el.innerHTML = '<p class="alert info">Loading content&hellip;</p>';
    if (_contentView) {
      _contentView.render();
    } else {
      _this.onError();
    }
  };

  /**
   * Replace relative paths in text products with fully qualified URLs
   * based on the URLs found in the product's content collection
   *
   * @param bytes {String}
   *    byte data from the text product contents
   *
   * @param contents {Array}
   *    array of content objects to check for relative paths that exist
   *    in the bytes data
   */
  _this.replaceRelativePaths = function (bytes, contents) {
    var content,
        i,
        len;

    len = contents.length;

    for (i = 0; i < len; i++) {
      content = contents[i].get();
      if (content.id !== '') {
        bytes = bytes.replace(new RegExp('"' + content.id + '"', 'g'),
            '"' + content.url + '"');
      }
    }

    return bytes;
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = TextProductView;

},{"core/ContentView":"core/ContentView","core/ProductView":"core/ProductView","util/Util":"util/Util"}],"dyfi/DYFIFormModule":[function(require,module,exports){
'use strict';


var DYFIFormView = require('dyfi/DYFIFormView'),
    Events = require('util/Events'),
    ModalView = require('mvc/ModalView'),
    Model = require('mvc/Model'),
    Module = require('core/Module'),
    Util = require('util/Util'),
    Xhr = require('util/Xhr');


var _ID,
    _TITLE,
    _hasContent,
    _parseMessageAsHtml,
    _parseMessageAsString;

_ID = 'tellus';
_TITLE = 'Felt Report - Tell Us!';


/**
 * Helper method to parse a raw response using HTML DOM manipulation. This
 * is the most reliable parsing method, but may not be as supported across
 * browsers.
 *
 * @param response {String}
 *     An HTML string from which to parse a response.
 *
 * @return {String}
 *     The parsed message.
 *
 * @throws {Error}
 *     If the response does not represent valid HTML. Of if the response does
 *     not include a description list tag (<dl>).
 */
_parseMessageAsHtml = function (response) {
  var h;

  h = document.createElement('html');
  h.innerHTML = response;

  return h.querySelector('dl').outerHTML;
};

/**
 * Helper method to parse a raw response using String manipulation. This is a
 * fallback approach when DOM parsing fails.
 *
 * @param response {String}
 *     An HTML string from which to parse a response.
 *
 * @return {String}
 *     The parsed message or null if no message is found.
 */
_parseMessageAsString = function (response) {
  var endIdx,
      startIdx;

  startIdx = response.indexOf('<dl>');
  endIdx = response.indexOf('</dl>');

  if (startIdx === -1 || endIdx === -1) {
    return null;
  }

  return response.substring(startIdx, endIdx) + '</dl>';
};

/**
 * Determines if this module has content. Scenario events do will not
 * get this module.
 *
 * @param eventPageModel
 *     The model use by the {EventPage} class.
 *
 * @return {Boolean}
 *     True if the module should be included. False otherwise.
 */
_hasContent = function (eventPageModel) {
  var config;

  config = eventPageModel.get('config');

  return config.hasOwnProperty('SCENARIO_MODE') ?
    (!config.SCENARIO_MODE) : true;
};

var _DEFAULTS = {
  DYFI_RESPONSE_URL: '/products/dyfi/response.html',
  FORM_VERSION: '1.5'
};


/**
 * Module for displaying the {DYFIFormView}. This module handles the modal
 * dialog in which the view is rendered. It communicates with the view through
 * the model provided to the view in order to get the form values when the
 * submit button is clicked. This module deals with form submission while the
 * view itself deals with user inputs.
 *
 * @param options {Object}
 *     Configuration options for this module. See _initialize method
 *     documentation for details.
 */
var DYFIFormModule = function (options) {
  var _this,
      _initialize,

      _formModel,
      _formVersion,
      _modal,
      _submitButton,
      _submitResult,
      _submitUrl,
      _view;


  options = Util.extend({}, _DEFAULTS, options);
  _this = Module(options);

  /**
   * Constructor. Initializes a new DYFIModule.
   *
   * @param options {Object}
   *     Configuration options for this module. In addition to what can be
   *     provided a generic module, these may also include:
   * @param options.FORM_VERSION {String}
   *     A version string identifier for this form.
   */
  _initialize = function (options) {
    var catalogEvent,
        config,
        eventTimestamp;

    _this.ID = _ID;
    _this.TITLE = _TITLE;

    config = _this.model.get('config');
    _submitUrl = (config && config.DYFI_RESPONSE_URL) ?
        config.DYFI_RESPONSE_URL : options.DYFI_RESPONSE_URL;
    _submitResult = null;

    _formVersion = options.FORM_VERSION;

    _this.content.addEventListener('click', _this.onContentClick);

    catalogEvent = _this.model.get('event');

    if (catalogEvent) {
      eventTimestamp = catalogEvent.getTime();
    }

    _formModel = Model({
      eventTime: eventTimestamp ? eventTimestamp.toUTCString() : '',
      language: 'en'
      // TODO :: Also include eventid in some way?
    });

    _formModel.on('change', 'onFormChange', _this);

    _view = DYFIFormView({
      model: _formModel
    });
    _view.render();

    _modal = ModalView(_view.el, {
      buttons: [
        {
          callback: _this.onSubmit,
          classes: ['green', 'dyfi-submit-button'],
          text: 'Submit'
        },
        {
          callback: _this.onCancel,
          classes: ['dyfi-cancel-button'],
          text: 'Cancel'
        }
      ],
      title: null // No title. View should render title and OMB number.
    });
  };


  /**
   * Frees resources associated with this module.
   *
   */
  _this.destroy = Util.compose(function () {
    _this.content.removeEventListener('click', _this.onContentClick);
    _formModel.off('change', 'onFormChange', _this);

    _modal.hide();
    _modal.destroy();
    _view.destroy(); // NB: Destroy view before destroying model
    _formModel.destroy();

    _formModel = null;
    _formVersion = null;
    _modal = null;
    _submitResult = null;
    _submitUrl = null;
    _view = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Callback when user clicks the cancel button. Form is hidden and browser
   * is navigated back to some other event page content.
   *
   */
  _this.onCancel = function () {
    _modal.hide();

    // Notify the EventPage this view would like to go back
    Events.trigger('back');
  };

  /**
   * Callback to handel re-showing the form when a button is clicked on the
   * page in the background.
   *
   * @param evt {Event}
   *     The event that triggered this callback.
   */
  _this.onContentClick = function (evt) {
    if (evt.target && evt.target.classList.contains('show-form')) {
      _this.showForm();
    }
  };

  /**
   * Callback when the _formModel is changed. Checks to see if required
   * fields are complete and if so, enables submit button; otherwise disables
   * the button.
   *
   */
  _this.onFormChange = function () {
    if (_submitButton) {
      if (!_formModel.get('ciim_mapLat') ||
          !_formModel.get('ciim_mapLon') ||
          !_formModel.get('ciim_time') ||
          !_formModel.get('fldSituation_felt')) {
        // A required field is missing, disable submit button
        _submitButton.setAttribute('disabled', 'disabled');
      } else {
        _submitButton.removeAttribute('disabled');
      }
    }
  };

  /**
   * Callback when the submit button is clicked on the form. This method
   * augments the form data with some internally required information, then
   * submits the request using AJAX via CORS.
   *
   */
  _this.onSubmit = function () {
    var data,
        ev;

    _submitResult = null;

    ev = _this.model.get('event');

    data = Util.extend({
      eventid: ev ? ev.getEventId() : null,
      form_version: _formVersion,
      ciim_report: 'Submit Form'
    }, _formModel.get());

    Xhr.ajax({
      method: 'POST',
      data: data,
      error: _this.onSubmitError,
      url: _submitUrl,
      success: _this.onSubmitSuccess
    });

    _modal.hide();
  };

  /**
   * Callback when the submit Xhr fails. Note, this is only executed if an
   * HTTP status code accompanies the response. Updates the result object and
   * calls the render method.
   *
   * @param error {Mixed}
   *     See Xhr#ajax:error
   * @param xhr {XMLHttpRequest}
   *     The XHR that caused the error.
   */
  _this.onSubmitError = function (error/*, xhr*/) {
    _submitResult = {
      error: error
    };

    _this.render();
  };

  /**
   * Callback when the submit Xhr succeeds. Note, this may execute even if the
   * form was not processed if the response returns an HTTP 2XX status. Updates
   * the result object and calls the render method.
   *
   * @param response {String}
   *     The response message to parse.
   * @param xhr {XMLHttpRequest}
   *     The XHR that submitted the request.
   */
  _this.onSubmitSuccess = function (response/*, xhr*/) {
    var message;

    try {
      message = _parseMessageAsHtml(response);
    } catch (e) {
      message = _parseMessageAsString(response);
    }

    if (message) {
      _submitResult = {
        success: message
      };
    } else {
      _submitResult = {
        error: 'Required entries not provided! Please re-submit the form ' +
            'after answering all required questions.'
      };
    }

    _this.render();
  };

  /**
   * Called show the form or when it is submitted. Depending on the current
   * state of the result object, displays the result message or shows the form
   * itself.
   *
   */
  _this.render = function () {
    var buttonMarkup;

    buttonMarkup = '<button class="show-form">Show Form</button>';

    _this.header.innerHTML = '<h3>' + _this.TITLE + '</h3>';
    _this.footer.innerHTML = '';

    if (_submitResult && (_submitResult.error || _submitResult.success)) {
      if (_submitResult.error) {
        _this.content.innerHTML = '<p class="alert error">' +
            _submitResult.error + '</p>' + buttonMarkup;
      } else {
        _this.content.innerHTML = [
          '<h3>Questionnaire Complete</h3>',
          '<p class="alert success">',
            'Thank you for your contribution. ',
            'Your information will be processed shortly.',
          '</p>',
          _submitResult.success
        ].join('');
      }
    } else {
      _this.content.innerHTML = buttonMarkup;
      _this.showForm();
    }
  };

  /**
   * Shows the modal form. Once shown, lets updates the submit button state
   * (disabled or not), and then allows the sub-view to render.
   *
   */
  _this.showForm = function () {
    _modal.show();
    _submitButton = document.querySelector('.dyfi-submit-button');

    // Ensure submit button status is currently up-to-date
    _this.onFormChange();
  };


  _initialize(options);
  options = null;
  return _this;
};


DYFIFormModule.ID = _ID;
DYFIFormModule.TITLE = _TITLE;

DYFIFormModule.hasContent = _hasContent;


module.exports = DYFIFormModule;

},{"core/Module":"core/Module","dyfi/DYFIFormView":"dyfi/DYFIFormView","mvc/ModalView":37,"mvc/Model":"mvc/Model","util/Events":"util/Events","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"dyfi/DYFIFormPinView":[function(require,module,exports){
'use strict';


var BasicPinView = require('core/BasicPinView'),
    DYFIFormModule = require('dyfi/DYFIFormModule'),
    Formatter = require('core/Formatter'),
    Util = require('util/Util');

var _DEFAULTS = {
  module: DYFIFormModule
};


var DYFIFormPinView = function (options) {
  var _this,
      _initialize,

      _formatter;


  options = Util.extend({}, _DEFAULTS, options);
  _this = BasicPinView(options);

  _initialize = function (options) {
    _formatter = options.formatter || Formatter();
  };


  /**
   * Frees resources associated with this view.
   *
   */
  _this.destroy = Util.compose(function () {
    if (_this === null) {
      return;
    }

    _formatter = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Render the histograms as DYFIFormPinView content
   *
   */
  _this.renderPinContent = function () {
    var markup,
        numResponses,
        responses,
        stillZero,
        value;

    markup = [];
    responses = _this.model.getProperty('num-responses') ||
        _this.model.getProperty('numResp') || '0';
    numResponses = _formatter.numberWithCommas(responses);
    // pad with zeros
    responses = _formatter.leftPad(responses.toString(), 6, '0');
    stillZero = true;

    for (var i = 0, len = responses.length; i < len; i += 1) {
      value = responses.charAt(i);

      if (value === '0' && stillZero) {
        markup.push('<div class="responses-digit empty-digit">0</div>');
      } else {
        stillZero = false;
        markup.push('<div class="responses-digit">', value, '</div>');
      }
    }

    _this.content.innerHTML =
      '<div class="dyfi-responses-badge" title="Number of DYFI Responses">' +
        markup.join('') +
      '</div>' +
      '<div class="dyfi-responses-abbr">' +
        '<abbr title="' + numResponses + ' DYFI Responses">Responses</abbr>' +
      '</div>' +
      '<small class="disclaimer">' +
        'Contribute to citizen science. Please <a href="#tellus">tell us</a> ' +
        'about your experience.' +
      '</small>';
  };

  /**
   * Use custom attribution as this content is generated by user-submitted
   * felt reports from the "Tell Us!" link.
   *
   */
  _this.renderPinFooter = function () {
    _this.footer.innerHTML = 'Citizen Scientist Contributions';
  };


  _initialize(options);
  options = null;
  return _this;
};

module.exports = DYFIFormPinView;

},{"core/BasicPinView":"core/BasicPinView","core/Formatter":"core/Formatter","dyfi/DYFIFormModule":"dyfi/DYFIFormModule","util/Util":"util/Util"}],"dyfi/DYFIFormView":[function(require,module,exports){
'use strict';


var Events = require('util/Events'),
    Formatter = require('core/Formatter'),
    LocationView = require('locationview/LocationView'),
    Model = require('mvc/Model'),
    ModalView = require('mvc/ModalView'),
    QuestionView = require('questionview/QuestionView'),
    TextQuestionView = require('dyfi/TextQuestionView'),
    Util = require('util/Util'),
    View = require('mvc/View'),
    Xhr = require('util/Xhr');


var _DEFAULTS = {
  eventTime: null,
  language: 'en',
  url: 'js/languages/'
};

var _DYFI_DISCLAIMER =
  '<p class="alert info">' +
    'This form is subject to the Privacy Act of 1974.' +
  '</p>' +
  '<p>' +
    '<strong>Authority</strong><br/>' +
    'The National Earthquake Hazards Reduction Program (NEHRP), which ' +
    'was first authorized in 1977, Public Law (PL) 95–124), and most ' +
    'recently reauthorized in 2004 (NEHRP Reauthorization Act of 2004, ' +
    'PL 108–360' +
  '</p>' +
  '<p>' +
    '<strong>Principal Purpose</strong><br/>' +
    'The Earthquake Hazards Program provides rapid, authoritative ' +
    'information on earthquakes and their impact to emergency responders, ' +
    'governments, facilities managers and researchers across the country.' +
  '</p>' +
  '<p>' +
    '<strong>Routine Use</strong><br/>' +
    'Used to allow users to report shaking intensity of earthquake events, ' +
    'to allow users to receive notifications of earthquake events, and to ' +
    'allow users to volunteer to have seismic instrumentation installed ' +
    'on their property.' +
  '</p>' +
  '<p>' +
    '<strong>Disclosure is Voluntary</strong><br/>' +
    'If the individual does not furnish the information requested, there ' +
    'will be no adverse consequences. However, if you do not provide ' +
    'contact information we may be unable to contact you for additional ' +
    'information to verify your responses.' +
  '</p>' +
  '<p>' +
    '<strong>Privacy Act Statement</strong><br/>' +
    'You are not required to provide your personal contact information in' +
    'order to submit your survey. However, if you do not provide contact' +
    'information, we may be unable to contact you for additional information' +
    'to verify your responses. If you do provide contact information, this' +
    'information will only be used to initiate follow-up communications with' +
    'you. The records for this collection will be maintained in the' +
    'appropriate Privacy Act System of Records identified as Earthquake' +
    'Hazards Program Earthquake Information. (INTERIOR/USGS-2) published' +
    'at 74 FR 34033 (July 14,2009).' +
  '</p>' +
  '<p>' +
    '<strong>Paperwork Reduction Act Statement</strong><br/>' +
    'The Paperwork Reduction Act of 1995 (44 U.S.C. 3501 et. seq.) requires ' +
    'us to inform you that this information is being collected to supplement ' +
    'instrumental data and to promote public safety through better ' +
    'understanding of earthquakes. Response to this request is voluntary. ' +
    'Public reporting for this form is estimated to average 6 minutes per ' +
    'response, including the time for reviewing instructions and completing ' +
    'the form. A Federal agency may not conduct or sponsor, and a person is ' +
    'not required to respond to, a collection of information unless it ' +
    'displays a currently valid OMB Control Number. Comments regarding this ' +
    'collection of information should be directed to: Bureau Clearance ' +
    'officer, U.S. Geological Survey, 807 National Center, Reston, VA 20192.' +
  '</p>';


/**
 * View for the DYFI Form. This view retrieves the questions/answers from the
 * appropriate language object, builds the form, and binds the questions to
 * the model using the updateModel method.
* @param options {Object}
 *     Configuration options for this module. See _initialize method
 *     documentation for details.
 *
 * Class variables.
 *  _data: {object} Contains the questions/answers from the language object.
 *  _questions: {ojbect} An object containing the question views.
 */
var DYFIFormView = function (options) {
  var _this,
      _initialize,

      _curLoc,
      _data,
      _formatter,
      _locationButton,
      _locationDisplay,
      _locationView,
      _questions,
      _url;


  _this = View(options);

  /**
   * Constructor. Initializes a new DYFIView.
   *
   * @params language {string}
   *    The language to fetch the questions for.
   * @params eventTime {string}
   *    The time of the event.
   * @params url {string}
   *    The url location for the language/questions object.
   */
  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options || {});

    _curLoc = {};
    _data = null;
    _formatter = options.formatter || Formatter();
    _locationView = null;
    _questions = {};
    _url = options.url;

    if (!_this.model.get('language')) {
      _this.model.set({language: options.language}, {silent: true});
    }

    if (!_this.model.get('eventTime')) {
      _this.model.set({eventTime: options.eventTime}, {silent: true});
    } else {
      _this.model.set({ciim_time: _this.model.get('eventTime')},
          {silent: true});
    }
  };

  /**
   * Adds Listeners to all questions in the questions object.
   */
  _this.addQuestionListeners = function () {
    for (var field in _questions) {
      _questions[field].on('change', _this.updateModel);
    }
  };

  /**
   * Create DFYI Form
   *  Spins through the questions object, and builds the appropriate sections.
   */
  _this.createForm = function () {
    var el,
        // Form Elements
        baseQuestionsEl,
        contactContainer,
        disclaimerEl,
        header,
        moreQuestionsEl,
        toggleContainer,
        // data information
        baseQuestions,
        contactInfo,
        eventTime,
        moreQuestions,
        locationInfo,
        toggleInfo;

    el = _this.el;

    baseQuestions = _data.baseQuestions;
    contactInfo = _data.contactInfo;
    eventTime = _data.eventTime;
    moreQuestions = _data.moreQuestions;
    locationInfo = _data.locationInfo;
    toggleInfo = _data.toggleInfo;

    header = el.appendChild(document.createElement('header'));
    header.classList.add('dyfi-form-header');

    baseQuestionsEl = el.appendChild(document.createElement('div'));
    baseQuestionsEl.classList.add('dyfi-required-questions');

    toggleContainer = el.appendChild(document.createElement('div'));
    toggleContainer.classList.add('dyfi-optional-callout');
    toggleContainer.classList.add('alert');
    toggleContainer.classList.add('info');

    moreQuestionsEl = el.appendChild(document.createElement('div'));
    moreQuestionsEl.classList.add('dyfi-optional-questions');

    contactContainer = document.createElement('div');
    contactContainer.classList.add('dyfi-contact-questions');
    contactContainer.classList.add('alert');

    disclaimerEl = document.createElement('a');

    header.innerHTML = '<h2 class="felt-header">Felt Report - Tell Us!</h2>' +
        '<div class="omb-number">' +
          'OMB No. 1028-0048' +
          '<br/>' +
          'Expires 05/31/2018' +
        '</div>';

    // Handle location question
    _this.createLocationQuestions(locationInfo, baseQuestionsEl);

    if (_this.model.get('eventTime') === null) {
        _this.createTextQuestion(eventTime, baseQuestionsEl);
    }

    // Loop over each base question and create a QuestionView
    _this.createQuestions(baseQuestions, baseQuestionsEl);

      // Visual control to show/hide moreQuestionsEl
    _this.createToggleControl(toggleInfo, toggleContainer);

    // Loop over each additional question and create a QuestionView
    _this.createQuestions(moreQuestions, moreQuestionsEl);

    // Handle additional comments
    _this.createTextQuestion(_data.comments, moreQuestionsEl);

    // Handle contact information
    contactContainer.innerHTML = '<legend>Contact Information' +
        ' <small>(optional)</small></legend>';
    _this.createTextQuestion(contactInfo, contactContainer);
    moreQuestionsEl.appendChild(contactContainer);

    // Add disclaimer link
    disclaimerEl.className = 'dyfi-disclaimer';
    disclaimerEl.href = '/research/dyfi/disclaimer.php#DYFIFormDisclaimer';
    disclaimerEl.innerHTML = 'PRA - Privacy Statement';
    disclaimerEl.addEventListener('click', function (e) {
      var dialog = ModalView(_DYFI_DISCLAIMER, {
        title: 'PRA - Privacy Statement',
        closable: false,
        buttons: [
          {
            text: 'OK',
            classes: ['green'],
            callback: function () {
              dialog.hide();
              dialog.destroy();
              dialog = null;
            }
          }
        ]
      });

      dialog.show();
      e.preventDefault();
    });

    contactContainer.appendChild(disclaimerEl);

    _this.synchQuestionAnswers();
    _this.addQuestionListeners();
  };

  /**
   * Creates Location Questions.
   *    Location questions are not visible to users, instead a button is
   *    visible that calls a LocationView. Which then fills in the
   *    location questions. The location questions are a minimum subset of
   *    the QuestionView API.
   *
   * @params questionInfo {object}
   *    locationInfo: {object}
   *      label: {string}
   *      button: {string}
   *      buttonUpdate: {string}
   * @params container {dom element}
   */
  _this.createLocationQuestions = function (questionInfo, container) {
    var fieldset,
        legend,
        section;

    section = document.createElement('section');
    fieldset = section.appendChild(document.createElement('fieldset'));
    legend = fieldset.appendChild(document.createElement('legend'));
    _locationDisplay = fieldset.appendChild(document.createElement('div'));
    _locationButton = fieldset.appendChild(document.createElement('button'));

    section.classList.add('question');
    legend.innerHTML = questionInfo.label;
    _locationButton.innerHTML = questionInfo.button;
    _locationButton.classList.add('location-button');

    // Add QuestionView-like objects to the list of questions
    _questions.ciim_mapLat = Events();
    _questions.ciim_mapLat.model = Model({field:'ciim_mapLat'});
    _questions.ciim_mapLat.getAnswers = function () {
      return {value: _curLoc.latitude};
    };
    _questions.ciim_mapLat.setAnswers = function (latitude) {
      _curLoc.latitude = latitude;
    };

    _questions.ciim_mapLon = Events();
    _questions.ciim_mapLon.model = Model({field:'ciim_mapLon'});
    _questions.ciim_mapLon.getAnswers = function () {
      return {value: _curLoc.longitude};
    };
    _questions.ciim_mapLon.setAnswers = function (longitude) {
      _curLoc.longitude = longitude;
    };

    _questions.ciim_mapConfidence = Events();
    _questions.ciim_mapConfidence.model = Model({field:'ciim_mapConfidence'});
    _questions.ciim_mapConfidence.getAnswers = function () {
        return {value: _curLoc.confidence};
    };
    _questions.ciim_mapConfidence.setAnswers = function () {};

    _questions.ciim_mapAddress = Events();
    _questions.ciim_mapAddress.model = Model({field:'ciim_mapAddress'});
    _questions.ciim_mapAddress.getAnswers = function () {
        return {value: _curLoc.place};
    };
    _questions.ciim_mapAddress.setAnswers = function () {};

    _locationView = LocationView();

    _locationView.on('location', _this.locationCallback);

    _locationButton.addEventListener('click', function () {
      _locationView.show({initialLocation: _curLoc});
    });

    // Append content to container
    container.appendChild(section);
  };

  /**
   * Helper method to iterate over a hash of questionInfo creating a view
   * for each question, appending the views content to the container, and
   * holding on to a reference to that view on the question hash (keyed by the
   * same field as in the questionInfo hash).
   *
   * @param questionInfo {Object}
   *      An object of question information keyed by the field name
   *      corresponding to that information as expected by the DYFI form
   *      processing code.
   * @param container {DOMElement} pass-by-reference
   *      The container into which the view.el should be appended.
   */
  _this.createQuestions = function (questionInfo, container) {
    var field = null,
        view = null;

    for (field in questionInfo) {
      view = QuestionView(Util.extend(
          {
            el: document.createDocumentFragment()
          },
          questionInfo[field],
          {
            model: Model({field: field})
          }
        )
      );

      _questions[field] = view;
      container.appendChild(view.el);
    }
  };

  /**
   * Creates a set of text questions.
   *    see createQuestions for general overview.
   *    The main difference is that this calls TextQuestionView
   *    to handle questions that use input/Text-Area as it's type.
   */
  _this.createTextQuestion = function (questionInfo, container) {
    var field = null,
        view = null;

    for (field in questionInfo) {
      view = TextQuestionView(Util.extend(
          {
            el: document.createDocumentFragment()
          },
          questionInfo[field],
          {
            model: Model({field: field})
          }
        )
      );

      _questions[field] = view;
      container.appendChild(view.el);
    }
  };


  /**
   * sets the text of the toggle control, which informs the user whether
   * they need to continue filling the form or not.
   */
  _this.createToggleControl = function (info, control) {
    control.innerHTML = info.description;
  };

  /**
   * Free references.
   */
  _this.destroy = Util.compose(function () {
    if (_questions !== null) {
      _this.destroyForm();
      _questions = null;
    }

    if (_locationView) {
      _locationView.destroy();
      _locationView = null;
    }

    _this = null;
  }, _this.destroy);

  /**
   * Destroys the questions in the Form.
   */
  _this.destroyForm = function () {
    for (var field in _questions) {
      _questions[field].off('change');
      _questions[field].destroy();
    }
  };

  /**
   * Get list of questions.
   *   This exists for testing, _questions should be considered private.
   */
  _this.getQuestions = function () {
    return _questions;
  };

  /**
   * Render the form.
   *
   * @param changed {object}
   *    Contains a key:value pair of any question that has changed.
   *    If the object is null, or if the key is language, then the
   *    entire form is rendered, after fetching the language object.
   *    If it contains any other key, it updates the specific answer.
   */
  _this.render = function (changed) {
    if (!changed || changed.hasOwnProperty('language')) {
      _this.renderQuestions();
    } else {
        _this.updateAnswer(changed);
    }
  };

  /**
   * callback for the LocationView.
   *  When LocationView is done, it calls this function, which then sets the
   *  location values.
   *
   * @params locationObject {locationObject}
   *    see locationView
   *
   * Notes: Triggers change on the latitude, and longitude "questions"
   */
  _this.locationCallback = function (locationObject) {
    var confidence,
        markup = [],
        prettyLat = null,
        prettyLng = null;

    _curLoc = locationObject;
    confidence = (_curLoc.confidence === -1 ? 0 : _curLoc.confidence);

    prettyLat = _curLoc.latitude;
    if (prettyLat < 0.0) {
      prettyLat = (-1.0*prettyLat).toFixed(confidence) + '&deg;S';
    } else {
      prettyLat = prettyLat.toFixed(confidence) + '&deg;N';
    }

    prettyLng = _curLoc.longitude;
    if (prettyLng < 0.0) {
      prettyLng = (-1.0*prettyLng).toFixed(confidence) + '&deg;W';
    } else {
      prettyLng = prettyLng.toFixed(confidence) + '&deg;E';
    }

    if (_curLoc.place !== null) {
      markup.push(_curLoc.place + '<br/>');
    }

    _locationDisplay.classList.add('location-result', 'alert', 'success');

    _locationDisplay.innerHTML = '<span class="address">' +
        ((_curLoc.place) ? (_curLoc.place + '</span>') : '') +
        '<span class="coordinates">' +
        prettyLat + ', ' + prettyLng +
        ((_curLoc.place) ? '' : '</span>');


    _locationButton.innerHTML = _data.locationInfo.buttonUpdate;

    _questions.ciim_mapLat.trigger('change', _questions.ciim_mapLat);
    _questions.ciim_mapLon.trigger('change', _questions.ciim_mapLon);
  };

  /**
   * Renders the Question form after fetching the language object.
   */
  _this.renderQuestions = function () {
    var language;

    language = _this.model.get('language');

    Xhr.ajax({
      url: _url + language + '.json',
      success: function (data) {
        if (_data !== null) {
          _this.destroyForm();
        }

        _data = data;
        _this.createForm();
      },
      error: function (e) {
        console.log(e);
      }
    });
  };

  /**
   * Updates the Model when a question is changed.
   *
   * @params question {QuestionView}
   *    The question that has changed.
   */
  _this.updateModel = function (question) {
    var answer,
        field;

    field = question.model.get('field');
    answer = question.getAnswers();

    _this.model.set(_this.stripAnswer(field, answer));
  };

  /**
   * Update Answer for a question.
   *
   * @params changed {object}
   *     holds a key/value pair of the questionid/answer that has changed.
   */
  _this.updateAnswer = function (changed) {
    var field;

    for (field in changed) {
      _questions[field].setAnswers(changed[field]);
    }
  };

  /**
   * Synch's questions with the model answers.
   */
  _this.synchQuestionAnswers = function () {
    var field;

    for (field in _questions) {
      if (_this.model.hasOwnProperty(field)) {
        _questions[field].set(_this.model.get(field));
      }
    }
  };

  /**
   * Strips an Answer from the object a question passes back. And packages it
   *   in an object for the model.
   *
   * @params field {string}
   *    The name of a question.
   * @param answer {string}
   *    An answer from a questionView
   */
  _this.stripAnswer = function (field, answers) {
    var answerObject,
        cnt,
        fieldOther;

    answerObject = {};
    if (answers instanceof Array) {
      answerObject[field] = [];
      for (cnt = 0; cnt < answers.length; cnt++) {
        answerObject[field].push(answers[cnt].value);
      }
    } else if (answers instanceof Object && answers.value !== undefined) {
      answerObject[field] = answers.value;
      if(answers.value === '_Other') {
        fieldOther = field + '_Other';
        answerObject[fieldOther] = answers.otherValue;
      }
    } else {
      answerObject[field] = '';
    }

    return answerObject;
  };

  _initialize(options);
  options = null;
  return _this;
};

module.exports = DYFIFormView;

},{"core/Formatter":"core/Formatter","dyfi/TextQuestionView":"dyfi/TextQuestionView","locationview/LocationView":27,"mvc/ModalView":37,"mvc/Model":"mvc/Model","mvc/View":"mvc/View","questionview/QuestionView":29,"util/Events":"util/Events","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"dyfi/DYFIIntensityGraphView":[function(require,module,exports){
'use strict';


var ContentView = require('core/ContentView'),
    d3 = require('d3'),
    D3LineView = require('d3/D3LineView'),
    D3View = require('d3/D3View'),
    StandardDevationLineView = require('dyfi/StandardDeviationLineView'),
    Util = require('util/Util');


/**
 * This class extends the {ContentView} class and is specifically used
 * for rendering "dyfi_plot_atten.json" for the dyfi product.
 *
 * @param options {Object}
 *     An object containing configuration options for this view.
 *
 */
var DYFIIntensityGraphView = function (options) {
  var _this,

      _graph;

    _this = ContentView(options);

  /**
   * Adds a line view to the D3View (w/ connecting lines, this function is
   * called to build the line view when, dataset.class: "estimated1" or
   * class: "estimated2".
   *
   * @param {object} dataset
   *    an object used to describe a set of data
   *
   *    dataset.class = identifier for type of data
   *    dataset.legend = the dataset name, used by the legend
   *    dataset.data = the point data to plot
   */
  _this.buildLineView = function (dataset) {
    var line = D3LineView({
      view: _graph,
      showPoints: (dataset.showPoints ? dataset.showPoints : false),
      data: _this.parseDataIntoArray(dataset.data),
      className: dataset.class,
      label: dataset.legend,
      showLegendPoint: false
    });
    _graph.views.add(line);
  };

  /**
   * Adds a line view to the D3View (w/o connecting lines), this function is
   * called to build the line view when, dataset.class: "median".
   *
   * @param {object} dataset
   *    an object used to describe a set of data
   *
   *    dataset.class = identifier for type of data
   *    dataset.legend = the dataset name, used by the legend
   *    dataset.data = the point data to plot
   */
  _this.buildMedianDataView = function (dataset) {
    var medianData = D3LineView({
      view: _graph,
      showLine: false,
      data: _this.parseDataIntoArray(dataset.data),
      className: dataset.class,
      label: dataset.legend,
      pointRadius: 3
    });
    _graph.views.add(medianData);
  };

  /**
   * Adds a scatter plot D3View, this function is called to build
   * the line view when, dataset.class: "scatterplot1".
   *
   * @param {object} dataset
   *    an object used to describe a set of data
   *
   *    dataset.class = identifier for type of data
   *    dataset.legend = the dataset name, used by the legend
   *    dataset.data = the point data to plot
   */
  _this.buildScatterPlotView = function (dataset) {
    var scatterplot = D3LineView({
      view: _graph,
      showLine: false,
      data: _this.parseDataIntoArray(dataset.data),
      className: dataset.class,
      label: dataset.legend,
      pointRadius: 2
    });
    _graph.views.add(scatterplot);
  };

  /**
   * Adds a StandardDeviationLineView to the D3View, this function is called
   * to graph the standard devaiation binned data when, dataset.class: "binned"
   *
   * @param {object} dataset
   *    an object used to describe a set of data
   *
   *    dataset.class = identifier for type of data
   *    dataset.legend = the dataset name, used by the legend
   *    dataset.data = the point data to plot
   */
  _this.buildStandardDeviationLineView = function (dataset) {
    var standardDevationLineView = StandardDevationLineView({
      view: _graph,
      data: _this.parseDataIntoArray(dataset.data),
      histogram: dataset.data,
      className: dataset.class,
      label: dataset.legend,
      pointRadius: 5,
      showLine: false
    });
    _graph.views.add(standardDevationLineView);
  };

  /**
   * Unbind event listeners and free references.
   */
  _this.destroy = Util.compose(function () {
    var views;

    if (_this === null) {
      return;
    }

    if (_graph) {
      views = _graph.views.data();
      _graph.views.reset([], {'silent': true});
      views.forEach(function (view) {
        view.destroy();
      });
      _graph.destroy();
      _graph = null;
    }
    _this = null;
  }, _this.destroy);

  /**
   * Gets an arbitrary set of logrithmic values for graphs whose tick values
   *  would otherwise run into each other.
   *
   * @params {array} extent
   *    An array containing the min and max of the x axis data range.
   *
   * @returns {array} ticks
   *    An array of tick values.
   */
  _this.getLogTicks = function (extent) {
    var min,
        max,
        ticks;

    min = extent[0];
    max = extent[1];

    if (max > 5000) {
      ticks = [50, 100, 500, 1000, 2000, 5000, 10000];
    } else {
      ticks = [10, 20, 30, 40, 50, 100, 200, 300, 400, 500, 1000, 2000, 5000];
    }

    if (min > ticks[0] ) {
      ticks = ticks.filter(function(value) {
        return value > min;
      });
    }

    if (max < ticks[ticks.length - 1]) {
      ticks = ticks.filter(function(value) {
        return value < max;
      });
    }

  return ticks;
  };

  /**
   * Builds the D3View that will display all of the datasets returned by the
   * ContentView.fetchData Xhr request.
   *
   * @param {object} data
   *    Data returned by the Xhr request for dyfi_plot_atten.json
   */
  _this.onSuccess = function (data) {
    var datasets;

    datasets = data.datasets;

    if (datasets && datasets.length && datasets.length > 0) {
      _graph = D3View(Util.extend({
        title: 'Intensity vs. Distance Plot',
        xLabel: 'Hypocentral Distance (km)',
        yLabel: 'Intensity (mmi)',
        xAxisScale: d3.scale.log(),
        xAxisFormat: function (value) {
          return value;
        },
        xAxisTicks: _this.xAxisTicks,
        yAxisTicks: [1,2,3,4,5,6,7,8,9,10],
        yExtent: [1,10],
        marginTop: 10,
        marginLeft: 10,
        paddingLeft:70
      }, options));
      _this.el.innerHTML = '';
      _this.el.classList.add('IntensityGraphView');
      _this.el.appendChild(_graph.el);
      _this.parseData(datasets);
    } else {
      _this.el.innerHTML = '<p class="alert warning">Intensity vs. Distance ' +
          'data does not exist.</p>';
    }
  };

  /**
   * Scans all datasets returned in the XHR response and determines
   * which type of view will be added to the D3View.
   *
   * @param {array} data
   *    An array of datasets to be plotted in the D3View
   */
  _this.parseData = function (data) {
    data.forEach(function (dataset) {
      if (dataset.class === 'estimated1' ||
          dataset.class === 'estimated2') {
        _this.buildLineView(dataset);
      }
      if (dataset.class === 'scatterplot1') {
        _this.buildScatterPlotView(dataset);
      }
      if (dataset.class === 'median') {
        _this.buildMedianDataView(dataset);
      }
      if (dataset.class === 'binned') {
        _this.buildStandardDeviationLineView(dataset);
      }
    });
  };

  /**
   * Massages the point data into a new format that is expected by the
   * D3LineView and StandardDevationLineView.
   *
   * @param {array} dataPoints
   *    An array of objects that contain "x" and "y" attributes that represent
   *    point data.
   */
  _this.parseDataIntoArray = function (dataPoints) {
    var data;

    data = [];
    dataPoints.forEach(function (point) {
      data.push([point.x, point.y]);
    });

    return data;
  };

  /**
   * Makes certain that x Axis ticks are visible for small axis extents.
   *
   * @param {array} extent
   *    An array containing the min and max of the x axis data range.
   *
   * @returns {array} ticks
   *    An array of tick values, or null if the d3 default will suffice.
   */
  _this.xAxisTicks = function (extent) {
    var logmin,
        logmax,
        min,
        max,
        ticks;

    // No extents, return null.
    if (extent.length < 1) {
      return null;
    }

    min = extent[0];
    max = extent[extent.length -1];

    logmin = Math.log(min) / Math.LN10;
    logmax = Math.log(max) / Math.LN10;

    // range is completely within 2 ticks on the log 10 scale.
    // Create 2 ticks, rounded to the nearest 1000's.
    if (logmax - logmin < 1) {
      ticks = [Math.round(min * 1000.0) / 1000.0,
          Math.round(max * 1000.0) / 1000.0];
      return ticks;
    }

    if (logmax - logmin > 1.5) {
      ticks = _this.getLogTicks(extent);
      return ticks;
    }

    return null;
  };


  options = null;
  return _this;
};


module.exports = DYFIIntensityGraphView;

},{"core/ContentView":"core/ContentView","d3":1,"d3/D3LineView":4,"d3/D3View":7,"dyfi/StandardDeviationLineView":"dyfi/StandardDeviationLineView","util/Util":"util/Util"}],"dyfi/DYFIModule":[function(require,module,exports){
'use strict';


var DYFIFormModule = require('dyfi/DYFIFormModule'),
    DYFIView = require('dyfi/DYFIView'),
    ImpactSummaryModule = require('impact/ImpactSummaryModule'),
    Module = require('core/Module'),
    Util = require('util/Util');


var _ID,
    _TITLE,
    _TYPES;


_ID = 'dyfi';
_TITLE = 'Did You Feel It?';
_TYPES = ['dyfi'];


var _DEFAULTS = {

};


var DYFIModule = function (options) {
  var _this,
      _initialize,

      _dyfiView;


  options = Util.extend({}, _DEFAULTS, options);
  _this = Module(options);

  _initialize = function (/*options*/) {
    _this.ID = _ID;
    _this.TITLE = _TITLE;
  };


  _this.destroy = Util.compose(function () {
    if (_dyfiView) {
      _dyfiView.destroy();
    }

    _dyfiView = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  _this.render = function () {
    _this.renderHeader();
    _this.renderContent();
    _this.renderFooter();
  };

  _this.renderContent = function () {
    var product;

    product = _this.getProduct('dyfi');

    if (!product) {
      _this.content.innerHTML = '<p class="alert error">No DYFI Found!</p>';
    } else {
      if (_dyfiView && _dyfiView.destroy) {
        _dyfiView.destroy();
        _dyfiView = null;
      }

      _dyfiView = DYFIView({
        el: _this.content,
        model: product
      });

      _dyfiView.render();
    }
  };

  _this.renderFooter = function () {
    var additionalFooter,
        product;

    _this.footer.innerHTML =[
      '<h3>For More Information</h3>',
      '<ul>',
        '<li>',
          '<a href="/data/dyfi/">',
            'Scientific Background for Did You Feel It?',
          '</a>',
        '</li>',
      '</ul>'
    ].join('');

    product = _this.getProduct('dyfi');
    if (product) {
      additionalFooter = _this.getProductFooter({
        product: product
      });

      if (additionalFooter) {
        _this.footer.appendChild(additionalFooter);
      }
    }
  };
  _this.renderHeader = function () {
    var product;

    _this.header.innerHTML = '<h3 class="dyfi-title">' + _this.TITLE + '</h3>' +
        '<a class="tell-us-link" href="#' + DYFIFormModule.ID +
        '">' + DYFIFormModule.TITLE + '</a>';

    product = _this.getProduct('dyfi');

    if (product) {
      _this.header.appendChild(_this.getProductHeader({
        product: product,
        summaryModule: ImpactSummaryModule
      }));
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


DYFIModule.ID = _ID;
DYFIModule.TITLE = _TITLE;
DYFIModule.TYPES = _TYPES;


module.exports = DYFIModule;

},{"core/Module":"core/Module","dyfi/DYFIFormModule":"dyfi/DYFIFormModule","dyfi/DYFIView":"dyfi/DYFIView","impact/ImpactSummaryModule":"impact/ImpactSummaryModule","util/Util":"util/Util"}],"dyfi/DYFIPinView":[function(require,module,exports){
'use strict';


var BasicPinView = require('core/BasicPinView'),
    DYFIModule = require('dyfi/DYFIModule'),
    Formatter = require('core/Formatter'),
    Util = require('util/Util');


var _DEFAULTS = {
  module: DYFIModule
};

var DYFIPinView = function (options) {
  var _this,
      _initialize,

      _formatter;


  options = Util.extend({}, _DEFAULTS, options);
  _this = BasicPinView(options);

  _initialize = function (options) {
    _formatter = options.formatter || Formatter();
  };

  /**
   * Render the content section of the pin. This loads a DYFI image
   *
   */
  _this.renderPinContent = function () {
    var code,
        img;

    code = _this.model.get('code');
    img = _this.model.getContent('pin-thumbnail.png');
    if (!img) {
      img = _this.model.getContent(code + '_ciim.jpg');
    }

    if (img) {
      _this.content.innerHTML = '<img src="' + img.get('url') +
          '" class="dyfi-intensity-map" alt="DYFI Intensity Map"/>';
    } else {
      _this.content.innerHTML = '<p class="alert warning">Could not load ' +
          'DYFI intensity map</p>';
    }
  };

  /**
   * Render header for DYFIPinView with impact bubble
   *
   */
  _this.renderPinHeader = Util.compose(_this.renderPinHeader, function () {
    _this.header.insertAdjacentHTML('beforeend',
        _formatter.intensity(_this.model.getProperty('maxmmi'), null));
  });

  _initialize(options);
  options = null;
  return _this;
};

module.exports = DYFIPinView;

},{"core/BasicPinView":"core/BasicPinView","core/Formatter":"core/Formatter","dyfi/DYFIModule":"dyfi/DYFIModule","util/Util":"util/Util"}],"dyfi/DYFIResponsesView":[function(require,module,exports){
'use strict';

var Collection = require('mvc/Collection'),
    ContentView = require('core/ContentView'),
    DataTable = require('mvc/DataTable'),
    Formatter = require('core/Formatter'),
    Util = require('util/Util');


var _NO_CONTENT_MESSAGE = '<p class="alert error">No Responses available.</p>';

/* Formatter for _RESPONSE_DATA_COLUMNS */
var _FORMATTER = Formatter();

/* Array of Column Objects for Responses DataTable */
var _RESPONSE_DATA_COLUMNS = [
  {
    className: 'dyfi-response-location',
    title: 'Location',
    downloadTitle: 'City\tState/Region\tCountry\tZip Code',
    format: function (response) {
      return _FORMATTER.dyfiLocation(response);
    },
    downloadFormat: function (response) {
      var country,
          location,
          region,
          zip;

      country = response.country;
      location = response.name;
      region = response.state;
      zip = response.zip;

      return [location, region, country, zip].join('\t');
    }
  },
  {
    className: 'dyfi-response-mmi',
    title: 'MMI',
    format: function (response) {
      return _FORMATTER.intensity(response.cdi);
    },
    downloadFormat: function (response) {
      return _FORMATTER.mmi(response.cdi);
    }
  },
  {
    className: 'dyfi-response-numResp',
    title: 'Responses',
    format: function (response) {
      return response.nresp;
    }
  },
  {
    className: 'dyfi-response-distance',
    title: 'Distance',
    format: function (response) {
      return response.dist + ' km';
    }
  },
  {
    className: 'dyfi-response-latitude',
    title: 'Latitude',
    format: function (response) {
      return _FORMATTER.latitude(response.lat);
    },
    downloadFormat: function (response) {
      return response.lat;
    }
  },
  {
    className: 'dyfi-response-longitude',
    title: 'Longitude',
    format: function (response) {
      return _FORMATTER.longitude(response.lon);
    },
    downloadFormat: function (response) {
      return response.lon;
    }
  }
];

/* Array of sort objects for use by DataTable */
var _RESPONSE_DATA_SORTS = [
  {
    id: 'city',
    title: 'City',
    sortBy: function (response) {
      return response.name;
    }
  },
  {
    id: 'country',
    title: 'Country',
    sortBy: function (response) {
      return response.country;
    }
  },
  {
    id: 'distance',
    title: 'Distance',
    sortBy: function (response) {
      return response.dist;
    }
  },
  {
    id: 'mmi',
    title: 'MMI',
    sortBy: function (response) {
      return response.cdi;
    },
    descending: true
  },
  {
    id: 'state',
    title: 'Region / State',
    sortBy: function (response) {
      return response.state;
    }
  },
  {
    id: 'numResp',
    title: 'Responses',
    sortBy: function (response) {
      return response.nresp;
    },
    descending: true
  },
  {
    id: 'zip',
    title: 'Zip Code',
    sortBy: function (response) {
      if (response.zip !== '') {
        return response.zip;
      }
      else {
        return response.name;
      }
    }
  }
];


/**
 * This class extends the {ContentView} class and is specifically used
 * for rendering "stationlist.json" for a given product. The `options.model`
 * should be of type {Content}.
 *
 */
var DYFIResponsesView = function (options) {
  var _this,
      _initialize,

      _button,
      _formatter,
      _product,
      _responses,
      _responseTable,
      _responseTableEl;


  options = options || {};
  _this = ContentView(options);

  _initialize = function () {
    _button = null;
    _formatter = options.formatter || Formatter();
    _product = options.product || null;
    _responseTable = null;
    _responseTableEl = null;
  };

  /**
   * Add a toggle button to the reponses DataTable.
   *
   * @param containter
   *        The container element that the button should be added to.
   */
  _this.addToggleButton = function (container) {
    _button = container.appendChild(document.createElement('button'));
    _button.innerHTML = 'See All Responses';
    _button.className = 'view-all';
    _button.addEventListener('click', _this.onToggleButtonClick);
    container.appendChild(_button);
  };

  /**
   * Build a response collection from the DYFI xmlDoc.
   *
   * @param xmlDoc xmlObject
   *        the xml document to parse.
   * @return Collection
   *         A collection of DYFI responses.
   */
  _this.buildResponsesCollection = function (xmlDoc) {
    var data = xmlDoc.getElementsByTagName('location'),
        responsesArray = [],
        locationName, locations, location,
        node, nodeName, nodeValue;

    for (var x = 0; x < data.length; x++) {

      locationName = data[x].getAttribute('name');
      locations = data[x].childNodes;
      location = {
        id: x,  // Assign an ID for sorting caching
        zip: '' // Provide empty default to prevent undefined
      };

      for (var i = 0; i < locations.length; i++) {

        node = locations[i];
        nodeName = node.nodeName;
        nodeValue = node.textContent;

        if (nodeName === 'name' ||
            nodeName === 'state' ||
            nodeName === 'country' ||
            nodeName === 'zip') {
          location[nodeName] = nodeValue;
        } else if (
            nodeName === 'cdi' ||
            nodeName === 'dist' ||
            nodeName === 'lat' ||
            nodeName === 'lon') {
          location[nodeName] = parseFloat(nodeValue);
        } else if (nodeName === 'nresp') {
          location[nodeName] = parseInt(nodeValue, 10);
        }
      }

      // determine country/ add zip code to name
      if (locationName.length === 5) {
        location.country = 'United States of America';
        location.zip = locationName;
      } else {
        locationName = locationName.split('::');
        location.state = locationName[1];
        location.country = locationName[2];
      }

      responsesArray.push(location);
    }

    return Collection(responsesArray);
  };

  /**
   * Free references.
   */
  _this.destroy = Util.compose(function () {
    if (_button !== null) {
      _button.removeEventListener('click', _this.onToggleButtonClick);
    }
    if (_responseTable !== null) {
      _responseTable.destroy();
    }
    if (_responses) {
      _responses.destroy();
    }

    _button = null;
    _initialize = null;
    _responses = null;
    _responseTableEl = null;
    _responseTable = null;
    _this = null;
  }, _this.destroy);

  /**
   * Renders the default error message. Called if an error occurs during the
   * data fetch.
   *
   */
  _this.onError = function (/*status, xhr*/) {
    _this.el.innerHTML = _NO_CONTENT_MESSAGE;
  };


  /**
   * Renders the list of responses. Called when data is successfully fetched.
   *
   */
  _this.onSuccess = function (responseText, xhr) {
    _responses = _this.buildResponsesCollection(xhr.responseXML);

    _responseTable = DataTable({
      el: _this.el,
      className: 'dyfi-response-table',
      collection: _responses,
      emptyMarkup: _NO_CONTENT_MESSAGE,
      columns: _RESPONSE_DATA_COLUMNS,
      sorts: _RESPONSE_DATA_SORTS,
      defaultSort: 'distance'
    });

    _responseTableEl = _this.el.querySelector('.datatable-data');
    _responseTableEl.classList.add('horizontal-scrolling');
    if (_responses.data().length > 10) {
      _this.addToggleButton(_this.el);
    }
  };

  /**
   * Toggle the Response list size, either all responses, or the last 10.
   *
   */
  _this.onToggleButtonClick = function () {
    if (_responseTableEl.classList.contains('full-list')) {
      _responseTableEl.classList.remove('full-list');
      _button.innerHTML = 'Show All Responses';
    } else {
      _responseTableEl.classList.add('full-list');
      _button.innerHTML = 'Show Only 10 Responses';
    }
  };

  _initialize();
  options = null;
  return _this;
};


DYFIResponsesView.NO_CONTENT_MESSAGE = _NO_CONTENT_MESSAGE;


module.exports = DYFIResponsesView;

},{"core/ContentView":"core/ContentView","core/Formatter":"core/Formatter","mvc/Collection":32,"mvc/DataTable":35,"util/Util":"util/Util"}],"dyfi/DYFIView":[function(require,module,exports){
'use strict';


var DYFIIntensityGraphView = require('dyfi/DYFIIntensityGraphView'),
    DYFIResponsesView = require('dyfi/DYFIResponsesView'),
    InteractiveMapView = require('map/InteractiveMapView'),
    ProductView = require('core/ProductView'),
    SvgImageMap = require('svgimagemap/SvgImageMap'),
    TabList = require('tablist/TabList'),
    Util = require('util/Util');


var _DEFAULTS = {

};

// Map of information used to generate tabs
var _RESOURCES = {
  'intensity-map': {
    title: 'Intensity Map',
    suffix: '_ciim.jpg',
    usemap: 'imap_base',
    href: '#map?' +
        InteractiveMapView.SHAKEMAP_CONTOURS + '= false&' +
        InteractiveMapView.DYFI_10K_OVERLAY + '=true&' +
        InteractiveMapView.DYFI_DEFAULT_OVERLAY + '=true',
    mapSuffix: '_ciim_imap.html'
  },
  'geocode-map': {
    title:'Geocoded Map',
    suffix:'_ciim_geo.jpg',
    usemap:'imap_geo',
    mapSuffix:'_ciim_geo_imap.html'
  },
  'zoom-map': {
    title:'Zoom Map',
    suffix:'_ciim_zoom.jpg',
    usemap:'imap_zoom',
    mapSuffix:'_ciim_zoom_imap.html'
  },
  'zoom-out-map': {
    title:'Zoom Out Map',
    suffix:'_ciim_zoomout.jpg',
    usemap:'imap_zoomout',
    mapSuffix:'_ciim_zoomout_imap.html'
  },
  'intensity-distance': {
    title:'Intensity Vs. Distance',
    suffix:'_plot_atten.jpg',
    subview: DYFIIntensityGraphView,
    subviewContent: 'dyfi_plot_atten.json'
  },
  'response-time': {
    title:'Responses Vs. Time',
    suffix:'_plot_numresp.jpg'
  },
  'response-list': {
    title: 'DYFI Responses',
    subview: DYFIResponsesView,
    subviewContent: 'cdi_zip.xml'
  }
};


/**
 * This class extends a ProductView and is used to render a DYFI product.
 *
 * @param options {Object}
 *     Configuration options. See _initialize for more details.
 */
var DYFIView = function (options) {
  var _this,
      _initialize,

      _resources,
      _tabList,
      _tabs;


  options = Util.extend({}, _DEFAULTS, options);
  _this = ProductView(options);

  /**
   * Initializes a new view.
   *
   * @param options {Object}
   *     Configuration options. Nothing specific to this view at this time.
   */
  _initialize = function (/*options*/) {
    _this.el.classList.add('dyfi-view');

    _resources = Util.extend({}, _RESOURCES, options.resources);
  };


  /**
   * Creates an image-based tab. Image-based tabs consist of an image tag,
   * optionally wrapped in a link, optionally with a corresponding image map
   * for interations.
   *
   * @param params {Object}
   *     Information used to generate the image-based tab.
   * @param params.alt {String}
   *     The title for this tab. Also used as alt text for the image.
   * @param params.href {String} Optional.
   *     The URL to use for a link wrapping the image. If not specified,
   *     no link will wrap the image.
   * @param params.image {String}
   *     The URL to use for the image source.
   * @param params.map {String} Optional.
   *     The URL to use for the image map. If not specified, no corresponding
   *     image map will be generated.
   * @param params.usemap {String} Optional.
   *     The name/id to use for simple image maps. SvgImageMap (the typical
   *     behavior) will not use this parameter.
   *
   * @return {Object}
   *     A tab object as expected in order to provide to the TabList#addTab
   *     method.
   *
   * @see TabList#addTab
   */
  _this.createImageTab = function (params) {
    var container,
        image,
        map;

    if (params.href) {
      container = document.createElement('a');
      container.setAttribute('href', params.href);
    } else {
      container = document.createElement('div');
    }
    container.className = 'dyfi-tablist-image';

    if (!params.map) {
      image = container.appendChild(document.createElement('img'));
      image.setAttribute('alt', params.alt);
      // Defer setting image src so image is not fetched until tab is loaded
    }

    return {
      title: params.alt,
      content: function () {
        if (params.map) {
          map = SvgImageMap({
            el: container,
            imageAlt: params.alt,
            imageUrl: params.image,
            mapUrl: params.map,
            mapName: params.mapName
          });
        }

        return container;
      },
      // Called when tab list is destroyed. Cleans up map if one was generated.
      onDestroy: function () {
        if (map && map.destroy) {
          map.destroy();
        }
      },
      // Called when tab is selected. Give map chance to render if one was
      // generated, otherwise just set image.src to fetch the content.
      onSelect: function () {
        if (map && map.render) {
          map.render();
        } else if (image) {
          image.setAttribute('src', params.image);
        }
      }
    };
  };

  /**
   * Creates a subview-based tab. Subview-based tabs delegate rendering
   * to a different view. The subview itself is created immediately, rendered
   * during tab.onSelect, and destroyed during tabList.onDestroy.
   *
   * @param params {Object}
   *     Configuration parameters for creating the subview-base tab.
   * @param params.constructor {Function}
   *     A constructor factory that returns a view instance.
   * @param params.content {Model}
   *     The model to provide the created view. Typically a {Content} model.
   * @param params.title {String}
   *     The title to put on the tab.
   *
   * @return {Object}
   *     A tab object as expected in order to provide to the TabList#addTab
   *     method.
   *
   * @see TabList#addTab
   */
  _this.createSubViewTab = function (params) {
    var subview;

    subview = params.constructor({
      model: params.content,
      product: _this.model
    });

    return {
      title: params.title,
      content: subview.el,
      onDestroy: function () {
        subview.destroy();
      },
      onSelect: function () {
        subview.render();
      }
    };
  };

  /**
   * Creates a tab based on information found in the given params. Based on the
   * available information and corresponding content on `_this.model`, this
   * method will either (1) produce a subview-based tab, (2) produce an
   * image-based tab, or (3) not produce a tab.
   *
   * @param params {Object}
   *     Configuration parameters for creating the tab.
   *
   * @return {Object}
   *     A tab object as expected in order to provide to the TabList#addTab
   *     method.
   *
   * @see TabList#addTab
   * @see DYFIView#createImageTab
   * @see DYFIView#createSubViewTab
   */
  _this.createTab = function (params) {
    var code,
        imageContent,
        imageMapContent,
        subviewContent,
        tab;

    code = _this.model.get('code');

    imageContent = _this.model.getContent(code + params.suffix);
    imageMapContent = _this.model.getContent(code + params.mapSuffix);
    subviewContent = _this.model.getContent(params.subviewContent);

    if (params.subview && subviewContent) {
      tab = _this.createSubViewTab({
        constructor: params.subview,
        content: subviewContent,
        title: params.title
      });
    } else if (imageContent) {
      tab = _this.createImageTab({
        alt: params.title,
        href: params.href,
        image: imageContent.get('url'),
        map: imageMapContent ? imageMapContent.get('url') : null,
        mapName: params.usemap
      });
    }

    return tab;
  };

  /**
   * Destroys sub-views (TabList) and frees all references. Calls parent
   * destroy method via composition.
   *
   */
  _this.destroy = Util.compose(function () {
    if (_tabList && _tabList.destroy) {
      _tabList.destroy();
    }


    _resources = null;
    _tabList = null;
    _tabs = null;


    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Creates the `_tabList` and loads tab contents based on what is available
   * in `_this.model`. If an `_tabList` was previously created, it is destroyed
   * before a new `_tabList` is created. This is required since {TabList} does
   * not yet have a "removeTab" method.
   *
   */
  _this.render = function () {
    if (_tabList && _tabList.destroy) {
      _tabList.destroy();
    }

    _tabList = TabList({
      el: _this.el,
      tabs: []
    });

    // The `addTab` method returns an object with a select method such
    // that this view can subsequently select any particular tab as desired.
    _tabs = {};
    Object.keys(_resources).forEach(function (key) {
      var info,
          tab;

      info = _resources[key];
      tab = _this.createTab(info);
      if (tab) {
        _tabs[key] = _tabList.addTab(tab);
      }
    });
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = DYFIView;

},{"core/ProductView":"core/ProductView","dyfi/DYFIIntensityGraphView":"dyfi/DYFIIntensityGraphView","dyfi/DYFIResponsesView":"dyfi/DYFIResponsesView","map/InteractiveMapView":"map/InteractiveMapView","svgimagemap/SvgImageMap":"svgimagemap/SvgImageMap","tablist/TabList":"tablist/TabList","util/Util":"util/Util"}],"dyfi/StandardDeviationLineView":[function(require,module,exports){
'use strict';

var d3 = require('d3'),
    ClassList = require('d3/ClassList'),
    D3LineView = require('d3/D3LineView'),
    D3SubView = require('d3/D3SubView'),
    Util = require('util/Util');


/**
 * This class extends the {D3SubView} class and is specifically used
 * for rendering binned standard deviation data as part of a D3LineView
 *
 * @param options {Object}
 *    An object containing configuration options for a D3LineView
 *
 * @param options.histogram {Object}
 *    An array of datapoints with standard deviation data
 *    [ {x: x1, y: y1, stdev: value}, ...]
 */
var StandardDeviationLineView = function (options) {
  var _this,
      _initialize,

      _data,
      _el,
      _histograms,
      _legend,
      _legendLine,
      _lineView,
      _x,
      _y;

  _this = D3SubView(options);

  /**
   * @Constructor
   *
   * Initializes the view. See class level documentation for details.
   */
  _initialize = function (options) {
    ClassList.polyfill(_this.el);
    _this.el.classList.add('StandardDeviationLineView');
    _el = d3.select(_this.el);

    _histograms = _el.append('g');
    _lineView = D3LineView(Util.extend({}, options, {
      el: _el.append('g').node(),
      legend: _this.legend
    }));

    _data = options.histogram;
  };

  /**
   * Renders a point with a histogram (for the standard deviation)
   * on the D3LineView.
   */
  _this.render = function () {
    _x = _this.view.model.get('xAxisScale');
    _y = _this.view.model.get('yAxisScale');

    _lineView.render();
    _histograms.selectAll('*').remove();

    if (_data.length === 0) {
      return;
    }

    // update standard deviation for each point
    _data.forEach(function (point) {
      var el,
          p0y,
          p1y,
          px,
          width;

      if (point.stdev === 0) {
        return;
      }

      width = 6;
      el = _histograms.append('path').attr('class', 'standard-deviation');
      px = _x(point.x);
      p0y = _y(point.y - point.stdev);
      p1y = _y(point.y + point.stdev);
      el.attr('d',
          'M ' + (px - width) + ' ' + p0y +
          'L ' + (px + width) + ' ' + p0y +
          'M ' + (px - width) + ' ' + p1y +
          'L ' + (px + width) + ' ' + p1y +
          'M ' + px + ' ' + p0y +
          'L ' + px + ' ' + p1y
      );
    });

    // update legend
    if (_lineView.legend) {
      ClassList.polyfill(_this.legend);
      _legend = d3.select(_this.legend);
      _legendLine = _legend.select('path');
      _legendLine.attr('d',
          'M 1  -3 L 24 -3' +
          'M 1  -9 L 1   3' +
          'M 24 -9 L 24  3'
      ).attr('class', 'standard-deviation');
    }
  };

  /**
   * Unbind event listeners and free references.
   */
  _this.destroy = Util.compose(function () {
    if (_this === null) {
      return;
    }

    if (_lineView) {
      _lineView.destroy();
    }

    _data = null;
    _el = null;
    _histograms = null;
    _legend = null;
    _legendLine = null;
    _lineView = null;
    _x = null;
    _y = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  _initialize(options);
  options = null;
  return _this;
};

module.exports = StandardDeviationLineView;

},{"d3":1,"d3/ClassList":3,"d3/D3LineView":4,"d3/D3SubView":5,"util/Util":"util/Util"}],"dyfi/TextQuestionView":[function(require,module,exports){
'use strict';


var Util = require('util/Util'),
    View = require('mvc/View');


// Default values used by constructor.
var _DEFAULTS = {
  // label - The question being asked
  type: 'input',
  label: null,
  placeholder: '',
  value: null
};

var _ID_SEQUENCE = 0;


/**
 * Class: TextQuestionView
 * Creates a new TextQuestionView.
 *
 * @param options {Object}
 *     An object containing configuration options. See _DEFAULTS above for
 *     detailed documentation on what can be specified.
 */

var TextQuestionView = function (options) {
  var _this,
      _initialize,

      _input,
      _label;


  options = Util.extend({}, _DEFAULTS, options);
  _this = View(options);

  _initialize = function (options) {
    var id,
        section;

    id = 'text-input-' + (++_ID_SEQUENCE);

    section = document.createElement('section');
    _label = section.appendChild(document.createElement('label'));
    _input = section.appendChild(document.createElement(options.type));

    section.classList.add('question');
    section.classList.add('text-input');

    _label.setAttribute('for', id);

    _input.id = id;
    if (options.type === 'input') {
      _input.setAttribute('type', 'text');
    }
    if (options.placeholder) {
      _input.setAttribute('placeholder', options.placeholder);
    }

    _label.innerHTML = options.label;
    _input.value = options.value || '';

    _this.el.appendChild(section);


    _input.addEventListener('change', _this.onChange);
  };


  /**
   * Free references
   *
   */
  _this.destroy = Util.compose(function () {
    _input.removeEventListener('change', _this.onChange);

    _input = null;
    _label = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Get answers object.
   *
   * @return {Object}
   */
  _this.getAnswers = function () {
    return {value: _input.value || null, label: _label.innerHTML};
  };

  /**
   * Triggers an event change when a text question changes.
   *
   */
  _this.onChange = function () {
    _this.trigger('change', _this);
  };

  /**
   * Sets an answer.
   *
   */
  _this.setAnswers = function (value) {
    _input.value = value || '';
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = TextQuestionView;

},{"mvc/View":"mvc/View","util/Util":"util/Util"}],"finite-fault/FiniteFaultModule":[function(require,module,exports){
'use strict';

var FiniteFaultView = require('finite-fault/FiniteFaultView'),
    Module = require('core/Module'),
    ScientificSummaryModule = require('scientific/ScientificSummaryModule'),
    Util = require('util/Util');

var _ID,
    _TITLE,
    _TYPES;

_ID = 'finite-fault';
_TITLE = 'Finite Fault';
_TYPES = ['finite-fault'];

var FiniteFaultModule = function (options) {

  var _this,
      _initialize,

      _finiteFaultView;

  options = Util.extend({}, options);
  _this = Module(options);

  _initialize = function () {
    _this.ID = _ID;
    _this.TITLE = _TITLE;
  };

  _this.destroy = Util.compose(function () {
    if (_finiteFaultView) {
      _finiteFaultView.destroy();
      _finiteFaultView = null;
    }
    _initialize = null;
    _this = null;
  }, _this.destroy);


  /**
   * Renders the details for this module. Defers bulk of header Information
   * to generalized header rendering. Uses FiniteFaultView for bulk of
   * content rendering.
   *
   */
  _this.render = function () {
    var footer,
        product;

    // Destroy FiniteFaultView if it already exists
    if (_finiteFaultView && _finiteFaultView.destroy) {
      _finiteFaultView.destroy();
      _finiteFaultView = null;
    }

    _this.header.innerHTML = '<h3>Finite Fault</h3>';
    Util.empty(_this.content);
    Util.empty(_this.footer);

    product = _this.getProduct('finite-fault');
    if (!product) {
      _this.content.innerHTML =
          '<p class="alert warning">No Finite Fault Found</p>';
    } else {
      // Display review/preferred status in header section
      _this.header.appendChild(_this.getProductHeader({
        product: product,
        summaryModule: ScientificSummaryModule
      }));

      // Display Finite Fault View in content section
      _finiteFaultView = FiniteFaultView({
        el: _this.content,
        model: product
      });
      _finiteFaultView.render();

      // Display downloads in footer section
      footer = _this.getProductFooter({
        product: product,
      });
      if (footer) {
        _this.footer.appendChild(footer);
      }
    }
  };

  _initialize();
  options = null;
  return _this;
};


FiniteFaultModule.ID = _ID;
FiniteFaultModule.TITLE = _TITLE;
FiniteFaultModule.TYPES = _TYPES;


module.exports = FiniteFaultModule;

},{"core/Module":"core/Module","finite-fault/FiniteFaultView":"finite-fault/FiniteFaultView","scientific/ScientificSummaryModule":"scientific/ScientificSummaryModule","util/Util":"util/Util"}],"finite-fault/FiniteFaultPinView":[function(require,module,exports){
'use strict';


var BasicPinView = require('core/BasicPinView'),
    FiniteFaultModule = require('finite-fault/FiniteFaultModule'),
    Util = require('util/Util');


var _DEFAULTS = {
  module: FiniteFaultModule
};

var FiniteFaultPinView = function (options) {
  var _this;


  options = Util.extend({}, _DEFAULTS, options);
  _this = BasicPinView(options);


  _this.getSlipImage = function (product) {
    var code,
        image,
        paths;

    code = product.get('properties').eventsourcecode;
    image = product.getContent('web/' + code + '_slip2.png');
    image = image || product.getContent('web1/' + code + '_slip2.png');
    image = image || product.getContent('web2/' + code + '_slip2.png');

    if (!image) {
      paths = product.get('contents');
      paths = paths ? paths.getIds() : {};
      paths = Object.keys(paths);

      paths.some(function (path) {
        if (path.indexOf('slip') !== -1) {
          image = product.getContent(path);
          return true;
        }
      });
    }

    return image;
  };

  /**
   * Render the content section of the pin. This loads the smaller version
   * of the finite-fault basemap.png
   *
   */
  _this.renderPinContent = function () {
    var image,
        markup;

    try {
      image = _this.getSlipImage(_this.model);

      markup = '<span>Cross-section of slip distribution</span>' +
          '<img src="' + image.get('url') + '"' +
          ' class="finite-fault-cross-section" ' +
          ' alt="Cross-section of slip distribution"/>';
    } catch (e) {
      markup = '<p class="alert error">Could not load cross-section of ' +
          'slip distribution</p>';
    }

    _this.content.innerHTML = markup;
  };


  options = null;
  return _this;
};


module.exports = FiniteFaultPinView;

},{"core/BasicPinView":"core/BasicPinView","finite-fault/FiniteFaultModule":"finite-fault/FiniteFaultModule","util/Util":"util/Util"}],"finite-fault/FiniteFaultView":[function(require,module,exports){
'use strict';

var TextProductView = require('core/TextProductView'),
    Util = require('util/Util');


var _DEFAULTS = {

};


var FiniteFaultView = function (options) {
  var _this;


  options = Util.extend({contentPath: options.model ?
      (options.model.getProperty('eventsourcecode') + '.html') : ''},
    _DEFAULTS, options
  );
  _this = TextProductView(options);


  options = null;
  return _this;
};


module.exports = FiniteFaultView;

},{"core/TextProductView":"core/TextProductView","util/Util":"util/Util"}],"focal-mechanism/FocalMechanismModule":[function(require,module,exports){
'use strict';


var Formatter = require('core/Formatter'),
    Module = require('core/Module'),
    FocalMechanismView = require('focal-mechanism/FocalMechanismView'),
    ScientificSummaryModule = require('scientific/ScientificSummaryModule'),
    Util = require('util/Util');


var _DEFAULTS,
    _ID,
    _TITLE,
    _TYPES;


_ID = 'focal-mechanism';
_TITLE = 'Focal Mechanism';
_TYPES = ['focal-mechanism'];

_DEFAULTS = {
  formatter: null
};


/**
 * Module to display a focal-mechanism type {Product}.
 *
 * @param options {Object}
 * @param options.formatter {Formatter}
 *     formatter object to pass to FocalMechanismView.
 */
var FocalMechanismModule = function (options) {
  var _this,
      _initialize,

      _formatter,
      _focalMechanismView;


  _this = Module(options);

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);
    _formatter = options.formatter || Formatter();

    _this.ID = _ID;
    _this.TITLE = _TITLE;
  };

  /**
   * Free references.
   */
  _this.destroy = Util.compose(function () {
    if (_focalMechanismView) {
      _focalMechanismView.destroy();
    }
    _focalMechanismView = null;

    _formatter = null;
    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Render product content, or an error message if no product available.
   */
  _this.render = function () {
    var product;

    product = _this.getProduct('focal-mechanism');

    _this.renderHeader(product);
    _this.renderContent(product);
    _this.renderFooter(product);
  };

  /**
   * Render the content section of this module.
   *
   * @param product {Product}
   *     product to render, or null if no product.
   */
  _this.renderContent = function (product) {
    if (_focalMechanismView && _focalMechanismView.destroy) {
      _focalMechanismView.destroy();
      _focalMechanismView = null;
    }

    if (!product) {
      _this.content.innerHTML = '<p class="alert error">' +
          'No Focal Mechanism Found!' +
          '</p>';
    } else {
      _focalMechanismView = FocalMechanismView({
        el: _this.content,
        formatter: _formatter,
        model: product
      });
      _focalMechanismView.render();
    }
  };

  /**
   * Render the footer section of this module.
   *
   * @param product {Product}
   *     product to render, or null if no product.
   */
  _this.renderFooter = function (product) {
    var downloads;

    Util.empty(_this.footer);
    if (product) {
      downloads = _this.getProductFooter({
        product: product
      });
      if (downloads) {
        _this.footer.appendChild(downloads);
      }
    }
  };

  /**
   * Render the header section of this module.
   *
   * @param product {Product}
   *     product to render, or null if no product.
   */
  _this.renderHeader = function (product) {
    var header;

    Util.empty(_this.header);
    _this.header.innerHTML = '<h3>' + _this.TITLE + '</h3>';

    if (product) {
      header = _this.getProductHeader({
        product: product,
        summaryModule: ScientificSummaryModule
      });

      if (header) {
        _this.header.appendChild(header);
      }
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


FocalMechanismModule.ID = _ID;
FocalMechanismModule.TITLE = _TITLE;
FocalMechanismModule.TYPES = _TYPES;


module.exports = FocalMechanismModule;

},{"core/Formatter":"core/Formatter","core/Module":"core/Module","focal-mechanism/FocalMechanismView":"focal-mechanism/FocalMechanismView","scientific/ScientificSummaryModule":"scientific/ScientificSummaryModule","util/Util":"util/Util"}],"focal-mechanism/FocalMechanismPinView":[function(require,module,exports){
'use strict';


var FocalMechanismModule = require('focal-mechanism/FocalMechanismModule'),
    MomentTensorPinView = require('moment-tensor/MomentTensorPinView'),
    Util = require('util/Util');


var _DEFAULTS = {
  className: 'focal-mechanism-pin-beachball',
  fillColor: '#ffaa69',
  module: FocalMechanismModule
};


/**
 * This view is used for rendering a focal mechanism pin. Currently it
 * does the same thing as the {MomentTensorPinView} (i.e. a beachball), but
 * uses a different color and className by default.
 *
 * @see {moment-tensor/MomentTensorPinView}
 */
var FocalMechanismPinView = function (options) {
  var _this;


  options = Util.extend({}, _DEFAULTS, options);
  _this = MomentTensorPinView(options);


  options = null;
  return _this;
};


module.exports = FocalMechanismPinView;

},{"focal-mechanism/FocalMechanismModule":"focal-mechanism/FocalMechanismModule","moment-tensor/MomentTensorPinView":"moment-tensor/MomentTensorPinView","util/Util":"util/Util"}],"focal-mechanism/FocalMechanismView":[function(require,module,exports){
'use strict';

var Attribution = require('core/Attribution'),
    MomentTensorView = require('moment-tensor/MomentTensorView'),
    Util = require('util/Util');


var _DEFAULTS = {
  fillColor: '#ffaa69'
};


/**
 * View for displaying focal mechanisms.
 *
 * Same as MomentTensorView except suppresses axes, and MT specific information.
 *
 * @param options {Object}
 *     see MomentTensorView.
 */
var FocalMechanismView = function (options) {
  var _this;


  _this = MomentTensorView(Util.extend({}, _DEFAULTS, options));


  /**
   * Override getAxes to suppress axis information for focal mechanisms.
   */
  _this.getAxes = function () {
    // don't show any axes information
    return document.createDocumentFragment();
  };

  /**
   * Content for the "info" section of the moment tensor view.
   *
   * @param tensor {Tensor}
   *     the tensor being displayed.
   * @return {DOMElement}
   *     markup for the info section of the moment tensor view.
   */
  _this.getInfo = function (/*tensor*/) {
    var catalog,
        contributor,
        dataSource,
        el,
        product;

    product = _this.model;

    catalog = product.getProperty('eventsource');
    contributor = product.get('source');
    dataSource = product.getProperty('beachball-source') || contributor;

    catalog = catalog.toUpperCase();
    contributor = Attribution.getContributorReference(contributor);
    dataSource = Attribution.getContributorReference(dataSource);

    el = document.createElement('div');
    el.classList.add('moment-tensor-info');
    el.classList.add('horizontal-scrolling');
    el.innerHTML =
        '<table>' +
          '<tbody>' +
            '<tr>' +
              '<th scope="row">Catalog</th>' +
              '<td>' + catalog + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Data Source</th>' +
              '<td>' + dataSource + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Contributor</th>' +
              '<td>' + contributor + '</td>' +
            '</tr>' +
          '</tbody>' +
        '</table>';

    return el;
  };

  /**
   * Override the focal mechanism view title.
   *
   * @param tensor {Tensor}
   *     the tensor being displayed.
   * @return {DOMElement}
   *     markup for the info section of the moment tensor view.
   */
  _this.getTitle = function (/*tensor*/) {
    return document.createDocumentFragment();
  };


  return _this;
};


module.exports = FocalMechanismView;

},{"core/Attribution":"core/Attribution","moment-tensor/MomentTensorView":"moment-tensor/MomentTensorView","util/Util":"util/Util"}],"general/ExecutiveSummaryModule":[function(require,module,exports){
'use strict';


var DyfiFormPinView = require('dyfi/DYFIFormPinView'),
    DyfiPinView = require('dyfi/DYFIPinView'),
    FiniteFaultPinView = require('finite-fault/FiniteFaultPinView'),
    FocalMechanismPinView = require('focal-mechanism/FocalMechanismPinView'),
    InteractiveMapPinView = require('map/InteractiveMapPinView'),
    MomentTensorPinView = require('moment-tensor/MomentTensorPinView'),
    OriginPinView = require('origin/OriginPinView'),
    PAGERPinView = require('losspager/PAGERPinView'),
    Product = require('pdl/Product'),
    RegionalInfoPinView = require('general/RegionalInfoPinView'),
    ShakeMapPinView = require('shakemap/ShakeMapPinView'),
    SummaryModule = require('core/SummaryModule'),
    TsunamiPinView = require('general/TsunamiPinView'),
    Util = require('util/Util');


var _ID,
    _DEFAULTS,
    _TITLE,

    _hasContent;


_ID = 'executive';
_TITLE = 'Overview';

_hasContent = function (eventPageModel) {
  var ev;

  ev = eventPageModel.get('event');
  if (ev !== null) {
    // only show this module if there is an event
    return true;
  }

  return false;
};

_DEFAULTS = {
};


/**
 * The ExecutiveSummaryModule provides a "Pin Board" views of preferred product
 * information for the current event.
 *
 */
var ExecutiveSummaryModule = function (options) {
  var _this,
      _initialize;


  options = Util.extend({}, _DEFAULTS, options);
  _this = SummaryModule(options);

  /**
   * Creates a new ExecutiveSummaryModule.
   *
   * @param options.model.event {CatalogEvent}
   * @param options.model.config {Object}
   *
   */
  _initialize = function (/*options*/) {
    var el;

    el = _this.el;

    _this.ID = _ID;
    _this.TITLE = _TITLE;

    el.classList.add('executive-summary');

    _this.clearPins(true);
    _this.clearTexts(true); // general-header + general-text
    _this.clearLinks(true);
  };


  /**
   * Clears the views associated with pins.
   *
   * @param init {Boolean} Optional. Default false.
   *     Flag whether to re-initialize the views array. By default the views
   *     array is set to null, if true, initializes views array to empty array.
   *
   * @see #_this.clearViews
   */
  _this.clearPins = function (init) {
    _this.clearViews(_this.pinViews);

    if (init) {
      _this.pinViews = [];
    } else {
      _this.pinViews = null;
    }
  };

  /**
   * Creates an LI element, appends it to the given `parent` and sets
   * appropriate classes. The `executive-summary-pin` class is added by default
   * but other classes my be added by providing them in the `classes` parameter.
   *
   * @param parent {DOMElement}
   *     The parent element to which the created container should be appended.
   * @param classes {Array} Optional.
   *     An array of classes to add to the created container.
   *
   * @return {DOMElement}
   */
  _this.createPinContainer = function (parent, classes) {
    var container;

    parent = parent || document.createDocumentFragment();
    classes = classes || [];

    container = parent.appendChild(document.createElement('li'));
    container.classList.add('executive-summary-pin');

    classes.forEach(function (className) {
      container.classList.add(className);
    });

    return container;
  };

  _this.destroy = Util.compose(function () {
    if (_this === null) {
      return; // Already destroyed
    }

    _this.clearPins();

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * APIMethod.
   *
   * Implementing classes should override this method.
   *
   * @return {DOMElement}
   *     A header to label the links section for this {SummaryModule}. If no
   *     header is desired, return an empty {DocumentFragment}.
   */
  _this.getLinksHeader = function () {
    var header;

    header = document.createElement('h3');
    header.innerHTML = 'For More Information';

    return header;
  };

  /**
   * Renders each of the pins in order within _this.pinList container.
   *
   * @param ev {CatalogEvent}
   *     The event data to render.
   */
  _this.getPins = function (ev) {
    var config,
        eventProps,
        list,
        product;

    _this.pinViews = _this.pinViews || [];
    config = _this.model.get('config') || {};
    list = document.createElement('ul');
    list.classList.add('executive-summary-pins');

    if (!ev) {
      return list;
    }

    eventProps = ev.getSummary().properties || {};

    // Interactive Map pin
    _this.pinViews.push(InteractiveMapPinView({
      el: _this.createPinContainer(list),
      model: _this.model
    }));

    // Regional Info pin
    _this.pinViews.push(RegionalInfoPinView({
      el: _this.createPinContainer(list),
      model: ev.getPreferredOriginProduct()
    }));

    // DYFI Form pin
    if (config.SCENARIO_MODE !== true) {
      product = ev.getPreferredProduct(Product.getFullType('dyfi', config));
      _this.pinViews.push(DyfiFormPinView({
        el: _this.createPinContainer(list),
        model: product || Product()
      }));
    }

    // DYFI pin
    if (product) {
      _this.pinViews.push(DyfiPinView({
        el: _this.createPinContainer(list),
        model: product
      }));
    }

    // ShakeMap pin
    product = ev.getPreferredProduct(Product.getFullType('shakemap', config));
    if (product) {
      _this.pinViews.push(ShakeMapPinView({
        el: _this.createPinContainer(list),
        model: product
      }));
    }

    // PAGER pin
    product = ev.getPreferredProduct(Product.getFullType('losspager', config));
    if (product) {
      _this.pinViews.push(PAGERPinView({
        el: _this.createPinContainer(list),
        model: product
      }));
    }

    // Origin pin
    product = ev.getPreferredOriginProduct();
    if (product) {
      _this.pinViews.push(OriginPinView({
        el: _this.createPinContainer(list),
        model: product
      }));
    }

    // Moment Tensor pin
    product = ev.getPreferredProduct(Product.getFullType('moment-tensor',
        config));
    if (product) {
      _this.pinViews.push(MomentTensorPinView({
        el: _this.createPinContainer(list),
        model: product
      }));
    } else {
      // Only show focal mechanism if no moment tensor

      // Focal Mechanism pin
      product = ev.getPreferredProduct(Product.getFullType(
          'focal-mechanism', config));
      if (product) {
        _this.pinViews.push(FocalMechanismPinView({
          el: _this.createPinContainer(list),
          model: product
        }));
      }
    }

    // Finite Fault pin
    product = ev.getPreferredProduct(Product.getFullType('finite-fault',
        config));
    if (product) {
      _this.pinViews.push(FiniteFaultPinView({
        el: _this.createPinContainer(list),
        model: product
      }));
    }

    // Tsunami pin
    if (ev.getSummary().properties.tsunami === 1) {
      _this.pinViews.push(TsunamiPinView({
        el: _this.createPinContainer(list),
        model: ev.getPreferredOriginProduct()
      }));
    }

    return list;
  };

  /**
   * Does a comparison of one Product against an array of Products to see if
   * the same "url" property already exists in the array.
   *
   * @param {boolean}
   *     return true if the link already exists in the array
   *
   */
  _this.isDuplicate = function (needle, haystack) {
    var i;

    try {
      for (i = 0; i < haystack.length; i++) {
        if (haystack[i].get('properties').url ===
            needle.get('properties').url) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  };

  /**
   * Remove duplicate items from the array that have the same "url" property
   *
   * @param links {Array<Product>}
   *     An array of Products
   *
   */
  _this.removeDuplicateLinks = function (links) {
    var i,
        link,
        products;

    // add the first item since it cannot be a duplicate yet
    products = [];

    if (links.length) {
      products.push(links[0]);

      // add all additional links that do not already exist in products array
      for (i = 1; i < links.length; i++) {
        link = links[i];
        if (!_this.isDuplicate(link, products)) {
          products.push(link);
        }
      }
    }

    return products;
  };

  /**
   * Renders the module by delegating to three sub-render methods.
   *
   */
  _this.render = function () {
    var config,
        content,
        ev,
        footerEl,
        headers,
        links,
        posters,
        texts;

    ev = _this.model.get('event');

    _this.clearTexts(true);
    _this.clearLinks(true);
    _this.clearPins(true);

    Util.empty(_this.header);
    Util.empty(_this.content);
    Util.empty(_this.footer);

    if (!ev) {
      return;
    }

    config = _this.model.get('config');
    content = document.createDocumentFragment();
    headers = ev.getProducts(Product.getFullType('general-header'), config);
    posters = ev.getProducts(Product.getFullType('poster'), config);
    texts = ev.getProducts(Product.getFullType('general-text'), config);
    links = _this.removeDuplicateLinks(ev.getProducts(
        Product.getFullType('general-link'), config));


    _this.header.appendChild(_this.getTexts(headers));

    content.appendChild(_this.getPins(ev));
    content.appendChild(_this.getTexts(texts));
    content.appendChild(_this.getLinks(links));
    _this.content.appendChild(content);

    // Creates a download accordion if poster data is available. This accordion
    // has poster data.
    if (posters && posters.length > 0) {
      footerEl = _this.getProductFooter({
        product: posters[0]
      });

      // Calls render to make data available and removes the accordion-closed
      // class so that the accordion is open by default.
      if (footerEl && footerEl.querySelector('.accordion-closed')) {
        _this.downloadView.render();
        footerEl.querySelector('.accordion-closed').classList.
            remove('accordion-closed');
      }

      _this.footer.appendChild(footerEl);
    }

    // Render the pin views after they are in the DOM so they have extents
    _this.pinViews.forEach(function (view) {
      view.render();
    });
  };


  _initialize(options);
  options = null;
  return _this;
};


ExecutiveSummaryModule.ID = _ID;
ExecutiveSummaryModule.TITLE = _TITLE;

ExecutiveSummaryModule.hasContent = _hasContent;


module.exports = ExecutiveSummaryModule;

},{"core/SummaryModule":"core/SummaryModule","dyfi/DYFIFormPinView":"dyfi/DYFIFormPinView","dyfi/DYFIPinView":"dyfi/DYFIPinView","finite-fault/FiniteFaultPinView":"finite-fault/FiniteFaultPinView","focal-mechanism/FocalMechanismPinView":"focal-mechanism/FocalMechanismPinView","general/RegionalInfoPinView":"general/RegionalInfoPinView","general/TsunamiPinView":"general/TsunamiPinView","losspager/PAGERPinView":"losspager/PAGERPinView","map/InteractiveMapPinView":"map/InteractiveMapPinView","moment-tensor/MomentTensorPinView":"moment-tensor/MomentTensorPinView","origin/OriginPinView":"origin/OriginPinView","pdl/Product":"pdl/Product","shakemap/ShakeMapPinView":"shakemap/ShakeMapPinView","util/Util":"util/Util"}],"general/GeoserveNearbyPlacesView":[function(require,module,exports){
'use strict';

var Formatter = require('core/Formatter'),
    NearbyPlacesView = require('general/NearbyPlacesView'),
    Util = require('util/Util'),
    Xhr = require('util/Xhr');


var _DEFAULTS = {
  url: 'https://earthquake.usgs.gov/ws/geoserve/'
};


/**
 * View for a geoserve nearby-cities Product.
 *
 * @param options {Object}
 *    all options are passed to ProductView.
 */
var GeoserveNearbyPlacesView = function (options) {
  var _this,
      _initialize,

      _formatter,
      _url,
      _xhr;


  options = Util.extend({}, _DEFAULTS, options);
  _this = NearbyPlacesView(options);

  _initialize = function (options) {
    _formatter = options.formatter || Formatter();
    _url = options.url || null;
    _this.el.classList.add('geoserve-nearby-places');
  };


  /**
   * Gets data
   */
  _this.fetchData = function () {
    _xhr = Xhr.ajax({
      url: _url + 'places.json',
      success: _this.onSuccess,
      error: _this.onError,
      data: {
        latitude: _this.model.getProperty('latitude'),
        longitude: _this.model.getProperty('longitude'),
        type: 'event'
      },
      done: function () {
        _xhr = null;
      }
    });
  };

  /**
   * Displays message followed by the url requested on error
   */
  _this.onError = function () {
    _this.el.innerHTML = 'Unable to load geoserve web service, URL: ' + _url;
    _this.trigger('places-error');
  };

  /**
   * This method is called when data is successfully fetched from _this.model
   * {Content} object.
   *
   * @param data {String|JSON}
   *     The data for _this.model {Content} object.
   */
  _this.onSuccess = Util.compose(function (data) {
    return data.event.features.map(function (item) {
      var azimuth,
          countryOrState;

      azimuth = _formatter.backAzimuth(item.properties.azimuth);

      // Checks to see if location is inside the US or not if it is in the US
      // the state name is used if the location is outside the US
      // the country name is used.
      if (item.properties.country_code === 'US') {
        countryOrState = item.properties.admin1_name;
      } else {
        countryOrState = item.properties.country_name;
      }

      return {
        distance: item.properties.distance,
        direction: _formatter.compassWinds(azimuth),
        name: item.properties.name + ', ' + countryOrState,
        population: item.properties.population
      };
    });
  }, _this.onSuccess);

  /**
   * Called when the model changes. Initially sets a loading message then starts
   * the data fetch process to render the actual content. Relies on browser
   * caches to avoid duplicate HTTP overhead.
   */
  _this.render = function () {
    _this.el.innerHTML = 'Loading content&hellip;';
    _this.fetchData();
  };

  /**
   * Destroy all the things.
   */
  _this.destroy = Util.compose(function () {
    if (_xhr) {
      _xhr.abort();
      _xhr = null;
    }
    _url = null;
    _formatter = null;
    _initialize = null;
    _this = null;
  }, _this.destroy);


  _initialize(options);
  options = null;
  return _this;
};

module.exports = GeoserveNearbyPlacesView;

},{"core/Formatter":"core/Formatter","general/NearbyPlacesView":"general/NearbyPlacesView","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"general/GeoserveRegionSummaryView":[function(require,module,exports){
'use strict';

var ProductView = require('core/ProductView'),
    Util = require('util/Util'),
    Xhr = require('util/Xhr');


var _DEFAULTS = {
  url: 'https://earthquake.usgs.gov/ws/geoserve/regions.json'
};


/**
 * View for a geoserve tectonic summary Product.
 *
 * @param options {Object}
 *    all options are passed to ProductView.
 */
var GeoserveRegionSummaryView = function (options) {
  var _this,
      _initialize,

      _url,
      _xhr;


  options = Util.extend({}, _DEFAULTS, options);
  _this = ProductView(options);

  _initialize = function (options) {
    _this.el.classList.add('geoserve-region-summary');
    _url = options.url;
  };


  /**
   * Gets data
   */
  _this.fetchData = function () {
    _xhr = Xhr.ajax({
      url: _url,
      success: _this.onSuccess,
      error: _this.onError,
      data: {
        latitude: _this.model.getProperty('latitude'),
        longitude: _this.model.getProperty('longitude'),
        type: 'tectonic'
      },
      done: function () {
        _xhr = null;
      }
    });
  };

  /**
   * Displays message followed by the url requested on error
   */
  _this.onError = function () {
    _this.el.innerHTML = '<p class="alert error">' +
        'Error loading region tectonic summary' +
        '</p>';
  };

  /**
   * This method is called when data is successfully fetched from _this.model
   * {Content} object.
   *
   * @param data {String|JSON}
   *     The data for _this.model {Content} object.
   */
  _this.onSuccess = function (data) {
    var features;

    features = data.tectonic.features;
    if (features.length > 0) {
      _this.el.innerHTML = features[0].properties.summary;
    } else {
      _this.el.innerHTML = '<p class="alert info">' +
          'No region summary available for this location' +
          '</p>';
    }
  };

  /**
   * Called when the model changes. Initially sets a loading message then starts
   * the data fetch process to render the actual content. Relies on browser
   * caches to avoid duplicate HTTP overhead.
   */
  _this.render = function () {
    _this.el.innerHTML = '<p>Loading content&hellip;</p>';
    _this.fetchData();
  };

  /**
   * Destroy all the things.
   */
  _this.destroy = Util.compose(function () {
    if (_xhr) {
      _xhr.abort();
      _xhr = null;
    }
    _url = null;
    _initialize = null;
    _this = null;
  }, _this.destroy);


  _initialize(options);
  options = null;
  return _this;
};

module.exports = GeoserveRegionSummaryView;

},{"core/ProductView":"core/ProductView","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"general/LocationView":[function(require,module,exports){
'use strict';

var Attribution = require('core/Attribution'),
    Formatter = require('core/Formatter'),
    InteractiveMapView = require('map/InteractiveMapView'),
    Module = require('core/Module'),
    View = require('mvc/View'),
    Util = require('util/Util');


var _DEFAULTS = {};


/**
 * View to display location information.
 *
 * @param options {Object}
 *     padded to View.
 * @param options.formatter {Formatter}
 *     formatting object.
 *     default `Formatter()`.
 */
var LocationView = function (options) {
  var _this,
      _initialize,

      _attribution,
      _caption,
      _formatter,
      _mapView;


  _this = View(options);

  _initialize = function (options) {
    var el;

    options = Util.extend({}, _DEFAULTS, options);
    _formatter = options.formatter || Formatter();

    el = _this.el;
    el.classList.add('locationview');
    el.innerHTML =
        '<h3>Location</h3>' +
        '<small class="attribution"></small>' +
        '<figure>' +
          '<a href="#map" class="locationview-map">' +
            '<div></div>' +
          '</a>' +
          '<figcaption class="locationview-caption"></figcaption>' +
        '</figure>';

    _attribution = el.querySelector('.attribution');
    _caption = el.querySelector('.locationview-caption');
    _mapView = InteractiveMapView({
      el: el.querySelector('.locationview-map > div'),
      interactive: false,
      model: _this.model,
      module: options.module || Module()
    });
    _mapView.el.addEventListener('click', _this.onClick);
  };


  /**
   * Unbind events and free references.
   */
  _this.destroy = Util.compose(function () {
    if (_this === null) {
      return;
    }
    _mapView.el.removeEventListener('click', _this.onClick);
    _mapView.destroy();

    _attribution = null;
    _caption = null;
    _formatter = null;
    _mapView = null;
    _this = null;
  }, _this.destroy);

  /**
   * Get attribution for product.
   *
   * @param product {Product}
   *     the product.
   * @return {String}
   *     attribution markup.
   */
  _this.getAttribution = function (product) {
    if (!product) {
      return '';
    }

    return 'Contributed by ' +
        Attribution.getProductAttribution(product) +
        ' last updated ' +
        _formatter.datetime(product.get('updateTime'));
  };

  /**
   * Get location caption for product.
   *
   * @param product {Product}
   *     the product.
   * @return {String}
   *     caption markup.
   */
  _this.getCaption = function (product) {
    var depth,
        latitude,
        longitude;

    if (!product) {
      return '<p class="alert info">No location to display.</p>';
    }

    depth = product.getProperty('depth') || '';
    latitude = product.getProperty('latitude') || null;
    longitude = product.getProperty('longitude') || null;

    if (depth) {
      depth = ' depth=' + _formatter.depth(depth, 'km') +
          ' (' + _formatter.depth(_formatter.kmToMi(depth), 'mi') + ')';
    }

    return _formatter.location(latitude, longitude) + depth +
        '<br/><a href="#map">View interactive map</a>';
  };

  /**
   * Click handler for map.
   */
  _this.onClick = function () {
    window.location = '#map';
  };

  /**
   * Render location view.
   */
  _this.render = function () {
    var el,
        ev,
        product;

    el = _this.el;
    ev = _this.model.get('event');
    if (ev === null) {
      el.classList.add('locationview-empty');
      return;
    }

    el.classList.remove('locationview-empty');
    product = ev.getPreferredOriginProduct();
    _attribution.innerHTML = _this.getAttribution(product);
    _caption.innerHTML = _this.getCaption(product);
    _mapView.render();
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = LocationView;

},{"core/Attribution":"core/Attribution","core/Formatter":"core/Formatter","core/Module":"core/Module","map/InteractiveMapView":"map/InteractiveMapView","mvc/View":"mvc/View","util/Util":"util/Util"}],"general/NearbyPlacesView":[function(require,module,exports){
'use strict';

var ProductView = require('core/ProductView'),
    Formatter = require('core/Formatter'),
    Util = require('util/Util'),
    Xhr = require('util/Xhr');

var _DEFAULTS;

_DEFAULTS = {
  errorMessage: 'Error loading nearby places.',
  renderNewLayout: false
};


/**
 * View for a nearby-cities Product.
 *
 * @param options {Object}
 *    all options are passed to ProductView.
 */
var NearbyPlacesView = function (options) {
  var _this,
      _initialize,

      _errorMessage,
      _formatter,
      _renderNewLayout,
      _xhr;

  _this = ProductView(options);

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);

    _errorMessage = options.errorMessage;
    _formatter = options.formatter || Formatter();
    _renderNewLayout = options.renderNewLayout;

    _this.el.classList.add('nearby-places');
  };

  /**
   * Destroy all the things.
   */
  _this.destroy = Util.compose(function () {
    if (_xhr) {
      _xhr.abort();
      _xhr = null;
    }
    _errorMessage = null;
    _formatter = null;
    _this = null;
    _initialize = null;
  }, _this.destroy);

  /**
   * Gets the data
   */
  _this.fetchData = function () {
    var content;

    content = _this.model.getContent('nearby-cities.json');

    if (!content) {
      _this.onError();
      return;
    }

    _xhr = Xhr.ajax({
      url: content.get('url'),
      success: _this.onSuccess,
      error: _this.onError,
      done: function () {
        _xhr = null;
      }
    });
  };

  /**
   * Formats a place.
   *
   * @param place {Object}
   *     An object containing place information. Namely:
   *         "distance" {Number} (km)
   *         "direction" {String} (CompassWinds)
   *         "name" {String} (Description)
   *
   * @return {String}
   *     The formatted place markup.
   */
  _this.formatPlace = function (place) {
    var markup;

    if (_renderNewLayout) {
      markup = [
        '<li class="nearby-places-place">',
          '<span class="nearby-places-name">',
            place.name,
          '</span>',
          '<aside class="nearby-places-distance">',
            _formatter.distance(place.distance, 'km'),
            ' (',
              _formatter.distance(_formatter.kmToMi(place.distance), 'mi'),
            ') ',
            place.direction,
          '</aside>',
          '<aside class="nearby-places-population">Population: ',
            _formatter.numberWithCommas(place.population),
          '</aside>',
        '</li>'
      ];
    } else {
      markup = [
        '<li>',
          _formatter.distance(place.distance, 'km'),
          ' (',
            _formatter.distance(_formatter.kmToMi(place.distance), 'mi'),
          ') ',
          place.direction, ' of ', place.name,
        '</li>'
      ];
    }

    return markup.join('');
  };

  /**
   * This method is called when there is a problem.
   *
   * @param errorMessage {String}
   *      A description of the error that occurred.
   */
  _this.onError = function () {
    _this.el.innerHTML = _errorMessage;
    _this.trigger('places-error');
  };

  /**
   * This method is called to render nearby-cities.
   *
   * @param data {Object}
   *    The data for nearby-cities JSON.
   */
  _this.onSuccess = function (data) {
    var markup;

    // Formats nearby places
    markup = data.reduce(function (prev, item/*, idx, arr*/) {
      return prev + _this.formatPlace(item);
    }, '');


    _this.el.innerHTML = '<ul class="no-style">' + markup + '</ul>';
    _this.trigger('places', data);
  };

  /**
   * Called when the model changes. Initially sets a loading message then starts
   * the data fetch process to render the actual content. Relies on browser
   * caches to avoid duplicate HTTP overhead.
   */
   _this.render = function () {
     _this.el.innerHTML = 'Loading content&hellip;';
     _this.fetchData();
   };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = NearbyPlacesView;

},{"core/Formatter":"core/Formatter","core/ProductView":"core/ProductView","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"general/RegionalInfoModule":[function(require,module,exports){
/* global L */
'use strict';

var Terrain = require('leaflet/layer/Terrain'),
    GeoserveNearbyPlacesView = require('general/GeoserveNearbyPlacesView'),
    GeoserveRegionSummaryView = require('general/GeoserveRegionSummaryView'),
    HistoricSeismicity = require('leaflet/layer/HistoricSeismicity'),
    InteractiveMapModule = require('map/InteractiveMapModule'),
    InteractiveMapView = require('map/InteractiveMapView'),
    Module = require('core/Module'),
    NearbyPlacesView = require('general/NearbyPlacesView'),
    Product = require('pdl/Product'),
    Util = require('util/Util'),
    Xhr = require('util/Xhr');


var _ID,
    _TITLE,

    _hasContent;


_ID = 'region-info';
_TITLE = 'Regional Information';

_hasContent = function (eventPageModel) {
  var ev;

  ev = eventPageModel.get('event');
  if (ev !== null) {
    // only show this module if there is an event
    return true;
  }

  return false;
};

var _DEFAULTS = {
  formatter: null,
  mapRadius: 5.0
};


/**
 * A module for rendering non-event specific, regional information.
 *
 */
var RegionalInfoModule = function (options) {
  var _this,
      _initialize,

      _mapEl,
      _mapRadius,
      _nearbyPlacesEl,
      _nearbyPlacesView,
      _otherRegionInfoEl,
      _tectonicSummaryEl,
      _tectonicSummaryView;


  _this = Module(options);

  /**
   * Constructor for this module.
   *
   * @params options.formatter {Formatter}
   *     A formatter to use on this module.
   * @param options.mapRadius {Number}
   *     The default map radius in decimal degrees. Note: This value is
   *     not used unless nearby cities fails.
   */
  _initialize = function (options) {
    var el,
        mapLink;

    _this.ID = _ID;
    _this.TITLE = _TITLE;

    options = Util.extend({}, _DEFAULTS, options);

    _mapRadius = options.mapRadius;

    mapLink = [
      '#', InteractiveMapModule.ID, '?',
        encodeURIComponent(InteractiveMapView.HIST_SEIS_OVERLAY), '=true&amp;',
        encodeURIComponent(InteractiveMapView.POPULATION_OVERLAY), '=true&amp;',
        encodeURIComponent(InteractiveMapView.SHAKEMAP_CONTOURS), '=false'
    ].join('');

    el = _this.content;
    el.classList.add('regional-info-module');
    el.innerHTML = [
        '<div class="row right-to-left">',
          '<div class="column one-of-three regions-places">',
            '<div class="regional-info-module-regions"></div>',
            '<div class="regional-info-module-places"></div>',
          '</div>',
          '<div class="column two-of-three">',
            '<a href="', mapLink, '">',
              '<div class="regional-info-module-map"></div>',
              'View Interactive Map',
            '</a>',
          '<div class="regional-info-module-tectonic-summary"></div>',
          '</div>',
        '</div>',
    ].join('');

    _mapEl = el.querySelector('.regional-info-module-map');
    _nearbyPlacesEl = el.querySelector('.regional-info-module-places');
    _otherRegionInfoEl = el.querySelector('.regional-info-module-regions');
    _tectonicSummaryEl = el.querySelector(
        '.regional-info-module-tectonic-summary');
  };


  /**
   * Free references.
   */
  _this.destroy = Util.compose(function () {
    if (_this === null) {
      return;
    }

    if (_nearbyPlacesView) {
      _nearbyPlacesView.off('places', 'onNearbyPlaces', _this);
      _nearbyPlacesView.off('places-error', 'onNearbyPlaces', _this);
      _nearbyPlacesView.destroy();
      _nearbyPlacesView = null;
    }

    if (_tectonicSummaryView) {
      _tectonicSummaryView.destroy();
      _tectonicSummaryView = null;
    }

    if (_this.map) {
      _this.map.remove();
    }

    _mapEl = null;
    _mapRadius = null;
    _nearbyPlacesEl = null;
    _otherRegionInfoEl = null;
    _tectonicSummaryEl = null;


    _initialize = null;
    _this = null;
  }, _this.destroy);


  /**
   * Finds a non-automatic nearby-cities product. If none exists, returns null.
   *
   * @param ev {CatalogEvent}
   *     The event containing nearby-cities products.
   *
   * @param config {Object}
   *     An object containing a SCENARIO_MODE and/or INTERNAL_MODE flag
   *     (boolean) used to determine the full product types.
   *
   * @return {Product}
   *     The most preferred, non-automatic nearby-cities product or null if
   *     none exist.
   */
  _this.getNearbyPlacesProduct = function (ev, config) {
    var nearbyCities,
        origins,
        product;

    product = null;

    nearbyCities = ev.getProducts(Product.getFullType('nearby-cities'), config);
    origins = ev.getProducts(Product.getFullType('origin'), config);

    // Have both nearby-cities and origin products. Look for a nearby-cities
    // product that does not directly correspond to an origin. The resulting
    // list of nearby-cities products will be only those manually sent by RSNs.
    nearbyCities = nearbyCities.filter(function (nearbyCity) {
      var match;

      match = false;
      origins.some(function (origin) {
        match = _this.isAutomaticNearbyCity(nearbyCity, origin);
        return match;
      });

      return !match; // If not matched, then not automatic --> keep product
    });

    // If we have any non-automatic nearby-cities, use the first (most
    // preferred) one.
    if (nearbyCities.length) {
      product = nearbyCities[0];
    }

    return product;
  };

  /**
   * Determines if the given nearbyCity product is an automatic product that
   * was generated by the given origin product.
   *
   * @param nearbyCity {Product}
   *     The nearby city product to check
   * @param origin {Product}
   *     The origin product to check against
   *
   * @return {Boolean}
   *     True if the nearbyCity product was automatically generated by
   *     the origin product.
   */
  _this.isAutomaticNearbyCity = function (nearbyCity, origin) {
    var cityCode,
        citySource,
        originCode;

    citySource = nearbyCity.get('source');
    cityCode = nearbyCity.get('code');
    originCode = origin.get('code');

    // If code matches and source is "us" then product is automatic.
    return (
      citySource === 'us' &&
      cityCode === originCode
    );
  };

  /**
   * Callback method when the {NearbyPlacesView} receives and renders data. This
   * method updates the map extent to potentially include all the nearby
   * places in the given `places` array. A minimum extent is used in
   * case all the nearby places are very nearby such that no map context would
   * be visible.
   *
   * @param places {Array}
   *     An array of places to use as a basis for map context.
   */
  _this.onNearbyPlaces = function (places) {
    var degrees,
        ev,
        km,
        latitude,
        longitude,
        place;

    ev = _this.model.get('event');

    if (ev && _this.map) {
      places = places || [];
      place = places[places.length - 1] || {};
      km = place.distance;

      latitude = ev.getLatitude();
      longitude = ev.getLongitude();

      if (latitude === null || longitude === null) {
        return;
      }

      if (km) {
        degrees = km / 111.2; // not regarding latitude, but close enough
      } else {
        degrees = _mapRadius;
      }

      // Provide some minimum extent for context...
      degrees = Math.max(degrees, 1);

      _this.map.fitBounds([
        [latitude + degrees, longitude + degrees],
        [latitude - degrees, longitude - degrees]
      ]);
    }
  };

  /**
   * Callback method when the AJAX call to geoserve for other regional
   * completes. This method updates the "Administrative Region" and "FE Region"
   * sections of the page.
   *
   * @param data {Object}
   *      An object containing "admin" region information as
   *      returned by Geoserve.
   */
  _this.onOtherRegionComplete = function (data) {
    var admin,
        markup;

    if (!data || !data.admin) {
      return;
    }

    markup = [];
    admin = data.admin.features[0] || {};

    if (admin.properties) {
      admin = admin.properties;
      markup.push([
        '<h3>Administrative Region</h3>',
        '<dl class="no-style regional-info-module-admin vertical">',
          '<dt class="regional-info-module-admin-iso">',
            'ISO',
          '</dt>',
          '<dd>',
            (admin.iso === null) ? '&ndash;' : admin.iso,
          '</dd>',
          '<dt class="regional-info-module-admin-country">',
            'Country',
          '</dt>',
          '<dd>',
            (admin.country === null) ? '&ndash;' : admin.country,
          '</dd>',
          '<dt class="regional-info-module-admin-region">',
            'Region',
          '</dt>',
          '<dd>',
            (admin.region === null) ? '&ndash;' : admin.region,
          '</dd>',
        '</dl>',
      ].join(''));

      _otherRegionInfoEl.innerHTML = markup.join('');
    } else {
      _otherRegionInfoEl.parentNode.removeChild(_otherRegionInfoEl);
    }
  };

  /**
   * Starts the rendering process. Some parts of the page render synchronously
   * while others not so. Rendering is delegated to sub-methods.
   *
   */
  _this.render = function () {
    var ev;

    ev = _this.model.get('event');

    _this.renderHeader(ev);

    _this.renderMap(ev);

    _this.renderOtherRegionInfo(ev);
    _this.renderNearbyPlaces(ev);

    _this.renderTectonicSummary(ev);

    _this.renderFooter(ev);
  };

  /**
   * Render module footer.
   *
   * @param ev {CatalogEvent}
   *     the event.
   */
  _this.renderFooter = function (/*ev*/) {
    _this.footer.innerHTML = ''; // TODO :: Anything?
  };

  /**
   * Render module header.
   *
   * @param ev {CatalogEvent}
   *     the event.
   */
  _this.renderHeader = function (ev) {
    var latitude,
        eventid;

    Util.empty(_this.header);

    if (!ev) {
      return;
    }

    eventid = ev.getEventId();
    latitude = ev.getLatitude();

    // If location latitude extents are + or - 85 degrees show warning
    if (Math.abs(latitude) > 85.0) {
      _this.header.innerHTML = [
        '<p class="alert warning">',
          'Due to the high latitude of this',
          ' event, the location map does not show the correct location.',
          ' To see the actual location we recommend using',
          ' <a href="/earthquakes/feed/v1.0/detail/', eventid, '.kml">',
          'Google Earth KML',
          '</a>.',
        '</p>'
      ].join('');
    } else {
      _this.header.innerHTML = '';
    }
  };

  /**
   * Render map information for the event.
   *
   * @param ev {CatalogEvent}
   *     the event.
   */
  _this.renderMap = function (ev) {
    var latitude,
        longitude;

    if (_this.map) {
      _this.map.remove();
      _this.map = null;
    }

    if (!ev) {
      return;
    }

    latitude = ev.getLatitude();
    longitude = ev.getLongitude();

    if (latitude === null || longitude === null) {
      return;
    }

    _this.map = L.map(_mapEl, {
      attributionControl: false,
      boxZoom: false,
      center: [latitude, longitude],
      zoom: 1,
      doubleClickZoom: false,
      dragging: false,
      fadeAnimation: false,
      keyboard: false,
      markerZoomAnimation: false,
      layers: [
        Terrain({provider: Terrain.NATGEO}),
        HistoricSeismicity(),
        // TODO :: Population density layer ... need tile layer in GIS first
        L.marker([latitude, longitude], {
          zIndexOffset: 99,
          icon: L.icon({
            iconUrl: 'images/star.png',
            iconSize: [32, 32],
            iconAnchor: [16, 16]
          })
        })
      ],
      scrollWheelZoom: false,
      tap: false,
      touchZoom: false,
      zoomAnimation: false,
      zoomControl: false
    });

    L.control.scale({position: 'bottomleft'}).addTo(_this.map);
  };

  /**
   * Render nearby-cities product, or nearby places from geoserve.
   *
   * @param ev {CatalogEvent}
   */
  _this.renderNearbyPlaces = function (ev) {
    var config,
        product;

    if (_nearbyPlacesView) {
      _nearbyPlacesView.off('places', 'onNearbyPlaces', _this);
      _nearbyPlacesView.off('places-error', 'onNearbyPlaces', _this);
      _nearbyPlacesView.destroy();
      _nearbyPlacesView = null;
    }
    Util.empty(_nearbyPlacesEl);

    if (!ev) {
      return;
    }

    config = _this.model.get('config');

    product = _this.getNearbyPlacesProduct(ev, config);
    if (product) {
      _nearbyPlacesView = NearbyPlacesView({
        model: product,
        renderNewLayout: true
      });
    } else {
      product = ev.getPreferredOriginProduct();
      _nearbyPlacesView = GeoserveNearbyPlacesView({
        model: product,
        renderNewLayout: true,
        url: (config ? config.GEOSERVE_WS_URL : '/ws/geoserve/')
      });
    }

    _nearbyPlacesView.on('places', 'onNearbyPlaces', _this);
    _nearbyPlacesView.on('places-error', 'onNearbyPlaces', _this);

    _nearbyPlacesEl.innerHTML = '<h3>Nearby Places</h3>' +
        '<small>' +
          'Direction data (below) indicate the position of the event ' +
          'relative to the place.' +
        '</small>';

    _nearbyPlacesEl.appendChild(_nearbyPlacesView.el);
    _nearbyPlacesView.render();
  };

  /**
   * Fires off a Geoserve request for other regional information. When that
   * request completes, the `onOtherRegionInfoComplete` method is invoked.
   *
   * @param ev {CatalogEvent}
   */
  _this.renderOtherRegionInfo = function (ev) {
    var config,
        latitude,
        longitude;

    Util.empty(_otherRegionInfoEl);

    if (!ev) {
      return;
    }

    config = _this.model.get('config');
    latitude = ev.getLatitude();
    longitude = ev.getLongitude();

    if (latitude === null || longitude === null) {
      return;
    }

    Xhr.ajax({
      url: ((config) ? config.GEOSERVE_WS_URL : '/ws/geoserve/') +
          'regions.json',
      data: {
        latitude: latitude,
        longitude: longitude,
        type: 'admin,fe'
      },
      success: _this.onOtherRegionComplete,
      error: _this.onOtherRegionComplete
    });
  };

  /**
   * Render the tectonic-summary product if available.
   *
   * @param ev {CatalogEvent}
   *     the event.
   */
  _this.renderTectonicSummary = function (ev) {
    var product;

    if (_tectonicSummaryView) {
      _tectonicSummaryView.destroy();
      _tectonicSummaryView = null;
    }

    Util.empty(_tectonicSummaryEl);

    if (!ev) {
      return;
    }

    product = ev.getPreferredOriginProduct();

    if (product) {
      _tectonicSummaryView = GeoserveRegionSummaryView({
        el: _tectonicSummaryEl,
        model: product
      });
      _tectonicSummaryView.render();
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


RegionalInfoModule.ID = _ID;
RegionalInfoModule.TITLE = _TITLE;

RegionalInfoModule.hasContent = _hasContent;


module.exports = RegionalInfoModule;

},{"core/Module":"core/Module","general/GeoserveNearbyPlacesView":"general/GeoserveNearbyPlacesView","general/GeoserveRegionSummaryView":"general/GeoserveRegionSummaryView","general/NearbyPlacesView":"general/NearbyPlacesView","leaflet/layer/HistoricSeismicity":13,"leaflet/layer/Terrain":18,"map/InteractiveMapModule":"map/InteractiveMapModule","map/InteractiveMapView":"map/InteractiveMapView","pdl/Product":"pdl/Product","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"general/RegionalInfoPinView":[function(require,module,exports){
/* global L */
'use strict';


var BasicPinView = require('core/BasicPinView'),
    HistoricSeismicity = require('leaflet/layer/HistoricSeismicity'),
    Terrain = require('leaflet/layer/Terrain'),
    Util = require('util/Util');


var _DEFAULTS = {
  module: {ID: 'region-info', TITLE: 'Regional Information'}
};


var RegionalInfoPinView = function (options) {
  var _this,
      _initialize,

      _mapEl,
      _mapView,
      _marker;

  options = Util.extend({}, _DEFAULTS, options);
  _this = BasicPinView(options);

  /**
   * Initialize the new module.
   *
   * @param options {Object}
   */
  _initialize = function (/*options*/) {
    var latitude,
        longitude;

    _mapEl = document.createElement('div');
    _mapEl.classList.add('regional-info-map');
    _this.content.appendChild(_mapEl);

    latitude = parseFloat(_this.model.getProperty('latitude'));
    longitude = parseFloat(_this.model.getProperty('longitude'));

    if (isNaN(latitude) || isNaN(longitude)) {
      return;
    }

    _marker = L.marker([latitude, longitude], {
        zIndexOffset: 99,
        icon: L.icon({
          iconUrl: 'images/star.png',
          iconSize: [16, 16],
          iconAnchor: [8, 8]
        })
      });

    _mapView = L.map(_mapEl, {
      attributionControl: false,
      boxZoom: false,
      center: [0, 0],
      zoom: 0,
      doubleClickZoom: false,
      dragging: false,
      fadeAnimation: false,
      keyboard: false,
      markerZoomAnimation: false,
      layers: [
        Terrain({provider: Terrain.NATGEO}),
        HistoricSeismicity(),
        // TODO :: Population density layer ... need tile layer in GIS first
        _marker
      ],
      scrollWheelZoom: false,
      tap: false,
      touchZoom: false,
      zoomAnimation: false,
      zoomControl: false
    });
  };

  _this.destroy = Util.compose(function () {
    if (_this === null) {
      return;
    }

    if (_this.map) {
      _this.map.remove();
    }

    _mapEl = null;
    _mapView = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Render map information for the event.
   *
   */
  _this.renderPinContent = function () {
    var latitude,
        longitude;

    if (_mapView) {
      latitude = parseFloat(_this.model.getProperty('latitude'));
      longitude = parseFloat(_this.model.getProperty('longitude'));

      _mapView.invalidateSize();
      // give a 2 degree buffer around center point
      _mapView.fitBounds([
          [latitude - 2.0, longitude - 2.0],
          [latitude + 2.0, longitude + 2.0]
      ]);
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = RegionalInfoPinView;

},{"core/BasicPinView":"core/BasicPinView","leaflet/layer/HistoricSeismicity":13,"leaflet/layer/Terrain":18,"util/Util":"util/Util"}],"general/TsunamiPinView":[function(require,module,exports){
'use strict';


var BasicPinView = require('core/BasicPinView'),
    Util = require('util/Util');


var _DEFAULTS;

_DEFAULTS = {
  badgeImage: 'images/logos/tsunami.jpg',
  module: {ID: '#', TITLE: 'Tsunami'}
};


/**
 * A pin view to link to the current tsunami advisories page.
 *
 */
var TsunamiPinView = function (options) {
  var _this,
      _initialize;


  options = Util.extend({}, _DEFAULTS, options);
  _this = BasicPinView(options);

  /**
   * Creates a new pin view.
   *
   * @param options.badgeImage {String}
   *     A URL to an image to use.
   */
  _initialize = function (options) {
    _this.el.classList.add('tsunami-pin-view');
    _this.badgeImage = options.badgeImage;
  };


  /**
   * @return {String}
   *     The link to use when clicking on the pin.
   */
  _this.getLinkUrl = function () {
    return 'http://www.tsunami.gov/';
  };

  /**
   * Renders the pin content. Puts a badge with some text into the content.
   *
   */
  _this.renderPinContent = function () {
    _this.content.innerHTML = [
      '<figure class="pin-badge">',
        '<img src="', _this.badgeImage, '" alt="Tsunami Warning Center" ',
            'class="tsunami-pin-logo"/>',
      '</figure>',
      '<small class="disclaimer">',
        'To view any current tsunami advisories for this and other events, ',
        'please visit <a href="http://www.tsunami.gov/">',
        'http://www.tsunami.gov</a>.',
      '</small>'
    ].join('');
  };

  /**
   * Renders the pin footer. Puts a link to NOAA in the footer.
   *
   */
  _this.renderPinFooter = function () {
    _this.footer.innerHTML = [
      '<a href="', _this.getLinkUrl(), '">NOAA</a>'
    ].join('');
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = TsunamiPinView;

},{"core/BasicPinView":"core/BasicPinView","util/Util":"util/Util"}],"impact/ImpactSummaryModule":[function(require,module,exports){
'use strict';

var Attribution = require('core/Attribution'),
    Formatter = require('core/Formatter'),
    SummaryModule = require('core/SummaryModule'),
    Util = require('util/Util'),

    // these modules create a circular dependency,
    // require them in initialize
    DYFIModule,
    PAGERModule,
    ShakeMapModule;


var _ID,
    _TITLE,
    _TYPES;

_ID = 'impact';
_TITLE = 'Impact';
_TYPES = ['dyfi', 'shakemap', 'losspager'];


var _DEFAULTS = {

};


/**
 * Summary module for the impact products.
 *
 */
var ImpactSummaryModule = function (options) {
  var _this,
      _initialize,

      _formatter;


  options = Util.extend({}, _DEFAULTS, options);
  _this = SummaryModule(options);

  /**
   * Constructor. Initializes a new {ImpactSummaryModule}.
   *
   * @param options {Object}
   *     See Module#initialize documentation for details.
   */
  _initialize = function (options) {
    _formatter = options.formatter || Formatter();

    _this.ID = _ID;
    _this.TITLE = _TITLE;

    // these modules create a circular dependency,
    // require them first time initialize is called
    DYFIModule = DYFIModule || require('dyfi/DYFIModule');
    PAGERModule = PAGERModule || require('losspager/PAGERModule');
    ShakeMapModule = ShakeMapModule || require('shakemap/ShakeMapModule');
  };

  /**
   * Frees resources associated with this module.
   *
   */
  _this.destroy = Util.compose(function () {
    _formatter = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Gets the summary for the list of DYFI products.
   *
   * @param products {Array}
   *     An array of DYFI {Product}s to summarize.
   *
   * @return {DocumentFragment}
   *     A fragment containing the summary for the products.
   */
  _this.getDyfiSummary = function (products) {
    return _this.createSummary(products, 'Did You Feel It?', [
        'Catalog',
        '<abbr title="Community Determined Intensity">CDI</abbr>',
        'Responses',
        'Source'
      ], _this.getDyfiRow);
  };

  /**
   * Gets a single summary row for the single given product.
   *
   * @param product {Product}
   *     The product to summarize.
   * @param index {Number}
   *     The relative preferred number for the given product.
   *     0 = most preferred
   *
   * @return {DOMElement}
   *     A TR DOM Element for the row summary.
   */
  _this.getDyfiRow = function (product, index) {
    var preferred,
        row;

    preferred = (index === 0);
    row = _this.createRow(preferred);
    row.innerHTML = [
      '<th scope="row">',
        _this.getCatalogMarkup(DYFIModule, product, preferred),
      '</th>',
      '<td>',
        _formatter.intensity(product.getProperty('maxmmi')),
      '</td>',
      '<td>',
        product.getProperty('num-responses'),
      '</td>',
      '<td>',
        Attribution.getProductAttribution(product),
      '</td>'
    ].join('');

    return row;
  };

  /**
   * Gets the header for the links section for this module.
   *
   * @return {DOMElement}
   *     The header element.
   */
  _this.getLinksHeader = function () {
    var header;

    header = document.createElement('h3');
    header.innerHTML = 'Impact Links';

    return header;
  };

  /**
   * Gets the summary for the list of LossPAGER products.
   *
   * @param products {Array}
   *     An array of LossPAGER {Product}s to summarize.
   *
   * @return {DocumentFragment}
   *     A fragment containing the summary for the products.
   */
  _this.getPagerSummary = function (products) {
    return _this.createSummary(products, 'PAGER', [
        'Catalog',
        'Alert Level',
        'Source'
      ], _this.getPagerRow);
  };

  /**
   * Gets a single summary row for the single given product.
   *
   * @param product {Product}
   *     The product to summarize.
   * @param index {Number}
   *     The relative preferred number for the given product.
   *     0 = most preferred
   *
   * @return {DOMElement}
   *     A TR DOM Element for the row summary.
   */
  _this.getPagerRow = function (product, index) {
    var alertLevel,
        preferred,
        row;

    preferred = (index === 0);
    row = _this.createRow(preferred);

    alertLevel = product.getProperty('alertlevel') || 'pending';

    row.innerHTML = [
      '<th scope="row">',
        _this.getCatalogMarkup(PAGERModule, product, preferred),
      '</th>',
      '<td>',
        '<span class="mmi pager-alertlevel-', alertLevel.toLowerCase(), '">',
          '<strong class="roman">',
            alertLevel.toUpperCase(),
          '</strong>',
        '</span>',
      '</td>',
      '<td>',
        Attribution.getProductAttribution(product),
      '</td>'
    ].join('');

    return row;
  };

  /**
   * Gets the summary for the list of ShakeMap products.
   *
   * @param products {Array}
   *     An array of ShakeMap {Product}s to summarize.
   *
   * @return {DocumentFragment}
   *     A fragment containing the summary for the products.
   */
  _this.getShakeMapSummary = function (products) {
    return _this.createSummary(products, 'ShakeMap', [
        'Catalog',
        '<abbr title="Maximum Modified Mercalli Intensity">MMI</abbr>',
        'Source',
        'Description'
      ], _this.getShakeMapRow);
  };

  /**
   * Gets a single summary row for the single given product.
   *
   * @param product {Product}
   *     The product to summarize.
   * @param index {Number}
   *     The relative preferred number for the given product.
   *     0 = most preferred
   *
   * @return {DOMElement}
   *     A TR DOM Element for the row summary.
   */
  _this.getShakeMapRow = function (product, index) {
    var preferred,
        row;

    preferred = (index === 0);
    row = _this.createRow(preferred);

    row.innerHTML = [
      '<th scope="row">',
        _this.getCatalogMarkup(ShakeMapModule, product, preferred),
      '</th>',
      '<td>',
        _formatter.intensity(product.getProperty('maxmmi')),
      '</td>',
      '<td>',
        Attribution.getProductAttribution(product),
      '</td>',
      '<td>',
        product.getProperty('event-description') || '&ndash;',
      '</td>'
    ].join('');

    return row;
  };

  /**
   * Renders the summary content. Defers to sub-methods.
   *
   */
  _this.render = function () {
    var dyfi,
        fragment,
        header,
        link,
        pager,
        shakemap,
        text;

    fragment = document.createDocumentFragment();

    _this.clearTexts(true);
    _this.clearLinks(true);

    header = _this.getProducts('impact-header');
    dyfi = _this.getProducts('dyfi');
    shakemap = _this.getProducts('shakemap');
    pager = _this.getProducts('losspager');

    text = _this.getProducts('impact-text');
    link = _this.getProducts('impact-link');

    Util.empty(_this.header);
    _this.header.appendChild(_this.getTexts(header));

    fragment.appendChild(_this.getDyfiSummary(dyfi));
    fragment.appendChild(_this.getShakeMapSummary(shakemap));
    fragment.appendChild(_this.getPagerSummary(pager));
    fragment.appendChild(_this.getTexts(text));
    fragment.appendChild(_this.getLinks(link));

    Util.empty(_this.content);
    _this.content.appendChild(fragment);

    _this.footer.innerHTML = '';
  };


  _initialize(options);
  options = null;
  return _this;
};


ImpactSummaryModule.ID = _ID;
ImpactSummaryModule.TITLE = _TITLE;
ImpactSummaryModule.TYPES = _TYPES;


module.exports = ImpactSummaryModule;

},{"core/Attribution":"core/Attribution","core/Formatter":"core/Formatter","core/SummaryModule":"core/SummaryModule","dyfi/DYFIModule":"dyfi/DYFIModule","losspager/PAGERModule":"losspager/PAGERModule","shakemap/ShakeMapModule":"shakemap/ShakeMapModule","util/Util":"util/Util"}],"losspager/PAGERModule":[function(require,module,exports){
'use strict';


var ImpactSummaryModule = require('impact/ImpactSummaryModule'),
    Module = require('core/Module'),
    PagerView = require('losspager/PAGERView'),
    Util = require('util/Util');


var _ID,
    _TITLE,
    _TYPES;

_ID = 'pager';
_TITLE = 'PAGER';
_TYPES = ['losspager'];


var PAGERModule = function (options) {
  var _this,
      _initialize,

      _pagerView;

  options = Util.extend({}, options);
  _this = Module(options);

  _initialize = function () {
    _this.ID = _ID;
    _this.TITLE = _TITLE;
  };


  _this.destroy = Util.compose(function () {
    if (_pagerView) {
      _pagerView.destroy();
    }

    _pagerView = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Renders the details for this module. Defers bulk of header Information
   * to generalized header rendering. Uses {PAGERView} for bulk of content
   * rendering.
   *
   */
  _this.render = function () {
    var downloads,
        product;

    _this.header.innerHTML = '<h3>PAGER</h3>';

    product = _this.getProduct('losspager');
    if (!product) {
      _this.content.innerHTML =
          '<p class="alert warning">No PAGER Found</p>';
    } else {
      _this.header.appendChild(_this.getProductHeader({
        product: product,
        summaryModule: ImpactSummaryModule
      }));

      if (!_pagerView) {
        _pagerView = PagerView({
          el: _this.content,
          model: product
        });
      }

      _pagerView.render();

      downloads = _this.getProductFooter({product: product});
    }

    _this.footer.innerHTML =
      '<h3>For More Information</h3>' +
      '<ul>' +
        '<li>' +
          '<a href="/data/pager/">Scientific Background for PAGER</a>' +
        '</li>' +
      '</ul>';

    if (downloads) {
      _this.footer.appendChild(downloads);
    }
  };


  _initialize();
  options = null;
  return _this;
};


PAGERModule.ID = _ID;
PAGERModule.TITLE = _TITLE;
PAGERModule.TYPES = _TYPES;


module.exports = PAGERModule;

},{"core/Module":"core/Module","impact/ImpactSummaryModule":"impact/ImpactSummaryModule","losspager/PAGERView":"losspager/PAGERView","util/Util":"util/Util"}],"losspager/PAGERPinView":[function(require,module,exports){
'use strict';


var BasicPinView = require('core/BasicPinView'),
    Formatter = require('core/Formatter'),
    PAGERModule = require('losspager/PAGERModule'),
    Util = require('util/Util');

var _DEFAULTS = {
  module: PAGERModule
};


var PAGERPinView = function (options) {
  var _this,
      _initialize,

      _formatter;


  options = Util.extend({}, _DEFAULTS, options);
  _this = BasicPinView(options);

  _initialize = function (options) {
    _formatter = options.formatter || Formatter();
  };

  /**
   * Render the histograms as PAGERPinView content
   *
   */
  _this.renderPinContent = function () {
    var economic,
        fatality,
        markup;

    markup = [];
    economic = _this.model.getContent('alertecon_smaller.png');
    fatality = _this.model.getContent('alertfatal_smaller.png');

    if (economic) {
      markup.push('<span>Estimated Economic Losses</span>' +
          '<img src="' + economic.get('url') + '" />');
    }

    if (fatality) {
      markup.push('<span>Estimated Fatalities</span>' +
          '<img src="' + fatality.get('url') + '" />');
    }

    _this.content.innerHTML = markup.join('');
  };

  /**
   * Render header for PAGERPinView with impact bubble
   *
   */
  _this.renderPinHeader = Util.compose(_this.renderPinHeader, function () {
    var alertlevel;

    alertlevel = _this.model.getProperty('alertlevel');
    if (alertlevel) {
      _this.header.insertAdjacentHTML('beforeend',
        '<span class="pager-bubble bubble-border pager-alertlevel-' +
            alertlevel + '">' +
          '<strong class="roman">' +
            alertlevel.toUpperCase() +
          '</strong>' +
        '</span>'
      );
    }
  });


  _initialize(options);
  options = null;
  return _this;
};

module.exports = PAGERPinView;

},{"core/BasicPinView":"core/BasicPinView","core/Formatter":"core/Formatter","losspager/PAGERModule":"losspager/PAGERModule","util/Util":"util/Util"}],"losspager/PAGERView":[function(require,module,exports){
'use strict';

var PagerXmlParser = require('losspager/PagerXmlParser'),
    ProductView = require('core/ProductView'),
    Util = require('util/Util'),
    Xhr = require('util/Xhr');

var _DEFAULTS;

_DEFAULTS = {
  errorMessage: 'Error loading PAGER view'
};

var _createHistogram = function (container, title, pdf, png, caption) {
  var figure,
      figureMarkup,
      header;

  header = container.appendChild(document.createElement('h3'));
  header.innerHTML = title;
  figureMarkup = [];

  if (pdf && png) {
    figure = container.appendChild(document.createElement('figure'));
    figureMarkup.push('<a href="' + pdf.get('url') + '">');
    figureMarkup.push('<img src="' + png.get('url') + '" alt=""/>');
    figureMarkup.push('</a>');
    if (caption) {
      figureMarkup.push('<figcaption>' + caption + '</figcaption>');
    }
    figure.innerHTML = figureMarkup.join('');
  } else {
    figure = container.appendChild(document.createElement('p'));
    figure.innerHTML = 'Alert information unavailable';
  }

  return container;
};


/**
 * View for losspager product.
 *
 * @param options {object}
 *    all options are passed to ProductView.
 */
var PAGERView = function (options) {
  var _this,
      _initialize,

      _commentEl,
      _economicHistogramEl,
      _errorMessage,
      _exposureCityEl,
      _exposureCityTable,
      _exposureCityToggle,
      _exposureMapEl,
      _exposurePopulationEl,
      _fatalityHistogramEl,
      _pagerInfo,
      _pendingMessageEl;

  _this = ProductView(options);

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options || {});
    _errorMessage = options.errorMessage;
    _this.createScaffolding();
  };

  /**
   * Utility method to create exposure item markup.
   *
   * @param exposure {Object}
   *      The exposure level for which to create an element.
   *
   * @return {String}
   *      The markup.
   */
  _this.createExposureItem = function (exposure) {
    return '<tr>' +
      '<td class="exposure-mmi">' +
        '<span class="roman mmi ' + exposure.css + '">' +
        exposure.label + '</span>' +
      '</td>' +
      '<td class="exposure-perc">' + exposure.perc + '</td>' +
      '<td class="exposure-population">' + exposure.populationDisplay +
          '</td>' +
    '</tr>';
  };

  /**
   * Sets up basic layout of the Pager view and loads everything that can
   * be pulled from the model.
   */
  _this.createScaffolding = function () {
    _this.el.classList.add('losspager');
    _this.el.innerHTML =
      '<div class="alert-wrapper row">' +
        '<div class="column one-of-one pager-pending"></div>' +
        '<div class="column one-of-two fatality-histogram"></div>' +
        '<div class="column one-of-two economic-histogram"></div>' +
      '</div>' +
      '<div class="row pager-content">' +
        '<div class="column one-of-two">' +
          '<h3>Estimated Population Exposure to Earthquake Shaking</h3>' +
          '<div class="exposure-map"></div>' +
          '<div class="exposure-population"></div>' +
        '</div>' +
        '<div class="column one-of-two">' +
          '<div class="comment-wrapper"></div>' +
          '<div class="exposure-city">' +
            '<h3>Selected Cities Exposed</h3>' +
            '<div class="horizontal-scrolling">' +
              '<table class="pager-cities"></table>' +
            '</div>' +
            '<span class="pager-disclaimer">' +
              'From GeoNames Database of Cities with 1,000 or more ' +
              'residents (k = x1,000)' +
            '</span>' +
            '<button class="toggle">Show/Hide Full City List</button>' +
          '</div>' +
        '</div>' +
      '</div>';

    _pendingMessageEl = _this.el.querySelector('.pager-pending');
    _fatalityHistogramEl = _this.el.querySelector('.fatality-histogram');
    _economicHistogramEl = _this.el.querySelector('.economic-histogram');

    _exposureMapEl = _this.el.querySelector('.exposure-map');
    _exposurePopulationEl = _this.el.querySelector('.exposure-population');

    _commentEl = _this.el.querySelector('.comment-wrapper');
    _exposureCityEl = _this.el.querySelector('.exposure-city');
    _exposureCityToggle = _exposureCityEl.querySelector('.toggle');
    _exposureCityTable = _exposureCityEl.querySelector('.pager-cities');

    _exposureCityToggle.addEventListener('click', _this.onCityClick);
  };

  /**
   * Destroy all the things.
   */
  _this.destroy = Util.compose(function () {
    _commentEl = null;
    _economicHistogramEl = null;
    _errorMessage = null;
    _exposureCityEl = null;
    _exposureCityTable = null;
    _exposureCityToggle = null;
    _exposureMapEl = null;
    _exposurePopulationEl = null;
    _fatalityHistogramEl = null;
    _pagerInfo = null;
    _pendingMessageEl = null;


    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Gets the data.
   */
  _this.fetchData = function () {
    var content;

    content = _this.model.getContent('pager.xml');

    if(!content) {
      _this.onError();
      return;
    }

    Xhr.ajax({
      url: content.get('url'),
      success: _this.onSuccess,
      error: _this.onError
    });
  };

  /**
   * Uses correct comments.
   *
   * @param commentType {String};
   *    String can be fatality or economic.
   */
  _this.getAlertComment = function (commentType) {
    var comments,
        economicComment,
        fatalityComment;

    if (_pagerInfo && _pagerInfo.comments) {
      comments = _pagerInfo.comments.impact;
    }

    if (!comments) {
      return '';
    }

    if (comments.length === 2) {
      if (comments[0] !== '') {
        fatalityComment = comments[0];
        economicComment = comments[1];
      } else {
        fatalityComment = comments[1];
      }
    } else {
      fatalityComment = comments[0];
    }

    if (commentType === 'fatality') {
      return fatalityComment;
    } else if (commentType === 'economic') {
      return economicComment;
    }
  };

  /**
   * Event handler for click events on city list toggle control.
   */
  _this.onCityClick = function () {
    _exposureCityTable.classList.toggle('show-additional');
  };

  /**
   * This method is called when there is a problem.
   *
   * @param errorMessage {String}
   *    A description of the error that occurred.
   */
  _this.onError = function () {
    _this.el.innerHTML = _errorMessage;
  };

  /**
   * This method is called when Xhr is successful and calles all methods
   * that render PAGER content.
   */
  _this.onSuccess = function (data, xhr) {
    var xml;

    xml = ((xhr && xhr.responseXML) ? xhr.responseXML : data);

    _pagerInfo = PagerXmlParser.parse(xml);

    _this.renderFatalityHistogram();
    _this.renderEconomicHistogram();
    _this.renderExposures();
    _this.renderCities();
    _this.renderComments();
  };

  /**
   * Called when the model changes. Initially sets a loading message
   */
  _this.render = function () {
    _this.renderPending();

    _this.renderExposureMap();
    _this.fetchData();
  };

  /**
   * Adds the nearby cities list to the page. Cities have a very special sorting
   * algorithm. The first 11 cities are displayed by default and a control is
   * used to show/hide additional cities.
   */
  _this.renderCities = function () {
    var cities,
        city,
        i,
        len,
        markup;

    markup = [];
    cities = _pagerInfo.cities;
    len = cities.length;

    if (len <= 11) {
      _exposureCityEl.style.display = 'none';
    }

    markup.push(
        '<thead>' +
          '<tr>' +
            '<th><abbr title="Modified Mercalli Intensity">MMI</abbr></th>' +
            '<th>City</th>' +
            '<th><abbr title="Population">Pop.</abbr></th>' +
          '</tr>' +
        '</thead>'
    );

    for (i = 0; i < len; i++) {
      city = cities[i];

      markup.push(
        '<tr class="' + ((i>10)?'city-additional':'') +'">' +
          '<td class="cities-mmi">' +
            '<span class="roman mmi ' + city.css + '">' +
              city.roman +
            '</span>' +
          '</td>' +
          '<td>' + city.name + '</td>' +
          '<td class="cities-population">' + city.populationDisplay + '</td>' +
        '</tr>'
      );
    }

    markup.push(
      '</tbody>'
    );

    if (len === 0) {
      _exposureCityEl.parentNode.removeChild(_exposureCityEl);
      _exposureCityEl = null;
    } else {
      _exposureCityTable.innerHTML = markup.join('');
    }
  };

  /**
   * Adds the structure comment and secondary effects comments to the page.
   */
  _this.renderComments = function () {
    var comments = _pagerInfo.comments,
        markup = [];

    if (comments.hasOwnProperty('structure')) {
      markup.push(
        '<div class="wrapper">' +
          '<h3>Structure Information Summary</h3>' +
          '<p>' + comments.structure + '</p>' +
        '</div>'
      );
    }

    if (comments.hasOwnProperty('effects')) {
      markup.push(
        '<div class="wrapper">' +
          '<h3>Secondary Effects</h3>' +
          '<p>' + comments.effects + '</p>' +
        '</div>'
      );
    }

    if (markup.length) {
      _commentEl.innerHTML = markup.join('');
    } else {
      // If no comments, remove this section
      _commentEl.parentNode.removeChild(_commentEl);
      _commentEl = null;
    }
  };

  /**
   * Sends _createHistogram the params needed to render economic
   * histogram.
   */
  _this.renderEconomicHistogram = function () {
      var alertLevel,
          comment,
          pdf,
          png;

      alertLevel = _this.model.getProperty('alertlevel');
      comment = _this.getAlertComment('economic');
      png = _this.model.getContent('alertecon_small.png') ||
          _this.model.getContent('alertecon.png');
      pdf = _this.model.getContent('alertecon.pdf');

      if (alertLevel !== 'pending') {
        return _createHistogram(_economicHistogramEl, 'Estimated Economic Losses',
          pdf, png, comment);
      }
  };

  /**
   * Creates markup for exposure map.
   */
  _this.renderExposureMap = function () {
    var content;

    content = _this.model.getContent('exposure.png');

    if (content) {
      _exposureMapEl.innerHTML = [
        '<figure>',
          '<img src="', content.get('url'), '" alt="Population Exposure Map"/>',
          '<figcaption>',
            'Population per ~1 sq. km. from LandScan',
          '</figcaption>',
        '</figure>'
      ].join('');
    } else {
      _exposureMapEl.innerHTML = '&ndash;';
    }
  };

  /**
   * Adds exposure table info to PAGER view.
   */
  _this.renderExposures = function () {
    var exposure,
        exposures,
        i,
        len,
        markup;

    markup = [];
    exposures = _pagerInfo.exposures;
    len = exposures.length;

    if (len === 0) {
      _exposurePopulationEl.parentNode.removeChild(_exposurePopulationEl);
      _exposurePopulationEl = null;
      return;
    }

    markup.push(
      '<div class="horizontal-scrolling">' +
      '<table class="pager-exposures">' +
        '<thead>' +
          '<tr>' +
            '<th><abbr title="Modified Mercalli Intensity">MMI</abbr></th>' +
            '<th><abbr title="Perceived Shaking">Shaking</abbr></th>' +
            '<th><abbr title="Population Exposure">Pop.</abbr></th>' +
          '</tr>' +
        '</thead>' +
        '<tbody>'
      );

    // generate table row content
    for (i = 0; i < len; i++) {
      exposure = exposures[i];
      markup.push(_this.createExposureItem(exposure));
    }

    markup.push(
        '</tbody>' +
      '</table>' +
      '</div>' +
      '<span class="pager-disclaimer">' +
        '*Estimated exposure only includes population within ' +
        'map area (k = x1,000)' +
        '</br><a href="https://earthquake.usgs.gov/research/shakemap/#intmaps">'+
        'Modified Mercalli Intensity (MMI) scale</a>' +
      '</span>'
    );

    _exposurePopulationEl.innerHTML = markup.join('');
  };

  /**
   * Sends _createHistogram the params needed to render fatality
   * histogram.
   */
  _this.renderFatalityHistogram = function () {
      var alertLevel,
          comment,
          pdf,
          png;

      alertLevel = _this.model.getProperty('alertlevel');
      comment = _this.getAlertComment('fatality');
      png = _this.model.getContent('alertfatal_small.png') ||
          _this.model.getContent('alertfatal.png');
      pdf = _this.model.getContent('alertfatal.pdf');

      if (alertLevel !== 'pending') {
        return _createHistogram(_fatalityHistogramEl, 'Estimated Fatalities',
            pdf, png, comment);
      }
  };

  /**
   * Adds pending markup if alertLevel is equal to pending.
   */
  _this.renderPending = function () {
    var alertLevel;

    alertLevel = _this.model.getProperty('alertlevel');

    if (alertLevel === 'pending') {
      _pendingMessageEl.innerHTML = [
        '<p class="info alert">',
          'Alert information for this event is currently under review and ',
          'will be available soon. Thank you for your patience.',
        '</p>'
      ].join('');
    }
  };

  /**
   * Sets the pagerInfo to be rendered.
   *
   * @param pagerInfo {Object}
   *     The PAGER info to use for rendering.
   */
  _this.setPagerInfo = function (pagerInfo) {
    _pagerInfo = pagerInfo;
  };


  _initialize(options);
  options = null;
  return _this;
};

module.exports = PAGERView;

},{"core/ProductView":"core/ProductView","losspager/PagerXmlParser":"losspager/PagerXmlParser","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"losspager/PagerXmlParser":[function(require,module,exports){
'use strict';

var Util = require('util/Util');


var XML_VERSION_STRING = '1.0'; // pager.xml version number

// Meta info about the exposure levels
var EXPOSURE_INFO = [
  // MMI-0 doesn't exist, but arrays are zero-indexed, this is a placeholder
  {perc:'Not Felt',resist:'none',vuln:'none',roman:'I',label:'I',css:'mmiI'},
  {perc:'Not Felt',resist:'none',vuln:'none',roman:'I',label:'I',css:'mmiI'},

  // MMI-II and MMI-III are combined, need separate placeholders
  {perc:'Weak',resist:'none',vuln:'none',roman:'II',label:'II-III',
      css:'mmiII'},
  {perc:'Weak',resist:'none',vuln:'none',roman:'III',label:'II-III',
      css:'mmiIII'},

  {perc:'Light',resist:'none',vuln:'none',roman:'IV',label:'IV',css:'mmiIV'},
  {perc:'Moderate',resist:'Very Light',vuln:'Light',roman:'V',label:'V',
      css:'mmiV'},
  {perc:'Strong',resist:'Light',vuln:'Moderate',roman:'VI',label:'VI',
      css:'mmiVI'},
  {perc:'Very Strong',resist:'Moderate',vuln:'Moderate/Heavy',roman:'VII',
      label:'VII',css:'mmiVII'},
  {perc:'Severe',resist:'Moderate/Heavy',vuln:'Heavy',roman:'VIII',
      label:'VIII',css:'mmiVIII'},
  {perc:'Violent',resist:'Heavy',vuln:'Very Heavy',roman:'IX',label:'IX',
      css:'mmiIX'},
  {perc:'Extreme',resist:'Very Heavy',vuln:'Very Heavy',roman:'X',label:'X',
      css:'mmiX'},
  {perc:'Extreme',resist:'Very Heavy',vuln:'Very Heavy',roman:'XI',label:'XI',
      css:'mmiX'},
  {perc:'Extreme',resist:'Very Heavy',vuln:'Very Heavy',roman:'XII',
      label:'XII',css:'mmiX'}
];


/**
 * Sorts the cities so the first 11 in the list of the "selected" cities and
 * the remainder of the list is sorted by MMI (decreasing).
 *
 * @param cities {Array}
 *      An array of city information to sort. This array is modified in-place,
 *      so callers of this method should be careful to pass in a copy
 *      (Array.slice) of the array if they need the original to remain
 *      unchanged.
 *
 * @return {Array}
 *      A specially-sorted array of city information.
 */
var _sortCities = function (cities) {
  var sortedCities = [];

  function compareMmi (a, b) {
    return b.mmi - a.mmi;
  }

  function comparePopulation (a, b) {
    return b.population - a.population;
  }

  function compareCapital (a, b) {
    var acap = a.isCapital,
        bcap = b.isCapital;

    if ((acap && bcap) || (!acap && !bcap)) {
      return comparePopulation(a, b);
    } else if (acap) {
      return -1;
    } else if (bcap) {
      return 1;
    }

    return comparePopulation(a, b);
  }

  // Sort by largest MMI first
  cities.sort(compareMmi);
  // Take up to first 6-largest MMI
  Array.prototype.push.apply(sortedCities, cities.splice(0, 6));

  // Sort by capital/population
  cities.sort(compareCapital);
  // Take up to first 5-capitals
  while (cities.length && cities[0].isCapital && sortedCities.length < 11) {
    sortedCities.push(cities.splice(0, 1)[0]);
  }

  // Sort by population
  cities.sort(comparePopulation);
  // Fill in any remaining selections based on population
  while (cities.length && sortedCities.length < 11) {
    sortedCities.push(cities.splice(0, 1)[0]);
  }

  // Sort each part by MMI and combine to a single list
  return sortedCities.sort(compareMmi).concat(cities.sort(compareMmi));
};

/**
 * Injects thousands number separator between each segment.
 *
 * @param number {Integer}
 *      The number to format.
 * @param separator {String} Optional.
 *      The string to use as a thousands separator. Default ','.
 *
 * @return {String}
 *      The number with thousands segments separator by separator.
 */
var _injectNumberSeparator = function (number, separator) {
  separator = separator || ',';
  return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, separator);
};

/**
 * Format the population for the city list display.
 *
 * @param population {Integer}
 *      The population value to format.
 *
 * @return {String}
 *      A formatted display value representing the population.
 */
var _formatCityPopulation = function (population) {
  if (population < 1000) {
    return '&lt;1 k';
  } else {
    return _injectNumberSeparator(Math.round(population / 1000)) + ' k';
  }
};

/**
 * Format population for the exposure table display.
 *
 * @param population {Integer}
 *      The population value to format.
 * @param incomplete {Boolean} Optional. Default: false
 *      True if the exposure contour corresponding to this population value
 *      extends beyond the mapped boundary, false otherwise.
 *
 * @return {String}
 *      A formated display value representing the population.
 */
var _formatExposurePopulation = function (population, incomplete) {
  var display = _injectNumberSeparator(Math.round(population / 1000)) + ' k';

  if (incomplete) {
    if (population === 0) {
        display = '--';
    }

    display += '*';
  }

  return display;
};


// ----------------------------------------------------------------------
// Parsing functions for each component piece of data
// ----------------------------------------------------------------------

/**
 * @param xml {Document}
 *      The XML document from which to parse alert information.
 *
 * @return {Object}
 *      An object of parsed alert information. Keyed by alert type.
 */
var _parseAlerts = function (xml) {
  var alert,
      type,
      bins,
      binIter,
      numBins,
      bin,
      alerts = xml.querySelectorAll('pager > alerts > alert'),
      alertIter = 0,
      numAlerts = alerts.length,
      data = {};

  for (; alertIter < numAlerts; alertIter++) {
    alert = alerts[alertIter];
    type = alert.getAttribute('type');

    data[alert.getAttribute('type')] = {
      level: alert.getAttribute('level'),
      units: alert.getAttribute('units'),
      bins: []
    };

    bins = alert.querySelectorAll('bin');
    for (binIter = 0, numBins = bins.length; binIter < numBins; binIter++) {
      bin = bins[binIter];

      data[type].bins.push({
        min: bin.getAttribute('min'),
        max: bin.getAttribute('max'),
        prob: bin.getAttribute('probability'),
        color: bin.getAttribute('color')
      });
    }
  }

  return data;
};

/**
 * @param xml {Document}
 *      The XML document from which to parse exposure information.
 *
 * @return {Array}
 *      An array of parsed exposure information.
 */
var _parseExposures = function (xml) {
  var exposure,
      binMin,
      binMax,
      population,
      onMap,
      sumPop,
      sumOnMap,
      exposures = xml.querySelectorAll('pager > exposure'),
      exposureIter = 0,
      numExposures = exposures.length,
      data = [];

  for (; exposureIter < numExposures; exposureIter++) {
    exposure = exposures[exposureIter];

    binMin = parseFloat(exposure.getAttribute('dmin'));
    binMax = parseFloat(exposure.getAttribute('dmax'));
    population = parseInt(exposure.getAttribute('exposure'), 10);
    onMap = (exposure.getAttribute('rangeInsideMap') === '1');

    data.push(Util.extend({},
      EXPOSURE_INFO[Math.round(binMin)],
      {
        min: binMin,
        max: binMax,
        population: population,
        onMap: onMap,
        populationDisplay: _formatExposurePopulation(population, !onMap),
      }
    ));
  }

  // Generally not required. If it becomes a problem, this will sort it out.
  data.sort(function (a, b) {
    return a.min - b.min;
  });

  // Combine bins II-III together
  if (data[1] && data[2]) {
    sumPop = data[1].population + data[2].population;
    sumOnMap = (data[1].onMap && data[2].onMap);

    data.splice(1, 2, {
      min: data[1].min,
      max: data[2].max,
      population: sumPop,
      onMap: sumOnMap,
      populationDisplay: _formatExposurePopulation(sumPop, !sumOnMap),
      perc:data[1].perc,
      resist:data[1].resist,
      vuln:data[1].vuln,
      label:data[1].label,
      css:data[1].css
    });
  }

  return data;
};

/**
 * @param xml {Document}
 *      The XML document from which to parse city information.
 *
 * @return {Array}
 *      An array of parsed city information.
 */
var _parseCities = function (xml) {
  var city,
      population,
      mmi,
      cities = xml.querySelectorAll('pager > city'),
      cityIter = 0,
      numCities = cities.length,
      data = [];

  for (; cityIter < numCities; cityIter++) {
    city = cities[cityIter];
    population = parseInt(city.getAttribute('population'), 10);
    mmi = parseFloat(city.getAttribute('mmi'));

    data.push(Util.extend({},
      EXPOSURE_INFO[Math.round(mmi)],
      {
        name: city.getAttribute('name'),
        latitude: parseFloat(city.getAttribute('lat')),
        longitude: parseFloat(city.getAttribute('lon')),
        population: population,
        populationDisplay: _formatCityPopulation(population),
        mmi: mmi,
        isCapital: (city.getAttribute('iscapital') === '1')
      }
    ));
  }

  // Sort so first 10 cities are "selected" cities
  data = _sortCities(data);

  return data;
};

/**
 * @param xml {Document}
 *      The XML document from which to parse comment information.
 *
 * @return {Object}
 *      An object containing parsed comment information. Keyed by comment
 *      type.
 */
var _parseComments = function (xml) {
  var comment,
      data = {};

  // TODO :: Check old comment parsing and make sure it remains consistent
  comment = xml.querySelectorAll('pager > structcomment');
  if (comment && comment.length) {
    data.structure = comment[0].textContent.trim();
  }

  comment = xml.querySelectorAll('pager > secondary_effects');
  if (comment && comment.length) {
    comment = comment[0].textContent.trim();
    if (comment !== '') {
      data.effects = comment;
    }
  }

  // TODO :: This is a cluster. PAGER team should sort out a better way to
  //         send comments of this nature.
  comment = xml.querySelectorAll('pager > impact_comment');
  if (comment && comment.length) {
    data.impact = comment[0].textContent.trim().split('#').reverse();
    if (data.impact[0].indexOf('economic') !== -1) {
      data.impact.reverse();
    }
  }

  return data;
};


// ----------------------------------------------------------------------
// Return the parser object with API methods
// ----------------------------------------------------------------------

var PagerXmlParser = {
  /**
   * @return {String}
   *      The version identifier for which this parser is compatible.
   */
  version: function () {
    return XML_VERSION_STRING;
  },

  /**
   * Parses an XML string/object into an object with PAGER information.
   *
   * @return {Object}
   *      An object containing PAGER information.
   */
  parse: function (xml) {
    var domParser;

    if (typeof xml === 'string') {
      domParser = new DOMParser();
      xml = domParser.parseFromString(xml, 'application/xml');
    }

    return {
      alerts: _parseAlerts(xml),
      exposures: _parseExposures(xml),
      cities: _parseCities(xml),
      comments: _parseComments(xml)
    };
  }
};


module.exports = PagerXmlParser;

},{"util/Util":"util/Util"}],"map/ContoursLayer":[function(require,module,exports){
/* global L */
'use strict';


var Formatter = require('core/Formatter'),
    Util = require('util/Util');

require('leaflet/layer/AsynchronousGeoJson');


var _DEFAULTS,
    _FORMATTER;

_DEFAULTS = {
  clickable: true,

  style: function (feature) {
    return {
      color: feature.properties.color,
      weight: feature.properties.weight,
      opacity: 1.0
    };
  },

  onEachFeature: function (feature, layer) {
    var roman;

    roman = _FORMATTER.mmi(feature.properties.value);

    if (this.clickable) {
      layer.bindPopup(
          '<div class="roman station-summary-intensity mmi' + roman + '">' +
            roman +
            '<br><abbr title="Modified Mercalli Intensity">mmi</abbr>' +
          '</div>');
    }
  }
};

_FORMATTER = Formatter();


var ContoursLayer = L.AsynchronousGeoJson.extend({

  initialize: function (options) {
    L.AsynchronousGeoJson.prototype.initialize.call(this,
        Util.extend({}, _DEFAULTS, options));
  }

});


L.ContoursLayer = ContoursLayer;

L.contoursLayer = function (options) {
  return new ContoursLayer(options);
};


module.exports = L.contoursLayer;

},{"core/Formatter":"core/Formatter","leaflet/layer/AsynchronousGeoJson":11,"util/Util":"util/Util"}],"map/DyfiUtmLayer":[function(require,module,exports){
/* global L */
'use strict';

var Formatter = require('core/Formatter'),
    Util = require('util/Util');

require('leaflet/layer/AsynchronousGeoJson');


var _DEFAULT_FORMATTER = Formatter();

var _DEFAULT_OPTIONS = {
  style: function (feature) {
    var color = _DEFAULT_FORMATTER.mmiColor(feature.properties.cdi);
    return {
      color: '#999',
      fillColor: color,
      fillOpacity: 0.9,
      opacity: 0.9,
      weight: 0.5
    };
  },

  onEachFeature: function (feature, layer) {
    layer.bindPopup(this.formatPopup(feature));
  },

  formatPopup: function (feature) {
    var mmi,
        p;

    p = feature.properties;
    mmi = _DEFAULT_FORMATTER.mmi(p.cdi);

    return '<div class="dyfi-popup">' +
      '<h2 class="dyfi-name">' + p.name + '</h2>' +
      '<ul class="dyfi-summary">' +
        '<li class="dyfi-summary-intensity roman mmi' + mmi + '">' +
          mmi +
          '<br/><abbr title="Community Determined Intensity">cdi</abbr>' +
        '</li>' +
        '<li class="dyfi-summary-nresp">' +
          _DEFAULT_FORMATTER.number(p.nresp, 0, '&ndash;') +
          '<br/><abbr title="Number of Responses">responses</abbr>' +
        '</li>' +
        '<li class="dyfi-summary-distance">' +
          _DEFAULT_FORMATTER.number(p.dist, 0, '&ndash;', 'km') +
          '<br/><abbr title="Distance from Hypocenter">distance</abbr>' +
        '</li>' +
      '</ul>' +
    '</div>';
  }
};


var DyfiUtmLayer = L.AsynchronousGeoJson.extend({

  initialize: function (options) {
    L.AsynchronousGeoJson.prototype.initialize.call(this,
        Util.extend({}, _DEFAULT_OPTIONS, options));
  }

});


L.DyfiUtmLayer = DyfiUtmLayer;

L.dyfiUtmLayer = function (options) {
  return new DyfiUtmLayer(options);
};


module.exports = L.dyfiUtmLayer;

},{"core/Formatter":"core/Formatter","leaflet/layer/AsynchronousGeoJson":11,"util/Util":"util/Util"}],"map/InteractiveMapModule":[function(require,module,exports){
'use strict';


var Events = require('util/Events'),
    InteractiveMapView = require('map/InteractiveMapView'),
    ModalView = require('mvc/ModalView'),
    Module = require('core/Module'),
    Util = require('util/Util');


var _DEFAULTS,
    _ID,
    _TITLE,
    _TYPES;

_ID = 'map';
_TITLE = 'Interactive Map';
_TYPES = ['origin'];

_DEFAULTS = {

};


/**
 * The module handles interaction between the InteractiveMapView and the larger
 * EventPage framework. There are two top-level components to this module:
 *
 * The first is the background, in-page, content. This content is very simple
 * and only used as a fallback to allow navigation or to re-open the modal view.
 *
 * The second top-level component is the modal view itself. This view provides
 * the container into which the map itself will be rendered.
 *
 * Closing the map will navigate the page to either (1) the previous EventPage
 * module that the user was viewing or (2) the default EventPage module in the
 * case that the user was linked directly into the map.
 *
 * @param options {Object}
 *      See documentation on _initialize method for details.
 */
var InteractiveMapModule = function (options) {
  var _this,
      _initialize,

      _closeButton,
      _mapView,
      _modal,
      _scenarioBadge;


  options = Util.extend({}, _DEFAULTS, options);
  _this = Module(options);

  /**
   * Initialize the new module.
   *
   * @param options {Object}
   */
  _initialize = function (options) {
    var config;

    _this.ID = _ID;
    _this.TITLE = _TITLE;
    _this.TYPES = _TYPES;

    config = _this.model.get('config');

    _this.content.addEventListener('click', _this.onContentClick);

    _mapView = InteractiveMapView({
      formatter: options.formatter,
      model: _this.model,
      module: _this
    });

    _modal = ModalView(_mapView.el, {
      buttons: null, // no footer
      title: null    // no header
    });

    _modal.el.classList.add('modal-map');
    _this.appendCloseButton();

    if (config && config.SCENARIO_MODE === true) {
      _this.appendScenarioBadge();
    }
  };


  _this.appendCloseButton = function () {
    if (!_closeButton) {
      _closeButton = _modal.el.appendChild(document.createElement('button'));
      _closeButton.classList.add('cancel');
      _closeButton.classList.add('modal-close');
      _closeButton.innerHTML = 'Close Map';

      _closeButton.addEventListener('click', _this.onCloseButtonClick);
    }
  };

  _this.appendScenarioBadge = function () {
    if (!_scenarioBadge) {
      _scenarioBadge = _modal.el.appendChild(document.createElement('div'));
      _scenarioBadge.classList.add('scenario-badge');
      _scenarioBadge.classList.add('leaflet-control');
      _scenarioBadge.innerHTML = 'Scenario';
    }
  };

  /**
   * Free resources associated with this Module and then call parent
   * destroy method as well.
   *
   */
  _this.destroy = Util.compose(function () {
    _this.content.removeEventListener('click', _this.onContentClick);
    _closeButton.removeEventListener('click', _this.onCloseButtonClick);

    _mapView.destroy();
    _modal.hide();
    _modal.destroy();

    _mapView = null;
    _modal = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  _this.onCloseButtonClick = function () {
    Events.trigger('back');
  };

  /**
   * Delegatede event listener to capture clicks on the button and show
   * the modal view. This is a fallback so user can get back to map if
   * they somehow end up viewing the background content of this module.
   *
   */
  _this.onContentClick = function (ev) {
    if (ev.target && ev.target.classList.contains('show-map')) {
      _this.showMap();
    }
  };

  /**
   * Renders the background information and then shows the map.
   *
   */
  _this.render = function () {
    // Do basic background rendering stuff. This will largely go unseen.
    _this.header.innerHTML = '<a class="back-to-summary-link" ' +
        'href="#">Back to General Summary</a>';
    _this.content.innerHTML = '<button class="show-map">Show Map</button>';
    _this.footer.innerHTML = '';

    _this.showMap();
  };

  /**
   * Shows the map and notifies the sub-view that its content is in the DOM
   * so the view can invalidate dimensions etc...
   *
   */
  _this.showMap = function () {
    _modal.show();
    _mapView.onDomReady();
  };


  _initialize(options);
  options = null;
  return _this;
};


InteractiveMapModule.ID = _ID;
InteractiveMapModule.TITLE = _TITLE;
InteractiveMapModule.TYPES = _TYPES;


module.exports = InteractiveMapModule;

},{"core/Module":"core/Module","map/InteractiveMapView":"map/InteractiveMapView","mvc/ModalView":37,"util/Events":"util/Events","util/Util":"util/Util"}],"map/InteractiveMapPinView":[function(require,module,exports){
'use strict';


var Attribution = require('core/Attribution'),
    BasicPinView = require('core/BasicPinView'),
    InteractiveMapView = require('map/InteractiveMapView'),
    Product = require('pdl/Product'),
    Util = require('util/Util');


var _DEFAULTS = {
  module: {ID: 'map', TITLE: 'Interactive Map'}
};


var MapPinView = function (options) {
  var _this,
      _initialize,

      _mapView;

  options = Util.extend({}, _DEFAULTS, options);
  _this = BasicPinView(options);

  /**
   * Initialize the new module.
   *
   * @param options {Object}
   */
  _initialize = function (/*options*/) {
    var el,
        ev;

    el = document.createElement('div');
    el.classList.add('locationview-map');

    ev = _this.model.get('event');

    if (ev) {
      _this.product = ev.getPreferredOriginProduct();
    }

    if (!_this.product) {
      _this.product = Product();
    }

    _this.content.appendChild(el);

    _mapView = InteractiveMapView({
      el: el,
      interactive: false,
      markerSize: 16,
      model: _this.model,
      scaleControl: false
    });
  };

  _this.destroy = Util.compose(function () {
    if (_this === null) {
      return;
    }
    _mapView.destroy();
    _this = null;
  }, _this.destroy);

  _this.renderPinContent = function () {
    _mapView.onDomReady();
    _mapView.render();
  };

  /**
   * Override base function.
   * This pin doesn't have a contributor.
   */
  _this.renderPinFooter = function () {

    _this.footer.innerHTML = 'Contributed by ' +
        Attribution.getProductAttribution(_this.product);
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = MapPinView;

},{"core/Attribution":"core/Attribution","core/BasicPinView":"core/BasicPinView","map/InteractiveMapView":"map/InteractiveMapView","pdl/Product":"pdl/Product","util/Util":"util/Util"}],"map/InteractiveMapView":[function(require,module,exports){
/* global L */
'use strict';


var ContoursLayer = require('map/ContoursLayer'),
    DyfiUtmLayer = require('map/DyfiUtmLayer'),
    Grayscale = require('leaflet/layer/Grayscale'),
    Terrain = require('leaflet/layer/Terrain'),
    Formatter = require('core/Formatter'),
    HazDevLayers = require('leaflet/control/HazDevLayers'),
    HistoricSeismicity = require('leaflet/layer/HistoricSeismicity'),
    Module = require('core/Module'),
    MousePosition = require('leaflet/control/MousePosition'),
    Satellite = require('leaflet/layer/Satellite'),
    Street = require('leaflet/layer/Street'),
    Product = require('pdl/Product'),
    ShakeMapStationLayer = require('map/ShakeMapStationLayer'),
    TectonicPlates = require('leaflet/layer/TectonicPlates'),
    UsFault = require('leaflet/layer/UsFault'),
    Util = require('util/Util'),
    View = require('mvc/View');


// Display names of overlays
var _DYFI_10K_OVERLAY = 'DYFI Responses 10 km',
    _DYFI_1K_OVERLAY = 'DYFI Responses 1 km',
    _DYFI_DEFAULT_OVERLAY = 'DYFI Responses',
    _EPICENTER_OVERLAY = 'Epicenter',
    _FAULTS_OVERLAY = 'U.S. Faults',
    _HIST_SEIS_OVERLAY = 'Historical Seismicity',
    _PLATES_OVERLAY = 'Tectonic Plates',
    _POPULATION_OVERLAY = 'Population Density',
    _SHAKEMAP_CONTOURS = 'ShakeMap MMI Contours',
    _SHAKEMAP_STATIONS = 'ShakeMap Stations';

var _DEFAULTS = {
  config: {
    baseLayer: 'Terrain'
  },
  interactive: true,
  markerSize: 32
};

// Set up what we want enabled by default
_DEFAULTS.config[_EPICENTER_OVERLAY] = 'true';
_DEFAULTS.config[_PLATES_OVERLAY] = 'true';
_DEFAULTS.config[_FAULTS_OVERLAY] = 'true';
_DEFAULTS.config[_SHAKEMAP_CONTOURS] = 'true';


/**
 * Checks if the given latitude/longitude represent a location within the U.S.
 * where the U.S. fault layer has data (so some regions are not considered).
 *
 * @param latitude {Number}
 *     Decimal degrees latitude.
 * @param longitude {Number}
 *     Decimal degrees longitude.
 *
 * @return {Boolean}
 *     True if the location is within the considered U.S., false otherwise.
 */
var __inUs = function (latitude, longitude) {
  // Note :: Only considering U.S. regions that have fault layer data...
  return (
    ( // Contemrinous U.S.
      latitude <= 50.0 && latitude >= 24.6 &&
      longitude <= 65.0 && longitude >= -125.0
    ) ||
    ( // Hawaii
      latitude <= 23.0 && latitude >= 23.0 &&
      longitude <= -154.0 && longitude >= -161.0
    )
  );
};


/**
 * This class is a view that renders an interactive map in a container. It
 * expects a model that is an instance of the EventPageModel (currently an
 * just a generalized {Model} instance with "event" and "config" properties).
 *
 * @param options {Object}
 *     See _initialize method documentation for details.
 */
var InteractiveMapView = function (options) {
  var _this,
      _initialize,

      _baseLayers,
      _defaultConfig,
      _formatter,
      _interactive,
      _layersControl,
      _map,
      _markerSize,
      _module,
      _overlays,
      _positionControl,
      _scaleControl;


  options = Util.extend({}, _DEFAULTS, options);
  _this = View(options);

  /**
   * Constructor. Initializes a new InteractiveMapView.
   *
   * @param options {Object}
   *     Configuration options. Specifically...
   * @param options.model {Model}
   *     The EventPageModel for this view to render.
   * @param options.formatter {Formatter}
   *     The formatting utility class to use when rendering.
   * @param options.scaleControl {boolean}
   *    The scale
   */
  _initialize = function (options) {
    _this.el.classList.add('interactive-map-view');

    _defaultConfig = Util.extend({}, _DEFAULTS.config);
    _module = options.module || Module();

    _formatter = options.formatter || Formatter();
    _interactive = options.interactive;
    _markerSize = options.markerSize;

    _baseLayers = {};
    _overlays = {};

    _map = L.map(_this.el, {
      attributionControl: false,
      boxZoom: _interactive,
      center: [0, 0],
      doubleClickZoom: _interactive,
      dragging: _interactive,
      scrollWheelZoom: _interactive,
      tap: _interactive,
      touchZoom: _interactive,
      zoom: 0,
      zoomAnimation: true,
      zoomControl: _interactive
    });

    // Create the control here, the "getAvailable*" methods determine what
    // is included in this control...
    _layersControl = HazDevLayers(
      _this.getAvailableBaseLayers(),
      {}
    );
    if (_interactive) {
      _map.addControl(_layersControl);
    }

    if (!Util.isMobile()) {
      if (_interactive) {
        _positionControl = MousePosition();
        _map.addControl(_positionControl);
      }

      if (options.scaleControl !== false) {
        _scaleControl = L.control.scale({position: 'bottomleft'});
        _map.addControl(_scaleControl);
      }
    }
  };

  /**
   * Creates the appropriate DYFI overlays based on the given product.
   * Adds each overlay to the instance _overlays mapping.
   *
   * @param dyfi {Product}
   *     The DYFI product for which to create overlays. If null, no overlays
   *     are added.
   *
   * @return {Object}
   *     The _overlays instance variable, as augmented with new layers.
   */
  _this.addDyfiOverlays = function (dyfi) {
    var content;

    if (!dyfi) {
      return;
    }

    // 10k responses aggregation
    content = dyfi.getContent('dyfi_geo_10km.geojson');
    if (content) {
      _overlays[_DYFI_10K_OVERLAY] = DyfiUtmLayer({
        url: content.get('url')
      });
    }

    // 1km responses aggregation
    content = dyfi.getContent('dyfi_geo_1km.geojson');
    if (content) {
      _overlays[_DYFI_1K_OVERLAY] = DyfiUtmLayer({
        url: content.get('url')
      });
    }

    // Fallback responses aggregation
    if (!_overlays.hasOwnProperty(_DYFI_10K_OVERLAY) &&
        !_overlays.hasOwnProperty(_DYFI_1K_OVERLAY)) {

      content = dyfi.getContent('dyfi_geo.geojson');
      if (content) {
        _overlays[_DYFI_DEFAULT_OVERLAY] = DyfiUtmLayer({
          url: content.get('url')
        });
      }
    }

    return _overlays;
  };

  /**
   * Creates the appropriate ShakeMap overlays based on the given product.
   * Adds each overlay to the instance _overlays mapping.
   *
   * @param shakemap {Product}
   *     The ShakeMap product for which to create overlays. If null, no overlays
   *     are added.
   *
   * @return {Object}
   *     The _overlays instance variable, as augmented with new layers.
   */
  _this.addShakeMapOverlays = function (shakemap) {
    var content;

    if (!shakemap) {
      return;
    }

    content = shakemap.getContent('download/cont_mi.json');
    if (content) {
      _overlays[_SHAKEMAP_CONTOURS] = ContoursLayer({
        clickable: _interactive,
        url: content.get('url')
      });
    }

    content = shakemap.getContent('download/stationlist.json');
    if (content) {
      _overlays[_SHAKEMAP_STATIONS] = ShakeMapStationLayer(
          content.get('url'));
    }

    return _overlays;
  };

  /**
   * Creates a marker to indicate the epicenter at the given latitude and
   * longitude coordinates. Includes the magnitude in the tooltip text.
   *
   * @param latitude {Number}
   *     Decimal degrees latitude.
   * @param longitude {Number}
   *     Decimal degrees longitude.
   * @param magnitude {Number}
   *     Magnitude of event.
   *
   * @return {L.Marker}
   *     A marker centered on the given latitude/longitude coordinate with
   *     tooltip text including the magnitude.
   */
  _this.createEpicenterMarker = function (latitude, longitude, magnitude) {
    var marker;

    marker = L.marker([latitude, longitude], {
      zIndexOffset: 99,
      icon: L.icon({
        iconUrl: 'images/star.png',
        iconSize: [_markerSize, _markerSize],
        iconAnchor: [_markerSize/2, _markerSize/2]
      })
    });

    if (_interactive) {
      marker.bindPopup([
        'Epicenter M', _formatter.magnitude(magnitude),
        '<br/>',
        _formatter.location(latitude, longitude)
      ].join(''));
    }

    return marker;
  };

  /**
   * Free resources associated with this view and then call default
   * View.destroy.
   *
   */
  _this.destroy = Util.compose(function () {
    if (_positionControl) {
      _positionControl.removeFrom(_map);
    }

    if (_scaleControl) {
      _scaleControl.removeFrom(_map);
    }

    _map.remove(); // destroy map and free resources


    _baseLayers = null;
    _defaultConfig = null;
    _formatter = null;
    _layersControl = null;
    _map = null;
    _markerSize = null;
    _module = null;
    _overlays = null;
    _positionControl = null;
    _scaleControl = null;


    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Sets the instance `_baseLayers` object to a map of LayerName => Layer for
   * each supported base layer.
   *
   * @return {Object}
   *     The updated _baseLayers object.
   */
  _this.getAvailableBaseLayers = function () {
    _baseLayers = {
      'Terrain': Terrain({provider: Terrain.NATGEO}),
      'Grayscale': Grayscale(),
      'Street': Street(),
      'Satellite': Satellite()
    };

    return _baseLayers;
  };

  /**
   * Sets the instance `_overlays` object to a map of LayerName => Layer for
   * each supported overlay layer.
   *
   * @return {Object}
   *     The updated _overlays object.
   */
  _this.getAvailableOverlays = function () {
    var catalogEvent,
        eventLatitude,
        eventLongitude;

    _overlays = {};

    catalogEvent = _this.model.get('event');

    if (!catalogEvent) {
      // No event, no overlays to create
      return _overlays;
    }

    eventLatitude = catalogEvent.getLatitude();
    eventLongitude = catalogEvent.getLongitude();

    if (eventLatitude !== null && eventLongitude !== null) {
      // Put a star over the epicenter
      _overlays[_EPICENTER_OVERLAY] = _this.createEpicenterMarker(eventLatitude,
          eventLongitude, catalogEvent.getMagnitude());
    }

    // Always include tectonic plates
    _overlays[_PLATES_OVERLAY] = TectonicPlates();

    // Include faults layer if in U.S.
    if (__inUs(eventLatitude, eventLongitude)) {
      _overlays[_FAULTS_OVERLAY] = UsFault();
    }

    // Historic seismicity
    _overlays[_HIST_SEIS_OVERLAY] = HistoricSeismicity();

    // Calling _module.getProduct will get the current product in the
    // case that a specific ?source=&code= were requested...

    // DYFI
    _this.getProductOverlays('dyfi', _this.addDyfiOverlays);

    // ShakeMap
    _this.getProductOverlays('shakemap', _this.addShakeMapOverlays);

    return _overlays;
  };

  _this.getProductOverlays = function (type, callback) {
    var catalogEvent,
        codeKey,
        config,
        product,
        sourceKey;

    catalogEvent = _this.model.get('event');

    if (!catalogEvent) {
      return;
    }

    config = Util.extend({}, _defaultConfig, _this.model.get('map'));
    sourceKey = type + 'Source';
    codeKey = type + 'Code';
    type = Product.getFullType(type, _module.model.get('config'));

    if (config.hasOwnProperty(sourceKey) &&
        config.hasOwnProperty(codeKey)) {
      product = catalogEvent.getProductById(type, config[sourceKey],
          config[codeKey]);
    } else {
      product = catalogEvent.getPreferredProduct(type);
    }

    if (product) {
      callback(product);
    }
  };
  /**
   * Called to notify the view that it's element is now in the DOM so
   * things like dimensions can be inspected etc...
   *
   */
  _this.onDomReady = function () {
    if (_map && _map.getContainer() && _map.getContainer().parentNode) {
      _map.invalidateSize();
    }
  };

  /**
   * Renders the map.
   *
   */
  _this.render = function () {
    var catalogEvent,
        config,
        latitude,
        longitude;

    config = Util.extend({}, _defaultConfig, _this.model.get('map'));

    Object.keys(_baseLayers).forEach(function (layerName) {
      var layer;

      layer = _baseLayers[layerName];

      if (layer.map) {
        layer.removeFrom(_map);
      }

      if (layerName === config.baseLayer) {
        layer.addTo(_map);
      }
    });

    _this.updateOverlays(config);


    // Zoom to a two-degree map centered on event
    catalogEvent = _this.model.get('event');
    if (catalogEvent) {
      latitude = catalogEvent.getLatitude();
      longitude = catalogEvent.getLongitude();
      _map.fitBounds([[latitude + 2.0, longitude + 2.0],
          [latitude - 2.0, longitude - 2.0]]);
    }
  };

  _this.updateOverlays = function (config) {
    // Clear existing overlays (if any)
    Object.keys(_overlays).forEach(function (layerName) {
      var layer;

      layer = _overlays[layerName];

      if (layer._map) {
        _map.removeLayer(layer);
      }

      if (_layersControl && _layersControl._layers.hasOwnProperty(layerName)) {
        _layersControl.removeLayer(layer);
      }
    });

    _this.getAvailableOverlays();

    // Now add each overlay to control and potentially add to map if so
    // configured
    Object.keys(_overlays).forEach(function (layerName) {
      var layer;

      layer = _overlays[layerName];

      if (_layersControl) {
        _layersControl.addOverlay(layer, layerName);
      }

      if (config[layerName] === 'true') {
        layer.addTo(_map);
      }
    });
  };


  _initialize(options);
  options = null;
  return _this;
};

// Expose these so others know the layers available
InteractiveMapView.DYFI_10K_OVERLAY = _DYFI_10K_OVERLAY;
InteractiveMapView.DYFI_1K_OVERLAY = _DYFI_1K_OVERLAY;
InteractiveMapView.DYFI_DEFAULT_OVERLAY = _DYFI_DEFAULT_OVERLAY;
InteractiveMapView.EPICENTER_OVERLAY = _EPICENTER_OVERLAY;
InteractiveMapView.FAULTS_OVERLAY = _FAULTS_OVERLAY;
InteractiveMapView.HIST_SEIS_OVERLAY = _HIST_SEIS_OVERLAY;
InteractiveMapView.PLATES_OVERLAY = _PLATES_OVERLAY;
InteractiveMapView.POPULATION_OVERLAY = _POPULATION_OVERLAY;
InteractiveMapView.SHAKEMAP_CONTOURS = _SHAKEMAP_CONTOURS;
InteractiveMapView.SHAKEMAP_STATIONS = _SHAKEMAP_STATIONS;


module.exports = InteractiveMapView;

},{"core/Formatter":"core/Formatter","core/Module":"core/Module","leaflet/control/HazDevLayers":9,"leaflet/control/MousePosition":10,"leaflet/layer/Grayscale":12,"leaflet/layer/HistoricSeismicity":13,"leaflet/layer/Satellite":15,"leaflet/layer/Street":16,"leaflet/layer/TectonicPlates":17,"leaflet/layer/Terrain":18,"leaflet/layer/UsFault":20,"map/ContoursLayer":"map/ContoursLayer","map/DyfiUtmLayer":"map/DyfiUtmLayer","map/ShakeMapStationLayer":"map/ShakeMapStationLayer","mvc/View":"mvc/View","pdl/Product":"pdl/Product","util/Util":"util/Util"}],"map/ShakeMapStationLayer":[function(require,module,exports){
/* global L */
'use strict';


var Formatter = require('core/Formatter'),
    Xhr = require('util/Xhr');


var FLAG_DESCRIPTIONS = {
  'M': 'Manually flagged',
  'T': 'Outlier',
  'G': 'Glitch (clipped or below noise)',
  'I': 'Incomplete time series',
  'N': 'Not in list of known stations'
};


var ShakeMapStationLayer = L.GeoJSON.extend({

  initialize: function (stationJson) {
    var _this = this;

    this._formatter = new Formatter();
    this._layers = {};

    this.stationURL = stationJson;
    this.data = null;

    this.options = {
      pointToLayer: function (feature, latlng) {
        var p = feature.properties,
            romanIntensity = _this._formatter.mmi(p.intensity);

        if (p.network === 'DYFI' || p.network === 'INTENSITY') {
          return L.marker(latlng, {
            icon: L.divIcon({
              className: 'dyfi-layer-icon dyfi-station-mmi'+romanIntensity+'',
              iconSize: [14, 14],
              iconAnchor: [7, 7],
              popupAnchor: [0, 0]
            })
          });
        } else {
          return L.marker(latlng, {
            icon: L.divIcon({
              className: 'station-layer-icon station-mmi'+romanIntensity+'',
              iconSize: [14, 10],
              iconAnchor: [7, 8],
              popupAnchor: [0, -4]
            })
          });
        }
      },

      onEachFeature: function (feature, layer) {
        layer.options.title = _this._formatTitle(feature, true);
        layer.bindPopup(_this._generatePopupContent(feature),
            {minWidth:300});
      }
    };
  },

  onAdd: function (map) {
    if (this.data === null) {
      Xhr.ajax({
        url: this.stationURL,
        success: (function (layer) {
          return function (data) {
            layer.data = data;
            layer.addData(data);
            L.LayerGroup.prototype.onAdd.call(layer, map);
          };
        })(this)
      });
    } else {
      this.addData(this.data);
      L.LayerGroup.prototype.onAdd.call(this, map);
    }
  },

  _generatePopupContent: function (feature) {
    var p = feature.properties,
        romanIntensity = this._formatter.mmi(p.intensity);

    var markup = ['<div class="station-popup">',
      '<h2 class="station-title">', this._formatTitle(feature), '</h2>',
      '<ul class="station-summary">',
        '<li class="station-summary-intensity roman mmi', romanIntensity, '">',
          romanIntensity,
          '<br><abbr title="Modified Mercalli Intensity">mmi</abbr></br>',
        '</li>',
        '<li class="station-summary-pga">',
          this._formatter.number(p.pga, 3, '&ndash;'),
          '<br><abbr title="Maximum Horizontal Peak Ground Velocity (%g)">pga</abbr></br>',
        '</li>',
        '<li class="station-summary-pgv">',
          this._formatter.number(p.pgv, 3, '&ndash;'),
          '<br><abbr title="Maximum Horizontal Peak Ground Velocity (cm/s)">pgv</abbr></br>',
        '</li>',
        '<li class="station-summary-distance">',
          this._formatter.number(p.distance, 1, '&ndash;'),' km',
          '<br><abbr title="Distance (km)">dist</abbr></br>',
        '</li>',
      '</ul>',
      '<dl class="station-metadata horizontal">',
        '<dt class="station-metadata-type">Type</dt>',
          '<dd class="station-metadata-type">',
            (p.instrumentType||'&ndash;'),
          '</dd>',
        '<dt class="station-metadata-location">Location</dt>',
          '<dd class="station-metadata-location">',
            this._formatLocation(feature),
          '</dd>',
        '<dt class="station-metadata-source">Source</dt>',
          '<dd class="station-metadata-source">', (p.source || '&ndash;'), '</dd>',
        '<dt class="station-metadata-intensity">Intensity</dt>',
          '<dd class="station-metadata-intensity">',
            this._formatter.number(p.intensity, 1, '&ndash;'),
          '</dd>',
      '</dl>',
      this._createChannelTable(p.channels),
    '</div>'];

    return markup.join('');
  },

  _createChannelTable: function (channels) {
    var i = 0, numChannels = channels.length;

    var markup = [
      '<table class="station-channels-map">',
        '<thead>',
          '<tr>',
            '<th scope="col" class="station-channels-map-name">name</th>',
            '<th scope="col" class="station-channels-map-pga">pga</th>',
            '<th scope="col" class="station-channels-map-pgv">pgv</th>',
            '<th scope="col" class="station-channels-map-psa03">psa03</th>',
            '<th scope="col" class="station-channels-map-psa10">psa10</th>',
            '<th scope="col" class="station-channels-map-psa30">psa30</th>',
          '</tr>',
        '</thead>',
        '<tbody>'
    ];

    for (; i < numChannels; i++) {
      markup.push(this._createChannelRow(channels[i]));
    }

    markup.push('</tbody></table>');

    return markup.join('');
  },

  _createAmplitudesObject: function (amplitudes) {
    var amp = {},
        i,
        len = amplitudes.length,
        amplitude = null;

    for (i = 0; i < len; i++) {
      amplitude = amplitudes[i];
      amp[amplitude.name] = amplitude;
    }

    return amp;
  },

  _createChannelRow: function (channel) {
    var amplitude = this._createAmplitudesObject(channel.amplitudes);

    return [
      '<tr>',
        '<th scope="row" class="station-channel-name">',
          channel.name,
        '</th>',
        '<td class="station-channel-pga">',
        this._formatComponent(amplitude.pga),
        '</td>',
        '<td class="station-channel-pgv">',
        this._formatComponent(amplitude.pgv),
        '</td>',
        '<td class="station-channel-psa03">',
          this._formatComponent(amplitude.psa03),
        '<td class="station-channel-psa10">',
          this._formatComponent(amplitude.psa10),
        '</td>',
        '<td class="station-channel-psa30">',
          this._formatComponent(amplitude.psa30),
        '</td>',
      '</tr>'
    ].join('');
  },

  _formatTitle: function (feature, plainText) {
    var p = feature.properties;

    var title = [];

    if (!plainText) { title.push('<span class="station-code">'); }
    title.push(p.code || '&ndash;');
    if (!plainText) { title.push('</span>'); }

    title.push(' ');

    if (!plainText) { title.push('<span class="station-name">'); }
    title.push(p.name || '&ndash;');
    if (!plainText) { title.push('</span>'); }

    return title.join('');
  },

  _formatLocation: function (feature) {
    return ((feature.properties.location) ?
        (feature.properties.location + '<br/>') : '') + ' (' +
        feature.geometry.coordinates[1] + ', ' +
        feature.geometry.coordinates[0] + ')';
  },

  _formatComponent: function (data) {
    var content = [],
        flag,
        value;

    if (data) {
      flag = data.flag;
      value = data.value;

      // Add flag class for all non-zero flags
      if (flag && flag !== '0') {
        content.push('<span class="station-flag">');
        content.push(parseFloat(value, 10).toFixed(3));

        // display flag with title text
        if (FLAG_DESCRIPTIONS.hasOwnProperty(flag)) {
          content.push('<abbr title="' + FLAG_DESCRIPTIONS[flag] + '">(' +
              flag + ')</abbr>');
        } else {
          content.push('(' + flag + ')');
        }
        content.push('</span>');
      } else {
        content.push('<span>');
        content.push(parseFloat(value, 10).toFixed(3));
        content.push('</span>');
      }
    } else {
      content.push('<span>&ndash;</span>');
    }

    return content.join('');
  }
});


L.ShakeMapStationLayer = ShakeMapStationLayer;

L.shakeMapStationLayer = function (options) {
  return new ShakeMapStationLayer(options);
};


module.exports = L.shakeMapStationLayer;

},{"core/Formatter":"core/Formatter","util/Xhr":"util/Xhr"}],"moment-tensor/BeachBallView":[function(require,module,exports){
/* This is based on code in GMT, utilmeca.c. */
'use strict';

var Canvas = require('moment-tensor/Canvas'),
    Util = require('util/Util'),
    View = require('mvc/View');


var _D2R,
    _DEFAULTS,
    _EPSILON,
    _MERGE_THRESHOLD,
    _R2D,
    _SPLIT_THRESHOLD;

_D2R = Math.PI / 180;
_R2D = 180 / Math.PI;

_EPSILON = Number.EPSILON || 1e-16;

// threshold x and y pixel difference when polygons should be merged.
// Pixels are in the range [-1, 1], so 0.02 represents a 1% difference.
_MERGE_THRESHOLD = 0.02;

// threshold takeoff angle when polygons should be split.
_SPLIT_THRESHOLD = 85 * _D2R;

_DEFAULTS = {
  axisSize: null,
  bgColor: '#fff',
  fillColor: '#ddd',
  height: null,
  labelAxes: true,
  labelAxesFont: '24px Arial',
  labelPlanes: true,
  labelPlanesFont: '14px Arial',
  lineColor: '#000',
  lineWidth: 0.25,
  plotAxes: false,
  plotPlanes: true,
  radius: null,
  size: 200,
  tensor: null,
  width: null,
  x0: null,
  y0: null
};


/**
 * Make sure number is between 0 and 2pi.
 *
 * @param value {Number}
 *     angle in radians.
 * @return {Number}
 *     angle in radians, in the range [0, 2pi).
 */
var __0To2Pi = function (value) {
  var twoPi;

  twoPi = 2 * Math.PI;
  while (value < 0) {
    value += twoPi;
  }
  while (value >= twoPi) {
    value -= twoPi;
  }
  return value;
};

/**
 * Compute trig values of axis.
 *
 * @param axis {Vector3}
 *        principal axis, with value property.
 * @return {Object} with these keys:
 *         v: value,
 *         a: azimuth,
 *         ca: cos(azimuth),
 *         sa: sin(azimuth),
 *         p: plunge,
 *         cp: cos(plunge),
 *         sp: sin(plunge).
 */
var __axisCache = function (axis) {
  var azimuth,
      plunge;

  // Vector azimuth method returns clockwise from north
  // code in this file expects counter-clockwise from east
  azimuth = (Math.PI / 2) - axis.azimuth();
  plunge = axis.plunge();
  // make axis plunge downward (negative values are up)
  if (plunge < 0) {
    plunge *= -1;
    azimuth += Math.PI;
  }
  // make azimuth in range [0, 2*PI)
  azimuth = __0To2Pi(azimuth, 0, Math.PI * 2);

  return {
    v: axis.eigenvalue,
    a: azimuth,
    ca: Math.cos(azimuth),
    sa: Math.sin(azimuth),
    p: plunge,
    cp: Math.cos(plunge),
    sp: Math.sin(plunge)
  };
};


var BeachBallView = function (options) {
  var _this,
      _initialize,

      _axisSize,
      _bgColor,
      _canvas,
      _fillColor,
      _height,
      _labelAxes,
      _labelAxesFont,
      _labelPlanes,
      _labelPlanesFont,
      _lineColor,
      _lineWidth,
      _plotAxes,
      _plotPlanes,
      _radius,
      _size,
      _tensor,
      _width,
      _x0,
      _y0;

  _this = View(options);

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);

    _bgColor = options.bgColor;
    _fillColor = options.fillColor;
    _labelAxes = options.labelAxes;
    _labelAxesFont = options.labelAxesFont;
    _labelPlanes = options.labelPlanes;
    _labelPlanesFont = options.labelPlanesFont;
    _lineColor = options.lineColor;
    _lineWidth = options.lineWidth;
    _plotAxes = options.plotAxes;
    _plotPlanes = options.plotPlanes;
    _size = options.size;
    _tensor = options.tensor;

    // options with computed defaults
    _radius = options.radius || parseInt((_size - 2) / 2, 10);
    _axisSize = options.axisSize || parseInt(_radius / 12.5, 10);
    _height = options.height || _size;
    _width = options.width || _size;
    _x0 = options.x0 || _width / 2;
    _y0 = options.y0 || _height / 2;
  };


  /**
   * Complete polygon, by inserting points at edge of circle.
   *
   * @param poly {Object}
   *     polygon to potentially complete.
   * @return {Object}
   *     completed polygon.
   */
  _this.completePolygon = function (polygon) {
    var az,
        az1,
        az2,
        x,
        y;

    if (polygon.x.length === 360) {
      // already a complete polygon
      return polygon;
    }

    az1 = polygon.startAz.az;
    az2 = polygon.endAz.az;
    x = polygon.x;
    y = polygon.y;
    // fill in circle portion of polygons
    if (az1 - az2 > Math.PI) {
      az1 -= 2 * Math.PI;
    }
    if (az2 - az1 > Math.PI) {
      az1 += 2 * Math.PI;
    }
    if (az1 < az2) {
      for (az = az2 - _D2R; az > az1; az -= _D2R) {
        x.push(Math.sin(az));
        y.push(Math.cos(az));
      }
    } else {
      for (az = az2 + _D2R; az < az1; az += _D2R) {
        x.push(Math.sin(az));
        y.push(Math.cos(az));
      }
    }

    return polygon;
  };

  /**
   * Compute azimuth label relative positioning.
   *
   * @param label {Object}
   * @return {Object}
   *     same `label` object, with additional properties:
   *     - `align` {String}
   *         'left' or 'right'
   *     - `size` {Object}
   *         `width` and `height` of label
   *     - `tick` {Object}
   *         `x` and `y` relative tick coordinates.
   *     - `x` {Number}
   *         relative x coordinate of label.
   *     - `y` {Number}
   *         relative y coordinate of label.
   */
  _this.computeAzimuthLabel = function (label) {
    var align,
        point,
        labelOffset,
        size,
        tickLength,
        x,
        y;

    // point on edge
    point = _this.getPoint(label.azimuth, 0);
    x = point.x;
    y = point.y;
    align = (x < 0) ? 'right' : 'left';
    size = _this.measureText(label.text, label.font);

    labelOffset = (_radius + 10) / _radius;
    tickLength = (_radius + 5) / _radius;

    label.align = align;
    label.size = size;
    label.tick = {
      x: [x, x * tickLength],
      y: [y, y * tickLength],
    };
    label.x = x * labelOffset;
    label.y = y * labelOffset;

    if (y < 0) {
      // shift label down when in bottom half
      label.y = y * (_radius + 10 + Math.abs(y) * size.height / 2) / _radius;
    }

    return label;
  };

  /**
   * Free references.
   */
  _this.destroy = Util.compose(function () {
    if (!_this) {
      return;
    }

    _axisSize = null;
    _bgColor = null;
    _fillColor = null;
    _labelAxes = null;
    _labelAxesFont = null;
    _labelPlanes = null;
    _labelPlanesFont = null;
    _lineColor = null;
    _lineWidth = null;
    _plotAxes = null;
    _plotPlanes = null;
    _size = null;
    _tensor = null;

    _radius = null;
    _height = null;
    _width = null;
    _x0 = null;
    _y0 = null;

    _this = null;
    _initialize = null;
  }, _this.destroy);

  /**
   * Get a line for a nodal plane.
   *
   * @param np {Object}
   *     Nodal plane object with keys `strike`, `dip`, and `rake` and
   *     values in degrees.
   * @return {Object}
   *     With properties `x` and `y` that are Arrays of points in the
   *     range [-1, 1].
   */
  _this.getPlaneLine = function (np) {
    var dip,
        j,
        point,
        strike,
        tanDip,
        vertical,
        x,
        y;

    strike = np.strike * _D2R;
    dip = np.dip * _D2R;
    x = [];
    y = [];

    vertical = (Math.abs(dip - Math.PI / 2)) < _EPSILON;
    if (vertical) {
      x.push(Math.sin(strike), Math.sin(strike + Math.PI));
      y.push(Math.cos(strike), Math.cos(strike + Math.PI));
    } else {
      tanDip = Math.tan(dip);
      for (j = 0; j <= Math.PI; j += _D2R) {
        // dip from [0,0,0] to intersection of plane and focal sphere
        // at azimuth `strike + j`
        dip = Math.atan(tanDip * Math.sin(j));
        point = _this.getPoint(strike + j, dip);
        x.push(point.x);
        y.push(point.y);
      }
    }

    return {
      x: x,
      y: y
    };
  };

  /**
   * Get x, y coordinates for a vector.
   *
   * @param vector {Vector}
   *     vector reprenenting point.
   * @return {Object}
   *     with properties `x` and `y` in the range [-1, 1] representing location
   *     of point in focal sphere.
   */
  _this.getPoint = function (azimuth, plunge) {
    var r,
        x,
        y;

    if (plunge < 0) {
      plunge *= -1;
      azimuth += Math.PI;
    }
    azimuth = __0To2Pi(azimuth);

    r = Math.sqrt(1 - Math.sin(plunge));
    x = r * Math.sin(azimuth);
    y = r * Math.cos(azimuth);

    return {
      x: x,
      y: y
    };
  };

  /**
   * Get Polygons representing pressure and tension regions of the beachball.
   *
   * May swap foreground and background colors.
   *
   * @param tensor {Tensor}
   *        tensor.
   * @return {Array<Object>} each object will have properties:
   *         x: {Array<Number>} x coordinates of line,
   *         y: {Array<Number} y coordinates of line,
   *         startAz: {Object} start azimuth of line,
   *         endAz: {Object} end azimuth of line.
   */
  _this.getPolygons = function (tensor) {
    var alphan,
        az,
        azes,
        azp,
        c,
        cfi,
        f,
        fir,
        i,
        iso,
        n,
        p,
        polygon,
        polygons,
        r,
        s,
        s2alphan,
        sfi,
        swapColors,
        t,
        tmp,
        takeoff,
        vi,
        x,
        xe,
        xn,
        xz,
        y;

    t = __axisCache(tensor.T);
    n = __axisCache(tensor.N);
    p = __axisCache(tensor.P);

    azes = [];
    polygons = [];


    vi = (t.v + n.v + p.v) / 3;
    t.v -= vi;
    n.v -= vi;
    p.v -= vi;

    // compute f, iso
    f = (-n.v / t.v) || _EPSILON;
    iso = (vi / t.v) || _EPSILON;

    // build azes
    swapColors = false;
    for (i = 0; i < 360; i++) {
      fir = i * _D2R;
      sfi = Math.sin(fir);
      cfi = Math.cos(fir);
      s2alphan = (2 + 2 * iso) / (3 + (1 - 2 * f) * Math.cos(2 * fir));
      if (Math.abs(1 - s2alphan) <= _EPSILON) {
        s2alphan = 1;
      }
      if (s2alphan > 1) {
        // swap axes
        tmp = t;
        t = p;
        p = tmp;
        // swap bg/fill colors
        swapColors = !swapColors;
        // recompute f, iso, s2alphan
        f = (-n.v / t.v) || _EPSILON;
        iso = (vi / t.v) || _EPSILON;
        s2alphan = (2 + 2 * iso) / (3 + (1 - 2 * f) * Math.cos(2 * fir));
      }
      // compute z,n,e components
      alphan = Math.asin(Math.sqrt(s2alphan));
      s = Math.sin(alphan);
      c = Math.cos(alphan);
      xz = c * t.sp        + s * sfi * n.sp        + s * cfi * p.sp;
      xn = c * t.cp * t.ca + s * sfi * n.cp * n.ca + s * cfi * p.cp * p.ca;
      xe = c * t.cp * t.sa + s * sfi * n.cp * n.sa + s * cfi * p.cp * p.sa;
      // compute azimuth and takeoff angle
      if (Math.abs(xn) < _EPSILON && Math.abs(xe) < _EPSILON) {
        az = 0;
        takeoff = 0;
      } else {
        az = __0To2Pi(Math.atan2(xe, xn));
        takeoff = Math.acos(xz / Math.sqrt(xz*xz + xn*xn + xe*xe));
        if (takeoff > Math.PI / 2) {
          az = __0To2Pi(az + Math.PI);
          takeoff = Math.PI - takeoff;
        }
      }
      // save for later
      azes.push({
        az: az,
        takeoff: takeoff
      });
    }

    // build polygons
    polygon = null;
    for (i = 0; i < azes.length; i++) {
      az = azes[i];
      r = Math.SQRT2 * Math.sin(az.takeoff / 2);
      x = r * Math.sin(az.az);
      y = r * Math.cos(az.az);
      if (polygon !== null) {
        // check if current point should be part of this polygon
        azp = azes[(i === 0) ? azes.length - 1 : i - 1];
        if (Math.abs(Math.abs(az.az - azp.az) - Math.PI) < 10 * _D2R) {
          // polygons should only end at edge of beachball
          if (az.takeoff > _SPLIT_THRESHOLD &&
              azp.takeoff > _SPLIT_THRESHOLD) {
            // end a polygon
            if (polygon !== null) {
              polygon.endAz = azp;
              polygons.push(polygon);
              polygon = null;
            }
          }
        }
      }
      if (polygon === null) {
        // start a polygon
        polygon = {
          x: [],
          y: [],
          startAz: az,
          endAz: null
        };
      }
      // add point to current polygon
      polygon.x.push(x);
      polygon.y.push(y);
    }
    // close last polygon
    polygon.endAz = azes[azes.length - 1];
    polygons.push(polygon);

    // fix up polygons
    polygons = _this.mergePolygons(polygons);
    polygons = polygons.map(_this.completePolygon);
    polygons.swapColors = swapColors;
    return polygons;
  };

  /**
   * Call getPoint using a Vector.
   *
   * Vector azimuth is reported counter-clockwise from east.
   * getPoint expects azimuth to be clockwise from north.
   *
   * @param vector {Vector}
   *     the vector.
   * @return {Object}
   *     relative point within focal sphere.
   */
  _this.getVectorPoint = function (vector) {
    return _this.getPoint(
      (Math.PI / 2) - vector.azimuth(),
      vector.plunge()
    );
  };

  /**
   * Measure pixel size of text.
   *
   * @param text {String}
   *     text to measure.
   * @param font {String}
   *     css/canvas font property.
   * @return {Object}
   *     with `width` and `height` properties that are the pixel size of `text`.
   */
  _this.measureText = function (text, font) {
    var el,
        size;

    // create hidden element with text content
    el = document.createElement('div');
    el.setAttribute('style',
        'height:auto;' +
        'position:absolute;' +
        'visibility:hidden;' +
        'white-space:nowrap;' +
        'width:auto;' +
        'font:' + font + ';');
    el.innerText = text;

    // add to view element and measure
    _this.el.appendChild(el);
    size = {
      height: el.scrollHeight,
      width: el.scrollWidth
    };

    // clean up
    _this.el.removeChild(el);
    el = null;

    return size;
  };

  /**
   * Label an axis.
   *
   * @param axis {Vector}
   *     axis to label.
   * @param text {String}
   *     axis label.
   */
  _this.labelAxis = function (axis, text) {
    var point;

    point = _this.getVectorPoint(axis);
    _canvas.text(text,
        _labelAxesFont,
        _this.projectX(point.x),
        _this.projectY(point.y),
        null,
        'black',
        'center');
  };

  /**
   * Draw an azimuth label.
   *
   * @param label {Object}
   *     label object with `azimuth`, `text`, and `font` properties.
   */
  _this.labelAzimuth = function (label) {
    var tick;

    if (!('size' in label)) {
      label = _this.computeAzimuthLabel(label);
    }

    tick = label.tick;
    _canvas.line(
        tick.x.map(_this.projectX),
        tick.y.map(_this.projectY),
        'black');

    _canvas.text(label.text, label.font,
        _this.projectX(label.x),
        _this.projectY(label.y),
        null,
        'black',
        label.align);
  };

  /**
   * Adjust size to make room for azimuth labels.
   *
   * Updates _canvas, _height, _width, _x0, and _y0.
   * Resets canvas content, any rendering should occur after calling.
   *
   * @param label {Object}
   *     label object with `azimuth`, `text`, and `font` properties.
   */
  _this.makeRoomForAzimuthLabel = function (label) {
    var bottom,
        left,
        right,
        size,
        top,
        x,
        y;

    if (!('size' in label)) {
      label = _this.computeAzimuthLabel(label);
    }

    x = _this.projectX(label.x);
    y = _this.projectY(label.y);
    size = label.size;

    // measure actual top/right/bottom/left
    bottom = 0;
    left = 0;
    right = 0;
    top = 0;
    bottom = y - size.height;
    top = y + size.height;
    if (label.align === 'left') {
      left = x;
      right = x + size.width;
    } else {
      left = x - size.width;
      right = x;
    }

    // convert from actual size to relative size increase
    if (bottom < 0) {
      bottom = Math.abs(bottom);
    } else {
      bottom = 0;
    }
    if (top > _height) {
      top = top - _height;
    } else {
      top = 0;
    }
    if (left < 0) {
      left = Math.abs(left);
    } else {
      left = 0;
    }
    if (right > _width) {
      right = right - _width;
    } else {
      right = 0;
    }

    // change size
    _width = _width + left + right;
    _x0 = _x0 + left;
    _height = _height + top + bottom;
    _y0 = _y0 + top;
  };

  /**
   * Merge adjacent lines that should be part of the same polygon.
   *
   * @param polygons {Array<Object>}
   *     array of polygons to potentially merge.
   * @return {Array<Object>}
   *     array of polygons that remain after any merges.
   */
  _this.mergePolygons = function (polygons) {
    var i,
        nextI,
        p1,
        p1x,
        p1y,
        p2,
        p2x,
        p2y;

    if (polygons.length === 1) {
      // nothing to merge
      return polygons;
    }

    for (i = 0; i < polygons.length; i++) {
      nextI = (i === polygons.length - 1 ? 0 : i + 1);
      p1 = polygons[i];
      p1x = p1.x;
      p1y = p1.y;
      p2 = polygons[nextI];
      p2x = p2.x;
      p2y = p2.y;
      if (Math.abs(p1x[p1x.length - 1] - p2x[0]) < _MERGE_THRESHOLD &&
          Math.abs(p1y[p1y.length - 1] - p2y[0]) < _MERGE_THRESHOLD) {
        // merge polygons
        p1x.push.apply(p1x, p2x);
        p1y.push.apply(p1y, p2y);
        p1.endAz = p2.endAz;
        polygons.splice(nextI, 1);
      }
    }
    return polygons;
  };

  /**
   * Convert a relative x coordinate to a canvas pixel coordinate.
   *
   * @param x {Number}
   *     relative x coordinate.
   * @return {Number}
   *     canvas pixel x coordinate.
   */
  _this.projectX = function (x) {
    return _x0 + _radius * x;
  };

  /**
   * Convert a relative y coordinate to a canvas pixel coordinate.
   *
   * @param y {Number}
   *     relative y coordinate.
   * @return {Number}
   *     canvas pixel y coordinate.
   */
  _this.projectY = function (y) {
    return _height - (_y0 + _radius * y);
  };

  /**
   * Render view based on current model settings.
   */
  _this.render = function () {
    var azimuthLabels,
        point,
        polygons,
        tmp,
        x,
        y;

    azimuthLabels = [];
    // create azimuth labels, for now only nodal planes.
    if (_labelPlanes) {
      [_tensor.NP1, _tensor.NP2].forEach(function (np) {
        var azimuth,
            text;

        azimuth = np.strike * _D2R;
        text = '(' +
            np.strike.toFixed(0) + ', ' +
            np.dip.toFixed(0) + ', ' +
            np.rake.toFixed(0) +
            ')';
        azimuthLabels.push({
          'azimuth': azimuth,
          'font': _labelPlanesFont,
          'text': text
        });
      });
    }
    // adjust plot area so labels are visible.
    azimuthLabels.forEach(_this.makeRoomForAzimuthLabel);

    _canvas = Canvas({
      height: _height,
      width: _width
    });
    _canvas.context.lineWidth = _lineWidth;

    // get polygons
    // represents either solid regions (swapColors = false),
    // or holes (swapColors = true)
    polygons = _this.getPolygons(_tensor);
    if (polygons.swapColors) {
      tmp = _bgColor;
      _bgColor = _fillColor;
      _fillColor = tmp;
    }

    // center of beachball.
    x = _this.projectX(0);
    y = _this.projectY(0);

    // plot circle outline, with background color
    // in case polygons represent holes
    _canvas.circle(x, y, _radius * 2, _lineColor, _bgColor);

    // draw polygons
    polygons.forEach(function(p) {
      _canvas.polygon(
          p.x.map(_this.projectX),
          p.y.map(_this.projectY),
          _lineColor,
          _fillColor);
    });

    // draw nodal plane lines
    if (_plotPlanes) {
      [_tensor.NP1, _tensor.NP2].forEach(function (np) {
        var line;
        line = _this.getPlaneLine(np);
        _canvas.line(
            line.x.map(_this.projectX),
            line.y.map(_this.projectY),
            _lineColor);
      });
    }

    // plot circle without fill, in case polygons covered outline.
    _canvas.circle(x, y, _radius * 2, _lineColor);

    if (_labelAxes) {
      _this.labelAxis(_tensor.P, 'P');
      _this.labelAxis(_tensor.T, 'T');
    } else if (_plotAxes) {
      point = _this.getVectorPoint(_tensor.P);
      _canvas.circle(point.x, point.y, _axisSize, 'white', 'black');
      point = _this.getVectorPoint(_tensor.T);
      _canvas.circle(point.x, point.y, _axisSize, 'black', 'white');
    }

    // draw azimuth labels
    azimuthLabels.forEach(_this.labelAzimuth);

    Util.empty(_this.el);
    _this.el.appendChild(_canvas.canvas);
    _canvas.destroy();
    _canvas = null;
  };


  _initialize(options);
  options = null;
  return _this;
};


BeachBallView.zeroToTwoPi = __0To2Pi;


module.exports = BeachBallView;

},{"moment-tensor/Canvas":"moment-tensor/Canvas","mvc/View":"mvc/View","util/Util":"util/Util"}],"moment-tensor/Canvas":[function(require,module,exports){
'use strict';

var Util = require('util/Util');


var _DEFAULTS = {
  canvas: null,
  height: 100,
  width: 100
};


/**
 * Create a new Canvas object.
 *
 * @param options {Object}
 * @param options.canvas {DOMElement}
 *        Optional, An existing canvas element.
 *        If omitted, a new canvas element is created.
 * @param options.width {Number}
 *        Optional, default 100.
 *        Width of canvas, when options.canvas is null.
 * @param options.height {Number}
 *        Optional, default 100.
 *        Height of canvas, when options.canvas is null.
 */
var Canvas = function (options) {
  var _this,
      _initialize,

      _canvas,
      _context;

  _this = {};

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);

    _canvas = options.canvas;
    if (_canvas === null) {
      _canvas = document.createElement('canvas');
      _canvas.width = options.width;
      _canvas.height = options.height;
    }
    _context = _canvas.getContext('2d');
    // expose these as public properties
    _this.canvas = _canvas;
    _this.context = _context;
  };


  /**
   * Clear the canvas.
   */
  _this.clear = function () {
    if (_context.clearRect) {
      _context.clearRect(0, 0, _canvas.width, _canvas.height);
    } else {
      _canvas.width = _canvas.width;
    }
  };

  /**
   * Free references.
   */
  _this.destroy = function () {
    _canvas = null;
    _context = null;
    _initialize = null;
    _this = null;
  };

  /**
   * Draw a circle
   *
   * @param x {Number}
   *        center of circle.
   * @param y {Number}
   *        center of circle.
   * @param size {Number}
   *        diameter of circle.
   * @param stroke {String}
   *        strokeStyle, or null to not stroke.
   * @param fill {String}
   *        fillStyle, or null to not fill.
   */
  _this.circle = function (x, y, size, stroke, fill) {
    var c;

    c = _context;
    c.beginPath();
    c.arc(x, y, size/2, 0, Math.PI*2, true);
    c.closePath();

    _this._strokeAndFill(stroke, fill);
  };

  /**
   * Draw a polygon
   *
   * @param x {Array<Number>}
   *        array of x coordinates.
   * @param y {Array<Number>}
   *        array of y coordinates.
   * @param stroke {String}
   *        strokeStyle, or null to not stroke.
   * @param fill {String}
   *        fillStyle, or null to not fill.
   */
  _this.polygon = function (x, y, stroke, fill) {
    var c,
        i,
        len;

    c = _context;
    c.beginPath();
    c.moveTo(x[0], y[0]);
    for (i = 1, len = x.length; i < len; i++) {
      c.lineTo(x[i], y[i]);
    }
    c.closePath();

    _this._strokeAndFill(stroke, fill);
  };

  /**
   * Draw a line.
   *
   * Same as polygon, without closingPath before calling stroke/fill.
   *
   * @param x {Array<Number>}
   *        array of x coordinates.
   * @param y {Array<Number}
   *        array of y coordinates.
   * @param stroke {String}
   *        strokeStyle, or null to not stroke.
   * @param fill {String}
   *        fillStyle, or null to not fill.
   */
  _this.line = function (x, y, stroke, fill) {
    var c,
        i,
        len;

    c = _context;
    c.beginPath();
    c.moveTo(x[0], y[0]);
    for (i = 1, len = x.length; i < len; i++) {
      c.lineTo(x[i], y[i]);
    }

    this._strokeAndFill(stroke, fill);
  };

  /**
   * Measure how many pixels are needed to plot text in the given font.
   *
   * @param font {String}
   *     context font property.
   * @param text {String}
   *     text to plot.
   * @return {TextMetrics}
   *     size of text once plotted, "width" is the only widely supported
   *     TextMetrics property.
   */
  _this.measureText = function (font, text) {
    var c;

    c = _context;
    c.font = font;
    return c.measureText(text);
  };

  /**
   * Draw text.
   *
   * @param text {String}
   *        text to draw.
   * @param font {String}
   *        font to use, e.g. '30px Arial'.
   * @param x {Number}
   *        x coordinate.
   * @param y {Number}
   *        y coordinate.
   * @param stroke {String}
   *        strokeStyle, or null to not stroke.
   * @param fill {String}
   *        fillStyle, or null to not fill.
   * @param align {String} default 'left'
   *        where to align text around x.
   *        'left' starts at x.
   *        'center' centers around x.
   *        'right' ends at x.
   */
  _this.text = function (text, font, x, y, stroke, fill, align) {
    var c,
        size;

    c = _context;
    align = align || 'left';

    c.font = font;
    if (align !== 'left') {
      size = c.measureText(text);
      if (align === 'center') {
        x = x - size.width / 2;
      } else if (align === 'right') {
        x = x - size.width;
      }
    }

    if (stroke) {
      c.strokeStyle = stroke;
      c.strokeText(text, x, y);
    }

    if (fill) {
      c.fillStyle = fill;
      c.fillText(text, x, y);
    }
  };


  /**
   * Stroke and fill the current path.
   *
   * @param context {Object}
   *        canvas context
   * @param stroke {String}
   *        strokeStyle, or null to not stroke.
   * @param fill {String}
   *        fillStyle, or null to not fill.
   */
  _this._strokeAndFill = function (stroke, fill) {
    var c;

    c = _context;

    if (stroke) {
      c.strokeStyle = stroke;
      c.stroke();
    }
    if (fill) {
      c.fillStyle = fill;
      c.fill();
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = Canvas;

},{"util/Util":"util/Util"}],"moment-tensor/MomentTensorModule":[function(require,module,exports){
'use strict';


var Formatter = require('core/Formatter'),
    Module = require('core/Module'),
    MomentTensorView = require('moment-tensor/MomentTensorView'),
    ScientificSummaryModule = require('scientific/ScientificSummaryModule'),
    Util = require('util/Util');


var _DEFAULTS,
    _ID,
    _TITLE,
    _TYPES;


_ID = 'moment-tensor';
_TITLE = 'Moment Tensor';
_TYPES = ['moment-tensor'];

_DEFAULTS = {
  formatter: null
};


/**
 * Module to display a moment-tensor type {Product}.
 *
 * @param options {Object}
 * @param options.formatter {Formatter}
 *     formatter object to pass to MomentTensorView.
 */
var MomentTensorModule = function (options) {
  var _this,
      _initialize,

      _formatter,
      _momentTensorView;


  _this = Module(options);

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);
    _formatter = options.formatter || Formatter();

    _this.ID = _ID;
    _this.TITLE = _TITLE;
  };

  /**
   * Free references.
   */
  _this.destroy = Util.compose(function () {
    if (_momentTensorView) {
      _momentTensorView.destroy();
    }
    _momentTensorView = null;

    _formatter = null;
    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Render product content, or an error message if no product available.
   */
  _this.render = function () {
    var product;

    product = _this.getProduct('moment-tensor');

    _this.renderContent(product);
    _this.renderHeader(product);
    _this.renderFooter(product);
  };

  /**
   * Render the content section of this module.
   *
   * @param product {Product}
   *     product to render, or null if no product.
   */
  _this.renderContent = function (product) {
    if (_momentTensorView && _momentTensorView.destroy) {
      _momentTensorView.destroy();
      _momentTensorView = null;
    }

    if (!product) {
      _this.content.innerHTML = '<p class="alert error">' +
          'No Moment Tensor Found!' +
          '</p>';
    } else {
      _momentTensorView = MomentTensorView({
        el: _this.content,
        formatter: _formatter,
        model: product
      });
      _momentTensorView.render();
    }
  };

  /**
   * Render the footer section of this module.
   *
   * @param product {Product}
   *     product to render, or null if no product.
   */
  _this.renderFooter = function (product) {
    var downloads;

    Util.empty(_this.footer);
    if (product) {
      downloads = _this.getProductFooter({
        product: product
      });
      if (downloads) {
        _this.footer.appendChild(downloads);
      }
    }
  };

  /**
   * Render the header section of this module.
   *
   * @param product {Product}
   *     product to render, or null if no product.
   */
  _this.renderHeader = function (product) {
    var header;

    Util.empty(_this.header);
    _this.header.innerHTML = '<h3>' + _this.TITLE + '</h3>';

    if (product) {
      header = _this.getProductHeader({
        product: product,
        summaryModule: ScientificSummaryModule
      });

      if (header) {
        _this.header.appendChild(header);
      }
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


MomentTensorModule.ID = _ID;
MomentTensorModule.TITLE = _TITLE;
MomentTensorModule.TYPES = _TYPES;


module.exports = MomentTensorModule;

},{"core/Formatter":"core/Formatter","core/Module":"core/Module","moment-tensor/MomentTensorView":"moment-tensor/MomentTensorView","scientific/ScientificSummaryModule":"scientific/ScientificSummaryModule","util/Util":"util/Util"}],"moment-tensor/MomentTensorPinView":[function(require,module,exports){
'use strict';

var BasicPinView = require('core/BasicPinView'),
    BeachBallView = require('moment-tensor/BeachBallView'),
    MomentTensorModule = require('moment-tensor/MomentTensorModule'),
    Tensor = require('moment-tensor/Tensor'),
    Util = require('util/Util');


var _DEFAULTS = {
  className: 'moment-tensor-pin-beachball',
  fillColor: '#6ea8ff',
  module: MomentTensorModule
};


var MomentTensorPinView = function (options) {
  var _this,
      _initialize,

      _beachballView,
      _className,
      _fillColor,
      _tensor;

  options = Util.extend({}, _DEFAULTS, options);
  _this = BasicPinView(options);

  _initialize = function (options) {
    _className = options.className;
    _fillColor = options.fillColor;
    _tensor = Tensor.fromProduct(_this.model);
  };

  _this.destroy = Util.compose(function () {
    if (_beachballView) {
      _beachballView.destroy();
    }

    _beachballView = null;
    _className = null;
    _fillColor = null;
    _tensor = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Creats pin content
   */
  _this.renderPinContent = function () {
    Util.empty(_this.content);

    _beachballView = BeachBallView({
      fillColor: _fillColor,
      labelAxes: false,
      labelPlanes: false,
      size: 200,
      tensor: _tensor
    });

    _beachballView.el.classList.add(_className);
    _this.content.appendChild(_beachballView.el);
    _beachballView.render();
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = MomentTensorPinView;

},{"core/BasicPinView":"core/BasicPinView","moment-tensor/BeachBallView":"moment-tensor/BeachBallView","moment-tensor/MomentTensorModule":"moment-tensor/MomentTensorModule","moment-tensor/Tensor":"moment-tensor/Tensor","util/Util":"util/Util"}],"moment-tensor/MomentTensorView":[function(require,module,exports){
'use strict';

var Attribution = require('core/Attribution'),
    BeachBallView = require('moment-tensor/BeachBallView'),
    Formatter = require('core/Formatter'),
    ProductView = require('core/ProductView'),
    Tensor = require('moment-tensor/Tensor'),
    Util = require('util/Util');


var _DEFAULTS = {
  empty: '&ndash;',
  fillColor: '#6ea8ff',
  formatter: null,
  tensor: null
};

var _R2D = 180 / Math.PI;


/**
 * View for a `moment-tensor` product.
 *
 * @param options {Object}
 * @param options.empty {String}
 *     string to display if a value is missing.
 *     default '&ndash;'.
 * @param options.fillColor {String}
 *     fill color for beachball.
 *     default '#6ea8ff'.
 * @param options.formatter {Formatter}
 *     formatter object.
 *     default `Formatter()`.`
 * @param options.model {Product}
 *     moment-tensor product to display.
 */
var MomentTensorView = function (options) {
  var _this,
      _initialize,

      _empty,
      _fillColor,
      _formatter,
      _tensor;


  _this = ProductView(options);

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);
    _empty = options.empty;
    _fillColor = options.fillColor;
    _formatter = options.formatter || Formatter();
    _tensor = Tensor.fromProduct(_this.model);
  };

  /**
   * Free references.
   */
  _this.destroy = Util.compose(function () {
    _empty = null;
    _fillColor = null;
    _formatter = null;
    _initialize = null;
    _tensor = null;
    _this = null;
  }, _this.destroy);

  /**
   * Content for the "axes" section of the moment tensor view.
   *
   * @param tensor {Tensor}
   *     the tensor being displayed.
   * @return {DOMElement}
   *     markup for the axes section of the moment tensor view.
   */
  _this.getAxes = function (tensor) {
    var el,
        formatAxis,
        fragment;

    formatAxis = function (axis, name) {
      var azimuth,
          plunge,
          value;

      azimuth = (Math.PI / 2) - axis.azimuth();
      plunge = axis.plunge();
      value = axis.eigenvalue / tensor.scale;
      // make sure plunge is down
      if (plunge < 0) {
        azimuth = azimuth + Math.PI;
        plunge = plunge * -1;
      }
      azimuth = BeachBallView.zeroToTwoPi(azimuth);

      // format values
      azimuth = Math.round(azimuth * _R2D) + '&deg;';
      plunge = Math.round(plunge * _R2D) + '&deg';
      value = value.toFixed(3) + 'e+' + tensor.exponent + ' ' + tensor.units;

      return '<tr>' +
          '<th scope="row">' + name + '</th>' +
          '<td>' + value + '</td>' +
          '<td>' + plunge + '</td>' +
          '<td>' + azimuth + '</td>' +
          '</tr>';
    };

    fragment = document.createDocumentFragment();

    el = document.createElement('h4');
    el.innerHTML = 'Principal Axes';
    fragment.appendChild(el);

    el = document.createElement('div');
    el.classList.add('horizontal-scrolling');
    el.innerHTML =
        '<table>' +
          '<thead>' +
            '<tr>' +
              '<th>Axis</th>' +
              '<th>Value</th>' +
              '<th>Plunge</th>' +
              '<th>Azimuth</th>' +
            '</tr>' +
          '</thead>' +
          '<tbody>' +
            formatAxis(tensor.T, 'T') +
            formatAxis(tensor.N, 'N') +
            formatAxis(tensor.P, 'P') +
          '</tbody>' +
        '</table>';
    fragment.appendChild(el);

    return fragment;
  };

  /**
   * Content for the "info" section of the moment tensor view.
   *
   * @param tensor {Tensor}
   *     the tensor being displayed.
   * @return {DOMElement}
   *     markup for the info section of the moment tensor view.
   */
  _this.getInfo = function (tensor) {
    var catalog,
        contributor,
        dataSource,
        depth,
        el,
        halfDuration,
        magnitude,
        moment,
        percentDC,
        product;

    product = _this.model;

    catalog = product.getProperty('eventsource');
    contributor = product.get('source');
    dataSource = product.getProperty('beachball-source') || contributor;
    depth = _formatter.depth(tensor.depth, 'km');
    halfDuration = product.getProperty('sourcetime-duration');
    if (halfDuration) {
      halfDuration = (halfDuration / 2) + ' s';
    } else {
      halfDuration = _empty;
    }
    magnitude = _formatter.magnitude(
        tensor.magnitude,
        product.getProperty('derived-magnitude-type') || '');
    moment = (tensor.moment / tensor.scale).toFixed(3) +
        'e+' + tensor.exponent + ' ' + tensor.units;
    percentDC = Math.round(tensor.percentDC * 100) + ' %';

    catalog = catalog.toUpperCase();
    contributor = Attribution.getContributorReference(contributor);
    dataSource = Attribution.getContributorReference(dataSource);

    el = document.createElement('div');
    el.classList.add('moment-tensor-info');
    el.classList.add('horizontal-scrolling');
    el.innerHTML =
        '<table>' +
          '<tbody>' +
            '<tr>' +
              '<th scope="row">Moment</th></th>' +
              '<td>' + moment + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Magnitude</th>' +
              '<td>' + magnitude + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Depth</th>' +
              '<td>' + depth + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">' +
                'Percent <abbr title="Double Couple">DC</abbr>' +
              '</th>' +
              '<td>' + percentDC + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Half Duration</th>' +
              '<td>' + halfDuration + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Catalog</th>' +
              '<td>' + catalog + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Data Source</th>' +
              '<td>' + dataSource + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Contributor</th>' +
              '<td>' + contributor + '</td>' +
            '</tr>' +
          '</tbody>' +
        '</table>';

    return el;
  };

  /**
   * Content for the "planes" section of the moment tensor view.
   *
   * @param tensor {Tensor}
   *     the tensor being displayed.
   * @return {DOMElement}
   *     markup for the info section of the moment tensor view.
   */
  _this.getPlanes = function (tensor) {
    var el,
        formatPlane,
        fragment;

    formatPlane = function (plane, name) {
      var dip,
          rake,
          strike;

      dip = Math.round(plane.dip) + '&deg;';
      rake = Math.round(plane.rake) + '&deg;';
      strike = Math.round(plane.strike) + '&deg';

      return '<tr>' +
          '<th scope="row">' + name + '</th>' +
          '<td>' + strike + '</td>' +
          '<td>' + dip + '</td>' +
          '<td>' + rake + '</td>' +
        '</tr>';
    };

    fragment = document.createDocumentFragment();

    el = document.createElement('h4');
    el.innerHTML = 'Nodal Planes';
    fragment.appendChild(el);

    el = document.createElement('div');
    el.classList.add('horizontal-scrolling');
    el.innerHTML =
        '<table>' +
          '<thead>' +
            '<tr>' +
            '<th>Plane</th>' +
            '<th>Strike</th>' +
            '<th>Dip</th>' +
            '<th>Rake</th>' +
            '</tr>' +
          '</thead>' +
          '<tbody>' +
            formatPlane(tensor.NP1, 'NP1') +
            formatPlane(tensor.NP2, 'NP2') +
          '</tbody>' +
        '</table>';
    fragment.appendChild(el);

    return fragment;
  };

  /**
   * Get the title for this tensor.
   *
   * @param tensor {Tensor}
   *     tensor object.
   * @return {DOMElement}
   *     title for view.
   */
  _this.getTitle = function (tensor) {
    var el,
        title,
        type;

    type = tensor.type;
    if (type !== null) {
      // use derived magnitude type
      type = type.toUpperCase();
      if (type === 'MWW') {
        title = 'W-phase Moment Tensor (Mww)';
      } else if (type === 'MWC') {
        title = 'Centroid Moment Tensor (Mwc)';
      } else if (type === 'MWB') {
        title = 'Body-wave Moment Tensor (Mwb)';
      } else if (type === 'MWR') {
        title = 'Regional Moment Tensor (Mwr)';
      }
    }

    if (!title) {
      if (type !== null) {
        title = 'Moment Tensor (' + tensor.type + ')';
      } else {
        title = 'Moment Tensor';
      }
    }

    el = document.createElement('h3');
    el.innerHTML = title;

    return el;
  };

  /**
   * Render view.
   */
  _this.render = function () {
    var el,
        beachball,
        info,
        title;

    el = _this.el;
    el.innerHTML =
        '<section class="moment-tensor-view">' +
          '<header class="title"></header>' +
          '<div class="row">' +
            '<div class="column one-of-two"></div>' +
            '<div class="column one-of-two"></div>' +
          '</div>' +
        '</section>';
    title = el.querySelector('.title');
    info = el.querySelector('.column');
    beachball = el.querySelector('.column + .column');

    title.appendChild(_this.getTitle(_tensor));

    info.appendChild(_this.getInfo(_tensor));
    info.appendChild(_this.getPlanes(_tensor));
    info.appendChild(_this.getAxes(_tensor));

    beachball = BeachBallView({
      el: beachball,
      fillColor: _fillColor,
      size: 320,
      tensor: _tensor
    });
    beachball.render();
    beachball.destroy();
    beachball = null;
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = MomentTensorView;

},{"core/Attribution":"core/Attribution","core/Formatter":"core/Formatter","core/ProductView":"core/ProductView","moment-tensor/BeachBallView":"moment-tensor/BeachBallView","moment-tensor/Tensor":"moment-tensor/Tensor","util/Util":"util/Util"}],"moment-tensor/Tensor":[function(require,module,exports){
'use strict';

var Matrix = require('math/Matrix');


var _BEACHBALL_METHODS,
    _D2R,
    _R2D,
    __calculatePlane,
    __fromProduct,
    __fromStrikeDipRake,
    __range,
    __sortEigenvalues,
    Tensor;


_BEACHBALL_METHODS = {
  'smi:ci.anss.org/momentTensor/TMTS': 'TMTS',
  'smi:nc.anss.org/momentTensor/TMTS': 'TMTS',
  'smi:nc.anss.org/momentTensor/TMTS-ISO': 'TMTS-ISO',
  'smi:uu.anss.org/momentTensor/TDMT': 'TDMT'
};

_D2R = Math.PI / 180;
_R2D = 180 / Math.PI;

/**
 * Calculate one nodal plane.
 *
 * Argument order matters, so getPlane(v1, v2) and getPlane(v2, v1)
 * are different planes.
 *
 * @param v1 {Vector}
 *     first vector.
 * @param v2 {Vector}
 *     second vector.
 * @return {Object}
 *     computed plane, defined as the properties strike, dip, and rake.
 */
__calculatePlane = function (v1, v2) {
  v1 = v1.unit();
  v2 = v2.unit();
  // make sure first vector dips downward
  if (v1.z() > 0) {
    v1 = v1.multiply(-1);
    v2 = v2.multiply(-1);
  }
  return {
    strike: __range(Math.atan2(-v1.x(), v1.y()), 0, 2 * Math.PI) * _R2D,
    dip: Math.acos(-v1.z()) * _R2D,
    rake: Math.atan2(-v2.z(), v2.cross(v1).z()) * _R2D
  };
};

/**
 * Create a Tensor object from a Product object.
 *
 * @param product {Product}
 *     a focal-mechanism or moment-tensor product.
 */
__fromProduct = function (product) {
  var depth,
      props,
      type,
      tensor;

  tensor = null;
  type = product.get('type');
  props = product.get('properties') || {};

  if (type === 'focal-mechanism') {
    tensor = __fromStrikeDipRake(
        Number(props['nodal-plane-1-strike']),
        Number(props['nodal-plane-1-dip']),
        Number(props['nodal-plane-1-rake'] || props['nodal-plane-1-slip'] || 0),
        Number(props['scalar-moment'] || Math.SQRT2));
  } else if (type === 'moment-tensor') {
    tensor = Tensor({
      mrr: Number(props['tensor-mrr']),
      mtt: Number(props['tensor-mtt']),
      mpp: Number(props['tensor-mpp']),
      mrt: Number(props['tensor-mrt']),
      mrp: Number(props['tensor-mrp']),
      mtp: Number(props['tensor-mtp'])
    });

    depth = product.getProperty('derived-depth');
    if (depth === null)  {
      depth = product.getProperty('depth');
    }

    tensor.depth = depth;
  }

  if (tensor) {
    type = product.getProperty('derived-magnitude-type');
    if (!type) {
      type = product.getProperty('beachball-type');
      if (type && _BEACHBALL_METHODS.hasOwnProperty(type)) {
        type = _BEACHBALL_METHODS[type];
      }
    }

    if (type) {
      tensor.type = type;
    }
  }

  return tensor;
};

/**
 * Create a Tensor from strike, dip, and rake of one nodal plane.
 *
 * @param strike {Number}
 *        strike of nodal plane in degrees.
 * @param dip {Number}
 *        dip of nodal plane in degrees.
 * @param rake {Number}
 *        rake of nodal plane in degrees.
 * @param moment {Number}
 *        scale resulting matrix by this number.
 * @return Tensor object.
 */
__fromStrikeDipRake = function(strike, dip, rake, moment) {
  var c2d,
      c2s,
      cd,
      cr,
      cs,
      d,
      mxx,
      mxy,
      mxz,
      myy,
      myz,
      mzz,
      r,
      s,
      s2d,
      s2s,
      sd,
      sr,
      ss;

  s = strike * _D2R;
  ss = Math.sin(s);
  cs = Math.cos(s);
  s2s = Math.sin(2*s);
  c2s = Math.cos(2*s);
  d = dip * _D2R;
  sd = Math.sin(d);
  cd = Math.cos(d);
  s2d = Math.sin(2*d);
  c2d = Math.cos(2*d);
  r = (rake % 90 !== 0 ? rake : rake + 1e-15) * _D2R;
  sr = Math.sin(r);
  cr = Math.cos(r);

  // mtt
  mxx = -1 * (sd * cr * s2s + s2d * sr * ss * ss);
  // -mtp
  mxy =      (sd * cr * c2s + s2d * sr * s2s * 0.5);
  // mrt
  mxz = -1 * (cd * cr * cs  + c2d * sr * ss);
  // mpp
  myy =      (sd * cr * s2s - s2d * sr * cs * cs);
  // -mrp
  myz = -1 * (cd * cr * ss  - c2d * sr * cs);
  // mrr
  mzz =      (s2d * sr);

  return Tensor({
    mrr:  mzz * moment,
    mtt:  mxx * moment,
    mpp:  myy * moment,
    mtp: -mxy * moment,
    mrp: -myz * moment,
    mrt:  mxz * moment
  });
};

/**
 * Shift a number until it is in the specified range.
 *
 * Add or subtract the range size (max - min) until value is between.
 *
 * @param value {Number}
 *        value to normalize.
 * @param min {Number}
 *        range minimum.
 * @param max {Number}
 *        range maximum.
 * @return {Number} value in the range [min, max).
 */
__range = function (value, min, max) {
  var span = max - min;
  while (value < min) {
    value += span;
  }
  while (value >= max) {
    value -= span;
  }
  return value;
};

/**
 * Sort eigen vectors in descending order by magnitude.
 *
 * @param v1 {Vector}
 *     first vector.
 * @param v2 {Vector}
 *     second vector.
 */
__sortEigenvalues = function (v1, v2) {
  var v1mag,
      v2mag;
  // largest value first
  v1mag = v1.eigenvalue;
  v2mag = v2.eigenvalue;
  if (v1mag < v2mag) {
    return 1;
  } else if (v1mag > v2mag) {
    return -1;
  } else {
    return 0;
  }
};

/**
 * Construct a new tensor.
 *
 * @param mtt {Number}
 *        mtt value in N-m.
 * @param mpp {Number}
 *        mpp value in N-m.
 * @param mrr {Number}
 *        mrr value in N-m.
 * @param mrt {Number}
 *        mrt value in N-m.
 * @param mrp {Number}
 *        mrp value in N-m.
 * @param mtp {Number}
 *        mtp value in N-m.
 */
 Tensor = function (options) {
  var _this,
      _initialize;

  _this = {};

  _initialize = function (options) {
    var eigen,
        exponent,
        l,
        moment,
        moment_log10,
        mpp,
        mrr,
        mrt,
        mrp,
        mtp,
        mtt,
        n,
        p,
        t;

    _this.mtt = mtt = options.mtt || options.mxx || 0;
    _this.mpp = mpp = options.mpp || options.myy || 0;
    _this.mrr = mrr = options.mrr || options.mzz || 0;
    _this.mrt = mrt = options.mrt || options.mxz || 0;
    _this.mrp = mrp = options.mrp || -options.myz || 0;
    _this.mtp = mtp = options.mtp || -options.mxy || 0;
    _this.units = 'N-m';

    // calculate moment and derived values
    _this.moment = moment = Math.sqrt(0.5 *
        ( (mrr * mrr + mtt * mtt + mpp * mpp) +
        2 * (mrt * mrt + mrp * mrp + mtp * mtp) ));
    _this.moment_log10 = moment_log10 = Math.log(moment) / Math.LN10;
    _this.exponent = exponent = parseInt(moment_log10, 10);
    _this.scale = Math.pow(10, exponent);
    _this.magnitude = (2/3) * (moment_log10 - 9.1);

    // calculate principal axes
    _this.matrix = Matrix([
      mtt, -mtp, mrt,
      -mtp, mpp, -mrp,
      mrt, -mrp, mrr
    ], 3, 3);
    eigen = _this.matrix.jacobi();
    eigen.sort(__sortEigenvalues);
    _this.T = t = eigen[0];
    _this.N = n = eigen[1];
    _this.P = p = eigen[2];
    _this.fCLVD = n.eigenvalue /
        Math.max(Math.abs(t.eigenvalue), Math.abs(p.eigenvalue));
    _this.percentDC = Math.abs(1 - Math.abs(_this.fCLVD) / 0.5);
    _this.forceThrust = Math.pow(Math.sin(t.plunge()), 2);
    _this.forceStrikeSlip = Math.pow(Math.sin(n.plunge()), 2);
    _this.forceNormal = Math.pow(Math.sin(p.plunge()), 2);

    // calculate nodal planes
    // p = (n - l) / sqrt2
    // t = (n + l) / sqrt2
    l = t.subtract(p).unit();
    n = t.add(p).unit();
    _this.NP1 = __calculatePlane(l, n);
    _this.NP2 = __calculatePlane(n, l);
  };


  _initialize(options);
  options = null;
  return _this;
};


// add static methods
Tensor.calculatePlane = __calculatePlane;
Tensor.fromProduct = __fromProduct;
Tensor.fromStrikeDipRake = __fromStrikeDipRake;


module.exports = Tensor;

},{"math/Matrix":30}],"mvc/Model":[function(require,module,exports){
'use strict';

var Events = require('../util/Events'),
    Util = require('../util/Util');

/**
 * Constructor
 *
 * @param data {Object}
 *      key/value attributes of this model.
 */
var Model = function (data) {
  var _this,
      _initialize,

      _model;


  _this = Events();

  _initialize = function () {
    _model = Util.extend({}, data);

    // track id at top level
    if (data && data.hasOwnProperty('id')) {
      _this.id = data.id;
    }

    data = null;
  };

  /**
   * Get one or more values.
   *
   * @param key {String}
   *      the value to get; when key is undefined, returns the object with all
   *      values.
   * @return
   *      - if key is specified, the value or null if no value exists.
   *      - when key is not specified, the underlying object is returned.
   *        (Any changes to this underlying object will not trigger events!!!)
   */
  _this.get = function (key) {
    if (typeof(key) === 'undefined') {
      return _model;
    }

    if (_model.hasOwnProperty(key)) {
      return _model[key];
    }

    return null;
  };

  /**
   * Update one or more values.
   *
   * @param data {Object}
   *      the keys and values to update.
   * @param options {Object}
   *      options for this method.
   * @param options.silent {Boolean}
   *      default false. true to suppress any events that would otherwise be
   *      triggered.
   */
  _this.set = function (data, options) {
    // detect changes
    var changed = {},
      anyChanged = false,
      c;

    for (c in data) {
      if (!_model.hasOwnProperty(c) || _model[c] !== data[c]) {
        changed[c] = data[c];
        anyChanged = true;
      }
    }

    // persist changes
    _model = Util.extend(_model, data);

    // if id is changing, update the model id
    if (data && data.hasOwnProperty('id')) {
      _this.id = data.id;
    }

    if (options && options.hasOwnProperty('silent') && options.silent) {
      // don't trigger any events
      return;
    }

    // trigger events based on changes
    if (anyChanged ||
        (options && options.hasOwnProperty('force') && options.force)) {
      for (c in changed) {
        // events specific to a property
        _this.trigger('change:' + c, changed[c]);
      }
      // generic event for any change
      _this.trigger('change', changed);
    }
  };

  /**
   * Override toJSON method to serialize only model data.
   */
  _this.toJSON = function () {
    var json = Util.extend({}, _model),
        key,
        value;

    for (key in json) {
      value = json[key];

      if (typeof value === 'object' &&
          value !== null &&
          typeof value.toJSON === 'function') {
        json[key] = value.toJSON();
      }
    }

    return json;
  };


  _initialize();
  return _this;
};

module.exports = Model;

},{"../util/Events":"util/Events","../util/Util":"util/Util"}],"mvc/View":[function(require,module,exports){
'use strict';
/**
 * A lightweight view class.
 *
 * Primarily manages an element where a view can render its data.
 */


var Model = require('./Model'),

    Events = require('../util/Events'),
    Util = require('../util/Util');


var _DEFAULTS = {
};


/** create a new view. */
var View = function (params) {
  var _this,
      _initialize,

      _destroyModel;


  _this = Events();

  /**
   * @constructor
   *
   */
  _initialize = function (params) {
    params = Util.extend({}, _DEFAULTS, params);

    // Element where this view is rendered
    _this.el = (params && params.hasOwnProperty('el')) ?
        params.el : document.createElement('div');

    _this.model = params.model;

    if (!_this.model) {
      _this.model = Model({});
      _destroyModel = true;
    }

    _this.model.on('change', 'render', _this);
  };


  /**
   * API Method
   *
   * Renders the view
   */
  _this.render = function () {
    // Impelementations should update the view based on the current
    // model properties.
  };

  /**
   * API Method
   *
   * Cleans up resources allocated by the view. Should be called before
   * discarding a view.
   */
  _this.destroy = Util.compose(function () {
    if (_this ===  null) {
      return; // already destroyed
    }

    _this.model.off('change', 'render', _this);

    if (_destroyModel) {
      _this.model.destroy();
    }

    _destroyModel = null;

    _this.model = null;
    _this.el = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);


  _initialize(params);
  params = null;
  return _this;
};

module.exports = View;

},{"../util/Events":"util/Events","../util/Util":"util/Util","./Model":"mvc/Model"}],"oaf/ForecastTableView":[function(require,module,exports){
'use strict';


var ForecastView = require('oaf/ForecastView'),
    Formatter = require('core/Formatter'),
    Util = require('util/Util');


var _DEFAULTS = {

};


var ForecastTableView = function (options) {
  var _this,
      _initialize,

      _formatter;


  options = Util.extend({}, _DEFAULTS, options);
  _this = ForecastView(options);

  _initialize = function (options) {
    _this.el.classList.add('oaf-forecast-table-view');

    _formatter = options.formatter || Formatter();
  };

  _this.destroy = Util.compose(function () {
    _this.el.classList.remove('oaf-forecast-table-view');

    _formatter = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  _this.getRowHeader = function (info) {
    var th;

    th = document.createElement('th');
    th.setAttribute('scope', 'row');
    th.setAttribute('rowspan', info.bins.length);

    th.innerHTML = [
      '<strong>', info.label, '</strong>',
      '<br/>',
      _formatter.datetime(new Date(info.timeStart)),
      '<br/>through<br/>',
      _formatter.datetime(new Date(info.timeEnd))
    ].join('');

    return th;
  };

  _this.getTable = function (data) {
    var table,
        wrapper;

    wrapper = document.createElement('div');
    wrapper.classList.add('horizontal-scrolling');

    table = wrapper.appendChild(document.createElement('table'));

    table.innerHTML = [
      '<thead>',
        '<tr>',
          '<th scope="col">',
            'Time Window for Analysis',
          '</th>',
          '<th scope="col">',
            'Magnitude (M) range of aftershocks considered',
          '</th>',
          '<th scope="col">',
            'Most likely number of aftershocks (95 % condidence)',
          '</th>',
          '<th scope="col">',
            'Probability of one or more aftershocks',
          '</th>',
        '</tr>',
      '</thead>'
    ].join('');

    table.appendChild(_this.getTableBody(data));

    return wrapper;
  };

  _this.getTableBody = function (data) {
    var body;

    body = document.createElement('tbody');

    data.forecast.forEach(function (info) {
      body.appendChild(_this.getTableRow(info));
    });

    return body;
  };

  _this.getTableRow = function (info) {
    var fragment,
        row;

    fragment = document.createDocumentFragment();

    row = fragment.appendChild(document.createElement('tr'));
    row.classList.add('separator');
    row.appendChild(_this.getRowHeader(info));

    info.bins.forEach(function (bin, index) {
      var detailRow;

      if (index === 0) {
        detailRow = row;
      } else {
        detailRow = fragment.appendChild(document.createElement('tr'));
      }

      detailRow.appendChild(_this.getTableRowDetails(bin));
    });

    return fragment;
  };

  _this.getTableRowDetails = function (bin) {
    var expCell,
        magCell,
        p95Cell,
        row;

    row = document.createDocumentFragment();

    // Magnitude
    magCell = row.appendChild(document.createElement('td'));
    magCell.innerHTML = 'M &ge; ' + bin.magnitude;

    // 95 % confidence
    p95Cell = row.appendChild(document.createElement('td'));
    if (bin.p95minimum + bin.p95maximum) {
      p95Cell.innerHTML = bin.p95minimum + ' to ' + bin.p95maximum;
    } else {
      p95Cell.innerHTML = '*';
    }

    // Expectation
    expCell = row.appendChild(document.createElement('td'));
    if (bin.probability < 0.01) {
      expCell.innerHTML = '&lt; 1 %';
    } else if (bin.probability < 1.0) {
      expCell.innerHTML = _formatter.number(
          bin.probability*100, 0, '&ndash', '%');
    } else {
      expCell.innerHTML = '&gt; 99 %';
    }

    return row;
  };

  _this.renderForecast = function () {
    var footnote,
        topnote;

    _this.el.innerHTML = '';

    topnote = _this.el.appendChild(document.createElement('p'));
    topnote.classList.add('alert');
    topnote.innerHTML = [
      'Note: The expected rate of earthquakes continues to decline throughout ',
      'the time windows. The probabilities in the longer time windows are ',
      'higher only because the rates are being summed over a longer time ',
      'period. These longer periods may be useful when planning recovery ',
      'and rebuliding projects.'
    ].join('');

    _this.el.appendChild(_this.getTable(_this.forecast || {forecast:[]}));

    footnote = _this.el.appendChild(document.createElement('small'));
    footnote.innerHTML = '* Earthquake possible but with a low probability.';
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = ForecastTableView;

},{"core/Formatter":"core/Formatter","oaf/ForecastView":"oaf/ForecastView","util/Util":"util/Util"}],"oaf/ForecastTextView":[function(require,module,exports){
'use strict';


var ForecastView = require('oaf/ForecastView'),
    Formatter = require('core/Formatter'),
    Product = require('pdl/Product'),
    Util = require('util/Util');


var _DEFAULTS = {

};


var ForecastTextView = function (options) {
  var _this,
      _initialize,

      _catalogEvent,
      _formatter,
      _product;


  options = Util.extend({}, _DEFAULTS, options);
  _this = ForecastView(options);

  _initialize = function (options) {
    _this.el.classList.add('oaf-forecast-text-view');

    _catalogEvent = options.catalogEvent;
    _formatter = options.formatter || Formatter();
    _product = options.product || Product();
  };


  _this.getCommentary = function (forecast) {
    var awarenessTimeSpan,
        commentary,
        elevatedTimeSpan,
        feltTimeSpan,
        m3display,
        m5display,
        m6display,
        m7display,
        magDisplay,
        magnitude,
        mostAftershocksTimeSpan,
        place,
        summary,
        wcDisplay,
        weekFromIssue,
        weekInfo;

    if (_catalogEvent) {
      summary = _catalogEvent.getSummary() || {properties: {}};
      magnitude = _catalogEvent.getMagnitude();

      elevatedTimeSpan = (magnitude >= 6.0) ?
          'the next year or longer' :
          'the next month or longer';

      mostAftershocksTimeSpan = (magnitude >= 6.0) ?
          'the first few weeks' :
          'the first few days';

      magDisplay = _formatter.magnitude(magnitude);
      place = summary.properties.place;

      wcDisplay = _formatter.distance(
          2 * _product.getProperty('wcradius'), 'km');

      awarenessTimeSpan = (magnitude >= 6.0) ?
          'the coming months' :
          'the coming weeks';

      weekFromIssue = _formatter.datetime(604800000 +
          _product.get('updateTime') || 0);

      weekInfo = forecast.forecast[1];

      m3display = _this.getProbAndExp(weekInfo.bins[0]);
      m5display = _this.getProbAndExp(weekInfo.bins[1]);
      m6display = _this.getProbAndExp(weekInfo.bins[2]);
      m7display = _this.getProbAndExp(weekInfo.bins[3]);

      feltTimeSpan = (magnitude >= 6.0) ?
          'next month and next year' :
          'next week and next month';
    } else {
      // What are doing if no event ... ???
      elevatedTimeSpan = 'the next month or longer';
      mostAftershocksTimeSpan = 'the first few days';
      place = '&ndash;';
      wcDisplay = '&ndash;';
      awarenessTimeSpan = 'the coming weeks';
      weekFromIssue = _formatter.datetime(604800000 + (new Date()).getTime());

      m3display = {
        expectation: '&ndash;',
        probability: '&ndash;'
      };

      m5display = {
        expectation: '&ndash;',
        probability: '&ndash;'
      };

      m6display = {
        expectation: '&ndash;',
        probability: '&ndash;'
      };

      m7display = {
        expectation: '&ndash;',
        probability: '&ndash;'
      };

      feltTimeSpan = 'next week and next month';
    }

    commentary = document.createElement('article');
    commentary.innerHTML = [
      '<h2>What to Expect</h2>',
      '<p>',
        'It is normal for an earthquake of this size to cause an ',
        'increase in the number of earthquakes (called aftershocks) ',
        'in the area within ',
        elevatedTimeSpan, '. ',
        'Most of these aftershocks will likely occur within ',
        mostAftershocksTimeSpan, ' ',
        'and the number of aftershocks will drop off over time, but a ',
        'large aftershock can increase the numbers again, temporarily.',
      '</p>',
      '<p>',
        'The aftershocks will occur mostly in the area affected by the ',
        'magnitude ', magDisplay, ' ', place, ' ',
        'earthquake, approximately within ',
        wcDisplay, ' of ', place, '.',
      '</p>',
      '<p>',
        'When there are more earthquakes, the chance of a large ',
        'earthquake is greater and the chance of damage is greater. ',
        'The USGS advises everyone to remain aware of the possibility ',
        'of aftershocks in ', awarenessTimeSpan, ', ',
        'especially when in or around vulnerable structures such as ',
        'unreinforced masonry buildings.',
      '</p>',
      '<p>',
        'No one can predict the exact time or place of any earthquake, ',
        'including aftershocks. The USGS can forecast how many ',
        'earthquakes to expect, or the chance of having an earthquake ',
        'within a given time period.',
      '</p>',

      '<h2>Current Aftershock Forecast</h2>',
      '<p>',
        'The USGS estimates the chance of more aftershocks as follows.<br/>',
        'Within the next week until ', weekFromIssue,
      '</p>',
      '<ul>',
        '<li>',
          'the chance of an earthquake large enough to feel ',
          '(magnitude 3 or higher) is ',
          m3display.probability, ', and ', m3display.expectation, '.',
        '</li>',
        '<li>',
          'the chance of an earthquake of magnitude 5 or higher is ',
          m5display.probability, ', and ', m5display.expectation, '.',
        '</li>',
        '<li>',
          'the chance of an earthquake of magnitude 6 or higher is ',
          m6display.probability, ', and ', m6display.expectation, '.',
        '</li>',
        '<li>',
          'the chance of an earthquake of magnitude 7 or higher is ',
          m7display.probability, ', and ', m7display.expectation, '.',
        '</li>',
      '</ul>',
      '<p>',
        'The chance of earthquakes large enough to be felt or to cause ',
        'damage remains elevated for the ', feltTimeSpan, '.',
      '</p>',
      '<p>',
        'The USGS calculates this earthquake forecast using a statistical ',
        'analysis based on past earthquakes and the aftershocks recorded ',
        'for this sequence. The forecast changes as time passes due to ',
        'the decay in the frequency of aftershocks, larger aftershocks ',
        'that may trigger further earthquakes, and changes in forecast ',
        'modeling based on the earthquake data collected.',
      '</p>'
    ].join('');

    return commentary;
  };

  _this.getProbAndExp = function (info) {
    var expectation,
        probability;

    if (info.probability <= 0.01) {
      probability = '1 in 100';
    } else if (info.probability < 1.0) {
      probability = _formatter.number(
          info.probability * 100, 0, '&ndash', '%');
    } else {
      probability = '&gt; 99 %';
    }

    if (info.p95minimum + info.p95maximum) {
      expectation = 'it is most likely that ' +
          info.p95minimum + ' to ' + info.p95maximum +
          ' such earthquakes may occur' ;
    } else {
      expectation = 'such an earthquake is possible, but with low probability';
    }

    return {
      expectation: expectation,
      probability: probability
    };
  };

  _this.destroy = Util.compose(function () {
    _this.el.classList.remove('oaf-forcast-text-view');

    _catalogEvent = null;
    _formatter = null;
    _product = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  _this.renderForecast = function () {
    _this.el.innerHTML = '';
    _this.el.appendChild(_this.getCommentary(_this.forecast));
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = ForecastTextView;

},{"core/Formatter":"core/Formatter","oaf/ForecastView":"oaf/ForecastView","pdl/Product":"pdl/Product","util/Util":"util/Util"}],"oaf/ForecastView":[function(require,module,exports){
'use strict';


var ContentView = require('core/ContentView'),
    Util = require('util/Util');


var _DEFAULTS = {

};


var ForecastView = function (options) {
  var _this,
      _initialize;


  options = Util.extend({}, _DEFAULTS, options);
  _this = ContentView(options);

  _initialize = function (/*options*/) {

  };


  _this.destroy = Util.compose(function () {

    _initialize = null;
    _this = null;
  }, _this.destroy);

  _this.onError = function (/*status, xhr*/) {
    _this.el.innerHTML = '<p class="alert error">' +
        'Failed to load forecast data.</p>';
  };

  _this.onSuccess = function (data/*, xhr*/) {
    _this.forecast = data;
    _this.render();
    _this.trigger('forecast', _this.forecast);
  };

  _this.render = function () {
    if (!_this.forecast) {
      _this.el.innerHTML = '<p>Loading content&hellip;</p>';
      _this.fetchData();
    } else {
      _this.renderForecast();
    }
  };

  _this.renderForecast = function () {
    _this.el.innerHTML = JSON.stringify(_this.forecast);
  };

  _this.setForecast = function (forecast) {
    _this.forecast = forecast;
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = ForecastView;

},{"core/ContentView":"core/ContentView","util/Util":"util/Util"}],"oaf/ModelDetailsView":[function(require,module,exports){
'use strict';


var ForecastView = require('oaf/ForecastView'),
    Util = require('util/Util');


var _DEFAULTS = {

};


var ModelDetailsView = function (options) {
  var _this,
      _initialize;


  options = Util.extend({}, _DEFAULTS, options);
  _this = ForecastView(options);

  _initialize = function (/*options*/) {

  };


  _this.destroy = Util.compose(function () {

    _initialize = null;
    _this = null;
  }, _this.destroy);

  _this.renderForecast = function () {
    var model;

    // This is the aftershock mathematical model and has nothing to do with MVC
    model = _this.forecast.model;

    _this.el.innerHTML = [
      '<h3>', model.name, '</h3>',
      '<p>',
        'Reference Link: ',
        '<a href="', model.reference, '">', model.reference, '</a>',
      '</p>',
      '<table class="oaf-model-parameters">',
        '<tbody>',
          Object.keys(model.parameters).reduce(function (markup, key) {
            markup.push('<tr><th scope="row">' + key + '</th>' +
                '<td>' + model.parameters[key] + '</td></tr>');

            return markup;
          }, []).join(''),
        '</tbody>',
      '</table>'
    ].join('');
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = ModelDetailsView;

},{"oaf/ForecastView":"oaf/ForecastView","util/Util":"util/Util"}],"oaf/OafModule":[function(require,module,exports){
'use strict';


var Formatter = require('core/Formatter'),
    LinkProductView = require('core/LinkProductView'),
    OafView = require('oaf/OafView'),
    ScientificSummaryModule = require('scientific/ScientificSummaryModule'),
    TextProductView = require('core/TextProductView'),
    Util = require('util/Util'),
    Module = require('core/Module');


var _DEFAULTS,
    _ID,
    _TITLE,
    _TYPES;

_ID = 'oaf';
_TITLE = 'Aftershock Forecast';
_TYPES = ['oaf'];

_DEFAULTS = {

};


var OafModule = function (options) {
  var _this,
      _initialize,

      _formatter,
      _oafView,
      _subviews;


  options = Util.extend({}, _DEFAULTS, options);
  _this = Module(options);

  _initialize = function (options) {
    _this.ID = _ID;
    _this.TITLE = _TITLE;

    _formatter = options.formatter || Formatter();
    _subviews = [];
  };


  _this.destroy = Util.compose(function () {
    _this.destroyViews();

    _formatter = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  _this.destroyViews = function () {
    if (_oafView && _oafView.destroy) {
      _oafView.destroy();
    }

    if (_subviews) {
      _subviews.forEach(function (view) {
        if (view && view.destroy) {
          try { view.destroy(); } catch (e) { /* ignore */ }
        }
      });
    }

    _oafView = null;
    _subviews = null;
  };

  _this.getOafLinkViews = function () {
    var header,
        products,
        ul,
        wrapper;

    wrapper = document.createDocumentFragment();

    products = _this.getProducts('oaf-link');
    if (products.length) {
      header = wrapper.appendChild(document.createElement('h3'));
      ul = wrapper.appendChild(document.createElement('ul'));

      header.innerHTML = 'More Aftershock Information';

      products.forEach(function (product) {
        var view;

        view = LinkProductView({
          el: ul.appendChild(document.createElement('li')),
          formatter: _formatter,
          model: product
        });

        view.render();

        _subviews.push(view);
      });
    }

    return wrapper;
  };

  _this.getOafTextViews = function () {
    var fragment,
        products;

    fragment = document.createDocumentFragment();
    products = _this.getProducts('oaf-header');

    products.forEach(function (product) {
      var view;

      view = TextProductView({
        model: product,
        el: fragment.appendChild(document.createElement('div'))
      });

      view.render();

      _subviews.push(view);
    });

    return fragment;
  };

  _this.render = function () {
    var product;

    _this.destroyViews();
    _subviews = [];

    _this.header.innerHTML = '';
    _this.content.innerHTML = '';
    _this.footer.innerHTML = '';

    product = _this.getProduct('oaf');

    if (product) {
      _this.renderHeader(product);
      _this.renderContent(product);
      _this.renderFooter(product);
    } else {
      _this.content.innerHTML = '<p class="alert info">' +
          'No aftershock forecast is available for this event.</p>';
    }
  };

  _this.renderContent = function (product) {
    if (product) {
      _oafView = OafView({
        catalogEvent: _this.model.get('event'),
        el: _this.content,
        model: product
      });

      _oafView.render();
    }
  };

  _this.renderFooter = function (product) {
    var expires;

    if (product) {
      expires = _this.footer.appendChild(document.createElement('small'));
      expires.innerHTML = [
        'This advisory will be updated on or before: ',
        _formatter.datetime(new Date(604800000 + product.get('updateTime')))
      ].join('');
    }

    _this.footer.appendChild(_this.getOafLinkViews());

    if (product) {
      // Generates download section
      _this.footer.appendChild(_this.getProductFooter({
        product: product
      }));
    }
  };

  _this.renderHeader = function (product) {
    _this.header.innerHTML = '<h3>' + _this.TITLE + '</h3>';

    if (product) {
      _this.header.appendChild(_this.getProductHeader({
        product: product,
        summaryModule: ScientificSummaryModule
      }));
    }

    _this.header.appendChild(_this.getOafTextViews());
  };


  _initialize(options);
  options = null;
  return _this;
};


OafModule.ID = _ID;
OafModule.TITLE = _TITLE;
OafModule.TYPES = _TYPES;


module.exports = OafModule;

},{"core/Formatter":"core/Formatter","core/LinkProductView":"core/LinkProductView","core/Module":"core/Module","core/TextProductView":"core/TextProductView","oaf/OafView":"oaf/OafView","scientific/ScientificSummaryModule":"scientific/ScientificSummaryModule","util/Util":"util/Util"}],"oaf/OafView":[function(require,module,exports){
'use strict';


var ForecastTableView = require('oaf/ForecastTableView'),
    ForecastTextView = require('oaf/ForecastTextView'),
    ModelDetailsView = require('oaf/ModelDetailsView'),
    ProductView = require('core/ProductView'),
    TabList = require('tablist/TabList'),
    Util = require('util/Util');


var _DEFAULTS,
    _RESOURCES;

_DEFAULTS = {
};

_RESOURCES = {
  'forecast-text': {
    title: 'Commentary',
    content: 'forecast.json',
    subview: ForecastTextView
  },
  'forecast-table': {
    title: 'Forecast Probabilities',
    content: 'forecast.json',
    subview: ForecastTableView
  },
  'forecast-model': {
    title: 'Model Details',
    content: 'forecast.json',
    subview: ModelDetailsView
  }
};


var OafView = function (options) {
  var _this,
      _initialize,

      _catalogEvent,
      _resources,
      _subviews,
      _tabList,
      _tabs;

  options = Util.extend({}, _DEFAULTS, options);
  _this = ProductView(options);

  _initialize = function (options) {
    _this.el.classList.add('oaf-view');

    _catalogEvent = options.catalogEvent;

    _resources = Util.extend({}, _RESOURCES, options.resources);
  };


  _this.createTab = function (params) {
    var content,
        subview,
        tab;

    content = _this.model.getContent(params.content);

    if (content && params.subview) {
      subview = params.subview({
          catalogEvent: _catalogEvent,
          model: content,
          product: _this.model
      });

      subview.on('forecast', 'setSubviewForecast', _this);
      _subviews.push(subview);

      tab = {
        title: params.title,
        content: subview.el,
        onDestroy: function () {
          try { subview.destroy(); } catch (e) { /* ignore */ }
        },
        onSelect: function () {
          subview.render();
        }
      };
    }

    return tab;
  };

  _this.destroy = Util.compose(function () {
    _this.el.classList.remove('oaf-view');

    _this.destroyTabList();

    _resources = null;
    _tabList = null;
    _tabs = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  _this.destroyTabList = function () {
    if (_tabList && _tabList.destroy) {
      _tabList.destroy();
    }

    _subviews = null;
    _tabList = null;
    _tabs = null;
  };

  _this.render = function () {
    _this.destroyTabList();

    _tabList = TabList({
      el: _this.el,
      tabs: []
    });

    _subviews = [];
    _tabs = {};

    Object.keys(_resources).forEach(function (key) {
      var info,
          tab;

      info = _resources[key];
      tab = _this.createTab(info);
      if (tab) {
        _tabs[key] = _tabList.addTab(tab);
      }
    });
  };

  _this.setSubviewForecast = function (forecast) {
    _subviews.forEach(function (subview) {
      if (subview && typeof subview.setForecast === 'function') {
        subview.setForecast(forecast);
      }
    });
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = OafView;

},{"core/ProductView":"core/ProductView","oaf/ForecastTableView":"oaf/ForecastTableView","oaf/ForecastTextView":"oaf/ForecastTextView","oaf/ModelDetailsView":"oaf/ModelDetailsView","tablist/TabList":"tablist/TabList","util/Util":"util/Util"}],"origin/MagnitudesView":[function(require,module,exports){
'use strict';


var Accordion = require('accordion/Accordion'),
    Attribution = require('core/Attribution'),
    QuakemlView = require('origin/QuakemlView'),
    Util = require('util/Util');


var _DEFAULTS = {

};

// Value to display when a value is not provided
var _NOT_REPORTED = '&ndash;';


/**
 * View for displaying magnitude information found in a quakeml.xml {Content}
 * object. This view uses event delegation through a single {Accordion} instance
 * to deal with click events and it manually builds accordion markup for
 * each magnitude item.
 *
 * @param options {Object}
 *     Configuration options for this view. See _initialize method documentation
 *     for details.
 */
var MagnitudesView = function (options) {
  var _this,
      _initialize,

      _accordion;


  options = Util.extend({}, _DEFAULTS, options);
  _this = QuakemlView(options);

  /**
   * Constructor. Initializes a new {MagnitudesView}.
   *
   * @param options {Object}
   *     Configuration options for this view.
   * @param options.model {Content}
   *     The content model to render.
   * @param options.product {Product}
   *     The product that contains the given {Content}. Typically an origin
   *     or phase-data product.
   */
  _initialize = function (/*options*/) {
    _accordion = Accordion({
      el: _this.el
    });
  };


  /**
   * Frees resources allocated to this view.
   *
   */
  _this.destroy = Util.compose(function () {
    _accordion.destroy();

    _accordion = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Returns markup for the contributions table. This includes
   * a scrolling wrapper for responsiveness. If no contributions are provided,
   * this markup consists of an informational alert message.
   *
   * @param contributions {Array}
   *     An array of contribution information.
   *
   * @return {String}
   */
  _this.getContributionsMarkup = function (contributions) {
    if (!contributions || contributions.length === 0) {
      return '<p class="alert info">' +
          'No amplitudes contributed for this magnitude.</p>';
    } else {
      return [
        '<div class="horizontal-scrolling">',
          '<table class="magnitude-stations">',
            '<thead>',
              _this.getStationTableHeaderRow(),
            '</thead>',
            '<tbody>',
              contributions.reduce(function (markup, contribution) {
                markup.push(_this.getStationTableRow(contribution));
                return markup;
              }, []).join(''),
            '</tbody>',
          '</table>',
        '</div>'
      ].join('');
    }
  };

  /**
   * Returns markup for the table header row for the station details table.
   *
   * @return {String}
   */
  _this.getStationTableHeaderRow = function () {
    return [
      '<tr>',
        '<th scope="col">',
          '<abbr title="Network Station Channel Location">Channel</abbr>',
        '</th>',
        '<th scope="col">Type</th>',
        '<th scope="col">Amplitude</th>',
        '<th scope="col">Period</th>',
        '<th scope="col">Status</th>',
        '<th scope="col">Magnitude</th>',
        '<th scope="col">Weight</th>',
      '</tr>'
    ].join('');
  };

  /**
   * Returns markup for a single row in the station details table body.
   *
   * @param contribution {Object}
   *     An object containing contribution information. See {quakeml/Quakeml}
   *     for more details.
   *
   * @return {String}
   */
  _this.getStationTableRow = function (contribution) {
    var amp,
        amplitude,
        mag,
        period,
        station,
        stationMagnitude,
        status,
        type,
        weight;

    stationMagnitude = contribution.stationMagnitude;
    amplitude = stationMagnitude.amplitude || {};

    station = stationMagnitude.waveformID || amplitude.waveformID;

    amp = _NOT_REPORTED;
    mag = stationMagnitude.mag.value || _NOT_REPORTED;
    period = _NOT_REPORTED;
    status = amplitude.evaluationMode || stationMagnitude.status || 'automatic';
    type = stationMagnitude.type;
    weight = contribution.weight || _NOT_REPORTED;

    if (amplitude.genericAmplitude) {
      amp = amplitude.genericAmplitude.value + '&nbsp;' +
          (amplitude.unit || '');
    }

    if (amplitude.period) {
      period = amplitude.period.value + ' s';
    }

    if (period === _NOT_REPORTED && amplitude.unit === 's') {
      // quakeml requires a period value to be placed in the amplitude
      // if there is no other amplitude information
      period = amp;
      amp = _NOT_REPORTED;
    }

    return [
      '<tr>',
        '<th scope="row">',
          station.networkCode,
          ' ', station.stationCode,
          ' ', station.channelCode,
          ' ', station.locationCode,
        '</th>',
        '<td class="type">', type, '</td>',
        '<td class="amplitude">', amp, '</td>',
        '<td class="period">', period, '</td>',
        '<td class="status">', status, '</td>',
        '<td class="magnitude">', mag, '</td>',
        '<td class="weight">', weight, '</td>',
      '</tr>'
    ].join('');
  };

  /**
   * Returns markup for the magnitude error list item bubble.
   *
   * @param error {String}
   *     The error value to render.
   *
   * @return {String}
   */
  _this.getErrorMarkup = function (error) {
    return [
      '<li>',
        '<span class="bubble">',
          '<span>', error, '</span>',
          '<abbr title="Magnitude Error">Error</abbr>',
        '</span>',
      '</li>'
    ].join('');
  };

  /**
   * Returns markup for a single magnitude found in the quakeml.
   *
   * @param magnitude {Object}
   *     An object containing magntiude information as parsed out of
   *     the quakeml.
   *
   * @return {String}
   */
  _this.getMagnitudeMarkup = function (magnitude) {
    var contributions,
        error,
        mag,
        preferredType,
        source,
        stations,
        type,
        value;

    magnitude = magnitude || {};
    mag = magnitude.mag || {};

    if (magnitude.creationInfo) {
      source = magnitude.creationInfo.agencyID;
    } else {
      source = _this.product.get('source');
    }

    contributions = magnitude.contributions || [];

    type = magnitude.type || _NOT_REPORTED;
    value = mag.value || _NOT_REPORTED;
    error = mag.uncertainty || _NOT_REPORTED;
    stations = magnitude.stationCount || _NOT_REPORTED;
    preferredType = this.product.getProperty('magnitude-type') || '';

    return [
      '<section class="accordion accordion-closed magnitude-view-item">',
        (preferredType.toLowerCase() === type.toLowerCase() ?
            '<h3 class="preferred">': '<h3>' ),
          type,
        '</h3>',
        '<ul class="magnitude-summary">',
          _this.getValueMarkup(value),
          _this.getErrorMarkup(error),
          _this.getStationsMarkup(stations),
          _this.getSourceMarkup(source),
        '</ul>',
        '<a href="javascript:void(null);" class="accordion-toggle">Details</a>',
        '<div class="accordion-content">',
          _this.getContributionsMarkup(contributions),
        '</div>',
      '</section>'
    ].join('');
  };

  /**
   * Returns markup for all the magnitudes found in the quakeml.
   *
   * @param magnitudes {Array}
   *     An array of objects containing magnitude information as parsed
   *     out of the quakeml.
   *
   * @return {String}
   */
  _this.getMagnitudesMarkup = function (magnitudes) {
    magnitudes = magnitudes || [];

    return magnitudes.reduce(function (markup, magnitude) {
      markup.push(_this.getMagnitudeMarkup(magnitude));
      return markup;
    }, []).join('');
  };

  /**
   * Returns markup for the magnitude source list item bubble.
   *
   * @param source {String}
   *     The source value to render.
   *
   * @return {String}
   */
  _this.getSourceMarkup = function (source) {
    return [
      '<li>',
        '<span class="bubble">',
          Attribution.getContributorReference(source),
          '<abbr title="Magnitude Data Source">Source</abbr>',
        '</span>',
      '</li>'
    ].join('');
  };

  /**
   * Returns markup for the magnitude stations list item bubble.
   *
   * @param stations {String}
   *     The stations value to render.
   *
   * @return {String}
   */
  _this.getStationsMarkup = function (stations) {
    return [
      '<li>',
        '<span class="bubble">',
          '<span>', stations, '</span>',
          '<abbr title="Number of Stations">Stations</abbr>',
        '</span>',
      '</li>'
    ].join('');
  };

  /**
   * Returns markup for the magnitude value list item bubble.
   *
   * @param value {String}
   *     The magnitude value to render.
   *
   * @return {String}
   */
  _this.getValueMarkup = function (value) {
    return [
      '<li>',
        '<span class="bubble bubble-border">',
          '<span><strong>', value, '</strong></span>',
          '<abbr title="Magnitude">Mag</abbr>',
        '</span>',
      '</li>'
    ].join('');
  };

  /**
   * Renders the quakeml.
   *
   */
  _this.renderQuakeml = function () {
    var magnitudes;

    if (_this.quakeml) {
      // Already have quakeml, render it
      magnitudes = _this.quakeml.getMagnitudes();

      if (magnitudes.length) {
        _this.el.innerHTML = _this.getMagnitudesMarkup(magnitudes);
      } else {
        _this.el.innerHTML = '<p class="alert info">' +
            'No magnitude data available.</p>';
      }
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = MagnitudesView;

},{"accordion/Accordion":2,"core/Attribution":"core/Attribution","origin/QuakemlView":"origin/QuakemlView","util/Util":"util/Util"}],"origin/OriginModule":[function(require,module,exports){
'use strict';

var Formatter = require('core/Formatter'),
    Module = require('core/Module'),
    OriginView = require('origin/OriginView'),
    ScientificSummaryModule = require('scientific/ScientificSummaryModule'),
    Util = require('util/Util');


var _DEFAULTS,
    _ID,
    _TITLE,
    _TYPES;


_ID = 'origin';
_TITLE = 'Origin';
_TYPES = ['origin', 'phase-data'];

_DEFAULTS = {

};


var OriginModule = function (options) {
  var _this,
      _initialize,

      _formatter,
      _originView;


  _this = Module(options);

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);

    _formatter = options.formatter || Formatter;

    _this.ID = _ID;
    _this.TITLE = _TITLE;
  };


  _this.destroy = Util.compose(function () {
    if (_originView && _originView.destroy) {
      _originView.destroy();
    }

    _formatter = null;
    _originView = null;

    _initialize = null;
    _this =  null;
  }, _this.destroy);

  /**
   * Finds the proper origin-like product. First tries to get an origin product
   * if successful, checks if a phase-data product with the same source,
   * type and code exists, if so, uses that phase-data product instead.
   *
   * @return {Product}
   */
  _this.getOriginProduct = function () {
    var ev,
        origin,
        phase,
        product;

    origin = _this.getProduct('origin');

    if (origin) {
      ev = _this.model.get('event');
      phase = ev.getProductById('phase-data', origin.get('source'),
          origin.get('code'));
    }

    if (phase) {
      product = phase;
    } else {
      product = origin;
    }

    return product;
  };

  /**
   * Render the header, content and footer. Content rendering delegated
   * to {OriginView}.
   *
   */
  _this.render = function () {
    var product;

    product = _this.getOriginProduct();

    _this.renderHeader(product);
    _this.renderContent(product);
    _this.renderFooter(product);
  };

  _this.renderContent = function (product) {
    var config,
        geoserve;

    if (_originView && _originView.destroy) {
      _originView.destroy();
      _originView = null;
      // remove previous _originView skeleton
      Util.empty(_this.content);
    }

    config = _this.model.get('config');

    if (!product) {
      _this.content.innerHTML = '<p class="alert error">' +
          'No origin found!</p>';
    } else {
      geoserve = _this.getProduct('geoserve');
      _originView = OriginView({
        el: _this.content,
        formatter: _formatter,
        model: product,
        geoserve: geoserve,
        url: (config ? config.GEOSERVE_WS_URL : null)
      });

      _originView.render();
    }
  };

  /**
   * Renders the footer content. This delegates to the getProductFooter method.
   *
   */
  _this.renderFooter = function (product) {
    var downloads;

    Util.empty(_this.footer);
    if (product) {
      downloads = _this.getProductFooter({
        product: product
      });

      if (downloads) {
        _this.footer.appendChild(downloads);
      }
    }
  };

  /**
   * Renders the header content. This delegates to teh getProductHeader method.
   *
   */
  _this.renderHeader = function (product) {
    var header;

    Util.empty(_this.header);
    _this.header.innerHTML = '<h3>' + _this.TITLE + '</h3>';

    if (product) {
      header = _this.getProductHeader({
        product: product,
        summaryModule: ScientificSummaryModule,
        type: 'origin'
      });

      if (header) {
        _this.header.appendChild(header);
      }
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


OriginModule.ID = _ID;
OriginModule.TITLE = _TITLE;
OriginModule.TYPES = _TYPES;


module.exports = OriginModule;

},{"core/Formatter":"core/Formatter","core/Module":"core/Module","origin/OriginView":"origin/OriginView","scientific/ScientificSummaryModule":"scientific/ScientificSummaryModule","util/Util":"util/Util"}],"origin/OriginPinView":[function(require,module,exports){
'use strict';

var BasicPinView = require('core/BasicPinView'),
    Formatter = require('core/Formatter'),
    OriginModule = require('origin/OriginModule'),
    Util = require('util/Util');


var _DEFAULTS = {
  module: OriginModule
};


var OriginPinView = function (options) {
  var _this,
      _initialize,

      _formatter;

  options = Util.extend({}, _DEFAULTS, options);
  _this = BasicPinView(options);

  _initialize = function (options) {
    _formatter = options.formatter || Formatter();
  };

  _this.destroy = Util.compose(function () {
    _formatter = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Renders Origin content
   */
  _this.renderPinContent = function () {
    var depth,
        magnitude,
        magnitudeType,
        product,
        reviewStatus,
        time;

    product = _this.model;

    depth = product.getProperty('depth');
    magnitude = product.getProperty('magnitude');
    magnitudeType = product.getProperty('magnitude-type');
    reviewStatus = product.getProperty('review-status');
    time = product.getProperty('eventtime');

    depth = _formatter.depth(depth, 'km');
    magnitude = _formatter.magnitude(magnitude, magnitudeType);
    reviewStatus = (reviewStatus === null) ? '&ndash;' :
        reviewStatus.toUpperCase();
    time = (time === null ? '&ndash;' :
        '<time datetime="' + time + '">' +
          time.replace('T', '<br />').replace('Z', ' (UTC)') +
        '</time>');

    _this.content.innerHTML =
        '<dl class="no-style origin-pin-view">' +
          '<dt>Review Status</dt>' +
            '<dd class="origin-pin-review-status">' + reviewStatus + '</dd>' +
          '<dt>Magnitude</dt>' +
            '<dd class="origin-pin-magnitude">' + magnitude + '</dd>' +
          '<dt>Depth</dt>' +
            '<dd class="origin-pin-depth">' + depth + '</dd>' +
          '<dt>Time</dt>' +
            '<dd class="origin-pin-time">' + time + '</dd>' +
        '</dl>';
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = OriginPinView;

},{"core/BasicPinView":"core/BasicPinView","core/Formatter":"core/Formatter","origin/OriginModule":"origin/OriginModule","util/Util":"util/Util"}],"origin/OriginView":[function(require,module,exports){
'use strict';


var Attribution = require('core/Attribution'),
    Formatter = require('core/Formatter'),
    MagnitudesView = require('origin/MagnitudesView'),
    Model = require('mvc/Model'),
    PhasesView = require('origin/PhasesView'),
    ProductView = require('core/ProductView'),
    TabList = require('tablist/TabList'),
    Util = require('util/Util'),
    Xhr = require('util/Xhr');


var _DEFAULTS = {
  url: 'https://earthquake.usgs.gov/ws/geoserve/'
};
var NOT_REPORTED = '&ndash;';


var OriginView = function (options) {

  var _this,
      _initialize,

      _formatter,
      _geoserve,
      _region,
      _magnitudesView,
      _phasesView,
      _tabList,
      _url;

  options = Util.extend({}, _DEFAULTS, options);
  _this = ProductView(options);

  _initialize = function (options) {
    _formatter = options.formatter || Formatter();
    _geoserve = options.geoserve || null;
    _url = options.url;

    // Bind to geoserve model change
    _region = Model();
    _region.on('change:regions', 'buildFeRegionView', _this);
  };

  _this.destroy = Util.compose(function () {
    _region.off('change:regions', 'buildFeRegionView', _this);

    if (_tabList && _tabList.destroy) {
      _tabList.destroy();
      _tabList = null;
    }

    _formatter = null;
    _geoserve = null;
    _magnitudesView = null;
    _phasesView = null;
    _region = null;
    _url = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Build Fe Region string from the hazdev-geoserve-ws project.
   *
   * If no data is available a default message is displayed
   */
  _this.buildFeRegionView = function () {
    var fe,
        feElement,
        feName,
        feNumber;

    feElement = _this.el.querySelector('.fe-info');

    try {
      fe = _region.get('regions').fe.features[0].properties;
      feName = fe.name.toUpperCase();
      feNumber = fe.number;
      feElement.innerHTML = (feNumber ? feName + ' (' + feNumber + ')' : feName);
    } catch (e) {
      feElement.innerHTML = NOT_REPORTED;
    }
  };


  /**
   * Converts a product into an identifiable catalog and id string.
   *
   * @param product {Product}
   *    a Product model
   */
  _this.getCatalogDetail = function (product) {
    var eventId,
        eventSource,
        eventSourceCode;

    eventSource = product.getProperty('eventsource');
    eventSourceCode = product.getProperty('eventsourcecode');
    eventId = '';

    if (!eventSource) {
      return NOT_REPORTED;
    }

    eventId = (eventSource + eventSourceCode).toLowerCase();
    return eventSource.toUpperCase() + ' <small>(' + eventId + ')</small>';
  };

/**
 * Get fe region information.
 *
 * Attempts to load from a geoserve product first.
 * If no such product is found _getGeoserveFeRegion() is called
 * to retreive the fe region string from the geoserve ws.
 *
 * Once load is complete, _buildFeRegionView is called.
 */
  _this.getFeRegion = function () {
    var geoserveJson,
        that;

    that = _this;

    if (_geoserve) {
      geoserveJson = _geoserve.getContent('geoserve.json');
    }

    if (geoserveJson) {
      // if a geoserve product exists, use it
      Xhr.ajax({
        url: geoserveJson.get('url'),
        success: function (geoserve) {
          that.formatFeRegion(geoserve.fe);
        },
        error: function () {
          that.formatFeRegion(null);
        }
      });
    } else {
      // make a geoserve request
      _this.getGeoserveFeRegion();
    }
  };

  /**
   * Set _region with fe region data from the geoserve ws
   */
  _this.getGeoserveFeRegion = function () {
    var latitude,
        longitude;

    // get location
    latitude = _this.model.getProperty('latitude');
    longitude = _this.model.getProperty('longitude');

    if (latitude !== null && longitude !== null) {
      // request region information
      Xhr.ajax({
        url: _url + 'regions.json',
        data: {
          latitude: latitude,
          longitude: longitude,
          type: 'fe'
        },
        success: function (data) {
          _region.set({
            regions: data
          });
        },
        error: function () {
          throw new Error('Geoserve web service not found');
        }
      });
    }
  };

  /**
   * Builds markup for origin detail table
   *
   * @param product {Product}
   *    a Product model
   *
   * @return {string}
   *    html markup for the origin table
   */
  _this.getOriginDetailTable = function (product) {
    var azimuthalGap,
        buf,
        depth,
        depthError,
        eventTime,
        horizontalError,
        latitude,
        longitude,
        magnitude,
        magnitudeError,
        magnitudeSource,
        magnitudeType,
        minimumDistance,
        numPhases,
        numStations,
        originSource,
        reviewStatus,
        standardError;

    buf = [];

    // required attributes for origins
    latitude = product.getProperty('latitude');
    longitude = product.getProperty('longitude');
    eventTime = product.getProperty('eventtime');

    // optional attributes for origins
    magnitude = product.getProperty('magnitude');
    magnitudeType = product.getProperty('magnitude-type');
    magnitudeError = product.getProperty('magnitude-error');
    horizontalError = product.getProperty('horizontal-error');
    depth = product.getProperty('depth');
    depthError = product.getProperty('vertical-error');
    numStations = product.getProperty('num-stations-used');
    numPhases = product.getProperty('num-phases-used');
    minimumDistance = product.getProperty('minimum-distance');
    standardError = product.getProperty('standard-error');
    azimuthalGap = product.getProperty('azimuthal-gap');
    reviewStatus = product.getProperty('review-status') || 'automatic';
    originSource = product.getProperty('origin-source') || product.get('source');
    magnitudeSource = product.getProperty('magnitude-source') || product.get('source');


    buf.push(
      '<div class="horizontal-scrolling">',
      '<table class="origin-detail"><tbody>'
    );

    buf.push('<tr><th scope="row">Magnitude',
        (magnitudeError ? '<span class="uncertainty">uncertainty</span>' : ''),
        '</th><td>',
        _formatter.magnitude(magnitude, magnitudeType, magnitudeError),
        '</td></tr>');

    buf.push('<tr><th scope="row">Location',
        (horizontalError ? '<span class="uncertainty">uncertainty</span>' : ''),
        '</th><td>',
        _formatter.location(latitude, longitude),
        _formatter.uncertainty(horizontalError, 1, NOT_REPORTED, 'km'),
        '</td></tr>');

    buf.push('<tr><th scope="row">Depth',
        (depthError ? '<span class="uncertainty">uncertainty</span>' : ''),
        '</th><td>',
        _formatter.depth(depth, 'km', depthError) +
        '</td></tr>');

    buf.push('<tr><th scope="row">Origin Time</th><td>',
        (typeof eventTime === 'string' ?
            '<time datetime="' + eventTime + '">' +
                eventTime.replace('T', ' ').replace('Z', ' UTC') +
            '</time>' :
            ''),
        '</td></tr>');

    buf.push('<tr><th scope="row">Number of Stations</th><td>',
        (numStations === null ? NOT_REPORTED : numStations),
        '</td></tr>');

    buf.push('<tr><th scope="row">Number of Phases</th><td>',
        (numPhases === null ? NOT_REPORTED : numPhases),
        '</td></tr>');

    buf.push('<tr><th scope="row">Minimum Distance</th><td>',
        _formatter.distance((minimumDistance * 0.0174532925 * 6378.1), 'km'),
        ' (', _formatter.angle(minimumDistance, 2), ')',
        '</td></tr>');

    buf.push('<tr><th scope="row">Travel Time Residual</th><td>',
        (standardError === null ? NOT_REPORTED : standardError + ' s'),
        '</td></tr>');

    buf.push('<tr><th scope="row">Azimuthal Gap</th><td>',
        _formatter.angle(azimuthalGap),
        '</td></tr>');

    buf.push('<tr>',
        '<th scope="row">',
          '<abbr title="Flinn Engdahl">FE</abbr> Region',
        '</th>',
        '<td class="fe-info">' + _this.getFeRegion() + '</td></tr>');

    buf.push('<tr><th scope="row">Review Status</th><td>',
        reviewStatus.toUpperCase(),
        '</td></tr>');

    buf.push(
        '<tr><th scope="row">Catalog</th><td>',
          _this.getCatalogDetail(product),
        '</td></tr>',
        '<tr><th scope="row">Location Source</th><td>',
          Attribution.getContributorReference(originSource),
        '</td></tr>',
        '<tr><th scope="row">Magnitude Source</th><td>',
          Attribution.getContributorReference(magnitudeSource),
        '</td></tr>',
        '<tr><th scope="row">Contributor</th><td>',
          Attribution.getContributorReference(product.get('source')),
        '</td></tr>');

    buf.push('</tbody></table></div>');

    return buf.join('');
  };

  /**
   * Massage data from geoserve product into the same model object
   * that FeRegionView expects.
   *
   * @param fe {Object}
   *          fe.number {Number} fe region number.
   *          fe.name {String} fe region name.
   */
  _this.formatFeRegion = function(fe) {
    // only update model if an object is passed
    if (!fe) {
      return;
    }

    // set the (massaged) fe object
    _region.set({
      'regions': {
        'fe': {
          'features': [
            {
              'properties': {
                'name': fe.longName,
                'number': fe.number
              }
            }
          ]
        }
      }
    });
  };

  _this.render = function () {
    var content,
        product,
        quakeml;

    // Destroy tablist if it already exists
    if (_tabList && _tabList.destroy) {
      _tabList.destroy();
    }

    _tabList = TabList({
      el: _this.el,
      tabs: []
    });

    product = _this.model;
    if (product) {
      content = _this.getOriginDetailTable(product);
      _tabList.addTab({
        'title': 'Origin Detail',
        'content': content
      });

      if (product.get('type') === 'phase-data') {
        quakeml = product.getContent('quakeml.xml');

        _phasesView = PhasesView({
          el: document.createElement('div'),
          model: quakeml,
          product: product
        });

        _tabList.addTab({
          'title': 'Phases',
          'content': _phasesView.el,
          onDestroy: function () {
            _phasesView.destroy();
          },
          onSelect: function () {
            _phasesView.render();
          }
        });

        _magnitudesView = MagnitudesView({
          el: document.createElement('div'),
          model: quakeml,
          product: product
        });

        _tabList.addTab({
          'title': 'Magnitudes',
          'content': _magnitudesView.el,
          onDestroy: function () {
            _magnitudesView.destroy();
          },
          onSelect: function () {
            _magnitudesView.render();
          }
        });
      }

    } else {
      content = '<p class="alert error">' +
        'No Origin product exists.' +
        '</p>';
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = OriginView;

},{"core/Attribution":"core/Attribution","core/Formatter":"core/Formatter","core/ProductView":"core/ProductView","mvc/Model":"mvc/Model","origin/MagnitudesView":"origin/MagnitudesView","origin/PhasesView":"origin/PhasesView","tablist/TabList":"tablist/TabList","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"origin/PhasesView":[function(require,module,exports){
'use strict';


var Collection = require('mvc/Collection'),
    DataTable = require('mvc/DataTable'),
    QuakemlView = require('origin/QuakemlView'),
    Util = require('util/Util');


var _DEFAULTS,
    _PHASE_DATA_COLUMNS,
    _PHASE_DATA_SORTS;


_DEFAULTS = {

};

// columns for phase data table
_PHASE_DATA_COLUMNS = [
  {
    'className': 'channel',
    'title': 'Channel',
    'format': function (arrival) {
      var station = arrival.pick.waveformID;
      return station.networkCode + ' ' + station.stationCode +
          (station.channelCode ? ' ' + station.channelCode +
              (station.locationCode ? ' ' + station.locationCode : '')
              : '');
    },
    'header': true
  },
  {
    'className': 'distance',
    'title': 'Distance',
    'format': function (arrival) {
      return parseFloat(arrival.distance).toFixed(2) + '&deg;';
    },
    'downloadFormat': function (arrival) {
      return arrival.distance;
    }
  },
  {
    'className': 'azimuth',
    'title': 'Azimuth',
    'format': function (arrival) {
      return parseFloat(arrival.azimuth).toFixed(2) + '&deg;';
    },
    'downloadFormat': function (arrival) {
      return arrival.azimuth;
    }
  },
  {
    'className': 'phase',
    'title': 'Phase',
    'format': function (arrival) {
      return arrival.phase;
    }
  },
  {
    'className': 'time',
    'title': 'Arrival Time',
    'format': function (arrival) {
      var pick = arrival.pick,
          time;

      time = pick.time.value.split('T')[1].split('Z')[0].split(':');
      time[2] = parseFloat(time[2]).toFixed(2);
      if (time[2] < 10) {
        time[2] = '0' + time[2];
      }
      time = time.join(':');
      return time;
    },
    'downloadFormat': function (arrival) {
      return arrival.pick.time.value;
    }
  },
  {
    'className': 'status',
    'title': 'Status',
    'format': function (arrival) {
      return arrival.pick.evaluationMode;
    }
  },
  {
    'className': 'residual',
    'title': 'Residual',
    'format': function (arrival) {
      return parseFloat(arrival.timeResidual).toFixed(2);
    },
    'downloadFormat': function (arrival) {
      return arrival.timeResidual;
    }
  },
  {
    'className': 'weight',
    'title': 'Weight',
    'format': function (arrival) {
      return parseFloat(arrival.timeWeight).toFixed(2);
    },
    'downloadFormat': function (arrival) {
      return arrival.timeWeight;
    }
  }
];

// sort options for phase data table
_PHASE_DATA_SORTS = [
  {
    'id': 'channel',
    'title': 'Channel',
    'sortBy': function (arrival) {
      var station = arrival.pick.waveformID;
      return station.networkCode + ' ' + station.stationCode +
          ' ' + station.channelCode + ' ' + station.locationCode;
    }
  },
  {
    'id': 'distance',
    'title': 'Distance',
    'sortBy': function (arrival) {
      return parseFloat(arrival.distance);
    }
  },
  {
    'id': 'azimuth',
    'title': 'Azimuth',
    'sortBy': function (arrival) {
      return parseFloat(arrival.azimuth);
    }
  },
  {
    'id': 'phase',
    'title': 'Phase',
    'sortBy': function (arrival) {
      return arrival.phase;
    }
  },
  {
    'id': 'time',
    'title': 'Arrival Time',
    'sortBy': function (arrival) {
      return arrival.pick.time.value;
    }
  },
  {
    'id': 'residual',
    'title': 'Residual',
    'sortBy': function (arrival) {
      return parseFloat(arrival.timeResidual);
    }
  },
  {
    'id': 'weight',
    'title': 'Weight',
    'sortBy': function (arrival) {
      return parseFloat(arrival.timeWeight);
    }
  }
];


/**
 * View for rendering phase data.
 *
 * @see QuakemlView
 */
var PhasesView = function (options) {
  var _this,

      _phaseTable;


  options = Util.extend({}, _DEFAULTS, options);
  _this = QuakemlView(options);


  /**
   * Frees resources associated with this view.
   *
   */
  _this.destroy = Util.compose(function () {
    if (_phaseTable && _phaseTable.destroy) {
      _phaseTable.destroy();
    }
    _phaseTable = null;

    _this = null;
  }, _this.destroy);

  /**
   * Loops over all the given origins and looks for the preferred origin.
   *
   * @param origins {Array}
   *     An array of origin objects.
   */
  _this.getPreferredOrigin = function (origins) {
    var preferred;

    origins = origins || [];
    preferred = null;

    origins.some(function (origin) {
      if (origin.isPreferred) {
        preferred = origin;
        return true;
      }
    });

    return preferred;
  };

  /**
   * Returns markup for an error message when no phases exist.
   *
   * @param el {DOMElement}
   *     The DOM element into which to render.
   *
   * @return {String}
   */
  _this.renderNoPreferred = function (el) {
    el.innerHTML = '<p class="error alert">No Phase Data Exists</p>';
  };

  /**
   * Renders a table for the given origin
   *
   * @param origin {Object}
   *     An object containing origin information.
   * @param el {DOMElement}
   *     The DOM element into which to render.
   */
  _this.renderPreferred = function (origin, el) {
    var arrivals;

    origin = origin || {};

    // add ids to arrivals
    arrivals = origin.arrivals;
    arrivals.map(function (arrival, index) {
      arrival.id = index;
      return arrival;
    });

    _phaseTable = DataTable({
      el: el,
      className: 'hypocenter-phase',
      collection: Collection(arrivals),
      emptyMarkup: '<p class="error alert">No Phase Data Exists</p>',
      columns: _PHASE_DATA_COLUMNS,
      sorts: _PHASE_DATA_SORTS,
      defaultSort: 'distance'
    });

    el.querySelector('.datatable-data').classList.add('horizontal-scrolling');
  };

  /**
   * Renders the quakeml.
   *
   */
  _this.renderQuakeml = function () {
    var dataTableEl,
        origins,
        preferred;

    _this.el.innerHTML = '<section class="hypocenter-phase">' +
        '<header><h3>Phase Arrival Times</h3></header>' +
        '<div class="datatable"></div>' +
      '</section>';

    dataTableEl = _this.el.querySelector('.datatable');

    if (_this.quakeml) {
      origins = _this.quakeml.getOrigins();

      preferred = _this.getPreferredOrigin(origins);


      if (!preferred || !preferred.arrivals) {
        _this.renderNoPreferred(dataTableEl);
      } else {
        _this.renderPreferred(preferred, dataTableEl);
      }
    }
  };


  options = null;
  return _this;
};


module.exports = PhasesView;

},{"mvc/Collection":32,"mvc/DataTable":35,"origin/QuakemlView":"origin/QuakemlView","util/Util":"util/Util"}],"origin/QuakemlView":[function(require,module,exports){
'use strict';


var ContentView = require('core/ContentView'),
    Product = require('pdl/Product'),
    Quakeml = require('quakeml/Quakeml'),
    Util = require('util/Util');


var _DEFAULTS = {

};


/**
 * Abstract view for displaying quakeml.xml {Content} object.
 *
 * @param options {Object}
 *     Configuration options for this view. See _initialize method
 *     documentation for details.
 */
var QuakemlView = function (options) {
  var _this,
      _initialize;


  options = Util.extend({}, _DEFAULTS, options);
  _this = ContentView(options);

  /**
   * Constructor. Initializes a new {QuakemlView}.
   *
   * @param options {Object}
   *     Configuration options for this view.
   * @param options.model {Content}
   *     The content model to render.
   * @param options.product {Product}
   *     The product that contains the given {Content}. Typically an origin
   *     or phase-data product.
   */
  _initialize = function (options) {
    _this.product = options.product || Product();
  };


  /**
   * Frees resources allocated to this view.
   *
   */
  _this.destroy = Util.compose(function () {
    _initialize = null;
    _this = null;
  }, _this.destroy);


  /**
   * Callback executed when fetchData fails. Displays an error message.
   *
   * @param status {String}
   *     An error message. Currently ignored.
   * @param xhr {XMLHttpRequest}
   *     The XHR object used to fetch the data.
   */
  _this.onError = function (/*status, xhr*/) {
    _this.el.innerHTML = '<p class="alert error">' +
        'Failed to load quakeml data.</p>';
  };

  /**
   * Callback executed when fetchData succeeds. Parses and renders the
   * quakeml data and triggers an event offering the parsed quakeml back
   * so others can save the effort.
   *
   * @param data {String}
   *     The raw QuakeML XML string content.
   * @param xhr {XMLHttpRequest}
   *     The XHR object used to fetch the data.
   *
   */
  _this.onSuccess = function (data/*, xhr*/) {
    try {
      _this.quakeml = Quakeml({xml: data});

      _this.render();

      // Let others know about our success so they don't have to download
      // and parse it themselves...
      _this.trigger('quakeml', _this.quakeml);
    } catch (e) {
      // Ignore ...
      console.log(e.stack);
    }
  };

  /**
   * Fetches quakeml based on the current model, or renders it if the quakeml
   * is already available. Delegates to sub methods.
   *
   */
  _this.render = function () {
    if (!_this.quakeml) {
      // Don't have quakeml yet, try to get it
      _this.el.innerHTML = '<p>Loading content&hellip;</p>';
      _this.fetchData();
    } else {
      _this.renderQuakeml();
    }
  };

  /**
   * Renders the quakeml. This should be overriden by implementing classes.
   *
   */
  _this.renderQuakeml = function () {
    _this.el.innerHTML = JSON.stringify(_this.quakeml);
  };

  /**
   * Sets the quakeml to render. This is useful in case some external party
   * already downloaded/parsed the quakeml, thus saving time internally.
   *
   * @param quakeml {Quakeml}
   *     The parsed Quakeml to render.
   */
  _this.setQuakeml = function (quakeml) {
    _this.quakeml = quakeml;
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = QuakemlView;

},{"core/ContentView":"core/ContentView","pdl/Product":"pdl/Product","quakeml/Quakeml":39,"util/Util":"util/Util"}],"pdl/CatalogEvent":[function(require,module,exports){
'use strict';


var Product = require('pdl/Product'),
    Util = require('util/Util');


var _DEFAULTS = {
  config: {}
};


/**
 * Convert a product map to an array.
 *
 * @param map {Object}
 *        keys are product types.
 *        values are arrays of products.
 * @return {Array}
 *         array containing all products.
 */
var __productMapToList = function (map) {
  var list = [],
      type;
  for (type in map) {
    list.push.apply(list, map[type]);
  }
  return list;
};


/**
 * Filter superseded products (old versions) from array.
 *
 * @param list {Array}
 *        array of products.
 * @return {Array}
 *         array without superseded versions.
 */
var __getWithoutSuperseded = function (list) {
  var unique = {},
      products;
  list.forEach(function (product) {
    var key,
        modified;

    key = product.get('source') + '_' +
        product.get('type') + '_' +
        product.get('code');
    modified = -1;
    if (unique.hasOwnProperty(key)) {
      modified = unique[key].get('updateTime');
    }
    if (modified < product.get('updateTime')) {
      unique[key] = product;
    }
  });
  products = [];
  for (var id in unique) {
    products.push(unique[id]);
  }
  return products;
};

/**
 * Filter deleted products from array.
 *
 * @param list {Array}
 *        array of products.
 * @return {Array}
 *         array without deleted versions.
 */
var __getWithoutDeleted = function (list) {
  var withoutDeleted = [];
  list.forEach(function (product) {
    if (!product.isDeleted()) {
      withoutDeleted.push(product);
    }
  });
  return withoutDeleted;
};

/**
 * Sort products based on preferred weight.
 *
 * When preferred weights are equal, most recent updateTime is preferred.
 *
 * @param list {Array}
 *        array of products.
 * @return {Array}
 *         sorted array, most preferred first.
 */
var __getSortedMostPreferredFirst = function (list) {
  var sorted = list.splice(0);
  sorted.sort(function (p1, p2) {
    var diff;
    diff = p2.get('preferredWeight') - p1.get('preferredWeight');
    if (diff !== 0) {
      return diff;
    }
    diff = p2.get('updateTime') - p1.get('updateTime');
    if (diff !== 0) {
      return diff;
    }
    return (p1.id > p2.id ? 1 : -1);
  });
  return sorted;
};

/**
 * Check whether product has origin properties.
 *
 * Origin properties include event id (eventsource, eventsourcecode) and
 * event location (latitude, longitude, eventtime).
 *
 * @param product {Object}
 *        product to check.
 * @return true if product has all origin properties, false otherwise.
 */
var __productHasOriginProperties = function (product) {
  var props = product.get('properties');
  if (props.hasOwnProperty('eventsource') &&
      props.hasOwnProperty('eventsourcecode') &&
      props.hasOwnProperty('latitude') &&
      props.hasOwnProperty('longitude') &&
      props.hasOwnProperty('eventtime')) {
    return true;
  }
  return false;
};

/**
 * Get the most preferred product with origin properties.
 *
 * Origin properties include event id (eventsource, eventsourcecode) and
 * event location (latitude, longitude, eventtime).
 *
 * Products are sorted using __getSortedMostPreferredFirst before checking
 * for properties.
 *
 * @param list {Array}
 *        array of products.
 * @return {Object}
 *         most preferred product with origin properties.
 */
var __getProductWithOriginProperties = function (list) {
  var i,
      product;
  list = __getSortedMostPreferredFirst(list);
  for (i = 0; i < list.length; i++) {
    product = list[i];
    if (__productHasOriginProperties(product)) {
      return product;
    }
  }
  return null;
};


/**
 * Get the most preferred product with event id properties.
 *
 * Event ID properties are eventsource and eventsourcecode.
 *
 * Products are sorted using __getSortedMostPreferredFirst before checking
 * for properties.
 *
 * @param list {Array}
 *        array of products.
 * @return {Object}
 *         most preferred product with event id properties.
 */
var __getProductWithEventIdProperties = function (list) {
  var i,
      props;
  list = __getSortedMostPreferredFirst(list);
  for (i = 0; i < list.length; i++) {
    props = list[i].get('properties');
    if (props.hasOwnProperty('eventsource') &&
        props.hasOwnProperty('eventsourcecode')) {
      return list[i];
    }
  }
  return null;
};


/**
 * An event is a collection of products.
 */
var CatalogEvent = function (eventDetails, options) {
  var _this,
      _initialize,

      _config,
      _products,
      _properties,
      _summary;

  _this = Object.create({});

  _initialize = function (eventDetails, options) {
    var type;

    options = Util.extend({}, _DEFAULTS, options);

    _config = options.config;

    _products = {};
    _properties = {};

    if (eventDetails && eventDetails.properties) {
      _products = Util.extend({}, eventDetails.properties.products);
      _properties = Util.extend({}, eventDetails.properties, {products:null});
    }

    // convert all products to Product objects
    for (type in _products) {
      _products[type] = _products[type].map(Product);
    }
    _summary = null;
  };

  /**
   * Add a product to this event.
   *
   * @param product {Object}
   *        product to add.
   */
  _this.addProduct = function (product) {
    var type;

    type = product.get('type');
    if (!_products.hasOwnProperty(type)) {
      _products[type] = [];
    }
    _products[type].push(product);
    _summary = null;
  };

  /**
   * Remove a product from this event.
   *
   * @param product {Object}
   *        product to remove.
   */
  _this.removeProduct = function (product) {
    var type,
        typeProducts,
        index;
    type = product.get('type');
    if (_products.hasOwnProperty(type)) {
      typeProducts = _products[type];
      index = typeProducts.indexOf(product);
      if (index >= 0) {
        typeProducts.splice(index, 1);
        if (typeProducts.length === 0) {
          delete _products[type];
        } else {
          _products[type] = typeProducts;
        }
        _summary = null;
      }
    }
  };

  /**
   * Free references.
   */
  _this.destroy = function () {
    var key;

    if (_this === null) {
      return;
    }

    for (key in _products) {
      _products[key].map(function (model) {
        model.destroy();
      });
    }

    _initialize = null;
    _products = null;
    _properties = null;
    _summary = null;
    _this = null;
  };

  /**
   * Get event products.
   */
  _this.getProducts = function (type) {
    if (type) {
      return _products[type] || [];
    } else {
      return _products;
    }
  };

  /**
   * Get the preferred product of the specified type.
   *
   * @param type {String}
   *     type of product.
   * @return {Product}
   *     preferred product of type, or null if no product of that type exists.
   */
  _this.getPreferredProduct = function (type) {
    var products;
    products = _this.getProducts(type);
    products = __getSortedMostPreferredFirst(
        __getWithoutSuperseded(products));
    if (products.length > 0) {
      return products[0];
    }
    return null;
  };

  /**
   * Get all versions of a product (type, souce, code).
   */
  _this.getAllProductVersions = function (type, source, code) {
    var products;

    if (_products.hasOwnProperty(type)) {
      products = _products[type].filter(function (p) {
        return p.get('source') === source &&
            p.get('code') === code;
      });
    } else {
      products = [];
    }
    // sort most recent first.
    products.sort(function (p1, p2) {
      return p2.get('updateTime') - p1.get('updateTime');
    });
    return products;
  };

  /**
   * Gets a product based on the productId parameters.
   *
   * @param type {String}
   *     The type of the product to get
   * @param source {String}
   *     The source of the product to get
   * @param code {String}
   *     The code of the product to get
   * @param updateTime {Number} Optional.
   *     The updateTime of the product to get
   *
   * @return {Product}
   *     The product matching the given type, source, code, and updateTime. If
   *     no updateTime is specified, the most recently updated product matching
   *     type, source and code is returned instead.
   */
  _this.getProductById = function (type, source, code, updateTime) {
    var i,
        len,
        product,
        products;

    product = null;
    products = _this.getAllProductVersions(type, source, code);
    len = products.length;

    if (typeof updateTime !== 'undefined' && updateTime !== null) {
      for (i = 0; i < len; i++) {
        if (products[i].get('updateTime') === updateTime) {
          product = products[i];
          break;
        }
      }
    } else if (len) {
      // No updateTime specified, most recently updated product
      product = products[0]; // Products are sorted, so first is most recent
    }

    return product;
  };

  /**
   * Get the preferred event id.
   *
   * @return {String}
   *         the preferred event id, or null if none.
   */
  _this.getEventId = function () {
    var product = _this.getEventIdProduct(),
        props;
    if (product !== null) {
      props = product.get('properties');
      return props.eventsource + props.eventsourcecode;
    }
    return null;
  };

  /**
   * Get the preferred event source.
   *
   * @return {String}
   *         the preferred event source, or null if none.
   */
  _this.getSource = function () {
    var product = _this.getEventIdProduct();
    if (product !== null) {
      return product.getProperty('eventsource');
    }
    return null;
  };

  /**
   * Get the preferred event code.
   *
   * @return {String}
   *         the preferred event code, or null if none.
   */
  _this.getSourceCode = function () {
    var product = _this.getEventIdProduct();
    if (product !== null) {
      return product.getProperty('eventsourcecode');
    }
    return null;
  };

  /**
   * Get the preferred event time.
   *
   * @return {Date}
   *         the preferred origin time for this event, or null if none.
   */
  _this.getTime = function () {
    var product = _this.getProductWithOriginProperties();
    if (product !== null) {
      return new Date(product.getProperty('eventtime'));
    }
    return null;
  };

  /**
   * Get the preferred event latitude.
   *
   * @return {Number}
   *         the preferred latitude for this event, or null if none.
   */
  _this.getLatitude = function () {
    var product = _this.getProductWithOriginProperties();
    if (product !== null) {
      return Number(product.getProperty('latitude'));
    }
    return null;
  };

  /**
   * Get the preferred event longitude.
   *
   * @return {Number}
   *         the preferred longitude for this event, or null if none.
   */
  _this.getLongitude = function () {
    var product = _this.getProductWithOriginProperties();
    if (product !== null) {
      return Number(product.getProperty('longitude'));
    }
    return null;
  };

  /**
   * Get the preferred event depth.
   *
   * @return {Number}
   *         the preferred depth for this event, or null if none.
   */
  _this.getDepth = function () {
    var product = _this.getProductWithOriginProperties(),
        props;
    if (product !== null) {
      props = product.get('properties');
      return (props.hasOwnProperty('depth') ? Number(props.depth) : null);
    }
    return null;
  };

  /**
   * Get the preferred event magnitude.
   *
   * @return {Number}
   *         the preferred magnitude for this event, or null if none.
   */
  _this.getMagnitude = function () {
    var product = _this.getPreferredMagnitudeProduct(),
        props;
    if (product === null) {
      product = _this.getProductWithOriginProperties();
    }
    if (product !== null) {
      props = product.get('properties');
      return (props.hasOwnProperty('magnitude') ?
          Number(props.magnitude) : null);
    }
    return null;
  };

  /**
   * Check whether event is deleted.
   *
   * @return {Boolean}
   *         true if deleted, false otherwise.
   */
  _this.isDeleted = function () {
    var product = _this.getPreferredOriginProduct();
    if (product !== null &&
        !product.isDeleted() &&
        __productHasOriginProperties(product)) {
      // have "origin" product, that isn't deleted, and has origin properties.
      return false;
    }
    // otherwise, deleted
    return true;
  };

  /**
   * Get the product with event id properties.
   *
   * This may be a superseded or deleted product.
   *
   * @return {Number}
   *         the preferred latitude for this event, or null if none.
   */
  _this.getEventIdProduct = function () {
    var product = _this.getPreferredOriginProduct();
    if (product === null) {
      product = _this.getProductWithOriginProperties();
    }
    return product;
  };

  /**
   * Get the product with origin properties.
   *
   * This may be a superseded or deleted product.
   *
   * @return {Number}
   *         the product with origin properties this event, or null if none.
   */
  _this.getProductWithOriginProperties = function () {
    var originType,
        product;

    originType = Product.getFullType('origin', _config);

    if (_products.hasOwnProperty(originType)) {
      // origin products not superseded or deleted
      product = __getProductWithOriginProperties(
          __getWithoutDeleted(__getWithoutSuperseded(
              _products[originType])));

      if (product !== null) {
        return product;
      }

      // origin products superseded by a delete
      product = __getProductWithOriginProperties(
          __getWithoutSuperseded(__getWithoutDeleted(
              _products[originType])));

      if (product !== null) {
        return product;
      }
    }

    // products not superseded or deleted
    product = __getProductWithOriginProperties(
        __getWithoutDeleted(__getWithoutSuperseded(
            __productMapToList(_products))));

    if (product !== null) {
      return product;
    }

    // products superseded by a delete
    product = __getProductWithOriginProperties(
        __getWithoutSuperseded(__getWithoutDeleted(
            __productMapToList(_products))));
    return product;
  };

  /**
   * Get the preferred product with origin properties.
   *
   * If no preferred product has origin properties,
   * look for preferred product with event id.
   *
   * @return {Number}
   *         the preferred product with origin properties this event, or null.
   */
  _this.getPreferredOriginProduct = function () {
    var originType,
        product;

    originType = Product.getFullType('origin', _config);

    if (_products.hasOwnProperty(originType)) {
      // origin products not superseded or deleted
      product = __getProductWithOriginProperties(
          __getWithoutDeleted(__getWithoutSuperseded(
              _products[originType])));

      if (product !== null) {
        return product;
      }

      // origin products not superseded that have event id
      product = __getProductWithEventIdProperties(
          __getWithoutSuperseded(_products[originType]));

      if (product !== null) {
        return product;
      }

      // origin exists, but is incomplete
      return null;
    }

    // products not superseded or deleted
    product = __getProductWithOriginProperties(
        __getWithoutDeleted(__getWithoutSuperseded(
            __productMapToList(_products))));

    if (product !== null) {
      return product;
    }

    // products not superseded that have eventid.
    product = __getProductWithEventIdProperties(
        __getWithoutSuperseded(__productMapToList(_products)));

    if (product !== null) {
      return product;
    }

    // products superseded by a delete that have eventid
    product = __getProductWithEventIdProperties(
        __getWithoutSuperseded(__getWithoutDeleted(
          __productMapToList(_products))));
    return product;
  };


  /**
   * Get the preferred magnitude product.
   *
   * Current calls getPreferredOriginProduct.  Method is a placeholder in case
   * moment-tensor or other products become preferred source of magnitude.
   *
   * @return {Object}
   *         the product that defines the magnitude for the event, or null.
   */
  _this.getPreferredMagnitudeProduct = function () {
    return _this.getPreferredOriginProduct();
  };

  /**
   * Break this event into events by contributor.
   *
   * All products that do not include an event id are included with the
   * preferred sub event.
   *
   * @return {Object}
   *         keys are event ids.
   *         values are CatalogEvents.
   */
  _this.getSubEvents = function () {
    var preferredEvent,
        preferredEventId,
        productEvents,
        subEvents,
        withoutSuperseded;

    preferredEventId = _this.getEventId();
    preferredEvent = CatalogEvent();
    productEvents = {};
    subEvents = {};
    subEvents[preferredEventId] = preferredEvent;

    withoutSuperseded = __getWithoutSuperseded(
        __productMapToList(_products));
    withoutSuperseded.forEach(function (product) {
      var key,
          eventCode,
          eventSource,
          subEvent,
          subEventId;
      key = product.get('source') + '_' +
          product.get('type') + '_' +
          product.get('code');
      eventSource = product.getProperty('eventsource');
      eventCode = product.getProperty('eventsourcecode');
      if (eventSource === null || eventCode === null) {
        subEvent = preferredEvent;
      } else {
        subEventId = eventSource + eventCode;
        if (!subEvents.hasOwnProperty(subEventId)) {
          subEvents[subEventId] = CatalogEvent();
        }
        subEvent = subEvents[subEventId];
      }
      subEvent.addProduct(product);
      productEvents[key] = subEvent;
    });

    __productMapToList(_products).forEach(function (product) {
      var key;
      if (withoutSuperseded.indexOf(product) !== -1) {
        return;
      }
      key = product.get('source') + '_' +
          product.get('type') + '_' +
          product.get('code');
      productEvents[key].addProduct(product);
    });

    return subEvents;
  };

  /**
   * Return a map of all event ids associated to this event.
   *
   * @param includeDeleted {Boolean}
   *        optional, default false.
   * @return {Object}
   *         keys are event sources.
   *         values are array of codes from the corresponding source.
   */
  _this.getAllEventCodes = function (includeDeleted) {
    var allEventCodes = {},
        codes,
        id,
        source,
        sourceCode,
        subEvents,
        subEvent;

    subEvents = _this.getSubEvents();
    for (id in subEvents) {
      subEvent = subEvents[id];
      // skip the deleted subEvent
      if (!includeDeleted && subEvent.isDeleted()) {
        continue;
      }

      source = subEvent.getSource();
      sourceCode = subEvent.getSourceCode();
      if (!(source in allEventCodes)) {
        allEventCodes[source] = [];
      }
      codes = allEventCodes[source];
      if (codes.indexOf(sourceCode) === -1) {
        codes.push(sourceCode);
      }
    }
    return allEventCodes;
  };

  /**
   * Get event summary.
   *
   * @return {Object}
   *         event summary.
   */
  _this.getSummary = function () {
    var eventIdProduct,
        originProduct,
        magnitudeProduct,
        props;

    if (_summary !== null) {
      return _summary;
    }

    _summary = {
      depth: null,
      eventCodes: null,
      id: null,
      isDeleted: null,
      latitude: null,
      longitude: null,
      magnitude: null,
      properties: null,
      source: null,
      sourceCode: null,
      time: null,
      // products for above information
      eventIdProduct: null,
      originProduct: null,
      magnitudeProduct: null
    };
    _summary.isDeleted = _this.isDeleted();

    eventIdProduct = _this.getEventIdProduct();
    if (eventIdProduct !== null) {
      props = eventIdProduct.get('properties');
      _summary.id = props.eventsource + props.eventsourcecode;
      _summary.source = props.eventsource;
      _summary.sourceCode = props.eventsourcecode;
      _summary.eventIdProduct = eventIdProduct;
    }

    originProduct = _this.getProductWithOriginProperties();
    if (originProduct !== null) {
      props = originProduct.get('properties');
      _summary.depth = Number(props.depth);
      _summary.latitude = Number(props.latitude);
      _summary.longitude = Number(props.longitude);
      _summary.time = new Date(props.eventtime);
      _summary.originProduct = originProduct;
    }

    magnitudeProduct = _this.getPreferredMagnitudeProduct();
    if (magnitudeProduct !== null) {
      _summary.magnitude = Number(magnitudeProduct.getProperty('magnitude'));
      _summary.magnitudeProduct = magnitudeProduct;
    }

    _summary.eventCodes = _this.getAllEventCodes();
    _summary.properties = _properties;

    return _summary;
  };


  _initialize(eventDetails, options);
  eventDetails = null;
  options = null;
  return _this;
};


// add static methods
CatalogEvent.productMapToList = __productMapToList;
CatalogEvent.getWithoutDeleted = __getWithoutDeleted;
CatalogEvent.getWithoutSuperseded = __getWithoutSuperseded;
CatalogEvent.getSortedMostPreferredFirst = __getSortedMostPreferredFirst;
CatalogEvent.productHasOriginProperties = __productHasOriginProperties;


module.exports = CatalogEvent;

},{"pdl/Product":"pdl/Product","util/Util":"util/Util"}],"pdl/Content":[function(require,module,exports){
'use strict';

var Model = require('mvc/Model'),
    Util = require('util/Util');


/**
 * Check if attribute is valid.
 *
 * @param attrs {Object}
 *     object with keys/values.
 * @param attr {String}
 *     attribute name.
 * @return
 *     true, when `attrs` hsa a property named `attr`
 *     with a value that is not undefined; false, otherwise.
 */
var __attrIsValid = function (attrs, attr) {
  var value;

  if (attrs.hasOwnProperty(attr)) {
    value = attrs[attr];

    if (value !== null && typeof value !== 'undefined') {
      return true;
    }
  }

  return false;
};

/**
 * Product content.
 *
 * @param options {Object}
 * @param options.bytes {String}
 *     content as a string.
 *     Content should have `url` or `bytes`, but not both.
 * @param options.contentType {String}
 *     mime type, default 'text/plain'.
 * @param options.id {String}
 *     unique identifier, default null.
 * @param options.lastModified {Number}
 *     millisecond epoch time stamp, default new Date().getTime().
 * @param options.length {String}
 *     reported length of content.
 * @param options.url {String}
 *     url where content is available.
 *     Content should have `url` or `bytes`, but not both.
 */
var Content = function (options) {
  var _this,
      _initialize;


  _this = Model(Util.extend({
    bytes: null,
    contentType: 'text/plain',
    id: null,
    lastModified: (new Date()).getTime(),
    length: 0,
    url: null
  }, options));

  _initialize = function (/*options*/) {
    var bytes = _this.get('bytes'),
        url = _this.get('url');

    if (bytes === null && url === null) {
      throw new Error('Invalid product contents. Must have one of bytes or ' +
          'url.');
    }

    if (bytes !== null && bytes.length !== _this.get('length')) {
      console.log('Invalid product contents. Actual length and claimed ' +
          'length differ.');
    }
  };

  /**
   * Override set method to ensure only one of `url` or `bytes` is set.
   *
   * @param attributes {Object}
   *     attributes to set.
   */
  _this.set = Util.compose(function (attributes) {
    var hasBytes,
        hasUrl;

    hasBytes = attributes.hasOwnProperty('bytes');
    hasUrl = attributes.hasOwnProperty('url');

    // Content has either bytes, or url, but not both. If one is set,
    // clear the other...
    if (hasUrl && attributes.url !== null) {
      attributes.bytes = null;
    } else if (hasBytes && attributes.bytes !== null) {
      attributes.url = null;
    }

    return attributes;
  }, _this.set);

  /**
   * Validate content attributes.
   *
   * Checks that content has an `id` and one of `url` or `bytes` attributes.
   *
   * @throws {Error}
   *     when content is invalid
   */
  _this.validate = function () {
    var attrs;

    attrs = _this.get();

    if (!__attrIsValid(attrs, 'id')) {
      throw new Error('Product content must have a valid id');
    } else if (!__attrIsValid(attrs, 'url') && !__attrIsValid(attrs, 'bytes')) {
      throw new Error('Product content must have content');
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = Content;

},{"mvc/Model":"mvc/Model","util/Util":"util/Util"}],"pdl/Product":[function(require,module,exports){
'use strict';

var Collection = require('mvc/Collection'),
    Content = require('pdl/Content'),
    Model = require('mvc/Model'),
    Util = require('util/Util');


var _STATUS_UPDATE = 'UPDATE',
    _STATUS_DELETE = 'DELETE';

var _getBaseType,
    _getFullType;

/**
 * Remove "internal-" prefix and "-scenario" suffix from product "type".
 *
 * @param type {String}
 *     The initial product type.
 *
 * @return {String}
 *     The base product type without any known prefix or suffix.
 */
_getBaseType = function (type) {
  var base;

  base = type;

  if (base && base.match(/^internal-/)) {
    base = base.replace('internal-', '');
  }

  if (base && base.match(/-scenario$/)) {
    base = base.replace('-scenario', '');
  }

  return base;
};

/**
 * Add "internal-" prefix or "-scenario" suffix to product "type".
 *
 * @param type {String}
 *     The base product type.
 * @param config {Object}
 *     Configuration object containing INTERNAL_MODE and/or SCENARIO_MODE flags
 *     as appropriate.
 *
 * @return {String}
 *     The actual product type depending on the current configuration.
 */
_getFullType = function (type, config) {
  var fullType;

  config = config || {};
  fullType = type;

  if (config.INTERNAL_MODE) {
    fullType = 'internal-' + fullType;
  }

  if (config.SCENARIO_MODE) {
    fullType += '-scenario';
  }

  return fullType;
};


/**
 * A product object.
 *
 * Typically created from an event detail feed.
 * Created manually for new products.
 *
 * @param options {Object}
 *        a product object from an event detail feed.
 * @param options.code {String}
 *        product code.
 * @param options.contents {Collection<Content>}.
 * @param options.id {String}
 *        product id URN, unique per product.
 * @param options.indexid {String}
 *        server id for product, may vary between servers.
 * @param options.indexTime {Number}
 *        millisecond epoch timestamp when product was indexed on server.
 * @param options.links {Object}
 *        keys are link relation names.
 *        values are arrays of uri Strings for relation.
 * @param options.preferredWeight {Number}
 *        optional, current preferred weight of product.
 * @param options.properties {Object}
 *        keys are property names.
 *        values must be strings.
 * @param options.source {String}
 *        product source.
 * @param options.status {String}
 *        product status.
 *        default Product.STATUS_UPDATE,
 *        use Product.STATUS_DELETE for deletes.
 * @param options.type {String}
 *        product type.
 * @param options.updateTime {Number}
 *        product update time.
 */
var Product = function (options) {
  var _this,
      _initialize;


  _this = Model(Util.extend({
    code: null,
    contents: null,
    id: null,
    indexid: null,
    indexTime: null,
    links: {},
    preferredWeight: null,
    properties: {},
    source: null,
    status: _STATUS_UPDATE,
    type: null,
    updateTime: null
  }, options));

  _initialize = function (/*options*/) {
    var contents,
        properties;

    // make sure contents and properties are defined
    contents = _this.get('contents') || [];
    properties = _this.get('properties') || [];

    // make sure contents are Content objects
    if (Array.isArray(contents)) {
      // Handle case if given an array
      contents = contents.map(function (content) {
        if (!content.get) {
          content = Content(content);
        }
        return content;
      });
      contents = Collection(contents);
    } else if (!contents.hasOwnProperty('get') ||
        !contents.hasOwnProperty('add')) {
      // Handle case when given an object map (like from data feed)
      contents = Object.keys(contents).map(function (key) {
        return Content(Util.extend({'id': key}, contents[key]));
      });
      contents = Collection(contents);
    }

    _this.set({
      'contents': contents,
      'properties': properties
    });
  };

  /**
   * Convenience method to access product content.
   *
   * @param path {String}
   *     content path.
   * @return {Content}
   *     content object, or null if not found.
   */
  _this.getContent = function (path) {
    var contents;
    contents = _this.get('contents');
    return contents.get(path);
  };

  /**
   * Convenience method to access product property..
   *
   * @param name {String}
   *     property name.
   * @return {Content}
   *     property value, or null if not found.
   */
  _this.getProperty = function (name) {
    var properties;
    properties = _this.get('properties');
    if (properties.hasOwnProperty(name)) {
      return properties[name];
    }
    return null;
  };

  /**
   * Check whether product is deleted.
   *
   * @return {Boolean}
   *     true, if product status is Product.STATUS_DELETE.
   *     false, otherwise.
   */
  _this.isDeleted = function () {
    var status;
    status = this.get('status').toUpperCase();
    if (status === Product.STATUS_DELETE) {
      return true;
    }
    return false;
  };

  /**
   * Check whether product is reviewed.
   *
   * @return {Boolean}
   *    true, if product review-status property is `reviewed`,
   *    false, if product review-status property is any other value,
   *    null, if product does not have a review-status property.
   */
  _this.isReviewed = function () {
    var reviewed;
    reviewed = _this.getProperty('review-status');
    if (reviewed !== null) {
      return (reviewed.toUpperCase() === 'REVIEWED');
    }
    return null;
  };

  _this.setProperty = function (obj) {
    var changes,
        properties;

    properties = _this.get('properties');
    changes = [];

    Object.keys(obj).forEach(function (property) {
      var value;

      value = obj[property];

      if (properties[property] !== value) {
        changes.push(property);
        properties[property] = value;
      }
    });

    changes.forEach(function (change) {
      _this.trigger('change:property:' + change);
    });

    _this.trigger('change:property');
    _this.trigger('change');
  };

  /**
   * Override toJSON method so contents are output as object map.
   *
   * @param json {Object}
   *     JSONified object from Model.toJSON.
   * @return {Object}
   *     object, with contents as an object with content paths as keys.
   */
  _this.toJSON = Util.compose(_this.toJSON, function (json) {
    var objectContents = {};

    json.contents.forEach(function (content) {
      var id;

      id = content.id;

      objectContents[id] = {
        contentType: content.contentType,
        length: content.length,
        lastModified: content.lastModified
      };

      if (content.hasOwnProperty('url') && content.url !== null) {
        objectContents[id].url = content.url;
      } else if (content.hasOwnProperty('bytes') && content.bytes !== null) {
        objectContents[id].bytes = content.bytes;
      }
    });

    json.contents = objectContents;

    return json;
  });


  _initialize(options);
  options = null;
  return _this;
};


Product.getBaseType = _getBaseType;
Product.getFullType = _getFullType;

Product.STATUS_UPDATE = _STATUS_UPDATE;
Product.STATUS_DELETE = _STATUS_DELETE;


module.exports = Product;

},{"mvc/Collection":32,"mvc/Model":"mvc/Model","pdl/Content":"pdl/Content","util/Util":"util/Util"}],"scientific/ScientificSummaryModule":[function(require,module,exports){
'use strict';


var Attribution = require('core/Attribution'),
    BeachBallView = require('moment-tensor/BeachBallView'),
    Formatter = require('core/Formatter'),
    Product = require('pdl/Product'),
    SummaryModule = require('core/SummaryModule'),
    Tensor = require('moment-tensor/Tensor'),
    Util = require('util/Util'),

    // these modules create a circular dependency,
    // require them in initialize
    FiniteFaultModule,
    FocalMechanismModule,
    MomentTensorModule,
    OriginModule;



var _DEFAULTS,
    _ID,
    _TITLE,
    _TYPES;


_ID = 'scientific';
_TITLE = 'Technical';
_TYPES = [
  'origin',
  'phase-data',
  'moment-tensor',
  'focal-mechanism',
  'finite-fault',
  'scitech-link'
];

_DEFAULTS = {
  mtFillColor: '#6ea8ff',
  fmFillColor: '#ffaa69'
};


/**
 * Module for the scientific summary page. This module renders a table-like
 * set of summary-level data for the products contained within the "scientific"
 * section of the event page.
 *
 * @param options {Object}
 *     Configuration options for this module. See initialize documentation for
 *     details.
 */
var ScientificSummaryModule = function (options) {
  var _this,
      _initialize,

      _fmFillColor,
      _formatter,
      _mtFillColor;


  options = Util.extend({}, _DEFAULTS, options);
  _this = SummaryModule(options);

  /**
   * Constructor. Initializes a new {ScientificSummaryModule}.
   *
   * @param options {Object}
   *     Configuration options for the module. Specifically...
   * @param options.mtFillColor {String}
   *     A hexadecimal color to be used when rendering moment tensors.
   * @param options.fmFillColor {String}
   *     A hexadecimal color to be used when rendering focal mechanisms.
   */
  _initialize = function (options) {
    _this.ID = _ID;
    _this.TITLE = _TITLE;

    _formatter = options.formatter || Formatter();
    _mtFillColor = options.mtFillColor;
    _fmFillColor = options.fmFillColor;

    // these modules create a circular dependency,
    // require them first time initialize is called
    FiniteFaultModule = FiniteFaultModule ||
        require('finite-fault/FiniteFaultModule');
    FocalMechanismModule = FocalMechanismModule ||
        require('focal-mechanism/FocalMechanismModule');
    MomentTensorModule = MomentTensorModule ||
        require('moment-tensor/MomentTensorModule');
    OriginModule = OriginModule ||
        require('origin/OriginModule');
  };

  /**
   * Frees resources associated with this module.
   *
   */
  _this.destroy = Util.compose(function () {
    _fmFillColor = null;
    _formatter = null;
    _mtFillColor = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Creates the summary section for the finite fault product(s).
   *
   * @param products {Array}
   *     An array of products to summarize.
   *
   * @return {DocumentFragment}
   *     A (potentially empty) document fragment containing the summary for
   *     the given set of products.
   */
  _this.getFiniteFaultSummary = function (products) {
    return _this.createSummary(products, 'Finite Fault', [
        'Catalog',
        'Preview',
        'Source'
      ],
      _this.getFiniteFaultRow
    );
  };

  /**
   * Creates a row with summary information for the given product.
   *
   * @param product {Product}
   *     The product to summarize
   * @param index {Number}
   *     The place in which this product ranks among other products of the
   *     same type within the context of the current event. 0 = most preferred
   *
   * @return {DOMElement}
   *     A TR DOM element.
   */
  _this.getFiniteFaultRow = function (product, index) {
    var map,
        preferred,
        row;

    map = product.getContent('basemap.png');
    preferred = (index === 0);
    row = _this.createRow(preferred);

    row.innerHTML = [
      '<th scope="row">',
        _this.getCatalogMarkup(FiniteFaultModule, product, preferred),
      '</th>',
      '<td>',
        '<img src="', map.get('url'), '" class="image" alt="Finite Fault"/>',
      '</td>',
      '<td>',
        Attribution.getProductAttribution(product),
      '</td>'
    ].join('');

    return row;
  };

  /**
   * Creates the summary section for the focal mechanism product(s).
   *
   * @param products {Array}
   *     An array of products to summarize.
   *
   * @return {DocumentFragment}
   *     A (potentially empty) document fragment containing the summary for
   *     the given set of products.
   */
  _this.getFocalMechanismSummary = function (products) {
    return _this.createSummary(products, 'Focal Mechanism', [
        'Catalog',
        'Mechanism',
        'Nodal Plan 1<br/><small>Strike, Dip, Rake</small>',
        'Nodal Plan 1<br/><small>Strike, Dip, Rake</small>',
        'Source'
      ],
      _this.getFocalMechanismRow);
  };

  /**
   * Creates a row with summary information for the given product.
   *
   * @param product {Product}
   *     The product to summarize
   * @param index {Number}
   *     The place in which this product ranks among other products of the
   *     same type within the context of the current event. 0 = most preferred
   *
   * @return {DOMElement}
   *     A TR DOM element.
   */
  _this.getFocalMechanismRow = function (product, index) {
    var beachball,
        np1,
        np2,
        preferred,
        row,
        tensor;

    preferred = (index === 0);
    row = _this.createRow(preferred);

    tensor = Tensor.fromProduct(product);
    np1 = tensor.NP1;
    np2 = tensor.NP2;

    row.innerHTML = [
      '<th scope="row">',
        _this.getCatalogMarkup(FocalMechanismModule, product, preferred),
      '</th>',
      '<td class="beachball"></td>',
      '<td>(',
        _formatter.angle(np1.strike), ', ',
        _formatter.angle(np1.dip), ', ',
        _formatter.angle(np1.rake),
      ')</td>',
      '<td>(',
        _formatter.angle(np2.strike), ', ',
        _formatter.angle(np2.dip), ', ',
        _formatter.angle(np2.rake),
      ')</td>',
      '<td>',
        Attribution.getProductAttribution(product),
      '</td>'
    ].join('');

    beachball = BeachBallView({
      el: row.querySelector('.beachball'),
      fillColor: _fmFillColor,
      labelAxes: false,
      labelPlanes: false,
      size: 30,
      tensor: tensor
    });

    beachball.render();
    beachball.destroy();
    beachball = null;

    return row;
  };

  _this.getLinksHeader = function () {
    var header;

    header = document.createElement('h3');
    header.innerHTML = 'Scientific and Technical Links';

    return header;
  };

  /**
   * Creates the summary section for the moment tensor product(s).
   *
   * @param products {Array}
   *     An array of products to summarize.
   *
   * @return {DocumentFragment}
   *     A (potentially empty) document fragment containing the summary for
   *     the given set of products.
   */
  _this.getMomentTensorSummary = function (products) {
    return _this.createSummary(products, 'Moment Tensor', [
        'Catalog',
        'Tensor',
        'Magnitude',
        'Depth',
        '% <abbr title="Double Couple">DC</abbr>',
        'Source'
      ],
      _this.getMomentTensorRow
    );
  };

  /**
   * Creates a row with summary information for the given product.
   *
   * @param product {Product}
   *     The product to summarize
   * @param index {Number}
   *     The place in which this product ranks among other products of the
   *     same type within the context of the current event. 0 = most preferred
   *
   * @return {DOMElement}
   *     A TR DOM element.
   */
  _this.getMomentTensorRow = function (product, index) {
    var beachball,
        preferred,
        row,
        tensor;

    tensor = Tensor.fromProduct(product);
    preferred = (index === 0);
    row = _this.createRow(preferred);

    row.innerHTML = [
      '<th scope="row">',
        _this.getCatalogMarkup(MomentTensorModule, product, preferred),
      '</th>',
      '<td class="beachball"></td>',
      '<td>',
        _formatter.magnitude(
          tensor.magnitude,
          product.getProperty('derived-magnitude-type') || 'Mw'
        ),
      '</td>',
      '<td>',
        _formatter.depth(tensor.depth, 'km'),
      '</td>',
      '<td>',
        Math.round(tensor.percentDC * 100) + ' %',
      '</td>',
      '<td>',
        Attribution.getProductAttribution(product),
      '</td>'
    ].join('');

    beachball = BeachBallView({
      el: row.querySelector('.beachball'),
      fillColor: _mtFillColor,
      labelAxes: false,
      labelPlanes: false,
      size: 30,
      tensor: tensor
    });

    beachball.render();
    beachball.destroy();
    beachball = null;

    return row;
  };

  /**
   * Checks origin and phase-data type products on the given event. Prefers
   * phase-data from the same source and code unless there is a newer
   * corresponding origin.
   *
   * @param ev {CatalogEvent}
   *     The event to check.
   *
   * @return {Array}
   *     An array of {Product}s of either origin or phase-data type. Most
   *     preferred product first.
   */
  _this.getOriginProducts = function (ev) {
    var config,
        products;

    config = _this.model.get('config');

    if (ev) {
      products = ev.getProducts(Product.getFullType('origin', config)).map(
      function (origin) {
        var phase;

        // Find a corresponding phase-data product
        phase = ev.getProductById(Product.getFullType('phase-data', config),
            origin.get('source'), origin.get('code'));

        // Prefer the phase-data product if it is at least as new as the origin
        if (phase && phase.get('updateTime') >= origin.get('updateTime')) {
          return phase;
        } else {
          return origin;
        }
      });
    } else {
      products = [];
    }

    return products;
  };

  /**
   * Creates the summary section for the origin product(s).
   *
   * @param products {Array}
   *     An array of products to summarize.
   *
   * @return {DocumentFragment}
   *     A (potentially empty) document fragment containing the summary for
   *     the given set of products.
   */
  _this.getOriginSummary = function (products) {
    return _this.createSummary(products, 'Origin', [
        'Catalog',
        '<abbr title="Magnitude">Mag</abbr>',
        'Time',
        'Depth',
        'Review Status',
        'Location',
        'Source'
      ],
      _this.getOriginRow
    );
  };

  /**
   * Creates a row with summary information for the given product.
   *
   * @param product {Product}
   *     The product to summarize
   * @param index {Number}
   *     The place in which this product ranks among other products of the
   *     same type within the context of the current event. 0 = most preferred
   *
   * @return {DOMElement}
   *     A TR DOM element.
   */
  _this.getOriginRow = function (product, index) {
    var eventTime,
        preferred,
        reviewStatus,
        row;

    eventTime = new Date(product.getProperty('eventtime'));
    preferred = (index === 0);
    row = _this.createRow(preferred);
    reviewStatus = product.getProperty('review-status') || 'automatic';

    row.innerHTML = [
      '<th scope="row">',
        _this.getCatalogMarkup(OriginModule, product, preferred),
      '</th>',
      '<td>',
        _formatter.magnitude(
          product.getProperty('magnitude'),
          product.getProperty('magnitude-type')
        ),
      '</td>',
      '<td>',
        '<abbr title="', _formatter.datetime(eventTime, 0), '">',
          _formatter.time(eventTime),
        '</abbr>',
      '</td>',
      '<td>',
        _formatter.depth(product.getProperty('depth')),
      '</td>',
      '<td>',
        reviewStatus.toUpperCase(),
      '</td>',
      '<td>',
        _formatter.location(
          product.getProperty('latitude'),
          product.getProperty('longitude')
        ),
      '</td>',
      '<td>',
        Attribution.getProductAttribution(product),
      '</td>'
    ].join('');

    return row;
  };

  /**
   * Renders the module header, content, and footer.
   *
   */
  _this.render = function () {
    var faults,
        fragment,
        headers,
        links,
        mechs,
        origins,
        tensors,
        texts;

    fragment = document.createDocumentFragment();

    _this.clearLinks(true);
    _this.clearTexts(true);

    faults = _this.getProducts('finite-fault');
    headers = _this.getProducts('scitech-header');
    links = _this.getProducts('scitech-link');
    mechs = _this.getProducts('focal-mechanism');
    origins = _this.getOriginProducts(_this.model.get('event'));
    tensors = _this.getProducts('moment-tensor');
    texts = _this.getProducts('scitech-text');

    Util.empty(_this.header);
    _this.header.appendChild(_this.getTexts(headers));

    fragment.appendChild(_this.getOriginSummary(origins));
    fragment.appendChild(_this.getMomentTensorSummary(tensors));
    fragment.appendChild(_this.getFiniteFaultSummary(faults));
    fragment.appendChild(_this.getFocalMechanismSummary(mechs));
    fragment.appendChild(_this.getTexts(texts));
    fragment.appendChild(_this.getLinks(links));

    Util.empty(_this.content);
    _this.content.appendChild(fragment);

    _this.footer.innerHTML = '';
  };

  _initialize(options);
  options = null;
  return _this;
};


ScientificSummaryModule.ID = _ID;
ScientificSummaryModule.TITLE = _TITLE;
ScientificSummaryModule.TYPES = _TYPES;


module.exports = ScientificSummaryModule;

},{"core/Attribution":"core/Attribution","core/Formatter":"core/Formatter","core/SummaryModule":"core/SummaryModule","finite-fault/FiniteFaultModule":"finite-fault/FiniteFaultModule","focal-mechanism/FocalMechanismModule":"focal-mechanism/FocalMechanismModule","moment-tensor/BeachBallView":"moment-tensor/BeachBallView","moment-tensor/MomentTensorModule":"moment-tensor/MomentTensorModule","moment-tensor/Tensor":"moment-tensor/Tensor","origin/OriginModule":"origin/OriginModule","pdl/Product":"pdl/Product","util/Util":"util/Util"}],"shakemap/ShakeMapInfoView":[function(require,module,exports){
'use strict';


var ContentView = require('core/ContentView'),
    Formatter = require('core/Formatter'),
    Util = require('util/Util');


var _DEFAULTS = {
  empty: '&ndash;',
  formatter: null
};


/**
 * View for ShakeMap info.json content.
 *
 * @param options {Object}
 * @param options.empty {String}
 *     value to display if a field is missing or empty.
 *     default '&ndash;'.
 * @param options.formatter {Formatter}
 *     formatting object.
 */
var ShakeMapInfoView = function (options) {
  var _this,
      _initialize,

      _empty,
      _formatter;


  _this = ContentView(options);

  _initialize = function (options) {
    options = Util.extend({}, _DEFAULTS, options);
    _empty = options.empty;
    _formatter = options.formatter || Formatter();
  };


  /**
   * Format one ground motion row.
   *
   * @param gm {Object}
   *     ground motion object.
   * @param label {String}
   *     markup for `th` element.
   * @return {String}
   *     markup for table row.
   */
  _this.formatGroundMotion = function (gm, label) {
    var units;

    units = gm.units;

    return '<tr>' +
        '<th scope="row">' + label + '</th>' +
        '<td>' + gm.max_grid + ' ' + units + '</td>' +
        '<td>' + gm.max + ' ' + units + '</td>' +
        '<td>' + gm.bias + '</td>' +
        '</tr>';
  };

  /**
   * Format the output ground motions table.
   *
   * @param groundMotions {Object}
   *     the output ground motions section of info.json.
   * @return {String}
   *     markup for output ground motions table.
   */
  _this.formatOutputGroundMotions = function (groundMotions) {
    var buf,
        headers;

    buf = [];
    buf.push('<h3>Ground Motion/Intensity Information</h3>');

    buf.push(
        '<div class="horizontal-scrolling">' +
        '<table>' +
        '<thead>' +
          '<tr>' +
            '<th scope="col">Type</th>' +
            '<th scope="col">Max value in grid</th>' +
            '<th scope="col">Max value on land</th>' +
            '<th scope="col">Bias</th>' +
          '</tr>' +
        '</thead>' +
        '<tbody>');

    headers = {
      'intensity': 'Intensity',
      'pga': '<abbr title="Peak Ground Acceleration">PGA</abbr>',
      'pgv': '<abbr title="Peak Ground Velocity">PGV</abbr>',
      'psa03': '<abbr title="Pseudo Spectral Acceleration 0.3 s">' +
          'PSA03</abbr>',
      'psa10': '<abbr title="Pseudo Spectral Acceleration 1.0 s">' +
          'PSA10</abbr>',
      'psa30': '<abbr title="Pseudo Spectral Acceleration 3.0 s">' +
          'PSA30</abbr>'
    };

    Object.keys(headers).forEach(function (key) {
      if (key in groundMotions) {
        buf.push(_this.formatGroundMotion(groundMotions[key], headers[key]));
      }
    });

    Object.keys(groundMotions).forEach(function (key) {
      if (!(key in headers)) {
        // unknown groundMotion
        buf.push(_this.formatGroundMotion(groundMotions[key], key));
      }
    });

    buf.push(
        '</tbody>' +
        '</table>' +
        '</div>');

    return buf.join('');
  };

  /**
   * Format the output map information table.
   *
   * @param mapInformation {Object}
   *     the output map information section of info.json.
   * @return {String}
   *     markup for the map information table.
   */
  _this.formatOutputMapInformation = function (mapInformation) {
    var gridPoints,
        gridSpan,
        gridSpacing,
        max,
        min;

    gridPoints = mapInformation.grid_points;
    gridSpan = mapInformation.grid_span;
    gridSpacing = mapInformation.grid_spacing;
    max = mapInformation.max;
    min = mapInformation.min;

    return '<h3>Map Information</h3>' +
        '<div class="horizontal-scrolling">' +
        '<table>' +
          '<thead>' +
          '<tr>' +
            '<th scope="col">Type</th>' +
            '<th scope="col">Latitude</th>' +
            '<th scope="col">Longitude</th>' +
          '</tr>' +
          '</thead>' +
          '<tbody>' +
          '<tr>' +
            '<th scope="row">Span</th>' +
            '<td>' + gridSpan.latitude + '&deg;</td>' +
            '<td>' + gridSpan.longitude + '&deg;</td>' +
          '</tr>' +
          '<tr>' +
            '<th scope="row">Grid Spacing</th>' +
            '<td>' + gridSpacing.latitude + ' km</td>' +
            '<td>' + gridSpacing.longitude + ' km</td>' +
          '</tr>' +
          '<tr>' +
            '<th scope="row">Number of points</th>' +
            '<td>' + gridPoints.latitude + '</td>' +
            '<td>' + gridPoints.longitude + '</td>' +
          '</tr>' +
          '<tr>' +
            '<th scope="row">Min</th>' +
            '<td>' + _formatter.latitude(min.latitude) + '</td>' +
            '<td>' + _formatter.longitude(min.longitude) + '</td>' +
          '</tr>' +
          '<tr>' +
            '<th scope="row">Max</th>' +
            '<td>' + _formatter.latitude(max.latitude) + '</td>' +
            '<td>' + _formatter.longitude(max.longitude) + '</td>' +
          '</tr>' +
          '</tbody>' +
        '</table>' +
        '</div>';
  };

  /**
   * Format the processing ground motions table.
   *
   * @param groundMotions {Object}
   *     the processing ground motions section of info.json.
   * @return {String}
   *     markup for processing ground motions table.
   */
  _this.formatProcessingGroundMotions = function (groundMotions) {
    var buf,
        headers,
        formatGroundMotion;

    buf = [];
    buf.push('<h3>Ground Motion/Intensity Information</h3>');

    buf.push(
        '<div class="horizontal-scrolling">' +
        '<table>' +
          '<thead>' +
            '<tr>' +
            '<th scope="col">Type</th>' +
            '<th scope="col">Module</th>' +
            '<th scope="col">Reference</th>' +
            '</tr>' +
          '</thead>' +
          '<tbody>');

    /**
     * Format one ground motion row.
     *
     * @param gm {Object}
     *     ground motion object.
     * @param label {String}
     *     markup for `th` element.
     * @return {String}
     *     markup for table row.
     */
    formatGroundMotion = function (gm, label) {
      var units;

      units = gm.units;

      return '<tr>' +
          '<th scope="row">' + label + '</th>' +
          '<td>' + gm.module + '</td>' +
          '<td>' + gm.reference + '</td>' +
        '</tr>';
    };

    headers = {
      'gmpe': '<abbr title="Ground Motion Prediction Equation">GMPE</abbr>',
      'ipe': '<abbr title="Intensity Prediction Equation">IPE</abbr>',
      'mi2pgm': '<abbr title="Ground Motion Intensity Conversion Equation">' +
          'GMICE</abbr>',
      'pgm2mi':
          '<abbr title="Inverse Ground Motion Intensity Conversion Equation">' +
          'IGMICE</abbr>',
      'directivity': 'Directivity',
      'basin_correction': 'Basin'
    };

    Object.keys(headers).forEach(function (key) {
      if (key in groundMotions) {
        buf.push(formatGroundMotion(groundMotions[key], headers[key]));
      }
    });
    Object.keys(groundMotions).forEach(function (key) {
      if (!(key in headers)) {
        // unknown groundMotion
        buf.push(formatGroundMotion(groundMotions[key], key));
      }
    });

    buf.push('</tbody>' +
        '</table>' +
      '</div>');

    return buf.join('');
  };

  /**
   * Format the processing ground motions table.
   *
   * @param rois {Object}
   *     the processing rois section of info.json.
   * @return {String}
   *     markup for processing rois table.
   */
  _this.formatProcessingRois = function (rois) {
    var groundMotion,
        intensity;

    groundMotion = rois.gm;
    intensity = rois.intensity;

    return '<h3>ROI</h3>' +
      '<div class="horizontal-scrolling">' +
        '<table>' +
          '<thead>' +
            '<tr>' +
              '<th scope="col">Type</th>' +
              '<th scope="col">ROI</th>' +
              '<th scope="col">Observation Decay</th>' +
            '</tr>' +
          '</thead>' +
          '<tbody>' +
            '<tr>' +
              '<th scope="row">Ground Motion</th>' +
              '<td>' + groundMotion.roi + ' km</td>' +
              '<td>' + groundMotion.decay + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Intensity</th>' +
              '<td>' + intensity.roi + ' km</td>' +
              '<td>' + intensity.decay + '</td>' +
            '</tr>' +
          '</tbody>' +
        '</table>' +
      '</div>';
  };

  /**
   * Error callback if unable to load info.json.
   */
  _this.onError = function () {
    _this.el.innerHTML = '<p class="alert error">' +
        'Unable to load ShakeMap information' +
      '</p>';
  };

  /**
   * Success callback, once info.json has loaded.
   */
  _this.onSuccess = function (json) {
    var el = _this.el;

    el.innerHTML =
        '<div class="row">' +
          '<div class="one-of-two column shakemapinfo-input"></div>' +
          '<div class="one-of-two column shakemapinfo-output"></div>' +
        '</div>' +
        '<div class="shakemapinfo-processing"></div>';

    _this.renderInput(json, el.querySelector('.shakemapinfo-input'));
    _this.renderProcessing(json, el.querySelector('.shakemapinfo-processing'));
    _this.renderOutput(json, el.querySelector('.shakemapinfo-output'));
  };

  /**
   * Render the input section of info.json.
   *
   * @param el {DOMElement}
   *        element where content should be rendered.
   */
  _this.renderInput = function (json, el) {
    var buf,
        info,
        input;

    input = json.input;

    buf = [];
    buf.push('<h2>Input</h2>');

    info = input.event_information;
    buf.push('<h3>Event Information</h3>' +
      '<div class="horizontal-scrolling">' +
        '<table>' +
          '<tbody>' +
            '<tr>' +
              '<th scope="row">Description</th>' +
              '<td>' + info.event_description + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">ID</th>' +
              '<td>' + info.event_id + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Magnitude</th>' +
              '<td>' + _formatter.magnitude(info.magnitude) + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Depth</th>' +
              '<td>' + _formatter.depth(info.depth, 'km') + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Longitude</th>' +
              '<td>' + _formatter.longitude(info.longitude) + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Latitude</th>' +
              '<td>' + _formatter.latitude(info.latitude) + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Origin Time</th>' +
              '<td>' + info.origin_time + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Mechanism</th>' +
              '<td>' + (info.src_mech || _empty) + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Mechanism source</th>' +
              '<td>' + (info.mech_src || _empty) + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Location</th>' +
              '<td>' + info.location + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Flinn Engdahl region</th>' +
              '<td>' + info.feregion + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Fault file(s)</th>' +
              '<td>' + (info.faultfiles || _empty) + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Fault reference(s)</th>' +
              '<td>' + (info.fault_ref || _empty) + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Tectonic regime</th>' +
              '<td>' + (info.tectonic_regime || _empty) + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Number of seismic stations</th>' +
              '<td>' + info.seismic_stations + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Number of DYFI stations</th>' +
              '<td>' + info.intensity_observations + '</td>' +
            '</tr>' +
          '</tbody>' +
        '</table>' +
      '</div>');

    el.innerHTML = buf.join('');
  };

  /**
   * Render the output section of info.json.
   *
   * @param json {Object}
   *        parsed info.json content.
   * @param el {DOMElement}
   *        element where content should be rendered.
   */
  _this.renderOutput = function (json, el) {
    var buf,
        output,
        uncertainty;

    output = json.output;

    buf = [];
    buf.push('<h2>Output</h2>');
    buf.push(_this.formatOutputGroundMotions(output.ground_motions));
    buf.push(_this.formatOutputMapInformation(output.map_information));

    uncertainty = output.uncertainty;
    buf.push('<h3>Uncertainty</h3>' +
      '<div class="horizontal-scrolling">' +
        '<table>' +
          '<tbody>' +
            '<tr>' +
              '<th scope="row">Mean of map uncertainty</th>' +
              '<td>' + uncertainty.mean_uncertainty_ratio + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Emperical ShakeMap grade</th>' +
              '<td>' + uncertainty.grade + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Flagged seismic stations</th>' +
              '<td>' + uncertainty.total_flagged_pgm + '</td>' +
            '</tr>' +
            '<tr>' +
              '<th scope="row">Flagged DYFI stations</th>' +
              '<td>' + uncertainty.total_flagged_mi + '</td>' +
            '</tr>' +
          '</tbody>' +
        '</table>' +
      '</div>');

    el.innerHTML = buf.join('');
  };

  /**
   * Render the processing section of info.json.
   *
   * @param json {Object}
   *        parsed info.json content.
   * @param el {DOMElement}
   *        element where content should be rendered.
   */
  _this.renderProcessing = function (json, el) {
    var buf,
        misc,
        processing,
        response,
        versions;

    processing = json.processing;

    buf = [];
    buf.push('<h2>Processing</h2>' +
        '<div class="row">');

    buf.push('<div class="one-of-two column">' +
        _this.formatProcessingGroundMotions(processing.ground_motion_modules) +
      '</div>');

    misc = processing.miscellaneous;
    buf.push(
      '<div class="one-of-two column">' +
        '<h3>Miscellaneous</h3>' +
        '<div class="horizontal-scrolling">' +
          '<table>' +
            '<tbody>' +
              '<tr>' +
                '<th scope="row">Used log amp to compute bias?</th>' +
                '<td>' + misc.bias_log_amp + '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">' +
                  'Maximum distance to include station in bias' +
                '</th>' +
                '<td>' +
                  _formatter.distance(misc.bias_max_range, 'km') +
                '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">Max magnitude to compute bias</th>' +
                '<td>' + _formatter.magnitude(misc.bias_max_mag) + '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">Min allowed bias</th>' +
                '<td>' + (misc.bias_min_bias || _empty) + '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">Maximum magnitude to flag outliers</th>' +
                '<td>' + _formatter.magnitude(misc.outlier_max_mag) + '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">Norm of the bias</th>' +
                '<td>' + (misc.bias_norm || _empty) + '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">' +
                  'Min # of stations necessary to compute bias' +
                '</th>' +
                '<td>' + (misc.bias_min_stations || _empty) + '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">Max allowed bias</th>' +
                '<td>' + (misc.bias_max_bias || _empty) + '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">Outlier level (# of std dev)</th>' +
                '<td>' + (misc.outlier_deviation_level || _empty) + '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">Median distance used</th>' +
                '<td>' + misc.median_dist + '</td>' +
              '</tr>' +
            '</tbody>' +
          '</table>' +
        '</div>' +
      '</div>');

    versions = processing.shakemap_versions;
    buf.push(
      '<div class="one-of-two column">' +
        '<h3>ShakeMap Versions</h3>' +
        '<div class="horizontal-scrolling">' +
          '<table>' +
            '<tbody>' +
              '<tr>' +
                '<th scope="row">Code</th>' +
                '<td>' + versions.shakemap_revision + '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">Map</th>' +
                '<td>' + versions.map_version + '</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">Date</th>' +
                '<td>' + versions.process_time + '</td>' +
              '</tr>' +
            '</tbody>' +
          '</table>' +
        '</div>' +
      '</div>');

    response = processing.site_response;
    buf.push(
      '<div class="one-of-two column">' +
        '<h3>Site Response</h3>' +
        '<div class="horizontal-scrolling">' +
          '<table>' +
            '<tbody>' +
              '<tr>' +
                '<th scope="row">Reference rock Vs30</th>' +
                '<td>' + response.vs30default + ' m/s</td>' +
              '</tr>' +
              '<tr>' +
                '<th scope="row">Site correction applied</th>' +
                '<td>' + response.site_correction + '</td>' +
              '</tr>' +
            '</tbody>' +
          '</table>' +
        '</div>' +
      '</div>');

    buf.push(
      '<div class="one-of-two column">' +
        _this.formatProcessingRois(processing.roi) +
      '</div>');

    buf.push('</div>');
    el.innerHTML = buf.join('');
  };


  _initialize(options);
  options = null;
  return _this;
};


module.exports = ShakeMapInfoView;

},{"core/ContentView":"core/ContentView","core/Formatter":"core/Formatter","util/Util":"util/Util"}],"shakemap/ShakeMapModule":[function(require,module,exports){
'use strict';

var ImpactSummaryModule = require('impact/ImpactSummaryModule'),
    Module = require('core/Module'),
    ShakeMapView = require('shakemap/ShakeMapView'),
    Util = require('util/Util');


var _ID,
    _TITLE,
    _TYPES;


// Note: These should be overridden by each implementing sub-class.
_ID = 'shakemap';
_TITLE = 'ShakeMap';
_TYPES = ['shakemap'];


var _DEFAULTS = {

};


/**
 * Bridges the event page framework with the product rendering.
 *
 */
var ShakeMapModule = function (options) {
  var _this,
      _initialize,

      _shakeMapView;


  options = Util.extend({}, _DEFAULTS, options);
  _this = Module(options);

  /**
   * Initialize a new module.
   *
   * @see Module#_initialize
   */
  _initialize = function (/*options*/) {
    _this.ID = _ID;
    _this.TITLE = _TITLE;
  };


  /**
   * Destroy this module and sub-view(s).
   *
   */
  _this.destroy = Util.compose(function () {
    if (_shakeMapView) {
      _shakeMapView.destroy();
    }
    _shakeMapView = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Renders the details for this module. Defers bulk of header Information
   * to generalized header rendering. Uses {ShakeMapView} for bulk of content
   * rendering.
   *
   */
  _this.render = function () {
    var additionalFooter,
        product;


    _this.header.innerHTML = '<h3>ShakeMap</h3>';

    product = _this.getProduct('shakemap');
    if (!product) {
      _this.content.innerHTML =
          '<p class="alert warning">No ShakeMap Found</p>';
    } else {
      _this.header.appendChild(_this.getProductHeader({
        product: product,
        summaryModule: ImpactSummaryModule
      }));

      additionalFooter = _this.getProductFooter({
        product: product
      });

      // Load content from ShakeMapView
      _shakeMapView = ShakeMapView({
        el: _this.content,
        model: product
      });

      _shakeMapView.render();
    }

    _this.footer.innerHTML =
      '<h3>For More Information</h3>' +
      '<ul>' +
        '<li>' +
          '<a href="https://usgs.github.io/shakemap">ShakeMap Manual</a>' +
        '</li>' +
      '</ul>';

    if (additionalFooter) {
      _this.footer.appendChild(additionalFooter);
    }
  };


  _initialize(options);
  options = null;
  return _this;
};


ShakeMapModule.ID = _ID;
ShakeMapModule.TITLE = _TITLE;
ShakeMapModule.TYPES = _TYPES;


module.exports = ShakeMapModule;

},{"core/Module":"core/Module","impact/ImpactSummaryModule":"impact/ImpactSummaryModule","shakemap/ShakeMapView":"shakemap/ShakeMapView","util/Util":"util/Util"}],"shakemap/ShakeMapPinView":[function(require,module,exports){
'use strict';

var BasicPinView = require('core/BasicPinView'),
    Formatter = require('core/Formatter'),
    ShakeMapModule = require('shakemap/ShakeMapModule'),
    Util = require('util/Util');


var _DEFAULTS = {
  module: ShakeMapModule
};

var ShakeMapPinView = function (options) {
  var _this,
      _initialize,

      _formatter;


  options = Util.extend({}, _DEFAULTS, options);
  _this = BasicPinView(options);


  _initialize = function (options) {
    _formatter = options.formatter || Formatter();
  };

  /**
   * Frees resources associated with this view.
   *
   */
  _this.destroy = Util.compose(function () {
    _formatter = null;

    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * Renders content for ShakeMapPinView
   *
   */
  _this.renderPinContent = function () {
    var img,
        markup;

    img = _this.model.getContent('pin-thumbnail.png');
    if (!img) {
      img = _this.model.getContent('download/tvmap.jpg');
    }

    if (img) {
      markup = '<div class="shakemap-tvmap">' +
          '<img src="' + img.get('url') + '" alt="Intensity Map"/>' +
          '</div>';
    } else {
      markup = '<p class="alert warning">Map not available</p>';
    }

    _this.content.innerHTML = markup;
  };

  /**
   * Render header for ShakeMapPinView with impact bubble
   *
   */
  _this.renderPinHeader = Util.compose(_this.renderPinHeader, function () {
    _this.header.insertAdjacentHTML('beforeend',
        _formatter.intensity(_this.model.getProperty('maxmmi'), null));
  });

  _initialize(options);
  options = null;
  return _this;
};


module.exports = ShakeMapPinView;

},{"core/BasicPinView":"core/BasicPinView","core/Formatter":"core/Formatter","shakemap/ShakeMapModule":"shakemap/ShakeMapModule","util/Util":"util/Util"}],"shakemap/ShakeMapStationListView":[function(require,module,exports){
'use strict';

var Accordion = require('accordion/Accordion'),
    ContentView = require('core/ContentView'),
    Formatter = require('core/Formatter'),
    Util = require('util/Util');

var _NO_CONTENT_MESSAGE = 'No stations list available.';

var FLAG_DESCRIPTIONS = {
  'M': 'Manually flagged',
  'T': 'Outlier',
  'G': 'Glitch (clipped or below noise)',
  'I': 'Incomplete time series',
  'N': 'Not in list of known stations'
};


/**
 * View for a Station List.
 *
 * @param options {Object}
 *
 * @param options.formatter {Formatter}
 *     The formatter object to use for formatting intrinsic values.
 */
var ShakeMapStationListView = function (options) {
  var _this,
      _initialize,

      _accordion,
      _formatter;

  options = options || {};
  _this = ContentView(options);

  _initialize = function(options) {
    _this.el.classList.add('shakemap-stations');
    _formatter = options.formatter || Formatter();
  };


  /**
   * Generate summary markup for station list.
   *
   * @param  data {array},
   *         list of station objects.
   *
   * @return {string}
   *         HTML markup.
   */
  _this.buildStationList = function (data) {
    var distance,
        i,
        pga,
        pgv,
        props,
        stations,
        station,
        title;

    data = data.features;
    if (data.length === 0) {
      return '<p>No station data available at this time.</p>';
    }

    data.sort(_this.sortByDistance);
    stations = [];
    for (i = 0; i < data.length; i++) {
      station = data[i];
      props = station.properties;

      pga = props.pga;
      pgv = props.pgv;

      pgv = _formatter.number(pgv, 3);
      pga = _formatter.number(pga, 3);

      distance = _formatter.number(props.distance, 1);

      // Do not repeat the zip code if it's already part of the name
      if (props.name.indexOf('ZIP Code') === -1) {
        title = props.code + '<small>' + props.name + '</small>';
      } else {
        title = props.name;
      }

      stations.push([
        '<div class="accordion accordion-section accordion-closed station">',
          '<h3>', title, '</h3>',
          '<ul class="station-summary">',
            '<li>',
              _formatter.intensity(props.intensity,
                  '<abbr title="Modified Mercalli Intensity">mmi</abbr>'),
            '</li>',
            '<li>',
              '<span>', pga ,' %g</span>',
              '<abbr title="Maximum Horizontal Peak Ground Acceleration">',
                'pga',
              '</abbr>',
            '</li>',
            '<li>',
              '<span>', pgv ,' cm/s</span>',
              '<abbr title="Maximum Horizontal Peak Ground Velocity">',
                'pgv',
              '</abbr>',
            '</li>',
            '<li>',
              '<span>', distance , ' km','</span>',
              '<abbr title="Distance (km)">dist</abbr>',
            '</li>',
          '</ul>',
          '<a class="accordion-toggle" data-id="', i ,'">Details</a>',
          _this.buildStationDetails(station),
        '</div>'
      ].join(''));
    }

    return stations.join('');
  };

  /**
   * Generate details markup for station details. This is only called
   * when a station details section is expanded.
   *
   * @param  index {string},
   *         a data-id value that identifies the station details
   *         section that is expanded on a click event.
   *
   * @return {string}
   *         HTML markup.
   */
  _this.buildStationDetails = function (feature) {
    var props;

    props = feature.properties;

    return [
        '<div class="accordion-content">',
          '<dl class="station-metadata vertical">',
            '<dt class="station-metadata-type">Type</dt>',
              '<dd class="station-metadata-type">',
                (props.instrumentType||'&ndash;'),
              '</dd>',
            '<dt class="station-metadata-location">Location</dt>',
              '<dd class="station-metadata-location">',
                _this.formatLocation(feature),
              '</dd>',
            '<dt class="station-metadata-source">Source</dt>',
              '<dd class="station-metadata-source">',
                  (props.source || '&ndash;'), '</dd>',
            '<dt class="station-metadata-intensity">Intensity</dt>',
              '<dd class="station-metadata-intensity">',
                _formatter.number(props.intensity, 1, '&ndash;'),
              '</dd>',
          '</dl>',
          _this.createChannelTable(props.channels),
        '</div>'
      ].join('');
  };

  /**
   * Takes an array of amplitude objects from a channel, and creates
   *    a more user friendly amplitude object.
   * @param [objects] amplitudes
   *    An array of amplitude objects.
   *
   * @return {object}
   *    an object with a key object pair, where the key is the amplitude name.
   */
  _this.createAmplitudesObject = function (amplitudes) {
    var amp,
        amplitude,
        i,
        len;

    amp = {};
    len = amplitudes.length;
    for (i = 0; i < len; i++) {
      amplitude = amplitudes[i];
      amp[amplitude.name] = amplitude;
    }

    return amp;
  };

  /**
   * create the markup for a channel table.
   *
   * @params [objects] channels
   *
   * @return {string}
   *         HTML markup.
   */
  _this.createChannelTable = function (channels) {
    var i,
        numChannels;

    var markup = [
      '<div class="horizontal-scrolling">',
      '<table class="station-channels-list">',
        '<thead>',
          '<tr>',
            '<th scope="col" class="station-channels-list-name">name</th>',
            '<th scope="col" class="station-channels-list-pga">pga</th>',
            '<th scope="col" class="station-channels-list-pgv">pgv</th>',
            '<th scope="col" class="station-channels-list-psa03">psa03</th>',
            '<th scope="col" class="station-channels-list-psa10">psa10</th>',
            '<th scope="col" class="station-channels-list-psa30">psa30</th>',
          '</tr>',
        '</thead>',
        '<tbody>'
    ];

    numChannels = channels.length;
    for (i = 0; i < numChannels; i++) {
      markup.push(_this.createChannelRow(channels[i]));
    }

    markup.push('</tbody></table></div>');

    return markup.join('');
  };


  /**
   * create the markup for a channel row
   *
   * @params {objects} channel
   *
   * @return {string}
   *         HTML markup.
   */
  _this.createChannelRow = function (channel) {
    var amplitude;

    amplitude = _this.createAmplitudesObject(channel.amplitudes);

    return [
      '<tr>',
        '<th scope="row" class="station-channel-name">',
          channel.name,
        '</th>',
        '<td class="station-channel-pga">',
          _this.formatComponent(amplitude.pga),
        '</td>',
        '<td class="station-channel-pgv">',
          _this.formatComponent(amplitude.pgv),
        '</td>',
        '<td class="station-channel-psa03">',
          _this.formatComponent(amplitude.psa03),
        '</td>',
        '<td class="station-channel-psa10">',
          _this.formatComponent(amplitude.psa10),
        '</td>',
        '<td class="station-channel-psa30">',
          _this.formatComponent(amplitude.psa30),
        '</td>',
      '</tr>'
    ].join('');
  };

  /**
   * Free references.
   */
  _this.destroy = Util.compose(function () {
    if (_accordion) {
      _accordion.destroy();
    }
    _accordion = null;
    _formatter = null;
    _initialize = null;
    _this = null;
  }, _this.destroy);

  /**
   * format the component of a cell for a channel table.
   *
   * @params {object} data
   *
   * @returns {string}
   *         HTML markup.
   */
  _this.formatComponent = function (data) {
    var content,
        flag,
        value,
        units;

    content = [];
    if (data) {
      flag = data.flag;
      value = data.value;
      units = data.units;

      // Add flag class for all non-zero flags
      if (flag && flag !== '0') {
        content.push('<span class="station-flag">');
        content.push(parseFloat(value, 10).toFixed(3));

        // display flag with title text
        if (FLAG_DESCRIPTIONS.hasOwnProperty(flag)) {
          content.push('<abbr title="' + FLAG_DESCRIPTIONS[flag] + '">(' +
              flag + ')</abbr>');
        } else {
          content.push('(' + flag + ')');
        }
        content.push('</span>');
      } else {
        content.push('<span>');
        content.push(parseFloat(value, 10).toFixed(3));
        content.push('&nbsp;'+ units);
        content.push('</span>');
      }
    } else {
      content.push('<span>&ndash;</span>');
    }

    return content.join('');
  };

  /**
   * Get the Lat, Long; swap position and encapsulate in parens.
   *
   * @param {object} feature
   *
   * @return {string}
   *         HTML markup.
   */
  _this.formatLocation = function (feature) {
    var latitude,
        longitude;

    latitude = feature.geometry.coordinates[1];
    longitude = feature.geometry.coordinates[0];

    return ((feature.properties.location) ?
        (feature.properties.location + '<br/>') : '') +
        _formatter.location(latitude, longitude);
  };

  /**
   * Renders the default error message. Called if an error occurs during the
   * data fetch.
   *
   */
  _this.onError = function (/*status, xhr*/) {
    _this.el.innerHTML = _NO_CONTENT_MESSAGE;
  };

  /**
   * Renders the list of stations. Called when data is successfully fetched.
   *
   */
  _this.onSuccess = function (responseText/*, xhr*/) {
    _this.el.innerHTML = _this.buildStationList(responseText);
    _accordion = Accordion({
      el:_this.el
    });
  };

  /**
   * Sort by Distance
   *    Used by sort routines to determine which distance is greater.
   *
   * @params a {object}
   *         An object with distance in a properties sub object.
   * @params a {object}
   *         An object with distance in a properties sub object.
   *
   * @returns {number}
   *          The difference between the two distances.
   */
  _this.sortByDistance = function (a, b) {
    return parseFloat(a.properties.distance) - parseFloat(b.properties.distance);
  };


  _initialize(options);
  options = null;
  return _this;
};


ShakeMapStationListView.NO_CONTENT_MESSAGE = _NO_CONTENT_MESSAGE;

module.exports = ShakeMapStationListView;

},{"accordion/Accordion":2,"core/ContentView":"core/ContentView","core/Formatter":"core/Formatter","util/Util":"util/Util"}],"shakemap/ShakeMapView":[function(require,module,exports){
'use strict';

var InteractiveMapView = require('map/InteractiveMapView'),
    ProductView = require('core/ProductView'),
    ShakeMapInfoView = require('shakemap/ShakeMapInfoView'),
    ShakeMapStationListView = require('shakemap/ShakeMapStationListView'),
    TabList = require('tablist/TabList'),
    Util = require('util/Util');


var ShakeMapView = function (options) {
  var _this,
      _initialize,

      _shakeMapInfoView,
      _shakeMapStationListView,
      _tablist;

  _this = ProductView(options);

  _initialize = function () {
    _this.el.classList.add('shakemap');
  };

  /**
   * Create tab content for all PSA images (PSA 0.3, 1.0, 3.0)
   *
   * @param  {Product} shakemap
   *    shakemap product with PSA image contents
   *
   * @return {string} markup
   *    HTML markup for PSA tab contents
  **/
  _this.createPSATabListImages = function (shakemap) {
    var header,
        markup,
        psa03,
        psa10,
        psa30;

    header = [];
    markup = [];
    psa03 = shakemap.getContent('download/psa03.jpg');
    psa10 = shakemap.getContent('download/psa10.jpg');
    psa30 = shakemap.getContent('download/psa30.jpg');

    if (psa03) {
      header.push('0.3 s');
      markup.push(_this.createTabListImage(psa03,
          'ShakeMap Peak Spectral Acceleration 0.3 s image'));
    }

    if (psa10) {
      header.push('1.0 s');
      markup.push(_this.createTabListImage(psa10,
          'ShakeMap Peak Spectral Acceleration 1.0 s image'));
    }

    if (psa30) {
      header.push('3.0 s');
      markup.push(_this.createTabListImage(psa30,
          'ShakeMap Peak Spectral Acceleration 3.0 s image'));
    }

    return '<h3>' +
        'Peak Spectral Acceleration (%g) for ' + header.join(', ') +
        '</h3>' +
        markup.join('');
  };

  /**
   * Generate tab contents for tablist
   *
   * @param  {Product} shakemap,
   *         shakemap product with contents
   */
  _this.createTabListData = function (shakemap) {
    var intensityContent,
        pgaContent,
        pgvContent,
        shakeMapInfoContent,
        stationListContent,
        uncertaintyContent;

    // Intesity Image
    intensityContent = shakemap.getContent('download/intensity.jpg');
    if (intensityContent) {
      _tablist.addTab({
        title: 'Intensity',
        content: _this.createTabListImage(intensityContent,
            'ShakeMap Intensity image')
      });
    }

    // PGA Image
    pgaContent = shakemap.getContent('download/pga.jpg');
    if (pgaContent) {
      _tablist.addTab({
        title: '<abbr title="Peak Ground Acceleration">PGA</abbr>',
        content: _this.createTabListImage(pgaContent,
            'ShakeMap Peak Ground Acceleration image')
      });
    }

    // PGV Image
    pgvContent = shakemap.getContent('download/pgv.jpg');
    if (pgvContent) {
      _tablist.addTab({
        title: '<abbr title="Peak Ground Velocity">PGV</abbr>',
        content: _this.createTabListImage(pgvContent,
            'ShakeMap Peak Ground Velocity image')
      });
    }

    // StationList
    stationListContent = shakemap.getContent('download/stationlist.json');
    if (stationListContent) {
      _shakeMapStationListView = ShakeMapStationListView({
            el: document.createElement('div'),
            model: stationListContent
          });
      _tablist.addTab({
        title: 'Station List',
        content: function () {
          _shakeMapStationListView.render();
          return _shakeMapStationListView.el;
        }
      });
    }

    // Info
    shakeMapInfoContent = shakemap.getContent('download/info.json');
    if (shakeMapInfoContent) {
      _shakeMapInfoView = ShakeMapInfoView({
        el: document.createElement('div'),
        model: shakeMapInfoContent
      });
      _tablist.addTab({
        title: 'Metadata',
        content: function () {
          _shakeMapInfoView.render();
          return _shakeMapInfoView.el;
        }
      });
    }

    // Uncertainty Image
    uncertaintyContent = shakemap.getContent('download/sd.jpg');
    if (uncertaintyContent) {
      _tablist.addTab({
        title: 'Uncertainty',
        content: _this.createTabListImage(uncertaintyContent,
            'ShakeMap Uncertainty image')
      });
    }

    // PSA Images
    if (shakemap.getContent('download/psa03.jpg') ||
        shakemap.getContent('download/psa10.jpg') ||
        shakemap.getContent('download/psa30.jpg')) {
      _tablist.addTab({
        title: '<abbr title="Peak Spectral Acceleration">PSA</abbr>',
        content: _this.createPSATabListImages(shakemap)
      });
    }
  };

  /**
   * Create combined link/image for tablist image.
   *
   * @param  {Content} content
   *         shakemap Content object with an url property
   *
   * @return {string} link
   *         image link to interactive map.
  **/
  _this.createTabListImage = function (content, alt) {
    var link;

    if (!content.get('url')) {
      return '';
    }

    // In addition to contours (default), enable stations
    link =
      '<a href="#map?' + InteractiveMapView.SHAKEMAP_STATIONS + '=true' +
          '&shakemapSource=' + _this.model.get('source') +
          '&shakemapCode=' + _this.model.get('code') + '">' +
        '<img' +
          ' class="shakemap-tablist-image" ' +
          ' src="' + content.get('url') + '"' +
          ' alt="' + alt + '"' +
        '/>' +
      '</a>';

    return link;
  };

  _this.destroy = Util.compose(function () {
    // Destroy tablist
    if (_tablist) {
      _tablist.destroy();
      _tablist = null;
    }

    if (_shakeMapInfoView) {
      _shakeMapInfoView.destroy();
      _shakeMapInfoView = null;
    }

    // Destrop ShakeMapStationList
    if (_shakeMapStationListView) {
      _shakeMapStationListView.destroy();
      _shakeMapStationListView = null;
    }

    _initialize = null;
    _this = null;
  }, _this.destroy);

  _this.render = function () {
    var el,
        shakemap;

    el = _this.el;
    shakemap = _this.model;

    if (shakemap.isDeleted()) {
      el.innerHTML = '<p class="alert info">Product Deleted</p>';
    } else {
      // Build TabList with all of the shakemap images
      _tablist = new TabList({
        el: el,
        tabPosition: 'top',
        tabs: []
      });
      _this.createTabListData(shakemap);
    }
  };

  _initialize();
  options = null;
  return _this;
};

module.exports = ShakeMapView;

},{"core/ProductView":"core/ProductView","map/InteractiveMapView":"map/InteractiveMapView","shakemap/ShakeMapInfoView":"shakemap/ShakeMapInfoView","shakemap/ShakeMapStationListView":"shakemap/ShakeMapStationListView","tablist/TabList":"tablist/TabList","util/Util":"util/Util"}],"svgimagemap/SvgImageMap":[function(require,module,exports){
'use strict';

var View = require('mvc/View');
var Util = require('util/Util');
var Xhr = require('util/Xhr');


var DEFAULTS = {
  // container element
  el: null,
  // image url
  imageUrl: null,
  // image alt,
  imageAlt: '',
  // imagemap url
  mapUrl: null,
  // imagemap name (optional)
  mapName: null,
  // if imagemap is already as svg
  svgUrl: null,
  // width of imagemap
  width: null,
  // height of imagemap
  height: null,
  // areas of imagemap
  areas: null
};



/**
 * Parse an image map from an HTML string.
 *
 * Calls setAreas() with parsed area elements.
 *
 * @param html {String}
 *        html string containing imagemap.
 * @param mapName {String}
 *        optional, value of name attribute.
 *        by default, the first imagemap in html is parsed.
 * @return
 */
var parseMap = function(html, mapName) {
  var parsed = [],
      selector = 'map',
      parseEl = document.createElement('div'),
      el, areas, i, len;

  // insert into element to parse.
  parseEl.innerHTML = html;
  // find imagemap
  if (mapName) {
    selector += '[name=\'' + mapName + '\']';
  }
  el = parseEl.querySelector(selector);
  if (el) {
    // find areas
    areas = el.querySelectorAll('area');
    for (i=0, len=areas.length; i<len; i++) {
      el = areas[i];
      parsed.push({
        'shape': el.getAttribute('shape'),
        'coords': el.getAttribute('coords').split(','),
        'title': el.getAttribute('title'),
        'href': el.getAttribute('href')
      });
    }
    areas = null;
  }
  parseEl = null;

  return parsed;
};

/**
 * Convert an area object to a svg path element string.
 *
 * @param area {Object}
 * @param area.shape {String}
 *        'circle', 'rect', and 'poly' are supported.
 * @param area.coords {Array<String>}
 *        an array of coordinates, meaning depends on shape
 * @param area.title {String}
 *        optional.  title for area, shown on mouseover.
 * @param area.href {String}
 *        optional.  link for area, activated on click.
 * @return {String} svg circle, rect, or path, markup as string.
 */
var getPath = function (area) {
  var buf = [],
      shape = area.shape,
      coords = area.coords,
      title = area.title,
      href = area.href;

  // href and title are optional, but work the same for every shape
  href = (href === null ? '' : ' xlink:href="' + href + '"');
  title = (title === null ? '' : '<title>' + title + '</title>');

  if (shape === 'circle') {
    // circle coords are x,y,radius
    buf.push(
        '<circle',
        ' cx="', coords[0], '"',
        ' cy="', coords[1], '"',
        ' r="', coords[2], '"',
        href,
        '>', title, '</circle>');
  } else if (shape === 'rect') {
    // rectangle coords are x1,y1,x2,y2
    buf.push(
        '<rect',
        ' x="', coords[0], '"',
        ' y="', coords[1], '"',
        ' width="', coords[2]-coords[0], '"',
        ' height="', coords[3]-coords[1], '"',
        href,
        '>', title, '</rect>');
  } else if (shape === 'poly') {
    // poly coords are x1,y1,x2,y2,...xN,yN
    // convert area coordinate list to svg path
    var points = [];
    for (var i=0, len=coords.length; i<len; i+=2) {
      // svg "M" is move to, "L" is line to
      points.push((i === 0 ? 'M' : 'L'), coords[i], ',', coords[i+1]);
    }
    // svg "Z" is close path
    points.push('Z');
    buf.push(
        '<path',
        ' d="', points.join(''), '"',
        href,
        '>', title, '</path>');
  }

  return buf.join('');
};



/**
 * Create a new SvgImageMap.
 *
 * @param options {Object}
 * @param options.imageUrl {String}
 *        url to image
 * @param options.imageAlt {String}
 *        alt attribute for image.
 * @param options.className {String}
 *        classname for wrapper element.
 *
 * Other parameters configure how to load the image map:
 *
 * - From an existing SVG File:
 *
 * @param options.svgUrl {String}
 *        optiona, url to svg imagemap.
 *
 * - Programatically, either at construction or via setAreas():
 *
 * @param options.areas {Array<Area>}
 *        areas for imagemap.
 *
 * - From an existing HTML imagemap:
 *
 * @param options.mapUrl {String}
 *        url to html with imagemap
 * @param options.mapName {String}
 *        optional, specify the imagemap name in case there are many.
 */
var SvgImageMap = function (options) {
  var _this,
      _initialize,

      _areas,
      _className,
      _el,
      _height,
      _imageAlt,
      _imageUrl,
      _mapName,
      _mapUrl,
      _svgUrl,
      _width,

      _parentDestroy,
      _setSvg;

  _this = Object.create(View(options));

  _initialize = function () {
    var image,
        imageOnLoad;
    // parse options
    options = Util.extend({}, DEFAULTS, options);
    _areas = options.areas || [];
    _className = options.className;
    _height = options.height;
    _imageAlt = options.imageAlt;
    _imageUrl = options.imageUrl;
    _mapName = options.mapName;
    _mapUrl = options.mapUrl;
    _svgUrl = options.svgUrl;
    _width = options.width;
    // container element classes
    _el = _this.el;
    _el.classList.add('svgimagemap');
    if (_className) {
      _el.classList.add(_className);
    }
    // load image
    imageOnLoad = function () {
      _this.setSize(image.naturalWidth, image.naturalHeight);
      image.removeEventListener('load', imageOnLoad);
      imageOnLoad = null;
    };
    image = new Image();
    image.addEventListener('load', imageOnLoad);
    image.setAttribute('alt', _imageAlt);
    image.src = _imageUrl;
    _el.appendChild(image);
    // load imagemap
    if (_svgUrl) {
      Xhr.ajax({
        url: _svgUrl,
        success: function (response/*, xhr*/) {
          _this.setSvg(response);
        }
      });
    } else if (_mapUrl) {
      Xhr.ajax({
        url: _mapUrl,
        success: function (response/*, xhr*/) {
          _this.setAreas(parseMap(response, _mapName));
        }
      });
    }
    // clear options
    options = null;
  };

  // save reference to parent destroy method
  _parentDestroy = _this.destroy;
  _this.destroy = function () {
    _areas = null;
    _className = null;
    _el = null;
    _height = null;
    _mapUrl = null;
    _mapName = null;
    _svgUrl = null;
    _width = null;

    if (typeof _parentDestroy === 'function') {
      _parentDestroy();
    }
  };

  /**
   * Access the areas array.
   */
  _this.getAreas = function () {
    return _areas;
  };

  /**
   * Set the image map areas.
   *
   * Calls render() after setting areas.
   *
   * @param areas {Array<Area>}
   */
  _this.setAreas = function (areas) {
    _areas = areas;
    // redraw svg
    _this.render();
  };

  /**
   * Set the image map size.
   *
   * Calls render() after setting size.
   *
   * @param width width of image.
   * @param height height of image.
   */
  _this.setSize = function (width, height) {
    // save for svg
    _width = width;
    _height = height;
    if (_el && width && height) {
      // set element size
      _el.setAttribute('width', width);
      _el.setAttribute('height', height);
    }
    // redraw svg
    _this.render();
  };

  /**
   * Update the rendered imagemap based on width, height, and areas.
   */
  _this.render = function () {
    var buf,
        i,
        len;

    if (!_width || !_height || !_areas || _areas.length === 0) {
      return;
    }

    // build svg
    buf = [];
    // open svg element
    buf.push('<svg',
        ' xmlns="http://www.w3.org/2000/svg"',
        ' xmlns:xlink="http://www.w3.org/1999/xlink"',
        ' width="', _width, '"',
        ' height="', _height, '"',
        ' viewBox="0,0,', _width, ',', _height, '"',
        ' preserveAspectRatio="xMinYMin"',
        '>');
    // add imagemap areas
    len = _areas.length;
    for (i = 0; i < len; i++) {
      buf.push(getPath(_areas[i]));
    }
    // close svg element
    buf.push('</svg>');
    _setSvg(buf.join(''));
  };

  /**
   * Remove any existing svg element, and insert an svg element.
   *
   * @param svg {String|Element}
   *        the svg to insert.
   *        if a String, converted to an Element before insertion.
   */
  _setSvg = function (svg) {
    var oldSvg,
        parseEl;

    if (_el) {
      // remove any existing svg
      oldSvg = _el.querySelector('svg');
      if (oldSvg) {
        _el.removeChild(oldSvg);
      }
      // convert svg string to svg element
      if (typeof svg === 'string') {
        parseEl = document.createElement('div');
        parseEl.innerHTML = svg;
        svg = parseEl.children[0];
        parseEl = null;
      }
      // insert svg
      if (svg) {
        _el.appendChild(svg);
      }
    }
  };


  _initialize();
  return _this;
};


SvgImageMap.getPath = getPath;
SvgImageMap.parseMap = parseMap;


module.exports = SvgImageMap;

},{"mvc/View":"mvc/View","util/Util":"util/Util","util/Xhr":"util/Xhr"}],"tablist/TabList":[function(require,module,exports){
'use strict';

// sequence for assigning unique element ids, for aria roles
var ID_SEQUENCE = 0;


/**
 * Format tab (summary) content for a list item.
 *
 * @param obj {Object}
 *        object being added to the list.
 * @return {String|DOMElement}
 *         This implementation returns obj.title.
 */
var __getTabContent = function(obj) {
  return obj.title;
};


/**
 * Format panel (detail) content for a list item.
 *
 * @param obj {Object}
 *        object being added to the list.
 * @return {String|DOMElement}
 *         If obj.content is a function, its return value is returned.
 *         Otherwise, this implementation returns obj.content.
 */
var __getPanelContent = function(obj) {
  if (typeof obj.content === 'function') {
    return obj.content(obj);
  } else {
    return obj.content;
  }
};


/**
 * Construct a new ItemList.
 *
 * Sub-classes may override the methods __getTabContent() and
 * getPanelContent() to change list formatting.
 *
 * @param options {Object}
 * @param options.el {DOMElement}
 *        Optional, default is new section element.
 * @param options.header {String}
 *        Optional, markup placed in header for tab list.
 * @param options.tabs {Array<Object>}
 *        Optional, any items are passed to addItem().
 */
var TabList = function (options) {

  var _this,
      _initialize,

      _backward,
      _container,
      _endPosition,
      _header,
      _forward,
      _nav,
      _navPosition,
      _positionChange,
      _selected,
      _startPosition,
      _dontSelect,
      _tabs,

      _centerSelectedTab,
      _checkValueBeforeScrolling,
      _ensureSelected,
      _onDragEnd,
      _onDragScroll,
      _onDragStart,
      _onKeyPress,
      _selectTab,
      _setTranslate,
      _showTabPosition,
      _updateTabIndex;

  _this = Object.create({});


  _initialize = function () {
    _this.el = options.el || document.createElement('section');
    _this.el.classList.add('tablist');

    // add header
    if (options.header) {
      _header = _this.el.appendChild(document.createElement('header'));
      _header.innerHTML = options.header;
    }

    // create tab container
    _container = document.createElement('div');
    _container.className = 'tablist-container';

    // create tab list
    _nav = document.createElement('nav');
    _nav.setAttribute('role', 'tablist');
    _nav.classList.add('smooth');
    _navPosition = 0;
    _positionChange = 0;

    // add tab back/next buttons
    _backward = document.createElement('div');
    _backward.className = 'tablist-backward-button';
    _backward.innerHTML = '<div class="material-icons">chevron_left</div>';

    _forward = document.createElement('div');
    _forward.className = 'tablist-forward-button';
    _forward.innerHTML = '<div class="material-icons">chevron_right</div>';

    _container.appendChild(_nav);
    _this.el.appendChild(_backward);
    _this.el.appendChild(_container);
    _this.el.appendChild(_forward);

    // mouse (desktop) interactions
    _backward.addEventListener('click', _this.selectPreviousTab);
    _forward.addEventListener('click', _this.selectNextTab);
    _nav.addEventListener('mousedown', _onDragStart);

    // touch (mobile) interactions
    _nav.addEventListener('touchstart', _onDragStart);

    // keyboard interactions
    _nav.addEventListener('keydown', _onKeyPress);
    _nav.addEventListener('keyup', _onKeyPress);

    // array of tab objects
    _tabs = [];

    // add any items provided when constructing
    if (options.tabs) {
      for (var i=0, len=options.tabs.length; i<len; i++) {
        _this.addTab(options.tabs[i], true);
      }
      _ensureSelected();
    }
  };


  /**
   * Called on "keypress", handles changing the selected tab from the
   * tablist-tab navigation when a enter is clicked on a tab with focus,
   * or the left/right directional pad is clicked.
   *
   * @param  {object} e,
   *         "keypress" event
   */
  _onKeyPress = function (e) {
    var keyCode = e.keyCode;


    if (e.type === 'keydown') {
      // prevent scrolling the window
      if (keyCode === 38 || keyCode === 40) {
        e.preventDefault();
      }
      return;
    }

    if (keyCode === 37 || keyCode === 38) {
      // d-pad left/up key
      _this.selectPreviousTab();
    } else if (keyCode === 39 || keyCode === 40) {
      // d-pad right/down key
      _this.selectNextTab();
    }
  };


  /**
   * Called on "touchstart" or "mousedown", tracks the drag start position
   * and adds event listeners for mouse events or touch events that update
   * the position of the tablist-tab navigation.
   *
   * @param  {object} e,
   *         "mousedown" event OR "touchstart" event
   */
  _onDragStart = function (e) {
    // do not animate a click/touch drag event
    _nav.classList.remove('smooth');

    if (e.type === 'mousedown') {
      _startPosition = e.clientX;
      document.addEventListener('mousemove', _onDragScroll);
      document.addEventListener('mouseup', _onDragEnd);
    } else if (e.type === 'touchstart') {
      // keeps mouse event from being delivered on touch events
      e.preventDefault();
      _startPosition = e.touches[0].clientX;
      document.addEventListener('touchmove', _onDragScroll);
      document.addEventListener('touchend', _onDragEnd);
      document.addEventListener('touchcancel', _onDragEnd);
    }
  };


  /**
   * Called on "touchend" or "mouseup", removes event listeners
   * for mouse events or touch events that update the position
   * of the tablist-tab navigation.
   *
   * @param  {object} e,
   *         "mouseup" event OR "touchend" event
   */
  _onDragEnd = function (e) {

    if (e.type === 'mouseup') {
      document.removeEventListener('mousemove', _onDragScroll);
      document.removeEventListener('mouseup', _onDragEnd);
    } else if (e.type === 'touchend' || e.type === 'touchcancel') {
      document.removeEventListener('touchmove', _onDragScroll);
      document.removeEventListener('touchend', _onDragEnd);
      document.removeEventListener('touchcancel', _onDragEnd);
    }

    _checkValueBeforeScrolling(_navPosition + _positionChange);

    _positionChange = 0;

    // add back the class that animates nav sliding
    _nav.classList.add('smooth');
  };


  /**
   * center the selected tab on the navigation slidfr.
   */
  _centerSelectedTab = function () {
    var tab = _selected.tabEl,
        position;

    // slide all the way to left edge
    position = (tab.offsetLeft * -1);
    // push tab (left-edge of tab) to the middle
    position = position + (_nav.clientWidth / 2);
    // center the tab, by adjusting half of the width right
    position = position - (tab.clientWidth / 2);
    // don't leave half of a px
    position = Math.round(position);

    _checkValueBeforeScrolling(position);
  };


  /**
   * Checks the translate value before it is applied to ensure that
   * tab slider is not scrolled more than it needs to be to make
   * the selected tab visible.
   */
  _checkValueBeforeScrolling = function (value) {
    var maxScroll = 0,
        minScroll = _nav.clientWidth - _nav.scrollWidth;

    // sanitize value
    if (value < minScroll) {
      value = minScroll;
    } else if (value > maxScroll) {
      value = maxScroll;
    }

    // scroll nav slider
    _setTranslate(value);

    // update tracking of navPosition
    _navPosition = value;
  };


  /**
   * Called on "mousemove", updates the scrollLeft position
   * on the nav slider that contains the tab elements.
   *
   * @param  {object} e,
   *         "mousemove" event
   */
  _onDragScroll = function (e) {
    var position,
        positionChange,
        type;

    type = e.type;

    if (type === 'mousemove') {
      position = e.clientX;
    } else if (type === 'touchmove') {
      position = e.touches[0].clientX;
    }

    positionChange = position - _startPosition;
    _positionChange = positionChange;
    _setTranslate(_navPosition + positionChange);

    if (Math.abs(positionChange) >= 5) {
     _dontSelect = true;
    }
  };


  /**
   * Update the position of the nav slider.
   *
   * @param {Number} position,
   *        the x-position of the slider
   */
  _setTranslate = function (position) {

    _nav.style['-webkit-transform'] =
        'translate3d(' + position + 'px, 0px, 0px)';
    _nav.style['-moz-transform'] =
        'translate3d(' + position + 'px, 0px, 0px)';
    _nav.style['-ms-transform'] =
        'translate3d(' + position + 'px, 0px, 0px)';
    _nav.style['-o-transform'] =
        'translate3d(' + position + 'px, 0px, 0px)';
    _nav.style.transform = 'translate3d(' + position + 'px, 0px, 0px)';
  };

  /**
   * Adds/ Updates the span that indicates the current tab position,
   * automatically fades the tab position using the 'fade' class.
   */
  _showTabPosition = function () {
    var span = _this.el.querySelector('.tab-position-indicator'),
        currentTabNumber = _tabs.indexOf(_selected) + 1,
        totalTabNumber = _tabs.length;

    if (!span) {
      // create new span
      span = document.createElement('span');
      _this.el.appendChild(span);
    }

    // update text
    span.className = 'tab-position-indicator';
    span.innerHTML = currentTabNumber + ' of ' + totalTabNumber;

    window.setTimeout(function () {
      span.classList.add('fade');
    }, 500);
  };


  /**
   * Change tabindex to -1 on all tabs. Change tabindex on
   * selected tab to 0.
   */
  _updateTabIndex = function () {
    var tab;

    for (var i = 0; i < _tabs.length; i++) {
      tab = _tabs[i].tabEl;
      if (tab.getAttribute('tabindex') !== -1) {
        tab.setAttribute('tabindex', -1);
        tab.setAttribute('aria-hidden', true);
      }
    }

    _selected.tabEl.setAttribute('tabindex', 0);
    _selected.tabEl.setAttribute('aria-hidden', false);
  };


  /**
   * Select a tab in this list.
   *
   * @param  toSelect {Object}
   *         the tab to select, as returned by addTab().
   */
  _selectTab = function (toSelect) {
    var previouslySelected = _selected;

    for (var i=0, len=_tabs.length; i<len; i++) {
      var tab = _tabs[i],
          options = tab.options,
          tabEl = tab.tabEl,
          panelEl = tab.panelEl;
      if (tab === toSelect) {
        // load tab content, if needed...
        if (!tab.contentReady) {
          var panelContent = __getPanelContent(options);
          if (typeof panelContent === 'string') {
            tab.panelEl.innerHTML = panelContent;
          } else {
            tab.panelEl.appendChild(panelContent);
          }
          tab.contentReady = true;
        }
        // update state classes
        tabEl.classList.add('tablist-tab-selected');
        panelEl.classList.add('tablist-panel-selected');
        // notify tab it is visible, if needed...
        if (typeof options.onSelect === 'function') {
          options.onSelect();
        }
        // update selected tab
        _selected = tab;
        _updateTabIndex();
        _centerSelectedTab();
        tab.tabEl.focus();
        _showTabPosition();
      } else {
        tabEl.classList.remove('tablist-tab-selected');
        panelEl.classList.remove('tablist-panel-selected');
        // notify tab it is hidden, if needed...
        if (tab === previouslySelected &&
            typeof options.onDeselect === 'function') {
          options.onDeselect();
        }
      }
    }
  };


  _ensureSelected = function () {
    var selectedPanel = _this.el.querySelector('.tablist-panel-selected'),
        tabs;
    if (selectedPanel === null) {
      tabs = _tabs;
      if (tabs.length > 0) {
        // select first tab by default
        tabs[0].select();
      }
    }
  };


  /**
   * Add an item to this list.
   *
   * @param options {Object}
   *        item being added to list.
   * @param options.onSelect {Function}
   *        Optional.
   *        Called when tab is selected.
   * @see __getTabContent(), __getPanelContent()
   *      these methods format content shown in tabs and panels,
   *      and use the following parameters by default.
   * @param options.title {String|DOMElement}
   *        Used by __getTabContent() to generate tab content.
   * @param options.content {String|DOMElement|Function}
   *        Used by __getPanelContent() to generate panel content.
   * @return object with select() method that can be used to show the tab.
   */
  _this.addTab = function (options, dontEnsureSelected) {
    // assign unique ids to this items elements
    var id = ++ID_SEQUENCE;
    var tabId = 'tablist-tab-' + id;
    var panelId = 'tablist-panel-' + id;

    // summary element
    var tabEl = document.createElement('section');
    tabEl.id = tabId;
    tabEl.className = 'tablist-tab';
    tabEl.setAttribute('role', 'tab');
    tabEl.setAttribute('tabindex', -1);
    tabEl.setAttribute('aria-controls', panelId);
    var tabContent = __getTabContent(options);
    if (typeof tabContent === 'string') {
      tabEl.innerHTML = tabContent;
    } else {
      tabEl.appendChild(tabContent);
    }

    // detail element
    var panelEl = document.createElement('section');
    panelEl.id = panelId;
    panelEl.className = 'tablist-panel';
    panelEl.setAttribute('role', 'tabpanel');
    panelEl.setAttribute('aria-labelledby', tabId);
    // content added by _selectTab()

    // save reference to tab and elements
    var tab = {
      options: options,
      tabEl: tabEl,
      panelEl: panelEl,
      select: function () {
        if (_dontSelect === true) {
          _dontSelect = false;
        } else {
          _selectTab(tab);
        }
        return false;
      },
      touchend: function () {
        _nav.classList.add('smooth');
        tab.select();
        return false;
      },
      contentReady: false
    };

    _tabs.push(tab);

    // click handler for tab
    tabEl.addEventListener('click', tab.select);
    tabEl.addEventListener('touchend', tab.touchend);

    // select the first, or specified item
    if (options.selected === true) {
      tab.select();
    } else if (dontEnsureSelected !== true) {
      _ensureSelected();
    }

    // add elements to dom
    _nav.appendChild(tabEl);
    _this.el.appendChild(panelEl);

    // return reference to tab for selecting
    return tab;
  };

  _this.destroy = function () {
    var tab;

    // event bindings
    _nav.removeEventListener('mousedown', _onDragStart);
    _nav.removeEventListener('touchstart', _onDragStart);
    _nav.removeEventListener('keyup', _onKeyPress);
    _backward.removeEventListener('click', _this.selectPreviousTab);
    _forward.removeEventListener('click', _this.selectNextTab);

    // remove tabEl bindings
    if (_tabs) {
      for (var i = 0; i < _tabs.length; i++) {
        tab = _tabs[i];

        // if tab has onDestroy method, call onDestroy()
        if (typeof tab.options.onDestroy === 'function') {
          tab.options.onDestroy();
        }

        // remove click/tap event bindings
        tab.tabEl.removeEventListener('click', tab.select);
        tab.tabEl.removeEventListener('touchend', tab.touchend);
      }
    }

    // methods bound to 'this'
    _onDragScroll = null;
    _onDragStart = null;
    _onDragEnd = null;
    _onKeyPress = null;

    // DOM elements
    _this.el = null;
    _header = null;
    _container = null;
    _nav = null;
    _forward = null;
    _backward = null;

    // Position variables
    _navPosition = null;
    _positionChange = null;
    _startPosition = null;
    _endPosition = null;

    // tab objects
    _selected = null;
    _tabs = null;
  };

  /*
   * Called on 'backward' button click, and also called on
   * 'up'/'left' d-pad keyboard click. Selects the appropropriate tab
   * in the list. This includes wrapping from the last tab in the list
   * to the first.
   */
  _this.selectNextTab = function () {
    var increment = 1,
        currentIndex = _tabs.indexOf(_selected) + increment,
        maxTabIndex = _tabs.length - 1,
        minTabIndex = 0;

    // if at the end of the tablist, jump to start
    if (currentIndex > maxTabIndex) {
      currentIndex = minTabIndex;
    }

    _tabs[currentIndex].select();
  };

  /**
   * Called on 'forward' button click, and also called on
   * 'down'/'right' d-pad keyboard click. Selects the appropropriate tab
   * in the list. This includes wrapping from the first tab in the list
   * to the last.
   */
  _this.selectPreviousTab = function () {
    var increment = -1,
        currentIndex = _tabs.indexOf(_selected) + increment,
        maxTabIndex = _tabs.length - 1,
        minTabIndex = 0;

    // if at the start of the tablist, jump to end
    if (currentIndex < minTabIndex) {
      currentIndex = maxTabIndex;
      // bug with translate position, remove class that animates
      _nav.classList.remove('smooth');
      _tabs[currentIndex].select();
      _nav.classList.add('smooth');
    } else {
      _tabs[currentIndex].select();
    }
  };


  _initialize();
  return _this;
};


var tabbifyOne = function (el) {
  var tabs = [],
      panels,
      panel,
      i, len,
      tablist;

  panels = el.querySelectorAll('.panel');
  for (i = 0, len = panels.length; i < len; i++) {
    panel = panels[i];
    tabs.push({
      'title': panel.getAttribute('data-title') ||
          panel.querySelector('header').innerHTML,
      'content': panel,
      'selected': panel.getAttribute('data-selected') === 'true'
    });
  }

  tablist = TabList({
    'tabs': tabs
  });

  el.parentNode.replaceChild(tablist.el, el);
};

var tabbifyAll = function () {
  var lists,
      i;
  lists = document.querySelectorAll('.tablist');
  for (i = lists.length - 1; i >= 0; i--) {
    TabList.tabbifyOne(lists[i]);
  }
};


// Expose public methods
TabList.tabbifyAll = tabbifyAll;
TabList.tabbifyOne = tabbifyOne;

module.exports = TabList;

},{}],"util/Events":[function(require,module,exports){
'use strict';

var __INSTANCE__ = null;


var __is_string = function (obj) {
  return (typeof obj === 'string' || obj instanceof String);
};


var Events = function () {
  var _this,
      _initialize,

      _listeners;


  _this = {};

  _initialize = function () {
    // map of listeners by event type
    _listeners = {};
  };


  /**
   * Free all references.
   */
  _this.destroy = function () {
    _initialize = null;
    _listeners = null;
    _this = null;
  };

  /**
   * Remove an event listener
   *
   * Omitting callback clears all listeners for given event.
   * Omitting event clears all listeners for all events.
   *
   * @param event {String}
   *      event name to unbind.
   * @param callback {Function}
   *      callback to unbind.
   * @param context {Object}
   *      context for "this" when callback is called
   */
  _this.off = function (evt, callback, context) {
    var i;

    if (typeof evt === 'undefined') {
      // removing all listeners on this object
      _listeners = null;
      _listeners = {};
    } else if (!_listeners.hasOwnProperty(evt)) {
      // no listeners, nothing to do
      return;
    } else if (typeof callback === 'undefined') {
      // removing all listeners for this event
      delete _listeners[evt];
    } else {
      var listener = null;

      // search for callback to remove
      for (i = _listeners[evt].length - 1; i >= 0; i--) {
        listener = _listeners[evt][i];

        if (listener.callback === callback &&
            (!context || listener.context === context)) {

          // found callback, remove
          _listeners[evt].splice(i,1);

          if (context) {
            // found callback with context, stop searching
            break;
          }
        }
      }

      // cleanup if last callback of this type
      if (_listeners[evt].length === 0) {
        delete _listeners[evt];
      }

      listener = null;
    }
  };

  /**
   * Add an event listener
   *
   * @param event {String}
   *      event name (singular).  E.g. 'reset'
   * @param callback {Function}
   *      function to call when event is triggered.
   * @param context {Object}
   *      context for "this" when callback is called
   */
  _this.on = function (event, callback, context) {
    if (!((callback || !callback.apply) ||
        (context && __is_string(callback) && context[callback].apply))) {
      throw new Error('Callback parameter is not callable.');
    }

    if (!_listeners.hasOwnProperty(event)) {
      // first listener for event type
      _listeners[event] = [];
    }

    // add listener
    _listeners[event].push({
      callback: callback,
      context: context
    });
  };

  /**
   * Trigger an event
   *
   * @param event {String}
   *      event name.
   * @param args {…}
   *      variable length arguments after event are passed to listeners.
   */
  _this.trigger = function (event) {
    var args,
        i,
        len,
        listener,
        listeners;

    if (_listeners.hasOwnProperty(event)) {

      args = Array.prototype.slice.call(arguments, 1);
      listeners = _listeners[event].slice(0);

      for (i = 0, len = listeners.length; i < len; i++) {
        listener = listeners[i];

        // NOTE: if listener throws exception, this will stop...
        if (__is_string(listener.callback)) {
          listener.context[listener.callback].apply(listener.context, args);
        } else {
          listener.callback.apply(listener.context, args);
        }
      }
    }
  };

  _initialize();
  return _this;
};

// make Events a global event source
__INSTANCE__ = Events();
Events.on = function _events_on () {
  return __INSTANCE__.on.apply(__INSTANCE__, arguments);
};
Events.off = function _events_off () {
  return __INSTANCE__.off.apply(__INSTANCE__, arguments);
};
Events.trigger = function _events_trigger () {
  return __INSTANCE__.trigger.apply(__INSTANCE__, arguments);
};

// intercept window.onhashchange events, or simulate if browser doesn't
// support, and send to global Events object
var _onHashChange = function (e) {
  Events.trigger('hashchange', e);
};

// courtesy of:
// http://stackoverflow.com/questions/9339865/get-the-hashchange-event-to-work-in-all-browsers-including-ie7
if (!('onhashchange' in window)) {
  var oldHref = document.location.hash;

  setInterval(function () {
    if (oldHref !== document.location.hash) {
      oldHref = document.location.hash;
      _onHashChange({
        'type': 'hashchange',
        'newURL': document.location.hash,
        'oldURL': oldHref
      });
    }
  }, 300);

} else if (window.addEventListener) {
  window.addEventListener('hashchange', _onHashChange, false);
}

module.exports = Events;

},{}],"util/Util":[function(require,module,exports){
'use strict';

// do these checks once, instead of once per call
var isMobile = false,
    supportsDateInput = false;


// static object with utility methods
var Util = function () {
};


Util.isMobile = function () {
  return isMobile;
};

Util.supportsDateInput = function () {
  return supportsDateInput;
};

/**
 * Merge properties from a series of objects.
 *
 * @param dst {Object}
 *      target where merged properties are copied to.
 * @param <variable> {Object}
 *      source objects for properties. When a source is non null, it's
 *      properties are copied to the dst object. Properties are copied in
 *      the order of arguments: a property on a later argument overrides a
 *      property on an earlier argument.
 */
Util.extend = function (dst) {
  var i, len, src, prop;

  // iterate over sources where properties are read
  for (i = 1, len = arguments.length; i < len; i++) {
    src = arguments[i];
    if (src) {
      for (prop in src) {
        dst[prop] = src[prop];
      }
    }
  }

  // return updated object
  return dst;
};

/**
 * Checks if objects are equal.
 *
 * @param a {Object}
 *      Object a.
 * @param b {Object}
 *      Object b.
 */
Util.equals = function (objA, objB) {
  var keya, keyb;

  if (objA === objB) {
    // if === then ===, no question about that...
    return true;
  } else if (objA === null || objB === null) {
    // funny, typeof null === 'object', so ... hmph!
    return false;
  } else if (typeof objA === 'object' && typeof objB === 'object') {
    // recursively check objects
    for (keya in objA) {
      if (objA.hasOwnProperty(keya)) {
        if (!objB.hasOwnProperty(keya)) {
          return false; // objB is missing a key from objA
        }
      }
    }

    for (keyb in objB) {
      if (objB.hasOwnProperty(keyb)) {
        if (!objA.hasOwnProperty(keyb)) {
          return false; // objA is missing a key from objB
        } else if (!Util.equals(objA[keyb], objB[keyb])) {
          return false; // objA[key] !== objB[key]
        }
      }
    }

    return true; // Recursively equal, so equal
  } else {
    return objA === objB; // Use baked in === for primitives
  }
};

/**
 * Get an event object for an event handler.
 *
 * @param e the event that was received by the event handler.
 * @return {Object}
 *      with two properties:
 *      target
 *           the element where the event occurred.
 *      originalEvent
 *           the event object, either parameter e or window.event (in IE).
 */
Util.getEvent = function (e) {
  var targ;

  if (!e) {
    // ie puts event in global
    e = window.event;
  }

  // find target
  if (e.target) {
    targ = e.target;
  } else if (e.srcElement) {
    targ = e.srcElement;
  }

  // handle safari bug
  if (targ.nodeType === 3) {
    targ = targ.parentNode;
  }

  // return target and event
  return {
    target: targ,
    originalEvent: e
  };
};

/**
 * Get a parent node based on it's node name.
 *
 * @param el {DOMElement}
 *      element to search from.
 * @param nodeName {String}
 *      node name to search for.
 * @param maxParent {DOMElement}
 *      element to stop searching.
 * @return {DOMElement}
 *      matching element, or null if not found.
 */
Util.getParentNode = function (el, nodeName, maxParent) {
  var curParent = el;

  while (curParent && curParent !== maxParent &&
      curParent.nodeName.toUpperCase() !== nodeName.toUpperCase()) {
    curParent = curParent.parentNode;
  }
  if (curParent && 'nodeName' in curParent &&
      curParent.nodeName.toUpperCase() === nodeName.toUpperCase()) {
    // found the desired node
    return curParent;
  }

  // didn't find the desired node
  return null;
};

// remove an elements child nodes
Util.empty = function (el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
};

// detach an element from its parent
Util.detach = function (el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
};

Util.getWindowSize = function () {
  var dimensions = {width:null,height:null};

  if ('innerWidth' in window && 'innerHeight' in window) {
    dimensions = {
      width: window.innerWidth,
      height: window.innerHeight
    };
  } else {
    // probably IE<=8
    var elem = 'documentElement' in document ?
        document.documentElement : document.body;

    dimensions = {
      width: elem.offsetWidth,
      height: elem.offsetHeight
    };
  }

  return dimensions;
};

/**
 * Creates a function that is a composition of other functions.
 *
 * For example:
 *      a(b(c(x))) === compose(c, b, a)(x);
 *
 * Each function should accept as an argument, the result of the previous
 * function call in the chain. It is allowable for all functions to have no
 * return value as well.
 *
 * @param ... {Function} A variable set of functions to call, in order.
 *
 * @return {Function} The composition of the functions provided as arguments.
 */
Util.compose = function () {
  var fns = arguments;

  return function (result) {
    var i,
        fn,
        len;

    for (i = 0, len = fns.length; i < len; i++) {
      fn = fns[i];

      if (fn && fn.call) {
        result = fn.call(this, result);
      }
    }

    return result;
  };
};

/**
 * Checks the elements of a looking for b. b is assumed to be found if for
 * some object in a (a[i]), a[i] === b. Note strict equality.
 *
 * @param a {Array}
 *      An array to search
 * @param b {Mixed}
 *      A value to search for
 *
 * @return
 *      true if array a contains b
 */
Util.contains = function (a, b) {
  var i, len;

  for (i = 0, len = a.length; i < len; i++) {
    if (b === a[i]) {
      return true;
    }
  }

  return false;
};

/**
 * @return
 *      true if object is an array
 */
Util.isArray = function (a) {

  if (typeof Array.isArray === 'function') {
    return Array.isArray(a);
  } else {
    return Object.prototype.toString.call(a) === '[object Array]';
  }

};


/**
 * Load a script asynchronously.
 *
 * @param url {String}
 *        script to load.
 * @param options {Object}
 *        additional options.
 * @param options.success {Function} optional.
 *        called after script loads successfully.
 * @param options.error {Function} optional.
 *        called after script fails to load.
 * @param options.done {Function} optional
 *        called after loadScript is complete,
 *        after calling success or error.
 */
Util.loadScript = function (url, options) {
  // load secondary script
  var cleanup,
      done,
      onError,
      onLoad,
      script;

  options = Util.extend({}, {
    success: null,
    error: null,
    done: null
  }, options);

  cleanup = function () {
    script.removeEventListener('load', onLoad);
    script.removeEventListener('error', onError);
    script.parentNode.removeChild(script);
    cleanup = null;
    onLoad = null;
    onError = null;
    script = null;
  };

  done = function () {
    if (options.done !== null) {
      options.done();
    }
    options = null;
  };

  onError = function () {
    cleanup();
    if (options.error !== null) {
      options.error.apply(null, arguments);
    }
    done();
  };

  onLoad = function () {
    cleanup();
    if (options.success !== null) {
      options.success.apply(null, arguments);
    }
    done();
  };

  script = document.createElement('script');
  script.addEventListener('load', onLoad);
  script.addEventListener('error', onError);
  script.src = url;
  script.async = true;
  document.querySelector('script').parentNode.appendChild(script);
};


// Do these checks once and cache the results
(function() {
  var testEl = document.createElement('div');
  var testInput = document.createElement('input');
  var str = navigator.userAgent||navigator.vendor||window.opera;

  isMobile = str.match(/(Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone)/i);
  testInput.setAttribute('type', 'date');
  supportsDateInput = (testInput.type !== 'text');

  // clean up testing element
  testEl = null;
})();

module.exports = Util;
},{}],"util/Xhr":[function(require,module,exports){
'use strict';


var Util = require('./Util');


var _CALLBACK_SEQUENCE = 0;

// defaults for jsonp method
var _DEFAULT_JSONP_OPTIONS = {
  url: null,
  success: null,
  error: null,
  done: null,
  data: null,
  callbackName: null,
  callbackParameter: 'callback'
};

// defaults for ajax method
var _DEFAULT_AJAX_OPTIONS = {
  url: null,
  success: null,
  error: null,
  done: null,
  method: 'GET',
  headers: null,
  data: null,
  rawdata: null
};

// API Method Declarations

var ajax,
    getCallbackName,
    jsonp,
    restrictOrigin,
    urlEncode;


// API Method Definitions

/**
 * Make an AJAX request.
 *
 * @param options.url {String}
 *      the url to request.
 * @param options.success {Function}
 *      called with data loaded by script
 * @param options.error {Function} optional
 *      called when script fails to load
 * @param options.done {Function}
 *        called when ajax is complete, after success or error.
 * @param options.method {String}
 *      request method, default is 'GET'
 * @param options.headers {Object}
 *      request header name as key, value as value.
 * @param options.data {Object}
 *      request data, sent using content type
 *      'application/x-www-form-urlencoded'.
 * @param options.rawdata {?}
 *      passed directly to send method, when options.data is null.
 *      Content-type header must also be specified. Default is null.
 */
ajax = function (options) {
  var h,
      postdata,
      queryString,
      url,
      xhr;

  options = Util.extend({}, _DEFAULT_AJAX_OPTIONS, options);
  url = options.url;

  if (options.restrictOrigin) {
    url = restrictOrigin(url);
  }
  postdata = options.rawdata;

  if (options.data !== null) {
    queryString = urlEncode(options.data);
    if (options.method === 'GET') {
      // append to url
      url = url + '?' + queryString;
    } else {
      // otherwise send as request body
      postdata = queryString;
      if (options.headers === null) {
        options.headers = {};
      }
      // set request content type
      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
    }
  }

  xhr = new XMLHttpRequest();

  // setup callback
  xhr.onreadystatechange = function () {
    var data, contentType;

    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        if (options.success !== null) {
          try {
            data = xhr.response;
            contentType = xhr.getResponseHeader('Content-Type');
            if (contentType && contentType.indexOf('json') !== -1) {
              data = JSON.parse(data);
            }
            options.success(data, xhr);
          } catch (e) {
            if (options.error !== null) {
              options.error(e, xhr);
            }
          }
        }
      } else {
        if (options.error) {
          options.error(xhr.status, xhr);
        }
      }
      if (options.done !== null) {
        options.done(xhr);
      }
    }
  };

  // open request
  xhr.open(options.method, url, true);

  // send headers
  if (options.headers !== null) {
    for (h in options.headers) {
      xhr.setRequestHeader(h, options.headers[h]);
    }
  }

  // send data
  xhr.send(postdata);

  return xhr;
};

/**
 * Generate a unique callback name.
 *
 * @return a unique callback name.
 */
getCallbackName = function () {
  return '_xhr_callback_' + new Date().getTime() +
      '_' + (++_CALLBACK_SEQUENCE);
};

/**
 * Make a JSONP request.
 *
 * @param options.url {String}
 *      url to load
 * @param options.success {Function}
 *      called with data loaded by script
 * @param options.error {Function} optional
 *      called when script fails to load
 * @param options.done {Function} optional
 *        called when jsonp is complete, after success or error.
 * @param options.data {Object} optional
 *      request parameters to add to url
 *
 * @param options.callbackName {String} optional
 * @param options.callbackParameter {String} optional
 *      default is 'callback'
 */
jsonp = function (options) {
  var data,
      callback,
      url;

  options = Util.extend({}, _DEFAULT_JSONP_OPTIONS, options);
  url = options.url;
  data = Util.extend({}, options.data);
  callback = options.callbackName || getCallbackName();

  // add data and callback to url
  data[options.callbackParameter] = callback;
  url += (url.indexOf('?') === -1 ? '?' : '&') + urlEncode(data);

  // setup global callback called by script
  window[callback] = function () {
    options.success.apply(null, arguments);
  };

  Util.loadScript(url, {
    error: options.error,
    done: function () {
      window[callback] = null;
      delete window[callback];

      if (options.done !== null) {
        options.done();
      }
    }
  });
};

restrictOrigin = function (url) {
  var a,
      restrictedUrl;

  a = document.createElement('a'); // Hack to parse only the pathname
  a.setAttribute('href', url);
  restrictedUrl = a.pathname;

  // Needed for IE, which omits leading slash.
  if ((url.indexOf('http') === 0 || url.indexOf('/') === 0) &&
      restrictedUrl.indexOf('/') !== 0) {
    restrictedUrl = '/' + restrictedUrl;
  }

  return restrictedUrl;
};

/**
 * URL encode an object.
 *
 * @param obj {Object}
 *      object to encode
 *
 * @return {String}
 *      url encoded object
 */
urlEncode = function (obj) {
  var data, key, encodedKey, value, i, len;

  data = [];
  for (key in obj) {
    encodedKey = encodeURIComponent(key);
    value = obj[key];

    if (value instanceof Array) {
      // Add each value in array seperately
      for (i = 0, len = value.length; i < len; i++) {
        data.push(encodedKey + '=' + encodeURIComponent(value[i]));
      }
    } else {
      data.push(encodedKey + '=' + encodeURIComponent(value));
    }
  }
  return data.join('&');
};


// expose the API
module.exports = {
  ajax: ajax,
  getCallbackName: getCallbackName,
  jsonp: jsonp,
  restrictOrigin: restrictOrigin,
  urlEncode: urlEncode,
};
},{"./Util":"util/Util"}],"waveform/WaveformModule":[function(require,module,exports){
'use strict';

var Module = require('core/Module'),
    ScientificSummaryModule = require('scientific/ScientificSummaryModule'),
    Util = require('util/Util'),
    Xhr = require('util/Xhr');

var _DEFAULTS,
    _ID,
    _TITLE,

    _hasContent;


_DEFAULTS = {
  irisServiceUrl: 'https://service.iris.edu/fdsnws/event/1/query',
  irisSpudUrl:'https://www.iris.edu/spud/event/',
  irisWilberUrl:'https://www.iris.edu/wilber3/find_stations/',
  errorMessage: '<p class="alert error">Error finding waveform data</p>'
};
_ID = 'waveform';
_TITLE = 'Waveforms';


_hasContent = function (eventPageModel) {
  var config;

  config = eventPageModel.get('config');
  return config.hasOwnProperty('SCENARIO_MODE') ?
      !config.SCENARIO_MODE : true;
};


/**
 * Waveform module
 *
 * @param options {object}
 *    url options
 */
var WaveformModule = function (options) {
  var _this,
      _initialize,

      _errorMessage,
      _eventId,
      _irisServiceUrl,
      _irisSpudUrl,
      _irisWilberUrl,
      _waveformContentEl;

  options = Util.extend({}, _DEFAULTS, options);
  _this = Module(options);

  _initialize = function () {
    _this.ID = _ID;
    _this.TITLE = _TITLE;

    _errorMessage = options.errorMessage;
    _irisServiceUrl = options.irisServiceUrl;
    _irisSpudUrl = options.irisSpudUrl;
    _irisWilberUrl = options.irisWilberUrl;

    _this.el.classList.add('wave-form');
  };

  _this.destroy = Util.compose(function () {
    _initialize = null;
    _this = null;

    _waveformContentEl = null;
    _irisWilberUrl= null;
    _irisSpudUrl = null;
    _irisServiceUrl = null;
    _eventId = null;
    _errorMessage = null;
  }, _this.destroy);

  /**
   * Gets the data.
   * @param search {object}
   *    Search parameters.
   */
  _this.fetchData = function (search) {
    Xhr.ajax({
      url: _irisServiceUrl,
      data: search,
      success: _this.onSuccess,
      error: _this.onError,
    });
  };

  /**
   * Gets search parameters from the model and creates search object
   */
  _this.getSearch = function () {
    var ev,
        latitude,
        longitude,
        search,
        summary,
        time;

    ev = _this.model.get('event');
    search = null;

    if (ev) {
      summary = ev.getSummary();
      latitude = summary.latitude;
      longitude = summary.longitude;
      time = Number(summary.time.getTime());
      // search parameters
      search = {
        'starttime': new Date(time - 16000).toISOString().replace('Z', ''),
        'endtime': new Date(time + 16000).toISOString().replace('Z', ''),
        'latitude': latitude,
        'longitude': longitude,
        'maxradius': 1,
        'format': 'text'
      };
    }

    return search;
  };

  /**
   * Shows default error message which can be changed.
   */
  _this.onError = function () {
    _this.el.innerHTML = _errorMessage;
  };

  /**
   * onSuccess is called when Xhr is successful and calls eventId if no event
   * is found. If an event is found it calls renderContent.
   * @param data {string}
   *    data in string format.
   */
  _this.onSuccess = function (data) {
    var eventId;

    eventId = _this.parseIrisEventId(data);

    if (!eventId) {
      _this.onError();
      return;
    }

    _this.renderContent(eventId);
  };

  /**
   * Gets eventId from data
   * @param {string}
   *    data in string format.
   */
  _this.parseIrisEventId = function (data) {
    return data.split('\n')[1].split('|')[0];
  };

  /**
   * Called when the model changes
   */
  _this.render = function () {
    var search;

    _this.header.innerHTML = '<h3>Waveforms</h3>' +
        '<a class="back-to-summary-link"' +
        ' href="#' + ScientificSummaryModule.ID + '">Back to ' +
        ScientificSummaryModule.TITLE + '</a>';

    search = _this.getSearch();

    if (search === null) {
      _this.onError();
    } else {
      _this.fetchData(search);
    }
  };

  /**
   * Renders main content and adds urls.
   * @param eventId {string}
   *    The event id parsed from data.
   */
  _this.renderContent = function (eventId) {
    _this.content.innerHTML = [
      '<dl class="iris-products vertical">',
        '<dt>',
          '<a href="', _irisWilberUrl, eventId, '" target="_blank">',
            'IRIS Seismic Waveform Data (Wilber 3)',
          '</a>',
        '</dt>',
        '<dd>',
          'Wilber 3 locates stations in operation at the time of the event,',
          ' allows users to filter stations, preview waveform data, and',
          ' view record section plots. Data can be downloaded in a',
          ' number of formats including <abbr title="Seismic Analysis',
          ' Code">SAC</abbr>, <abbr title="Standard for the Exchange of',
          ' Earthquake Data">SEED</abbr>, miniSEED and ASCII.',
        '</dd>',

        '<dt>',
          '<a href="', _irisSpudUrl, eventId, '" target="_blank">',
            'IRIS Searchable Product Depository (SPUD) Event Page',
          '</a>',
        '</dt>',
        '<dd>',
          'SPUD is the IRIS DMC&rsquo;s primary data product management system.',
          ' Complementing the DMC&rsquo;s SEED and assembled data archives,',
          ' which contain time series recordings, the SPUD system',
          ' primarily contains derivative data products of other types',
          ' (images, movies, etc.) created either at the DMC or by members',
          ' of the community.',
        '</dd>',
      '</dl>'
    ].join('');
  };

  _initialize(options);
  options = null;
  return _this;
};

WaveformModule.ID = _ID;
WaveformModule.TITLE = _TITLE;
WaveformModule.hasContent = _hasContent;

module.exports = WaveformModule;

},{"core/Module":"core/Module","scientific/ScientificSummaryModule":"scientific/ScientificSummaryModule","util/Util":"util/Util","util/Xhr":"util/Xhr"}]},{},[])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZDMvZDMuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWFjY29yZGlvbi9zcmMvYWNjb3JkaW9uL0FjY29yZGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtZDMvc3JjL2QzL0NsYXNzTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtZDMvc3JjL2QzL0QzTGluZVZpZXcuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWQzL3NyYy9kMy9EM1N1YlZpZXcuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWQzL3NyYy9kMy9EM1V0aWwuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWQzL3NyYy9kMy9EM1ZpZXcuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWxlYWZsZXQvc3JjL2xlYWZsZXQvVXRmR3JpZC5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtbGVhZmxldC9zcmMvbGVhZmxldC9jb250cm9sL0hhekRldkxheWVycy5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtbGVhZmxldC9zcmMvbGVhZmxldC9jb250cm9sL01vdXNlUG9zaXRpb24uanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWxlYWZsZXQvc3JjL2xlYWZsZXQvbGF5ZXIvQXN5bmNocm9ub3VzR2VvSnNvbi5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtbGVhZmxldC9zcmMvbGVhZmxldC9sYXllci9HcmF5c2NhbGUuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWxlYWZsZXQvc3JjL2xlYWZsZXQvbGF5ZXIvSGlzdG9yaWNTZWlzbWljaXR5LmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi1sZWFmbGV0L3NyYy9sZWFmbGV0L2xheWVyL01vdXNlT3ZlckxheWVyLmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi1sZWFmbGV0L3NyYy9sZWFmbGV0L2xheWVyL1NhdGVsbGl0ZS5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtbGVhZmxldC9zcmMvbGVhZmxldC9sYXllci9TdHJlZXQuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWxlYWZsZXQvc3JjL2xlYWZsZXQvbGF5ZXIvVGVjdG9uaWNQbGF0ZXMuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWxlYWZsZXQvc3JjL2xlYWZsZXQvbGF5ZXIvVGVycmFpbi5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtbGVhZmxldC9zcmMvbGVhZmxldC9sYXllci9UaWxlUHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWxlYWZsZXQvc3JjL2xlYWZsZXQvbGF5ZXIvVXNGYXVsdC5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtbG9jYXRpb24tdmlldy9zcmMvbG9jYXRpb252aWV3L0NvbmZpZGVuY2VDYWxjdWxhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi1sb2NhdGlvbi12aWV3L3NyYy9sb2NhdGlvbnZpZXcvQ29vcmRpbmF0ZUNvbnRyb2wuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LWxvY2F0aW9uLXZpZXcvc3JjL2xvY2F0aW9udmlldy9HZW9jb2RlQ29udHJvbC5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtbG9jYXRpb24tdmlldy9zcmMvbG9jYXRpb252aWV3L0dlb2NvZGVyLmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi1sb2NhdGlvbi12aWV3L3NyYy9sb2NhdGlvbnZpZXcvR2VvbG9jYXRpb25Db250cm9sLmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi1sb2NhdGlvbi12aWV3L3NyYy9sb2NhdGlvbnZpZXcvTG9jYXRpb25Db250cm9sLmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi1sb2NhdGlvbi12aWV3L3NyYy9sb2NhdGlvbnZpZXcvTG9jYXRpb25WaWV3LmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi1sb2NhdGlvbi12aWV3L3NyYy9sb2NhdGlvbnZpZXcvUG9pbnRDb250cm9sLmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi1xdWVzdGlvbi12aWV3L3NyYy9xdWVzdGlvbnZpZXcvUXVlc3Rpb25WaWV3LmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi13ZWJ1dGlscy9zcmMvbWF0aC9NYXRyaXguanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LXdlYnV0aWxzL3NyYy9tYXRoL1ZlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtd2VidXRpbHMvc3JjL212Yy9Db2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi13ZWJ1dGlscy9zcmMvbXZjL0NvbGxlY3Rpb25TZWxlY3RCb3guanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LXdlYnV0aWxzL3NyYy9tdmMvQ29sbGVjdGlvblRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi13ZWJ1dGlscy9zcmMvbXZjL0RhdGFUYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtd2VidXRpbHMvc3JjL212Yy9Eb3dubG9hZFZpZXcuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LXdlYnV0aWxzL3NyYy9tdmMvTW9kYWxWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi13ZWJ1dGlscy9zcmMvbXZjL1NvcnRWaWV3LmpzIiwibm9kZV9tb2R1bGVzL3F1YWtlbWwtcGFyc2VyLWpzL3NyYy9xdWFrZW1sL1F1YWtlbWwuanMiLCJub2RlX21vZHVsZXMvcXVha2VtbC1wYXJzZXItanMvc3JjL3F1YWtlbWwvUXVha2VtbEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3F1YWtlbWwtcGFyc2VyLWpzL3NyYy9xdWFrZW1sL1htbFV0aWwuanMiLCJzcmMvaHRkb2NzL2pzL2NvcmUvQWNjb3JkaW9uVmlldy5qcyIsInNyYy9odGRvY3MvanMvY29yZS9BdHRyaWJ1dGlvbi5qcyIsInNyYy9odGRvY3MvanMvY29yZS9CYXNpY1BpblZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL2NvcmUvQ29udGVudFZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL2NvcmUvQ29vcGVyYXRvckxvZ28uanMiLCJzcmMvaHRkb2NzL2pzL2NvcmUvRG93bmxvYWRWaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9jb3JlL0V2ZW50UGFnZS5qcyIsInNyYy9odGRvY3MvanMvY29yZS9Gb3JtYXR0ZXIuanMiLCJzcmMvaHRkb2NzL2pzL2NvcmUvTGlua1Byb2R1Y3RWaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9jb3JlL01vZHVsZS5qcyIsInNyYy9odGRvY3MvanMvY29yZS9OZWFyYnlTZWlzbWljaXR5LmpzIiwic3JjL2h0ZG9jcy9qcy9jb3JlL1Byb2R1Y3RWaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9jb3JlL1N1bW1hcnlNb2R1bGUuanMiLCJzcmMvaHRkb2NzL2pzL2NvcmUvVGV4dFByb2R1Y3RWaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9keWZpL0RZRklGb3JtTW9kdWxlLmpzIiwic3JjL2h0ZG9jcy9qcy9keWZpL0RZRklGb3JtUGluVmlldy5qcyIsInNyYy9odGRvY3MvanMvZHlmaS9EWUZJRm9ybVZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL2R5ZmkvRFlGSUludGVuc2l0eUdyYXBoVmlldy5qcyIsInNyYy9odGRvY3MvanMvZHlmaS9EWUZJTW9kdWxlLmpzIiwic3JjL2h0ZG9jcy9qcy9keWZpL0RZRklQaW5WaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9keWZpL0RZRklSZXNwb25zZXNWaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9keWZpL0RZRklWaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9keWZpL1N0YW5kYXJkRGV2aWF0aW9uTGluZVZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL2R5ZmkvVGV4dFF1ZXN0aW9uVmlldy5qcyIsInNyYy9odGRvY3MvanMvZmluaXRlLWZhdWx0L0Zpbml0ZUZhdWx0TW9kdWxlLmpzIiwic3JjL2h0ZG9jcy9qcy9maW5pdGUtZmF1bHQvRmluaXRlRmF1bHRQaW5WaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9maW5pdGUtZmF1bHQvRmluaXRlRmF1bHRWaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9mb2NhbC1tZWNoYW5pc20vRm9jYWxNZWNoYW5pc21Nb2R1bGUuanMiLCJzcmMvaHRkb2NzL2pzL2ZvY2FsLW1lY2hhbmlzbS9Gb2NhbE1lY2hhbmlzbVBpblZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL2ZvY2FsLW1lY2hhbmlzbS9Gb2NhbE1lY2hhbmlzbVZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL2dlbmVyYWwvRXhlY3V0aXZlU3VtbWFyeU1vZHVsZS5qcyIsInNyYy9odGRvY3MvanMvZ2VuZXJhbC9HZW9zZXJ2ZU5lYXJieVBsYWNlc1ZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL2dlbmVyYWwvR2Vvc2VydmVSZWdpb25TdW1tYXJ5Vmlldy5qcyIsInNyYy9odGRvY3MvanMvZ2VuZXJhbC9Mb2NhdGlvblZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL2dlbmVyYWwvTmVhcmJ5UGxhY2VzVmlldy5qcyIsInNyYy9odGRvY3MvanMvZ2VuZXJhbC9SZWdpb25hbEluZm9Nb2R1bGUuanMiLCJzcmMvaHRkb2NzL2pzL2dlbmVyYWwvUmVnaW9uYWxJbmZvUGluVmlldy5qcyIsInNyYy9odGRvY3MvanMvZ2VuZXJhbC9Uc3VuYW1pUGluVmlldy5qcyIsInNyYy9odGRvY3MvanMvaW1wYWN0L0ltcGFjdFN1bW1hcnlNb2R1bGUuanMiLCJzcmMvaHRkb2NzL2pzL2xvc3NwYWdlci9QQUdFUk1vZHVsZS5qcyIsInNyYy9odGRvY3MvanMvbG9zc3BhZ2VyL1BBR0VSUGluVmlldy5qcyIsInNyYy9odGRvY3MvanMvbG9zc3BhZ2VyL1BBR0VSVmlldy5qcyIsInNyYy9odGRvY3MvanMvbG9zc3BhZ2VyL1BhZ2VyWG1sUGFyc2VyLmpzIiwic3JjL2h0ZG9jcy9qcy9tYXAvQ29udG91cnNMYXllci5qcyIsInNyYy9odGRvY3MvanMvbWFwL0R5ZmlVdG1MYXllci5qcyIsInNyYy9odGRvY3MvanMvbWFwL0ludGVyYWN0aXZlTWFwTW9kdWxlLmpzIiwic3JjL2h0ZG9jcy9qcy9tYXAvSW50ZXJhY3RpdmVNYXBQaW5WaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9tYXAvSW50ZXJhY3RpdmVNYXBWaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9tYXAvU2hha2VNYXBTdGF0aW9uTGF5ZXIuanMiLCJzcmMvaHRkb2NzL2pzL21vbWVudC10ZW5zb3IvQmVhY2hCYWxsVmlldy5qcyIsInNyYy9odGRvY3MvanMvbW9tZW50LXRlbnNvci9DYW52YXMuanMiLCJzcmMvaHRkb2NzL2pzL21vbWVudC10ZW5zb3IvTW9tZW50VGVuc29yTW9kdWxlLmpzIiwic3JjL2h0ZG9jcy9qcy9tb21lbnQtdGVuc29yL01vbWVudFRlbnNvclBpblZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL21vbWVudC10ZW5zb3IvTW9tZW50VGVuc29yVmlldy5qcyIsInNyYy9odGRvY3MvanMvbW9tZW50LXRlbnNvci9UZW5zb3IuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LXdlYnV0aWxzL3NyYy9tdmMvTW9kZWwuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LXdlYnV0aWxzL3NyYy9tdmMvVmlldy5qcyIsInNyYy9odGRvY3MvanMvb2FmL0ZvcmVjYXN0VGFibGVWaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9vYWYvRm9yZWNhc3RUZXh0Vmlldy5qcyIsInNyYy9odGRvY3MvanMvb2FmL0ZvcmVjYXN0Vmlldy5qcyIsInNyYy9odGRvY3MvanMvb2FmL01vZGVsRGV0YWlsc1ZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL29hZi9PYWZNb2R1bGUuanMiLCJzcmMvaHRkb2NzL2pzL29hZi9PYWZWaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9vcmlnaW4vTWFnbml0dWRlc1ZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL29yaWdpbi9PcmlnaW5Nb2R1bGUuanMiLCJzcmMvaHRkb2NzL2pzL29yaWdpbi9PcmlnaW5QaW5WaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9vcmlnaW4vT3JpZ2luVmlldy5qcyIsInNyYy9odGRvY3MvanMvb3JpZ2luL1BoYXNlc1ZpZXcuanMiLCJzcmMvaHRkb2NzL2pzL29yaWdpbi9RdWFrZW1sVmlldy5qcyIsInNyYy9odGRvY3MvanMvcGRsL0NhdGFsb2dFdmVudC5qcyIsInNyYy9odGRvY3MvanMvcGRsL0NvbnRlbnQuanMiLCJzcmMvaHRkb2NzL2pzL3BkbC9Qcm9kdWN0LmpzIiwic3JjL2h0ZG9jcy9qcy9zY2llbnRpZmljL1NjaWVudGlmaWNTdW1tYXJ5TW9kdWxlLmpzIiwic3JjL2h0ZG9jcy9qcy9zaGFrZW1hcC9TaGFrZU1hcEluZm9WaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9zaGFrZW1hcC9TaGFrZU1hcE1vZHVsZS5qcyIsInNyYy9odGRvY3MvanMvc2hha2VtYXAvU2hha2VNYXBQaW5WaWV3LmpzIiwic3JjL2h0ZG9jcy9qcy9zaGFrZW1hcC9TaGFrZU1hcFN0YXRpb25MaXN0Vmlldy5qcyIsInNyYy9odGRvY3MvanMvc2hha2VtYXAvU2hha2VNYXBWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi1zdmdpbWFnZW1hcC9zcmMvc3ZnaW1hZ2VtYXAvU3ZnSW1hZ2VNYXAuanMiLCJub2RlX21vZHVsZXMvaGF6ZGV2LXRhYmxpc3Qvc3JjL3RhYmxpc3QvVGFiTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9oYXpkZXYtd2VidXRpbHMvc3JjL3V0aWwvRXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi13ZWJ1dGlscy9zcmMvdXRpbC9VdGlsLmpzIiwibm9kZV9tb2R1bGVzL2hhemRldi13ZWJ1dGlscy9zcmMvdXRpbC9YaHIuanMiLCJzcmMvaHRkb2NzL2pzL3dhdmVmb3JtL1dhdmVmb3JtTW9kdWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2p0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDem1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDajNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaDFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNucEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIhZnVuY3Rpb24oKSB7XG4gIHZhciBkMyA9IHtcbiAgICB2ZXJzaW9uOiBcIjMuNS4xN1wiXG4gIH07XG4gIHZhciBkM19hcnJheVNsaWNlID0gW10uc2xpY2UsIGQzX2FycmF5ID0gZnVuY3Rpb24obGlzdCkge1xuICAgIHJldHVybiBkM19hcnJheVNsaWNlLmNhbGwobGlzdCk7XG4gIH07XG4gIHZhciBkM19kb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQ7XG4gIGZ1bmN0aW9uIGQzX2RvY3VtZW50RWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgKG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlLmRvY3VtZW50IHx8IG5vZGUpLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICBmdW5jdGlvbiBkM193aW5kb3cobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IG5vZGUuZG9jdW1lbnQgJiYgbm9kZSB8fCBub2RlLmRlZmF1bHRWaWV3KTtcbiAgfVxuICBpZiAoZDNfZG9jdW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgZDNfYXJyYXkoZDNfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNoaWxkTm9kZXMpWzBdLm5vZGVUeXBlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGQzX2FycmF5ID0gZnVuY3Rpb24obGlzdCkge1xuICAgICAgICB2YXIgaSA9IGxpc3QubGVuZ3RoLCBhcnJheSA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgd2hpbGUgKGktLSkgYXJyYXlbaV0gPSBsaXN0W2ldO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBpZiAoIURhdGUubm93KSBEYXRlLm5vdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgfTtcbiAgaWYgKGQzX2RvY3VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGQzX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIikuc3R5bGUuc2V0UHJvcGVydHkoXCJvcGFjaXR5XCIsIDAsIFwiXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB2YXIgZDNfZWxlbWVudF9wcm90b3R5cGUgPSB0aGlzLkVsZW1lbnQucHJvdG90eXBlLCBkM19lbGVtZW50X3NldEF0dHJpYnV0ZSA9IGQzX2VsZW1lbnRfcHJvdG90eXBlLnNldEF0dHJpYnV0ZSwgZDNfZWxlbWVudF9zZXRBdHRyaWJ1dGVOUyA9IGQzX2VsZW1lbnRfcHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TLCBkM19zdHlsZV9wcm90b3R5cGUgPSB0aGlzLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLCBkM19zdHlsZV9zZXRQcm9wZXJ0eSA9IGQzX3N0eWxlX3Byb3RvdHlwZS5zZXRQcm9wZXJ0eTtcbiAgICAgIGQzX2VsZW1lbnRfcHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgdmFsdWUgKyBcIlwiKTtcbiAgICAgIH07XG4gICAgICBkM19lbGVtZW50X3Byb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uKHNwYWNlLCBsb2NhbCwgdmFsdWUpIHtcbiAgICAgICAgZDNfZWxlbWVudF9zZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIHNwYWNlLCBsb2NhbCwgdmFsdWUgKyBcIlwiKTtcbiAgICAgIH07XG4gICAgICBkM19zdHlsZV9wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgZDNfc3R5bGVfc2V0UHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSArIFwiXCIsIHByaW9yaXR5KTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGQzLmFzY2VuZGluZyA9IGQzX2FzY2VuZGluZztcbiAgZnVuY3Rpb24gZDNfYXNjZW5kaW5nKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG4gIH1cbiAgZDMuZGVzY2VuZGluZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG4gIH07XG4gIGQzLm1pbiA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgYjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYSA+IGIpIGEgPSBiO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICBkMy5tYXggPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPiBhKSBhID0gYjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+IGEpIGEgPSBiO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbiAgZDMuZXh0ZW50ID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBiLCBjO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBjID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGEgPiBiKSBhID0gYjtcbiAgICAgICAgaWYgKGMgPCBiKSBjID0gYjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYyA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhID4gYikgYSA9IGI7XG4gICAgICAgIGlmIChjIDwgYikgYyA9IGI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbIGEsIGMgXTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbnVtYmVyKHgpIHtcbiAgICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xuICB9XG4gIGZ1bmN0aW9uIGQzX251bWVyaWMoeCkge1xuICAgIHJldHVybiAhaXNOYU4oeCk7XG4gIH1cbiAgZDMuc3VtID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgcyA9IDAsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGkgPSAtMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSArYXJyYXlbaV0pKSBzICs9IGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gK2YuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkgcyArPSBhO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfTtcbiAgZDMubWVhbiA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIHMgPSAwLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBpID0gLTEsIGogPSBuO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihhcnJheVtpXSkpKSBzICs9IGE7IGVsc2UgLS1qO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkpKSBzICs9IGE7IGVsc2UgLS1qO1xuICAgIH1cbiAgICBpZiAoaikgcmV0dXJuIHMgLyBqO1xuICB9O1xuICBkMy5xdWFudGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgcCkge1xuICAgIHZhciBIID0gKHZhbHVlcy5sZW5ndGggLSAxKSAqIHAgKyAxLCBoID0gTWF0aC5mbG9vcihIKSwgdiA9ICt2YWx1ZXNbaCAtIDFdLCBlID0gSCAtIGg7XG4gICAgcmV0dXJuIGUgPyB2ICsgZSAqICh2YWx1ZXNbaF0gLSB2KSA6IHY7XG4gIH07XG4gIGQzLm1lZGlhbiA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIG51bWJlcnMgPSBbXSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgaSA9IC0xO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihhcnJheVtpXSkpKSBudW1iZXJzLnB1c2goYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkpIG51bWJlcnMucHVzaChhKTtcbiAgICB9XG4gICAgaWYgKG51bWJlcnMubGVuZ3RoKSByZXR1cm4gZDMucXVhbnRpbGUobnVtYmVycy5zb3J0KGQzX2FzY2VuZGluZyksIC41KTtcbiAgfTtcbiAgZDMudmFyaWFuY2UgPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoLCBtID0gMCwgYSwgZCwgcyA9IDAsIGkgPSAtMSwgaiA9IDA7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoYXJyYXlbaV0pKSkge1xuICAgICAgICAgIGQgPSBhIC0gbTtcbiAgICAgICAgICBtICs9IGQgLyArK2o7XG4gICAgICAgICAgcyArPSBkICogKGEgLSBtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkpIHtcbiAgICAgICAgICBkID0gYSAtIG07XG4gICAgICAgICAgbSArPSBkIC8gKytqO1xuICAgICAgICAgIHMgKz0gZCAqIChhIC0gbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGogPiAxKSByZXR1cm4gcyAvIChqIC0gMSk7XG4gIH07XG4gIGQzLmRldmlhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZDMudmFyaWFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Jpc2VjdG9yKGNvbXBhcmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgbG8gPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIGhpID0gYS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTsgZWxzZSBoaSA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG87XG4gICAgICB9LFxuICAgICAgcmlnaHQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGxvID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSBoaSA9IGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPiAwKSBoaSA9IG1pZDsgZWxzZSBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdmFyIGQzX2Jpc2VjdCA9IGQzX2Jpc2VjdG9yKGQzX2FzY2VuZGluZyk7XG4gIGQzLmJpc2VjdExlZnQgPSBkM19iaXNlY3QubGVmdDtcbiAgZDMuYmlzZWN0ID0gZDMuYmlzZWN0UmlnaHQgPSBkM19iaXNlY3QucmlnaHQ7XG4gIGQzLmJpc2VjdG9yID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBkM19iaXNlY3RvcihmLmxlbmd0aCA9PT0gMSA/IGZ1bmN0aW9uKGQsIHgpIHtcbiAgICAgIHJldHVybiBkM19hc2NlbmRpbmcoZihkKSwgeCk7XG4gICAgfSA6IGYpO1xuICB9O1xuICBkMy5zaHVmZmxlID0gZnVuY3Rpb24oYXJyYXksIGkwLCBpMSkge1xuICAgIGlmICgobSA9IGFyZ3VtZW50cy5sZW5ndGgpIDwgMykge1xuICAgICAgaTEgPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobSA8IDIpIGkwID0gMDtcbiAgICB9XG4gICAgdmFyIG0gPSBpMSAtIGkwLCB0LCBpO1xuICAgIHdoaWxlIChtKSB7XG4gICAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgICB0ID0gYXJyYXlbbSArIGkwXSwgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF0sIGFycmF5W2kgKyBpMF0gPSB0O1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG4gIGQzLnBlcm11dGUgPSBmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgIHZhciBpID0gaW5kZXhlcy5sZW5ndGgsIHBlcm11dGVzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHBlcm11dGVzW2ldID0gYXJyYXlbaW5kZXhlc1tpXV07XG4gICAgcmV0dXJuIHBlcm11dGVzO1xuICB9O1xuICBkMy5wYWlycyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoIC0gMSwgcDAsIHAxID0gYXJyYXlbMF0sIHBhaXJzID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICAgIHdoaWxlIChpIDwgbikgcGFpcnNbaV0gPSBbIHAwID0gcDEsIHAxID0gYXJyYXlbKytpXSBdO1xuICAgIHJldHVybiBwYWlycztcbiAgfTtcbiAgZDMudHJhbnNwb3NlID0gZnVuY3Rpb24obWF0cml4KSB7XG4gICAgaWYgKCEobiA9IG1hdHJpeC5sZW5ndGgpKSByZXR1cm4gW107XG4gICAgZm9yICh2YXIgaSA9IC0xLCBtID0gZDMubWluKG1hdHJpeCwgZDNfdHJhbnNwb3NlTGVuZ3RoKSwgdHJhbnNwb3NlID0gbmV3IEFycmF5KG0pOyArK2kgPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGogPSAtMSwgbiwgcm93ID0gdHJhbnNwb3NlW2ldID0gbmV3IEFycmF5KG4pOyArK2ogPCBuOyApIHtcbiAgICAgICAgcm93W2pdID0gbWF0cml4W2pdW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3NlO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc3Bvc2VMZW5ndGgoZCkge1xuICAgIHJldHVybiBkLmxlbmd0aDtcbiAgfVxuICBkMy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMudHJhbnNwb3NlKGFyZ3VtZW50cyk7XG4gIH07XG4gIGQzLmtleXMgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBtYXApIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuICBkMy52YWx1ZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG1hcCkgdmFsdWVzLnB1c2gobWFwW2tleV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG4gIGQzLmVudHJpZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBtYXApIGVudHJpZXMucHVzaCh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiBtYXBba2V5XVxuICAgIH0pO1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9O1xuICBkMy5tZXJnZSA9IGZ1bmN0aW9uKGFycmF5cykge1xuICAgIHZhciBuID0gYXJyYXlzLmxlbmd0aCwgbSwgaSA9IC0xLCBqID0gMCwgbWVyZ2VkLCBhcnJheTtcbiAgICB3aGlsZSAoKytpIDwgbikgaiArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgIG1lcmdlZCA9IG5ldyBBcnJheShqKTtcbiAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgIGFycmF5ID0gYXJyYXlzW25dO1xuICAgICAgbSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlICgtLW0gPj0gMCkge1xuICAgICAgICBtZXJnZWRbLS1qXSA9IGFycmF5W21dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9O1xuICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gIGQzLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHN0b3AgLSBzdGFydCkgLyBzdGVwID09PSBJbmZpbml0eSkgdGhyb3cgbmV3IEVycm9yKFwiaW5maW5pdGUgcmFuZ2VcIik7XG4gICAgdmFyIHJhbmdlID0gW10sIGsgPSBkM19yYW5nZV9pbnRlZ2VyU2NhbGUoYWJzKHN0ZXApKSwgaSA9IC0xLCBqO1xuICAgIHN0YXJ0ICo9IGssIHN0b3AgKj0gaywgc3RlcCAqPSBrO1xuICAgIGlmIChzdGVwIDwgMCkgd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA+IHN0b3ApIHJhbmdlLnB1c2goaiAvIGspOyBlbHNlIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPCBzdG9wKSByYW5nZS5wdXNoKGogLyBrKTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3JhbmdlX2ludGVnZXJTY2FsZSh4KSB7XG4gICAgdmFyIGsgPSAxO1xuICAgIHdoaWxlICh4ICogayAlIDEpIGsgKj0gMTA7XG4gICAgcmV0dXJuIGs7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY2xhc3MoY3RvciwgcHJvcGVydGllcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsIGtleSwge1xuICAgICAgICB2YWx1ZTogcHJvcGVydGllc1trZXldLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGQzLm1hcCA9IGZ1bmN0aW9uKG9iamVjdCwgZikge1xuICAgIHZhciBtYXAgPSBuZXcgZDNfTWFwKCk7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIGQzX01hcCkge1xuICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBvYmplY3QubGVuZ3RoLCBvO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGksIG9iamVjdFtpXSk7IGVsc2Ugd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoZi5jYWxsKG9iamVjdCwgbyA9IG9iamVjdFtpXSwgaSksIG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBtYXAuc2V0KGtleSwgb2JqZWN0W2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuICBmdW5jdGlvbiBkM19NYXAoKSB7XG4gICAgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICB2YXIgZDNfbWFwX3Byb3RvID0gXCJfX3Byb3RvX19cIiwgZDNfbWFwX3plcm8gPSBcIlxceDAwXCI7XG4gIGQzX2NsYXNzKGQzX01hcCwge1xuICAgIGhhczogZDNfbWFwX2hhcyxcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX1tkM19tYXBfZXNjYXBlKGtleSldO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fW2QzX21hcF9lc2NhcGUoa2V5KV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIHJlbW92ZTogZDNfbWFwX3JlbW92ZSxcbiAgICBrZXlzOiBkM19tYXBfa2V5cyxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgdmFsdWVzLnB1c2godGhpcy5fW2tleV0pO1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGVudHJpZXMucHVzaCh7XG4gICAgICAgIGtleTogZDNfbWFwX3VuZXNjYXBlKGtleSksXG4gICAgICAgIHZhbHVlOiB0aGlzLl9ba2V5XVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZW50cmllcztcbiAgICB9LFxuICAgIHNpemU6IGQzX21hcF9zaXplLFxuICAgIGVtcHR5OiBkM19tYXBfZW1wdHksXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oZikge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgZi5jYWxsKHRoaXMsIGQzX21hcF91bmVzY2FwZShrZXkpLCB0aGlzLl9ba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gZDNfbWFwX2VzY2FwZShrZXkpIHtcbiAgICByZXR1cm4gKGtleSArPSBcIlwiKSA9PT0gZDNfbWFwX3Byb3RvIHx8IGtleVswXSA9PT0gZDNfbWFwX3plcm8gPyBkM19tYXBfemVybyArIGtleSA6IGtleTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfdW5lc2NhcGUoa2V5KSB7XG4gICAgcmV0dXJuIChrZXkgKz0gXCJcIilbMF0gPT09IGQzX21hcF96ZXJvID8ga2V5LnNsaWNlKDEpIDoga2V5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9oYXMoa2V5KSB7XG4gICAgcmV0dXJuIGQzX21hcF9lc2NhcGUoa2V5KSBpbiB0aGlzLl87XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX3JlbW92ZShrZXkpIHtcbiAgICByZXR1cm4gKGtleSA9IGQzX21hcF9lc2NhcGUoa2V5KSkgaW4gdGhpcy5fICYmIGRlbGV0ZSB0aGlzLl9ba2V5XTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfa2V5cygpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGtleXMucHVzaChkM19tYXBfdW5lc2NhcGUoa2V5KSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX3NpemUoKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pICsrc2l6ZTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfZW1wdHkoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGQzLm5lc3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmVzdCA9IHt9LCBrZXlzID0gW10sIHNvcnRLZXlzID0gW10sIHNvcnRWYWx1ZXMsIHJvbGx1cDtcbiAgICBmdW5jdGlvbiBtYXAobWFwVHlwZSwgYXJyYXksIGRlcHRoKSB7XG4gICAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHJldHVybiByb2xsdXAgPyByb2xsdXAuY2FsbChuZXN0LCBhcnJheSkgOiBzb3J0VmFsdWVzID8gYXJyYXkuc29ydChzb3J0VmFsdWVzKSA6IGFycmF5O1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwga2V5ID0ga2V5c1tkZXB0aCsrXSwga2V5VmFsdWUsIG9iamVjdCwgc2V0dGVyLCB2YWx1ZXNCeUtleSA9IG5ldyBkM19NYXAoKSwgdmFsdWVzO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9IHZhbHVlc0J5S2V5LmdldChrZXlWYWx1ZSA9IGtleShvYmplY3QgPSBhcnJheVtpXSkpKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZXNCeUtleS5zZXQoa2V5VmFsdWUsIFsgb2JqZWN0IF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWFwVHlwZSkge1xuICAgICAgICBvYmplY3QgPSBtYXBUeXBlKCk7XG4gICAgICAgIHNldHRlciA9IGZ1bmN0aW9uKGtleVZhbHVlLCB2YWx1ZXMpIHtcbiAgICAgICAgICBvYmplY3Quc2V0KGtleVZhbHVlLCBtYXAobWFwVHlwZSwgdmFsdWVzLCBkZXB0aCkpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0ID0ge307XG4gICAgICAgIHNldHRlciA9IGZ1bmN0aW9uKGtleVZhbHVlLCB2YWx1ZXMpIHtcbiAgICAgICAgICBvYmplY3Rba2V5VmFsdWVdID0gbWFwKG1hcFR5cGUsIHZhbHVlcywgZGVwdGgpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFsdWVzQnlLZXkuZm9yRWFjaChzZXR0ZXIpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50cmllcyhtYXAsIGRlcHRoKSB7XG4gICAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHJldHVybiBtYXA7XG4gICAgICB2YXIgYXJyYXkgPSBbXSwgc29ydEtleSA9IHNvcnRLZXlzW2RlcHRoKytdO1xuICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24oa2V5LCBrZXlNYXApIHtcbiAgICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgdmFsdWVzOiBlbnRyaWVzKGtleU1hcCwgZGVwdGgpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc29ydEtleSA/IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gc29ydEtleShhLmtleSwgYi5rZXkpO1xuICAgICAgfSkgOiBhcnJheTtcbiAgICB9XG4gICAgbmVzdC5tYXAgPSBmdW5jdGlvbihhcnJheSwgbWFwVHlwZSkge1xuICAgICAgcmV0dXJuIG1hcChtYXBUeXBlLCBhcnJheSwgMCk7XG4gICAgfTtcbiAgICBuZXN0LmVudHJpZXMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgcmV0dXJuIGVudHJpZXMobWFwKGQzLm1hcCwgYXJyYXksIDApLCAwKTtcbiAgICB9O1xuICAgIG5lc3Qua2V5ID0gZnVuY3Rpb24oZCkge1xuICAgICAga2V5cy5wdXNoKGQpO1xuICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgfTtcbiAgICBuZXN0LnNvcnRLZXlzID0gZnVuY3Rpb24ob3JkZXIpIHtcbiAgICAgIHNvcnRLZXlzW2tleXMubGVuZ3RoIC0gMV0gPSBvcmRlcjtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgbmVzdC5zb3J0VmFsdWVzID0gZnVuY3Rpb24ob3JkZXIpIHtcbiAgICAgIHNvcnRWYWx1ZXMgPSBvcmRlcjtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgbmVzdC5yb2xsdXAgPSBmdW5jdGlvbihmKSB7XG4gICAgICByb2xsdXAgPSBmO1xuICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgfTtcbiAgICByZXR1cm4gbmVzdDtcbiAgfTtcbiAgZDMuc2V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgc2V0ID0gbmV3IGQzX1NldCgpO1xuICAgIGlmIChhcnJheSkgZm9yICh2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGg7IGkgPCBuOyArK2kpIHNldC5hZGQoYXJyYXlbaV0pO1xuICAgIHJldHVybiBzZXQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX1NldCgpIHtcbiAgICB0aGlzLl8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGQzX2NsYXNzKGQzX1NldCwge1xuICAgIGhhczogZDNfbWFwX2hhcyxcbiAgICBhZGQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhpcy5fW2QzX21hcF9lc2NhcGUoa2V5ICs9IFwiXCIpXSA9IHRydWU7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBkM19tYXBfcmVtb3ZlLFxuICAgIHZhbHVlczogZDNfbWFwX2tleXMsXG4gICAgc2l6ZTogZDNfbWFwX3NpemUsXG4gICAgZW1wdHk6IGQzX21hcF9lbXB0eSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBmLmNhbGwodGhpcywgZDNfbWFwX3VuZXNjYXBlKGtleSkpO1xuICAgIH1cbiAgfSk7XG4gIGQzLmJlaGF2aW9yID0ge307XG4gIGZ1bmN0aW9uIGQzX2lkZW50aXR5KGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfVxuICBkMy5yZWJpbmQgPSBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIHZhciBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1ldGhvZDtcbiAgICB3aGlsZSAoKytpIDwgbikgdGFyZ2V0W21ldGhvZCA9IGFyZ3VtZW50c1tpXV0gPSBkM19yZWJpbmQodGFyZ2V0LCBzb3VyY2UsIHNvdXJjZVttZXRob2RdKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICBmdW5jdGlvbiBkM19yZWJpbmQodGFyZ2V0LCBzb3VyY2UsIG1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseShzb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHNvdXJjZSA/IHRhcmdldCA6IHZhbHVlO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdmVuZG9yU3ltYm9sKG9iamVjdCwgbmFtZSkge1xuICAgIGlmIChuYW1lIGluIG9iamVjdCkgcmV0dXJuIG5hbWU7XG4gICAgbmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gZDNfdmVuZG9yUHJlZml4ZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgcHJlZml4TmFtZSA9IGQzX3ZlbmRvclByZWZpeGVzW2ldICsgbmFtZTtcbiAgICAgIGlmIChwcmVmaXhOYW1lIGluIG9iamVjdCkgcmV0dXJuIHByZWZpeE5hbWU7XG4gICAgfVxuICB9XG4gIHZhciBkM192ZW5kb3JQcmVmaXhlcyA9IFsgXCJ3ZWJraXRcIiwgXCJtc1wiLCBcIm1velwiLCBcIk1velwiLCBcIm9cIiwgXCJPXCIgXTtcbiAgZnVuY3Rpb24gZDNfbm9vcCgpIHt9XG4gIGQzLmRpc3BhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gbmV3IGQzX2Rpc3BhdGNoKCksIGkgPSAtMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRpc3BhdGNoW2FyZ3VtZW50c1tpXV0gPSBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoO1xuICB9O1xuICBmdW5jdGlvbiBkM19kaXNwYXRjaCgpIHt9XG4gIGQzX2Rpc3BhdGNoLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGkgPSB0eXBlLmluZGV4T2YoXCIuXCIpLCBuYW1lID0gXCJcIjtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBuYW1lID0gdHlwZS5zbGljZShpICsgMSk7XG4gICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCBpKTtcbiAgICB9XG4gICAgaWYgKHR5cGUpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHRoaXNbdHlwZV0ub24obmFtZSkgOiB0aGlzW3R5cGVdLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIGZvciAodHlwZSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHR5cGUpKSB0aGlzW3R5cGVdLm9uKG5hbWUsIG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBbXSwgbGlzdGVuZXJCeU5hbWUgPSBuZXcgZDNfTWFwKCk7XG4gICAgZnVuY3Rpb24gZXZlbnQoKSB7XG4gICAgICB2YXIgeiA9IGxpc3RlbmVycywgaSA9IC0xLCBuID0gei5sZW5ndGgsIGw7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGwgPSB6W2ldLm9uKSBsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2g7XG4gICAgfVxuICAgIGV2ZW50Lm9uID0gZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsID0gbGlzdGVuZXJCeU5hbWUuZ2V0KG5hbWUpLCBpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gbCAmJiBsLm9uO1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgbC5vbiA9IG51bGw7XG4gICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgwLCBpID0gbGlzdGVuZXJzLmluZGV4T2YobCkpLmNvbmNhdChsaXN0ZW5lcnMuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgbGlzdGVuZXJCeU5hbWUucmVtb3ZlKG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3RlbmVyKSBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lckJ5TmFtZS5zZXQobmFtZSwge1xuICAgICAgICBvbjogbGlzdGVuZXJcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaDtcbiAgICB9O1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBkMy5ldmVudCA9IG51bGw7XG4gIGZ1bmN0aW9uIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKSB7XG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19ldmVudFNvdXJjZSgpIHtcbiAgICB2YXIgZSA9IGQzLmV2ZW50LCBzO1xuICAgIHdoaWxlIChzID0gZS5zb3VyY2VFdmVudCkgZSA9IHM7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZXZlbnREaXNwYXRjaCh0YXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBuZXcgZDNfZGlzcGF0Y2goKSwgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkaXNwYXRjaFthcmd1bWVudHNbaV1dID0gZDNfZGlzcGF0Y2hfZXZlbnQoZGlzcGF0Y2gpO1xuICAgIGRpc3BhdGNoLm9mID0gZnVuY3Rpb24odGhpeiwgYXJndW1lbnR6KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZTEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZTAgPSBlMS5zb3VyY2VFdmVudCA9IGQzLmV2ZW50O1xuICAgICAgICAgIGUxLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICBkMy5ldmVudCA9IGUxO1xuICAgICAgICAgIGRpc3BhdGNoW2UxLnR5cGVdLmFwcGx5KHRoaXosIGFyZ3VtZW50eik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZDMuZXZlbnQgPSBlMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBkaXNwYXRjaDtcbiAgfVxuICBkMy5yZXF1b3RlID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoZDNfcmVxdW90ZV9yZSwgXCJcXFxcJCZcIik7XG4gIH07XG4gIHZhciBkM19yZXF1b3RlX3JlID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuICB2YXIgZDNfc3ViY2xhc3MgPSB7fS5fX3Byb3RvX18gPyBmdW5jdGlvbihvYmplY3QsIHByb3RvdHlwZSkge1xuICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gIH0gOiBmdW5jdGlvbihvYmplY3QsIHByb3RvdHlwZSkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHByb3RvdHlwZSkgb2JqZWN0W3Byb3BlcnR5XSA9IHByb3RvdHlwZVtwcm9wZXJ0eV07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbihncm91cHMpIHtcbiAgICBkM19zdWJjbGFzcyhncm91cHMsIGQzX3NlbGVjdGlvblByb3RvdHlwZSk7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuICB2YXIgZDNfc2VsZWN0ID0gZnVuY3Rpb24ocywgbikge1xuICAgIHJldHVybiBuLnF1ZXJ5U2VsZWN0b3Iocyk7XG4gIH0sIGQzX3NlbGVjdEFsbCA9IGZ1bmN0aW9uKHMsIG4pIHtcbiAgICByZXR1cm4gbi5xdWVyeVNlbGVjdG9yQWxsKHMpO1xuICB9LCBkM19zZWxlY3RNYXRjaGVzID0gZnVuY3Rpb24obiwgcykge1xuICAgIHZhciBkM19zZWxlY3RNYXRjaGVyID0gbi5tYXRjaGVzIHx8IG5bZDNfdmVuZG9yU3ltYm9sKG4sIFwibWF0Y2hlc1NlbGVjdG9yXCIpXTtcbiAgICBkM19zZWxlY3RNYXRjaGVzID0gZnVuY3Rpb24obiwgcykge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdE1hdGNoZXIuY2FsbChuLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zZWxlY3RNYXRjaGVzKG4sIHMpO1xuICB9O1xuICBpZiAodHlwZW9mIFNpenpsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZDNfc2VsZWN0ID0gZnVuY3Rpb24ocywgbikge1xuICAgICAgcmV0dXJuIFNpenpsZShzLCBuKVswXSB8fCBudWxsO1xuICAgIH07XG4gICAgZDNfc2VsZWN0QWxsID0gU2l6emxlO1xuICAgIGQzX3NlbGVjdE1hdGNoZXMgPSBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yO1xuICB9XG4gIGQzLnNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zZWxlY3QoZDNfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgfTtcbiAgdmFyIGQzX3NlbGVjdGlvblByb3RvdHlwZSA9IGQzLnNlbGVjdGlvbi5wcm90b3R5cGUgPSBbXTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZSwgZ3JvdXAsIG5vZGU7XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IChncm91cCA9IHRoaXNbal0pLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKHZhciBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChzdWJub2RlID0gc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSk7XG4gICAgICAgICAgaWYgKHN1Ym5vZGUgJiYgXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fc2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3RvciA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdChzZWxlY3RvciwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBub2RlO1xuICAgIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IGQzX2FycmF5KHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpKTtcbiAgICAgICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zZWxlY3RvckFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdG9yIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0QWxsKHNlbGVjdG9yLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19uc1hodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gIHZhciBkM19uc1ByZWZpeCA9IHtcbiAgICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB4aHRtbDogZDNfbnNYaHRtbCxcbiAgICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbiAgfTtcbiAgZDMubnMgPSB7XG4gICAgcHJlZml4OiBkM19uc1ByZWZpeCxcbiAgICBxdWFsaWZ5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIjpcIiksIHByZWZpeCA9IG5hbWU7XG4gICAgICBpZiAoaSA+PSAwICYmIChwcmVmaXggPSBuYW1lLnNsaWNlKDAsIGkpKSAhPT0gXCJ4bWxuc1wiKSBuYW1lID0gbmFtZS5zbGljZShpICsgMSk7XG4gICAgICByZXR1cm4gZDNfbnNQcmVmaXguaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtcbiAgICAgICAgc3BhY2U6IGQzX25zUHJlZml4W3ByZWZpeF0sXG4gICAgICAgIGxvY2FsOiBuYW1lXG4gICAgICB9IDogbmFtZTtcbiAgICB9XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuICAgICAgICBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5hbWUubG9jYWwgPyBub2RlLmdldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpIDogbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhbHVlIGluIG5hbWUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fYXR0cih2YWx1ZSwgbmFtZVt2YWx1ZV0pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9hdHRyKG5hbWUsIHZhbHVlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9hdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZSk7XG4gICAgZnVuY3Rpb24gYXR0ck51bGwoKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ck51bGxOUygpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJDb25zdGFudCgpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHggPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7IGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgeCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKCkge1xuICAgICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHggPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTsgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwsIHgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG5hbWUubG9jYWwgPyBhdHRyTnVsbE5TIDogYXR0ck51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbiA6IG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudDtcbiAgfVxuICBmdW5jdGlvbiBkM19jb2xsYXBzZShzKSB7XG4gICAgcmV0dXJuIHMudHJpbSgpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5jbGFzc2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpLCBuID0gKG5hbWUgPSBkM19zZWxlY3Rpb25fY2xhc3NlcyhuYW1lKSkubGVuZ3RoLCBpID0gLTE7XG4gICAgICAgIGlmICh2YWx1ZSA9IG5vZGUuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghdmFsdWUuY29udGFpbnMobmFtZVtpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghZDNfc2VsZWN0aW9uX2NsYXNzZWRSZShuYW1lW2ldKS50ZXN0KHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2NsYXNzZWQodmFsdWUsIG5hbWVbdmFsdWVdKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fY2xhc3NlZChuYW1lLCB2YWx1ZSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlZFJlKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/Ol58XFxcXHMrKVwiICsgZDMucmVxdW90ZShuYW1lKSArIFwiKD86XFxcXHMrfCQpXCIsIFwiZ1wiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlcyhuYW1lKSB7XG4gICAgcmV0dXJuIChuYW1lICsgXCJcIikudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlZChuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBkM19zZWxlY3Rpb25fY2xhc3NlcyhuYW1lKS5tYXAoZDNfc2VsZWN0aW9uX2NsYXNzZWROYW1lKTtcbiAgICB2YXIgbiA9IG5hbWUubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIGNsYXNzZWRDb25zdGFudCgpIHtcbiAgICAgIHZhciBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikgbmFtZVtpXSh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gLTEsIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIG5hbWVbaV0odGhpcywgeCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNsYXNzZWRGdW5jdGlvbiA6IGNsYXNzZWRDb25zdGFudDtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlZE5hbWUobmFtZSkge1xuICAgIHZhciByZSA9IGQzX3NlbGVjdGlvbl9jbGFzc2VkUmUobmFtZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICBpZiAoYyA9IG5vZGUuY2xhc3NMaXN0KSByZXR1cm4gdmFsdWUgPyBjLmFkZChuYW1lKSA6IGMucmVtb3ZlKG5hbWUpO1xuICAgICAgdmFyIGMgPSBub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCI7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaWYgKCFyZS50ZXN0KGMpKSBub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGQzX2NvbGxhcHNlKGMgKyBcIiBcIiArIG5hbWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZDNfY29sbGFwc2UoYy5yZXBsYWNlKHJlLCBcIiBcIikpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDMpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobiA8IDIpIHZhbHVlID0gXCJcIjtcbiAgICAgICAgZm9yIChwcmlvcml0eSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3N0eWxlKHByaW9yaXR5LCBuYW1lW3ByaW9yaXR5XSwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAobiA8IDIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICAgICAgcmV0dXJuIGQzX3dpbmRvdyhub2RlKS5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG4gICAgICB9XG4gICAgICBwcmlvcml0eSA9IFwiXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3N0eWxlKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fc3R5bGUobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgZnVuY3Rpb24gc3R5bGVOdWxsKCkge1xuICAgICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGVDb25zdGFudCgpIHtcbiAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGVGdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh4ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7IGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB4LCBwcmlvcml0eSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gc3R5bGVOdWxsIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZUZ1bmN0aW9uIDogc3R5bGVDb25zdGFudDtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUucHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSByZXR1cm4gdGhpcy5ub2RlKClbbmFtZV07XG4gICAgICBmb3IgKHZhbHVlIGluIG5hbWUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fcHJvcGVydHkodmFsdWUsIG5hbWVbdmFsdWVdKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fcHJvcGVydHkobmFtZSwgdmFsdWUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgZnVuY3Rpb24gcHJvcGVydHlOdWxsKCkge1xuICAgICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQoKSB7XG4gICAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTsgZWxzZSB0aGlzW25hbWVdID0geDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBwcm9wZXJ0eU51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHByb3BlcnR5RnVuY3Rpb24gOiBwcm9wZXJ0eUNvbnN0YW50O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuZWFjaCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICAgIH0gOiB2YWx1ZSA9PSBudWxsID8gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgfSkgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5lYWNoKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICAgIH0gOiB2YWx1ZSA9PSBudWxsID8gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlubmVySFRNTCA9IFwiXCI7XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICB9KSA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gZDNfc2VsZWN0aW9uX2NyZWF0b3IobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQobmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NyZWF0b3IobmFtZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCwgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgICByZXR1cm4gbmFtZXNwYWNlID09PSBkM19uc1hodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IGQzX25zWGh0bWwgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5TKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IChuYW1lID0gZDMubnMucXVhbGlmeShuYW1lKSkubG9jYWwgPyBjcmVhdGVOUyA6IGNyZWF0ZTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gICAgbmFtZSA9IGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpO1xuICAgIGJlZm9yZSA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvcihiZWZvcmUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShuYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGJlZm9yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICAgIH0pO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25SZW1vdmUpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25SZW1vdmUoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoLCBncm91cCwgbm9kZTtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gbmV3IEFycmF5KG4gPSAoZ3JvdXAgPSB0aGlzWzBdKS5sZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHZhbHVlW2ldID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiaW5kKGdyb3VwLCBncm91cERhdGEpIHtcbiAgICAgIHZhciBpLCBuID0gZ3JvdXAubGVuZ3RoLCBtID0gZ3JvdXBEYXRhLmxlbmd0aCwgbjAgPSBNYXRoLm1pbihuLCBtKSwgdXBkYXRlTm9kZXMgPSBuZXcgQXJyYXkobSksIGVudGVyTm9kZXMgPSBuZXcgQXJyYXkobSksIGV4aXROb2RlcyA9IG5ldyBBcnJheShuKSwgbm9kZSwgbm9kZURhdGE7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciBub2RlQnlLZXlWYWx1ZSA9IG5ldyBkM19NYXAoKSwga2V5VmFsdWVzID0gbmV3IEFycmF5KG4pLCBrZXlWYWx1ZTtcbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG47ICkge1xuICAgICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICAgIGlmIChub2RlQnlLZXlWYWx1ZS5oYXMoa2V5VmFsdWUgPSBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKSkpIHtcbiAgICAgICAgICAgICAgZXhpdE5vZGVzW2ldID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGVCeUtleVZhbHVlLnNldChrZXlWYWx1ZSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG07ICkge1xuICAgICAgICAgIGlmICghKG5vZGUgPSBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWUgPSBrZXkuY2FsbChncm91cERhdGEsIG5vZGVEYXRhID0gZ3JvdXBEYXRhW2ldLCBpKSkpKSB7XG4gICAgICAgICAgICBlbnRlck5vZGVzW2ldID0gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKG5vZGVEYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVzW2ldID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUuX19kYXRhX18gPSBub2RlRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbjsgKSB7XG4gICAgICAgICAgaWYgKGkgaW4ga2V5VmFsdWVzICYmIG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZXNbaV0pICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBleGl0Tm9kZXNbaV0gPSBncm91cFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBuMDsgKSB7XG4gICAgICAgICAgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgICAgIG5vZGVEYXRhID0gZ3JvdXBEYXRhW2ldO1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLl9fZGF0YV9fID0gbm9kZURhdGE7XG4gICAgICAgICAgICB1cGRhdGVOb2Rlc1tpXSA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudGVyTm9kZXNbaV0gPSBkM19zZWxlY3Rpb25fZGF0YU5vZGUobm9kZURhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDtpIDwgbTsgKytpKSB7XG4gICAgICAgICAgZW50ZXJOb2Rlc1tpXSA9IGQzX3NlbGVjdGlvbl9kYXRhTm9kZShncm91cERhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoO2kgPCBuOyArK2kpIHtcbiAgICAgICAgICBleGl0Tm9kZXNbaV0gPSBncm91cFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW50ZXJOb2Rlcy51cGRhdGUgPSB1cGRhdGVOb2RlcztcbiAgICAgIGVudGVyTm9kZXMucGFyZW50Tm9kZSA9IHVwZGF0ZU5vZGVzLnBhcmVudE5vZGUgPSBleGl0Tm9kZXMucGFyZW50Tm9kZSA9IGdyb3VwLnBhcmVudE5vZGU7XG4gICAgICBlbnRlci5wdXNoKGVudGVyTm9kZXMpO1xuICAgICAgdXBkYXRlLnB1c2godXBkYXRlTm9kZXMpO1xuICAgICAgZXhpdC5wdXNoKGV4aXROb2Rlcyk7XG4gICAgfVxuICAgIHZhciBlbnRlciA9IGQzX3NlbGVjdGlvbl9lbnRlcihbXSksIHVwZGF0ZSA9IGQzX3NlbGVjdGlvbihbXSksIGV4aXQgPSBkM19zZWxlY3Rpb24oW10pO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYmluZChncm91cCA9IHRoaXNbaV0sIHZhbHVlLmNhbGwoZ3JvdXAsIGdyb3VwLnBhcmVudE5vZGUuX19kYXRhX18sIGkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYmluZChncm91cCA9IHRoaXNbaV0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlLmVudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW50ZXI7XG4gICAgfTtcbiAgICB1cGRhdGUuZXhpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4aXQ7XG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZGF0YU5vZGUoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBfX2RhdGFfXzogZGF0YVxuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmRhdHVtID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB2YWx1ZSkgOiB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIik7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBncm91cCwgbm9kZTtcbiAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkM19zZWxlY3Rpb25fZmlsdGVyKGZpbHRlcik7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSB0aGlzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gKGdyb3VwID0gdGhpc1tqXSkucGFyZW50Tm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBmaWx0ZXIuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZmlsdGVyKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdE1hdGNoZXModGhpcywgc2VsZWN0b3IpO1xuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBub2RlLm5leHRTaWJsaW5nKSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICBjb21wYXJhdG9yID0gZDNfc2VsZWN0aW9uX3NvcnRDb21wYXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkgdGhpc1tqXS5zb3J0KGNvbXBhcmF0b3IpO1xuICAgIHJldHVybiB0aGlzLm9yZGVyKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zb3J0Q29tcGFyYXRvcihjb21wYXJhdG9yKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSBjb21wYXJhdG9yID0gZDNfYXNjZW5kaW5nO1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAmJiBiID8gY29tcGFyYXRvcihhLl9fZGF0YV9fLCBiLl9fZGF0YV9fKSA6ICFhIC0gIWI7XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaik7XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9lYWNoKGdyb3VwcywgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBjYWxsYmFjayhub2RlLCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ3MgPSBkM19hcnJheShhcmd1bWVudHMpO1xuICAgIGNhbGxiYWNrLmFwcGx5KGFyZ3NbMF0gPSB0aGlzLCBhcmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSAwO1xuICAgIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgKytuO1xuICAgIH0pO1xuICAgIHJldHVybiBuO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZW50ZXIoc2VsZWN0aW9uKSB7XG4gICAgZDNfc3ViY2xhc3Moc2VsZWN0aW9uLCBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUpO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgdmFyIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZSA9IFtdO1xuICBkMy5zZWxlY3Rpb24uZW50ZXIgPSBkM19zZWxlY3Rpb25fZW50ZXI7XG4gIGQzLnNlbGVjdGlvbi5lbnRlci5wcm90b3R5cGUgPSBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGU7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5hcHBlbmQgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuYXBwZW5kO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuZW1wdHkgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZW1wdHk7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5ub2RlID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLm5vZGU7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5jYWxsID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNhbGw7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5zaXplID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNpemU7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGUsIHVwZ3JvdXAsIGdyb3VwLCBub2RlO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHVwZ3JvdXAgPSAoZ3JvdXAgPSB0aGlzW2pdKS51cGRhdGU7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSBncm91cC5wYXJlbnROb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2godXBncm91cFtpXSA9IHN1Ym5vZGUgPSBzZWxlY3Rvci5jYWxsKGdyb3VwLnBhcmVudE5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKTtcbiAgICAgICAgICBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKG5hbWUsIGJlZm9yZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgYmVmb3JlID0gZDNfc2VsZWN0aW9uX2VudGVySW5zZXJ0QmVmb3JlKHRoaXMpO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25Qcm90b3R5cGUuaW5zZXJ0LmNhbGwodGhpcywgbmFtZSwgYmVmb3JlKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2VudGVySW5zZXJ0QmVmb3JlKGVudGVyKSB7XG4gICAgdmFyIGkwLCBqMDtcbiAgICByZXR1cm4gZnVuY3Rpb24oZCwgaSwgaikge1xuICAgICAgdmFyIGdyb3VwID0gZW50ZXJbal0udXBkYXRlLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlO1xuICAgICAgaWYgKGogIT0gajApIGowID0gaiwgaTAgPSAwO1xuICAgICAgaWYgKGkgPj0gaTApIGkwID0gaSArIDE7XG4gICAgICB3aGlsZSAoIShub2RlID0gZ3JvdXBbaTBdKSAmJiArK2kwIDwgbikgO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfVxuICBkMy5zZWxlY3QgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGdyb3VwO1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZ3JvdXAgPSBbIGQzX3NlbGVjdChub2RlLCBkM19kb2N1bWVudCkgXTtcbiAgICAgIGdyb3VwLnBhcmVudE5vZGUgPSBkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwID0gWyBub2RlIF07XG4gICAgICBncm91cC5wYXJlbnROb2RlID0gZDNfZG9jdW1lbnRFbGVtZW50KG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKFsgZ3JvdXAgXSk7XG4gIH07XG4gIGQzLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgdmFyIGdyb3VwO1xuICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGdyb3VwID0gZDNfYXJyYXkoZDNfc2VsZWN0QWxsKG5vZGVzLCBkM19kb2N1bWVudCkpO1xuICAgICAgZ3JvdXAucGFyZW50Tm9kZSA9IGQzX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSBkM19hcnJheShub2Rlcyk7XG4gICAgICBncm91cC5wYXJlbnROb2RlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihbIGdyb3VwIF0pO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDMpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobiA8IDIpIGxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAoY2FwdHVyZSBpbiB0eXBlKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX29uKGNhcHR1cmUsIHR5cGVbY2FwdHVyZV0sIGxpc3RlbmVyKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCAyKSByZXR1cm4gKG4gPSB0aGlzLm5vZGUoKVtcIl9fb25cIiArIHR5cGVdKSAmJiBuLl87XG4gICAgICBjYXB0dXJlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX29uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9vbih0eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICAgIHZhciBuYW1lID0gXCJfX29uXCIgKyB0eXBlLCBpID0gdHlwZS5pbmRleE9mKFwiLlwiKSwgd3JhcCA9IGQzX3NlbGVjdGlvbl9vbkxpc3RlbmVyO1xuICAgIGlmIChpID4gMCkgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGZpbHRlciA9IGQzX3NlbGVjdGlvbl9vbkZpbHRlcnMuZ2V0KHR5cGUpO1xuICAgIGlmIChmaWx0ZXIpIHR5cGUgPSBmaWx0ZXIsIHdyYXAgPSBkM19zZWxlY3Rpb25fb25GaWx0ZXI7XG4gICAgZnVuY3Rpb24gb25SZW1vdmUoKSB7XG4gICAgICB2YXIgbCA9IHRoaXNbbmFtZV07XG4gICAgICBpZiAobCkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbCwgbC4kKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQWRkKCkge1xuICAgICAgdmFyIGwgPSB3cmFwKGxpc3RlbmVyLCBkM19hcnJheShhcmd1bWVudHMpKTtcbiAgICAgIG9uUmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpc1tuYW1lXSA9IGwsIGwuJCA9IGNhcHR1cmUpO1xuICAgICAgbC5fID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcbiAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCJeX19vbihbXi5dKylcIiArIGQzLnJlcXVvdGUodHlwZSkgKyBcIiRcIiksIG1hdGNoO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgIGlmIChtYXRjaCA9IG5hbWUubWF0Y2gocmUpKSB7XG4gICAgICAgICAgdmFyIGwgPSB0aGlzW25hbWVdO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihtYXRjaFsxXSwgbCwgbC4kKTtcbiAgICAgICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaSA/IGxpc3RlbmVyID8gb25BZGQgOiBvblJlbW92ZSA6IGxpc3RlbmVyID8gZDNfbm9vcCA6IHJlbW92ZUFsbDtcbiAgfVxuICB2YXIgZDNfc2VsZWN0aW9uX29uRmlsdGVycyA9IGQzLm1hcCh7XG4gICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbiAgfSk7XG4gIGlmIChkM19kb2N1bWVudCkge1xuICAgIGQzX3NlbGVjdGlvbl9vbkZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoXCJvblwiICsgayBpbiBkM19kb2N1bWVudCkgZDNfc2VsZWN0aW9uX29uRmlsdGVycy5yZW1vdmUoayk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX29uTGlzdGVuZXIobGlzdGVuZXIsIGFyZ3VtZW50eikge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgbyA9IGQzLmV2ZW50O1xuICAgICAgZDMuZXZlbnQgPSBlO1xuICAgICAgYXJndW1lbnR6WzBdID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50eik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkMy5ldmVudCA9IG87XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fb25GaWx0ZXIobGlzdGVuZXIsIGFyZ3VtZW50eikge1xuICAgIHZhciBsID0gZDNfc2VsZWN0aW9uX29uTGlzdGVuZXIobGlzdGVuZXIsIGFyZ3VtZW50eik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xuICAgICAgaWYgKCFyZWxhdGVkIHx8IHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhKHJlbGF0ZWQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGFyZ2V0KSAmIDgpKSB7XG4gICAgICAgIGwuY2FsbCh0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdmFyIGQzX2V2ZW50X2RyYWdTZWxlY3QsIGQzX2V2ZW50X2RyYWdJZCA9IDA7XG4gIGZ1bmN0aW9uIGQzX2V2ZW50X2RyYWdTdXBwcmVzcyhub2RlKSB7XG4gICAgdmFyIG5hbWUgPSBcIi5kcmFnc3VwcHJlc3MtXCIgKyArK2QzX2V2ZW50X2RyYWdJZCwgY2xpY2sgPSBcImNsaWNrXCIgKyBuYW1lLCB3ID0gZDMuc2VsZWN0KGQzX3dpbmRvdyhub2RlKSkub24oXCJ0b3VjaG1vdmVcIiArIG5hbWUsIGQzX2V2ZW50UHJldmVudERlZmF1bHQpLm9uKFwiZHJhZ3N0YXJ0XCIgKyBuYW1lLCBkM19ldmVudFByZXZlbnREZWZhdWx0KS5vbihcInNlbGVjdHN0YXJ0XCIgKyBuYW1lLCBkM19ldmVudFByZXZlbnREZWZhdWx0KTtcbiAgICBpZiAoZDNfZXZlbnRfZHJhZ1NlbGVjdCA9PSBudWxsKSB7XG4gICAgICBkM19ldmVudF9kcmFnU2VsZWN0ID0gXCJvbnNlbGVjdHN0YXJ0XCIgaW4gbm9kZSA/IGZhbHNlIDogZDNfdmVuZG9yU3ltYm9sKG5vZGUuc3R5bGUsIFwidXNlclNlbGVjdFwiKTtcbiAgICB9XG4gICAgaWYgKGQzX2V2ZW50X2RyYWdTZWxlY3QpIHtcbiAgICAgIHZhciBzdHlsZSA9IGQzX2RvY3VtZW50RWxlbWVudChub2RlKS5zdHlsZSwgc2VsZWN0ID0gc3R5bGVbZDNfZXZlbnRfZHJhZ1NlbGVjdF07XG4gICAgICBzdHlsZVtkM19ldmVudF9kcmFnU2VsZWN0XSA9IFwibm9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oc3VwcHJlc3NDbGljaykge1xuICAgICAgdy5vbihuYW1lLCBudWxsKTtcbiAgICAgIGlmIChkM19ldmVudF9kcmFnU2VsZWN0KSBzdHlsZVtkM19ldmVudF9kcmFnU2VsZWN0XSA9IHNlbGVjdDtcbiAgICAgIGlmIChzdXBwcmVzc0NsaWNrKSB7XG4gICAgICAgIHZhciBvZmYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB3Lm9uKGNsaWNrLCBudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdy5vbihjbGljaywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIG9mZigpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgc2V0VGltZW91dChvZmYsIDApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDMubW91c2UgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICByZXR1cm4gZDNfbW91c2VQb2ludChjb250YWluZXIsIGQzX2V2ZW50U291cmNlKCkpO1xuICB9O1xuICB2YXIgZDNfbW91c2VfYnVnNDQwODMgPSB0aGlzLm5hdmlnYXRvciAmJiAvV2ViS2l0Ly50ZXN0KHRoaXMubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyAtMSA6IDA7XG4gIGZ1bmN0aW9uIGQzX21vdXNlUG9pbnQoY29udGFpbmVyLCBlKSB7XG4gICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMpIGUgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHZhciBzdmcgPSBjb250YWluZXIub3duZXJTVkdFbGVtZW50IHx8IGNvbnRhaW5lcjtcbiAgICBpZiAoc3ZnLmNyZWF0ZVNWR1BvaW50KSB7XG4gICAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgIGlmIChkM19tb3VzZV9idWc0NDA4MyA8IDApIHtcbiAgICAgICAgdmFyIHdpbmRvdyA9IGQzX3dpbmRvdyhjb250YWluZXIpO1xuICAgICAgICBpZiAod2luZG93LnNjcm9sbFggfHwgd2luZG93LnNjcm9sbFkpIHtcbiAgICAgICAgICBzdmcgPSBkMy5zZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcInN2Z1wiKS5zdHlsZSh7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiXG4gICAgICAgICAgfSwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgICAgdmFyIGN0bSA9IHN2Z1swXVswXS5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgICBkM19tb3VzZV9idWc0NDA4MyA9ICEoY3RtLmYgfHwgY3RtLmUpO1xuICAgICAgICAgIHN2Zy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGQzX21vdXNlX2J1ZzQ0MDgzKSBwb2ludC54ID0gZS5wYWdlWCwgcG9pbnQueSA9IGUucGFnZVk7IGVsc2UgcG9pbnQueCA9IGUuY2xpZW50WCwgXG4gICAgICBwb2ludC55ID0gZS5jbGllbnRZO1xuICAgICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0oY29udGFpbmVyLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICByZXR1cm4gWyBwb2ludC54LCBwb2ludC55IF07XG4gICAgfVxuICAgIHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBbIGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LCBlLmNsaWVudFkgLSByZWN0LnRvcCAtIGNvbnRhaW5lci5jbGllbnRUb3AgXTtcbiAgfVxuICBkMy50b3VjaCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgdG91Y2hlcywgaWRlbnRpZmllcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgaWRlbnRpZmllciA9IHRvdWNoZXMsIHRvdWNoZXMgPSBkM19ldmVudFNvdXJjZSgpLmNoYW5nZWRUb3VjaGVzO1xuICAgIGlmICh0b3VjaGVzKSBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMubGVuZ3RoLCB0b3VjaDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0b3VjaCA9IHRvdWNoZXNbaV0pLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIGQzX21vdXNlUG9pbnQoY29udGFpbmVyLCB0b3VjaCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBkMy5iZWhhdmlvci5kcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV2ZW50ID0gZDNfZXZlbnREaXNwYXRjaChkcmFnLCBcImRyYWdcIiwgXCJkcmFnc3RhcnRcIiwgXCJkcmFnZW5kXCIpLCBvcmlnaW4gPSBudWxsLCBtb3VzZWRvd24gPSBkcmFnc3RhcnQoZDNfbm9vcCwgZDMubW91c2UsIGQzX3dpbmRvdywgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZXVwXCIpLCB0b3VjaHN0YXJ0ID0gZHJhZ3N0YXJ0KGQzX2JlaGF2aW9yX2RyYWdUb3VjaElkLCBkMy50b3VjaCwgZDNfaWRlbnRpdHksIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIik7XG4gICAgZnVuY3Rpb24gZHJhZygpIHtcbiAgICAgIHRoaXMub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBtb3VzZWRvd24pLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIHRvdWNoc3RhcnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmFnc3RhcnQoaWQsIHBvc2l0aW9uLCBzdWJqZWN0LCBtb3ZlLCBlbmQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCB0YXJnZXQgPSBkMy5ldmVudC50YXJnZXQuY29ycmVzcG9uZGluZ0VsZW1lbnQgfHwgZDMuZXZlbnQudGFyZ2V0LCBwYXJlbnQgPSB0aGF0LnBhcmVudE5vZGUsIGRpc3BhdGNoID0gZXZlbnQub2YodGhhdCwgYXJndW1lbnRzKSwgZHJhZ2dlZCA9IDAsIGRyYWdJZCA9IGlkKCksIGRyYWdOYW1lID0gXCIuZHJhZ1wiICsgKGRyYWdJZCA9PSBudWxsID8gXCJcIiA6IFwiLVwiICsgZHJhZ0lkKSwgZHJhZ09mZnNldCwgZHJhZ1N1YmplY3QgPSBkMy5zZWxlY3Qoc3ViamVjdCh0YXJnZXQpKS5vbihtb3ZlICsgZHJhZ05hbWUsIG1vdmVkKS5vbihlbmQgKyBkcmFnTmFtZSwgZW5kZWQpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcyh0YXJnZXQpLCBwb3NpdGlvbjAgPSBwb3NpdGlvbihwYXJlbnQsIGRyYWdJZCk7XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICBkcmFnT2Zmc2V0ID0gb3JpZ2luLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZHJhZ09mZnNldCA9IFsgZHJhZ09mZnNldC54IC0gcG9zaXRpb24wWzBdLCBkcmFnT2Zmc2V0LnkgLSBwb3NpdGlvbjBbMV0gXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmFnT2Zmc2V0ID0gWyAwLCAwIF07XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IFwiZHJhZ3N0YXJ0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbjEgPSBwb3NpdGlvbihwYXJlbnQsIGRyYWdJZCksIGR4LCBkeTtcbiAgICAgICAgICBpZiAoIXBvc2l0aW9uMSkgcmV0dXJuO1xuICAgICAgICAgIGR4ID0gcG9zaXRpb24xWzBdIC0gcG9zaXRpb24wWzBdO1xuICAgICAgICAgIGR5ID0gcG9zaXRpb24xWzFdIC0gcG9zaXRpb24wWzFdO1xuICAgICAgICAgIGRyYWdnZWQgfD0gZHggfCBkeTtcbiAgICAgICAgICBwb3NpdGlvbjAgPSBwb3NpdGlvbjE7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogXCJkcmFnXCIsXG4gICAgICAgICAgICB4OiBwb3NpdGlvbjFbMF0gKyBkcmFnT2Zmc2V0WzBdLFxuICAgICAgICAgICAgeTogcG9zaXRpb24xWzFdICsgZHJhZ09mZnNldFsxXSxcbiAgICAgICAgICAgIGR4OiBkeCxcbiAgICAgICAgICAgIGR5OiBkeVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICAgIGlmICghcG9zaXRpb24ocGFyZW50LCBkcmFnSWQpKSByZXR1cm47XG4gICAgICAgICAgZHJhZ1N1YmplY3Qub24obW92ZSArIGRyYWdOYW1lLCBudWxsKS5vbihlbmQgKyBkcmFnTmFtZSwgbnVsbCk7XG4gICAgICAgICAgZHJhZ1Jlc3RvcmUoZHJhZ2dlZCk7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogXCJkcmFnZW5kXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZHJhZy5vcmlnaW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmlnaW47XG4gICAgICBvcmlnaW4gPSB4O1xuICAgICAgcmV0dXJuIGRyYWc7XG4gICAgfTtcbiAgICByZXR1cm4gZDMucmViaW5kKGRyYWcsIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19iZWhhdmlvcl9kcmFnVG91Y2hJZCgpIHtcbiAgICByZXR1cm4gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbiAgfVxuICBkMy50b3VjaGVzID0gZnVuY3Rpb24oY29udGFpbmVyLCB0b3VjaGVzKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB0b3VjaGVzID0gZDNfZXZlbnRTb3VyY2UoKS50b3VjaGVzO1xuICAgIHJldHVybiB0b3VjaGVzID8gZDNfYXJyYXkodG91Y2hlcykubWFwKGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICB2YXIgcG9pbnQgPSBkM19tb3VzZVBvaW50KGNvbnRhaW5lciwgdG91Y2gpO1xuICAgICAgcG9pbnQuaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSkgOiBbXTtcbiAgfTtcbiAgdmFyIM61ID0gMWUtNiwgzrUyID0gzrUgKiDOtSwgz4AgPSBNYXRoLlBJLCDPhCA9IDIgKiDPgCwgz4TOtSA9IM+EIC0gzrUsIGhhbGbPgCA9IM+AIC8gMiwgZDNfcmFkaWFucyA9IM+AIC8gMTgwLCBkM19kZWdyZWVzID0gMTgwIC8gz4A7XG4gIGZ1bmN0aW9uIGQzX3Nnbih4KSB7XG4gICAgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Nyb3NzMmQoYSwgYiwgYykge1xuICAgIHJldHVybiAoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSAtIChiWzFdIC0gYVsxXSkgKiAoY1swXSAtIGFbMF0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Fjb3MoeCkge1xuICAgIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyDPgCA6IE1hdGguYWNvcyh4KTtcbiAgfVxuICBmdW5jdGlvbiBkM19hc2luKHgpIHtcbiAgICByZXR1cm4geCA+IDEgPyBoYWxmz4AgOiB4IDwgLTEgPyAtaGFsZs+AIDogTWF0aC5hc2luKHgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NpbmgoeCkge1xuICAgIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgLSAxIC8geCkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Nvc2goeCkge1xuICAgIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RhbmgoeCkge1xuICAgIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2hhdmVyc2luKHgpIHtcbiAgICByZXR1cm4gKHggPSBNYXRoLnNpbih4IC8gMikpICogeDtcbiAgfVxuICB2YXIgz4EgPSBNYXRoLlNRUlQyLCDPgTIgPSAyLCDPgTQgPSA0O1xuICBkMy5pbnRlcnBvbGF0ZVpvb20gPSBmdW5jdGlvbihwMCwgcDEpIHtcbiAgICB2YXIgdXgwID0gcDBbMF0sIHV5MCA9IHAwWzFdLCB3MCA9IHAwWzJdLCB1eDEgPSBwMVswXSwgdXkxID0gcDFbMV0sIHcxID0gcDFbMl0sIGR4ID0gdXgxIC0gdXgwLCBkeSA9IHV5MSAtIHV5MCwgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSwgaSwgUztcbiAgICBpZiAoZDIgPCDOtTIpIHtcbiAgICAgIFMgPSBNYXRoLmxvZyh3MSAvIHcwKSAvIM+BO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFsgdXgwICsgdCAqIGR4LCB1eTAgKyB0ICogZHksIHcwICogTWF0aC5leHAoz4EgKiB0ICogUykgXTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkMSA9IE1hdGguc3FydChkMiksIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgz4E0ICogZDIpIC8gKDIgKiB3MCAqIM+BMiAqIGQxKSwgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSDPgTQgKiBkMikgLyAoMiAqIHcxICogz4EyICogZDEpLCByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgICAgIFMgPSAocjEgLSByMCkgLyDPgTtcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gdCAqIFMsIGNvc2hyMCA9IGQzX2Nvc2gocjApLCB1ID0gdzAgLyAoz4EyICogZDEpICogKGNvc2hyMCAqIGQzX3Rhbmgoz4EgKiBzICsgcjApIC0gZDNfc2luaChyMCkpO1xuICAgICAgICByZXR1cm4gWyB1eDAgKyB1ICogZHgsIHV5MCArIHUgKiBkeSwgdzAgKiBjb3NocjAgLyBkM19jb3NoKM+BICogcyArIHIwKSBdO1xuICAgICAgfTtcbiAgICB9XG4gICAgaS5kdXJhdGlvbiA9IFMgKiAxZTM7XG4gICAgcmV0dXJuIGk7XG4gIH07XG4gIGQzLmJlaGF2aW9yLnpvb20gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmlldyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgazogMVxuICAgIH0sIHRyYW5zbGF0ZTAsIGNlbnRlcjAsIGNlbnRlciwgc2l6ZSA9IFsgOTYwLCA1MDAgXSwgc2NhbGVFeHRlbnQgPSBkM19iZWhhdmlvcl96b29tSW5maW5pdHksIGR1cmF0aW9uID0gMjUwLCB6b29taW5nID0gMCwgbW91c2Vkb3duID0gXCJtb3VzZWRvd24uem9vbVwiLCBtb3VzZW1vdmUgPSBcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNldXAgPSBcIm1vdXNldXAuem9vbVwiLCBtb3VzZXdoZWVsVGltZXIsIHRvdWNoc3RhcnQgPSBcInRvdWNoc3RhcnQuem9vbVwiLCB0b3VjaHRpbWUsIGV2ZW50ID0gZDNfZXZlbnREaXNwYXRjaCh6b29tLCBcInpvb21zdGFydFwiLCBcInpvb21cIiwgXCJ6b29tZW5kXCIpLCB4MCwgeDEsIHkwLCB5MTtcbiAgICBpZiAoIWQzX2JlaGF2aW9yX3pvb21XaGVlbCkge1xuICAgICAgZDNfYmVoYXZpb3Jfem9vbVdoZWVsID0gXCJvbndoZWVsXCIgaW4gZDNfZG9jdW1lbnQgPyAoZDNfYmVoYXZpb3Jfem9vbURlbHRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAtZDMuZXZlbnQuZGVsdGFZICogKGQzLmV2ZW50LmRlbHRhTW9kZSA/IDEyMCA6IDEpO1xuICAgICAgfSwgXCJ3aGVlbFwiKSA6IFwib25tb3VzZXdoZWVsXCIgaW4gZDNfZG9jdW1lbnQgPyAoZDNfYmVoYXZpb3Jfem9vbURlbHRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkMy5ldmVudC53aGVlbERlbHRhO1xuICAgICAgfSwgXCJtb3VzZXdoZWVsXCIpIDogKGQzX2JlaGF2aW9yX3pvb21EZWx0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gLWQzLmV2ZW50LmRldGFpbDtcbiAgICAgIH0sIFwiTW96TW91c2VQaXhlbFNjcm9sbFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbShnKSB7XG4gICAgICBnLm9uKG1vdXNlZG93biwgbW91c2Vkb3duZWQpLm9uKGQzX2JlaGF2aW9yX3pvb21XaGVlbCArIFwiLnpvb21cIiwgbW91c2V3aGVlbGVkKS5vbihcImRibGNsaWNrLnpvb21cIiwgZGJsY2xpY2tlZCkub24odG91Y2hzdGFydCwgdG91Y2hzdGFydGVkKTtcbiAgICB9XG4gICAgem9vbS5ldmVudCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpc3BhdGNoID0gZXZlbnQub2YodGhpcywgYXJndW1lbnRzKSwgdmlldzEgPSB2aWV3O1xuICAgICAgICBpZiAoZDNfdHJhbnNpdGlvbkluaGVyaXRJZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZWFjaChcInN0YXJ0Lnpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2aWV3ID0gdGhpcy5fX2NoYXJ0X18gfHwge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICBrOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIH0pLnR3ZWVuKFwiem9vbTp6b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGR4ID0gc2l6ZVswXSwgZHkgPSBzaXplWzFdLCBjeCA9IGNlbnRlcjAgPyBjZW50ZXIwWzBdIDogZHggLyAyLCBjeSA9IGNlbnRlcjAgPyBjZW50ZXIwWzFdIDogZHkgLyAyLCBpID0gZDMuaW50ZXJwb2xhdGVab29tKFsgKGN4IC0gdmlldy54KSAvIHZpZXcuaywgKGN5IC0gdmlldy55KSAvIHZpZXcuaywgZHggLyB2aWV3LmsgXSwgWyAoY3ggLSB2aWV3MS54KSAvIHZpZXcxLmssIChjeSAtIHZpZXcxLnkpIC8gdmlldzEuaywgZHggLyB2aWV3MS5rIF0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBpKHQpLCBrID0gZHggLyBsWzJdO1xuICAgICAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHZpZXcgPSB7XG4gICAgICAgICAgICAgICAgeDogY3ggLSBsWzBdICogayxcbiAgICAgICAgICAgICAgICB5OiBjeSAtIGxbMV0gKiBrLFxuICAgICAgICAgICAgICAgIGs6IGtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkuZWFjaChcImludGVycnVwdC56b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB9KS5lYWNoKFwiZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19jaGFydF9fID0gdmlldztcbiAgICAgICAgICB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHpvb20udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyB2aWV3LngsIHZpZXcueSBdO1xuICAgICAgdmlldyA9IHtcbiAgICAgICAgeDogK19bMF0sXG4gICAgICAgIHk6ICtfWzFdLFxuICAgICAgICBrOiB2aWV3LmtcbiAgICAgIH07XG4gICAgICByZXNjYWxlKCk7XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2aWV3Lms7XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiB2aWV3LngsXG4gICAgICAgIHk6IHZpZXcueSxcbiAgICAgICAgazogbnVsbFxuICAgICAgfTtcbiAgICAgIHNjYWxlVG8oK18pO1xuICAgICAgcmVzY2FsZSgpO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGVFeHRlbnQ7XG4gICAgICBzY2FsZUV4dGVudCA9IF8gPT0gbnVsbCA/IGQzX2JlaGF2aW9yX3pvb21JbmZpbml0eSA6IFsgK19bMF0sICtfWzFdIF07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2VudGVyO1xuICAgICAgY2VudGVyID0gXyAmJiBbICtfWzBdLCArX1sxXSBdO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IF8gJiYgWyArX1swXSwgK19bMV0gXTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5kdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGR1cmF0aW9uO1xuICAgICAgZHVyYXRpb24gPSArXztcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS54ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDE7XG4gICAgICB4MSA9IHo7XG4gICAgICB4MCA9IHouY29weSgpO1xuICAgICAgdmlldyA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgazogMVxuICAgICAgfTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS55ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTE7XG4gICAgICB5MSA9IHo7XG4gICAgICB5MCA9IHouY29weSgpO1xuICAgICAgdmlldyA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgazogMVxuICAgICAgfTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbG9jYXRpb24ocCkge1xuICAgICAgcmV0dXJuIFsgKHBbMF0gLSB2aWV3LngpIC8gdmlldy5rLCAocFsxXSAtIHZpZXcueSkgLyB2aWV3LmsgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnQobCkge1xuICAgICAgcmV0dXJuIFsgbFswXSAqIHZpZXcuayArIHZpZXcueCwgbFsxXSAqIHZpZXcuayArIHZpZXcueSBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZVRvKHMpIHtcbiAgICAgIHZpZXcuayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVUbyhwLCBsKSB7XG4gICAgICBsID0gcG9pbnQobCk7XG4gICAgICB2aWV3LnggKz0gcFswXSAtIGxbMF07XG4gICAgICB2aWV3LnkgKz0gcFsxXSAtIGxbMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb21Ubyh0aGF0LCBwLCBsLCBrKSB7XG4gICAgICB0aGF0Ll9fY2hhcnRfXyA9IHtcbiAgICAgICAgeDogdmlldy54LFxuICAgICAgICB5OiB2aWV3LnksXG4gICAgICAgIGs6IHZpZXcua1xuICAgICAgfTtcbiAgICAgIHNjYWxlVG8oTWF0aC5wb3coMiwgaykpO1xuICAgICAgdHJhbnNsYXRlVG8oY2VudGVyMCA9IHAsIGwpO1xuICAgICAgdGhhdCA9IGQzLnNlbGVjdCh0aGF0KTtcbiAgICAgIGlmIChkdXJhdGlvbiA+IDApIHRoYXQgPSB0aGF0LnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICB0aGF0LmNhbGwoem9vbS5ldmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICBpZiAoeDEpIHgxLmRvbWFpbih4MC5yYW5nZSgpLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAoeCAtIHZpZXcueCkgLyB2aWV3Lms7XG4gICAgICB9KS5tYXAoeDAuaW52ZXJ0KSk7XG4gICAgICBpZiAoeTEpIHkxLmRvbWFpbih5MC5yYW5nZSgpLm1hcChmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiAoeSAtIHZpZXcueSkgLyB2aWV3Lms7XG4gICAgICB9KS5tYXAoeTAuaW52ZXJ0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb21zdGFydGVkKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoIXpvb21pbmcrKykgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcInpvb21zdGFydFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbWVkKGRpc3BhdGNoKSB7XG4gICAgICByZXNjYWxlKCk7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiem9vbVwiLFxuICAgICAgICBzY2FsZTogdmlldy5rLFxuICAgICAgICB0cmFuc2xhdGU6IFsgdmlldy54LCB2aWV3LnkgXVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb21lbmRlZChkaXNwYXRjaCkge1xuICAgICAgaWYgKCEtLXpvb21pbmcpIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJ6b29tZW5kXCJcbiAgICAgIH0pLCBjZW50ZXIwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91c2Vkb3duZWQoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsIGRpc3BhdGNoID0gZXZlbnQub2YodGhhdCwgYXJndW1lbnRzKSwgZHJhZ2dlZCA9IDAsIHN1YmplY3QgPSBkMy5zZWxlY3QoZDNfd2luZG93KHRoYXQpKS5vbihtb3VzZW1vdmUsIG1vdmVkKS5vbihtb3VzZXVwLCBlbmRlZCksIGxvY2F0aW9uMCA9IGxvY2F0aW9uKGQzLm1vdXNlKHRoYXQpKSwgZHJhZ1Jlc3RvcmUgPSBkM19ldmVudF9kcmFnU3VwcHJlc3ModGhhdCk7XG4gICAgICBkM19zZWxlY3Rpb25faW50ZXJydXB0LmNhbGwodGhhdCk7XG4gICAgICB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICBmdW5jdGlvbiBtb3ZlZCgpIHtcbiAgICAgICAgZHJhZ2dlZCA9IDE7XG4gICAgICAgIHRyYW5zbGF0ZVRvKGQzLm1vdXNlKHRoYXQpLCBsb2NhdGlvbjApO1xuICAgICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICAgIHN1YmplY3Qub24obW91c2Vtb3ZlLCBudWxsKS5vbihtb3VzZXVwLCBudWxsKTtcbiAgICAgICAgZHJhZ1Jlc3RvcmUoZHJhZ2dlZCk7XG4gICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZCgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcywgZGlzcGF0Y2ggPSBldmVudC5vZih0aGF0LCBhcmd1bWVudHMpLCBsb2NhdGlvbnMwID0ge30sIGRpc3RhbmNlMCA9IDAsIHNjYWxlMCwgem9vbU5hbWUgPSBcIi56b29tLVwiICsgZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllciwgdG91Y2htb3ZlID0gXCJ0b3VjaG1vdmVcIiArIHpvb21OYW1lLCB0b3VjaGVuZCA9IFwidG91Y2hlbmRcIiArIHpvb21OYW1lLCB0YXJnZXRzID0gW10sIHN1YmplY3QgPSBkMy5zZWxlY3QodGhhdCksIGRyYWdSZXN0b3JlID0gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKHRoYXQpO1xuICAgICAgc3RhcnRlZCgpO1xuICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgc3ViamVjdC5vbihtb3VzZWRvd24sIG51bGwpLm9uKHRvdWNoc3RhcnQsIHN0YXJ0ZWQpO1xuICAgICAgZnVuY3Rpb24gcmVsb2NhdGUoKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gZDMudG91Y2hlcyh0aGF0KTtcbiAgICAgICAgc2NhbGUwID0gdmlldy5rO1xuICAgICAgICB0b3VjaGVzLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICAgIGlmICh0LmlkZW50aWZpZXIgaW4gbG9jYXRpb25zMCkgbG9jYXRpb25zMFt0LmlkZW50aWZpZXJdID0gbG9jYXRpb24odCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG91Y2hlcztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0ZWQoKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBkMy5ldmVudC50YXJnZXQ7XG4gICAgICAgIGQzLnNlbGVjdCh0YXJnZXQpLm9uKHRvdWNobW92ZSwgbW92ZWQpLm9uKHRvdWNoZW5kLCBlbmRlZCk7XG4gICAgICAgIHRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNoYW5nZWQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgbG9jYXRpb25zMFtjaGFuZ2VkW2ldLmlkZW50aWZpZXJdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG91Y2hlcyA9IHJlbG9jYXRlKCksIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGlmIChub3cgLSB0b3VjaHRpbWUgPCA1MDApIHtcbiAgICAgICAgICAgIHZhciBwID0gdG91Y2hlc1swXTtcbiAgICAgICAgICAgIHpvb21Ubyh0aGF0LCBwLCBsb2NhdGlvbnMwW3AuaWRlbnRpZmllcl0sIE1hdGguZmxvb3IoTWF0aC5sb2codmlldy5rKSAvIE1hdGguTE4yKSArIDEpO1xuICAgICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3VjaHRpbWUgPSBub3c7XG4gICAgICAgIH0gZWxzZSBpZiAodG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIHAgPSB0b3VjaGVzWzBdLCBxID0gdG91Y2hlc1sxXSwgZHggPSBwWzBdIC0gcVswXSwgZHkgPSBwWzFdIC0gcVsxXTtcbiAgICAgICAgICBkaXN0YW5jZTAgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbW92ZWQoKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gZDMudG91Y2hlcyh0aGF0KSwgcDAsIGwwLCBwMSwgbDE7XG4gICAgICAgIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQuY2FsbCh0aGF0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IG47ICsraSwgbDEgPSBudWxsKSB7XG4gICAgICAgICAgcDEgPSB0b3VjaGVzW2ldO1xuICAgICAgICAgIGlmIChsMSA9IGxvY2F0aW9uczBbcDEuaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGlmIChsMCkgYnJlYWs7XG4gICAgICAgICAgICBwMCA9IHAxLCBsMCA9IGwxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobDEpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UxID0gKGRpc3RhbmNlMSA9IHAxWzBdIC0gcDBbMF0pICogZGlzdGFuY2UxICsgKGRpc3RhbmNlMSA9IHAxWzFdIC0gcDBbMV0pICogZGlzdGFuY2UxLCBzY2FsZTEgPSBkaXN0YW5jZTAgJiYgTWF0aC5zcXJ0KGRpc3RhbmNlMSAvIGRpc3RhbmNlMCk7XG4gICAgICAgICAgcDAgPSBbIChwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDIgXTtcbiAgICAgICAgICBsMCA9IFsgKGwwWzBdICsgbDFbMF0pIC8gMiwgKGwwWzFdICsgbDFbMV0pIC8gMiBdO1xuICAgICAgICAgIHNjYWxlVG8oc2NhbGUxICogc2NhbGUwKTtcbiAgICAgICAgfVxuICAgICAgICB0b3VjaHRpbWUgPSBudWxsO1xuICAgICAgICB0cmFuc2xhdGVUbyhwMCwgbDApO1xuICAgICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC50b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBjaGFuZ2VkID0gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjaGFuZ2VkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgZGVsZXRlIGxvY2F0aW9uczBbY2hhbmdlZFtpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaWRlbnRpZmllciBpbiBsb2NhdGlvbnMwKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCByZWxvY2F0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkMy5zZWxlY3RBbGwodGFyZ2V0cykub24oem9vbU5hbWUsIG51bGwpO1xuICAgICAgICBzdWJqZWN0Lm9uKG1vdXNlZG93biwgbW91c2Vkb3duZWQpLm9uKHRvdWNoc3RhcnQsIHRvdWNoc3RhcnRlZCk7XG4gICAgICAgIGRyYWdSZXN0b3JlKCk7XG4gICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdXNld2hlZWxlZCgpIHtcbiAgICAgIHZhciBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAobW91c2V3aGVlbFRpbWVyKSBjbGVhclRpbWVvdXQobW91c2V3aGVlbFRpbWVyKTsgZWxzZSBkM19zZWxlY3Rpb25faW50ZXJydXB0LmNhbGwodGhpcyksIFxuICAgICAgdHJhbnNsYXRlMCA9IGxvY2F0aW9uKGNlbnRlcjAgPSBjZW50ZXIgfHwgZDMubW91c2UodGhpcykpLCB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICBtb3VzZXdoZWVsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBtb3VzZXdoZWVsVGltZXIgPSBudWxsO1xuICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgfSwgNTApO1xuICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2NhbGVUbyhNYXRoLnBvdygyLCBkM19iZWhhdmlvcl96b29tRGVsdGEoKSAqIC4wMDIpICogdmlldy5rKTtcbiAgICAgIHRyYW5zbGF0ZVRvKGNlbnRlcjAsIHRyYW5zbGF0ZTApO1xuICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGJsY2xpY2tlZCgpIHtcbiAgICAgIHZhciBwID0gZDMubW91c2UodGhpcyksIGsgPSBNYXRoLmxvZyh2aWV3LmspIC8gTWF0aC5MTjI7XG4gICAgICB6b29tVG8odGhpcywgcCwgbG9jYXRpb24ocCksIGQzLmV2ZW50LnNoaWZ0S2V5ID8gTWF0aC5jZWlsKGspIC0gMSA6IE1hdGguZmxvb3IoaykgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzLnJlYmluZCh6b29tLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgdmFyIGQzX2JlaGF2aW9yX3pvb21JbmZpbml0eSA9IFsgMCwgSW5maW5pdHkgXSwgZDNfYmVoYXZpb3Jfem9vbURlbHRhLCBkM19iZWhhdmlvcl96b29tV2hlZWw7XG4gIGQzLmNvbG9yID0gZDNfY29sb3I7XG4gIGZ1bmN0aW9uIGQzX2NvbG9yKCkge31cbiAgZDNfY29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkgKyBcIlwiO1xuICB9O1xuICBkMy5oc2wgPSBkM19oc2w7XG4gIGZ1bmN0aW9uIGQzX2hzbChoLCBzLCBsKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19oc2wgPyB2b2lkICh0aGlzLmggPSAraCwgdGhpcy5zID0gK3MsIHRoaXMubCA9ICtsKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gaCBpbnN0YW5jZW9mIGQzX2hzbCA/IG5ldyBkM19oc2woaC5oLCBoLnMsIGgubCkgOiBkM19yZ2JfcGFyc2UoXCJcIiArIGgsIGQzX3JnYl9oc2wsIGQzX2hzbCkgOiBuZXcgZDNfaHNsKGgsIHMsIGwpO1xuICB9XG4gIHZhciBkM19oc2xQcm90b3R5cGUgPSBkM19oc2wucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG4gIGQzX2hzbFByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgcmV0dXJuIG5ldyBkM19oc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAvIGspO1xuICB9O1xuICBkM19oc2xQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLnBvdyguNywgYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKTtcbiAgICByZXR1cm4gbmV3IGQzX2hzbCh0aGlzLmgsIHRoaXMucywgayAqIHRoaXMubCk7XG4gIH07XG4gIGQzX2hzbFByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfaHNsX3JnYih0aGlzLmgsIHRoaXMucywgdGhpcy5sKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfaHNsX3JnYihoLCBzLCBsKSB7XG4gICAgdmFyIG0xLCBtMjtcbiAgICBoID0gaXNOYU4oaCkgPyAwIDogKGggJT0gMzYwKSA8IDAgPyBoICsgMzYwIDogaDtcbiAgICBzID0gaXNOYU4ocykgPyAwIDogcyA8IDAgPyAwIDogcyA+IDEgPyAxIDogcztcbiAgICBsID0gbCA8IDAgPyAwIDogbCA+IDEgPyAxIDogbDtcbiAgICBtMiA9IGwgPD0gLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgbTEgPSAyICogbCAtIG0yO1xuICAgIGZ1bmN0aW9uIHYoaCkge1xuICAgICAgaWYgKGggPiAzNjApIGggLT0gMzYwOyBlbHNlIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgICBpZiAoaCA8IDYwKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjA7XG4gICAgICBpZiAoaCA8IDE4MCkgcmV0dXJuIG0yO1xuICAgICAgaWYgKGggPCAyNDApIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwO1xuICAgICAgcmV0dXJuIG0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2dihoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh2KGgpICogMjU1KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IodnYoaCArIDEyMCksIHZ2KGgpLCB2dihoIC0gMTIwKSk7XG4gIH1cbiAgZDMuaGNsID0gZDNfaGNsO1xuICBmdW5jdGlvbiBkM19oY2woaCwgYywgbCkge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfaGNsID8gdm9pZCAodGhpcy5oID0gK2gsIHRoaXMuYyA9ICtjLCB0aGlzLmwgPSArbCkgOiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGggaW5zdGFuY2VvZiBkM19oY2wgPyBuZXcgZDNfaGNsKGguaCwgaC5jLCBoLmwpIDogaCBpbnN0YW5jZW9mIGQzX2xhYiA/IGQzX2xhYl9oY2woaC5sLCBoLmEsIGguYikgOiBkM19sYWJfaGNsKChoID0gZDNfcmdiX2xhYigoaCA9IGQzLnJnYihoKSkuciwgaC5nLCBoLmIpKS5sLCBoLmEsIGguYikgOiBuZXcgZDNfaGNsKGgsIGMsIGwpO1xuICB9XG4gIHZhciBkM19oY2xQcm90b3R5cGUgPSBkM19oY2wucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG4gIGQzX2hjbFByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2hjbCh0aGlzLmgsIHRoaXMuYywgTWF0aC5taW4oMTAwLCB0aGlzLmwgKyBkM19sYWJfSyAqIChhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpKSk7XG4gIH07XG4gIGQzX2hjbFByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBkM19oY2wodGhpcy5oLCB0aGlzLmMsIE1hdGgubWF4KDAsIHRoaXMubCAtIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpKTtcbiAgfTtcbiAgZDNfaGNsUHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19oY2xfbGFiKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwpLnJnYigpO1xuICB9O1xuICBmdW5jdGlvbiBkM19oY2xfbGFiKGgsIGMsIGwpIHtcbiAgICBpZiAoaXNOYU4oaCkpIGggPSAwO1xuICAgIGlmIChpc05hTihjKSkgYyA9IDA7XG4gICAgcmV0dXJuIG5ldyBkM19sYWIobCwgTWF0aC5jb3MoaCAqPSBkM19yYWRpYW5zKSAqIGMsIE1hdGguc2luKGgpICogYyk7XG4gIH1cbiAgZDMubGFiID0gZDNfbGFiO1xuICBmdW5jdGlvbiBkM19sYWIobCwgYSwgYikge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfbGFiID8gdm9pZCAodGhpcy5sID0gK2wsIHRoaXMuYSA9ICthLCB0aGlzLmIgPSArYikgOiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGwgaW5zdGFuY2VvZiBkM19sYWIgPyBuZXcgZDNfbGFiKGwubCwgbC5hLCBsLmIpIDogbCBpbnN0YW5jZW9mIGQzX2hjbCA/IGQzX2hjbF9sYWIobC5oLCBsLmMsIGwubCkgOiBkM19yZ2JfbGFiKChsID0gZDNfcmdiKGwpKS5yLCBsLmcsIGwuYikgOiBuZXcgZDNfbGFiKGwsIGEsIGIpO1xuICB9XG4gIHZhciBkM19sYWJfSyA9IDE4O1xuICB2YXIgZDNfbGFiX1ggPSAuOTUwNDcsIGQzX2xhYl9ZID0gMSwgZDNfbGFiX1ogPSAxLjA4ODgzO1xuICB2YXIgZDNfbGFiUHJvdG90eXBlID0gZDNfbGFiLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19sYWJQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBkM19sYWIoTWF0aC5taW4oMTAwLCB0aGlzLmwgKyBkM19sYWJfSyAqIChhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpKSwgdGhpcy5hLCB0aGlzLmIpO1xuICB9O1xuICBkM19sYWJQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfbGFiKE1hdGgubWF4KDAsIHRoaXMubCAtIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG4gIGQzX2xhYlByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfbGFiX3JnYih0aGlzLmwsIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGFiX3JnYihsLCBhLCBiKSB7XG4gICAgdmFyIHkgPSAobCArIDE2KSAvIDExNiwgeCA9IHkgKyBhIC8gNTAwLCB6ID0geSAtIGIgLyAyMDA7XG4gICAgeCA9IGQzX2xhYl94eXooeCkgKiBkM19sYWJfWDtcbiAgICB5ID0gZDNfbGFiX3h5eih5KSAqIGQzX2xhYl9ZO1xuICAgIHogPSBkM19sYWJfeHl6KHopICogZDNfbGFiX1o7XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IoZDNfeHl6X3JnYigzLjI0MDQ1NDIgKiB4IC0gMS41MzcxMzg1ICogeSAtIC40OTg1MzE0ICogeiksIGQzX3h5el9yZ2IoLS45NjkyNjYgKiB4ICsgMS44NzYwMTA4ICogeSArIC4wNDE1NTYgKiB6KSwgZDNfeHl6X3JnYiguMDU1NjQzNCAqIHggLSAuMjA0MDI1OSAqIHkgKyAxLjA1NzIyNTIgKiB6KSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGFiX2hjbChsLCBhLCBiKSB7XG4gICAgcmV0dXJuIGwgPiAwID8gbmV3IGQzX2hjbChNYXRoLmF0YW4yKGIsIGEpICogZDNfZGVncmVlcywgTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpLCBsKSA6IG5ldyBkM19oY2woTmFOLCBOYU4sIGwpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xhYl94eXooeCkge1xuICAgIHJldHVybiB4ID4gLjIwNjg5MzAzNCA/IHggKiB4ICogeCA6ICh4IC0gNCAvIDI5KSAvIDcuNzg3MDM3O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3h5el9sYWIoeCkge1xuICAgIHJldHVybiB4ID4gLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6IDcuNzg3MDM3ICogeCArIDQgLyAyOTtcbiAgfVxuICBmdW5jdGlvbiBkM194eXpfcmdiKHIpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgyNTUgKiAociA8PSAuMDAzMDQgPyAxMi45MiAqIHIgOiAxLjA1NSAqIE1hdGgucG93KHIsIDEgLyAyLjQpIC0gLjA1NSkpO1xuICB9XG4gIGQzLnJnYiA9IGQzX3JnYjtcbiAgZnVuY3Rpb24gZDNfcmdiKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX3JnYiA/IHZvaWQgKHRoaXMuciA9IH5+ciwgdGhpcy5nID0gfn5nLCB0aGlzLmIgPSB+fmIpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyByIGluc3RhbmNlb2YgZDNfcmdiID8gbmV3IGQzX3JnYihyLnIsIHIuZywgci5iKSA6IGQzX3JnYl9wYXJzZShcIlwiICsgciwgZDNfcmdiLCBkM19oc2xfcmdiKSA6IG5ldyBkM19yZ2IociwgZywgYik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IodmFsdWUgPj4gMTYsIHZhbHVlID4+IDggJiAyNTUsIHZhbHVlICYgMjU1KTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gZDNfcmdiTnVtYmVyKHZhbHVlKSArIFwiXCI7XG4gIH1cbiAgdmFyIGQzX3JnYlByb3RvdHlwZSA9IGQzX3JnYi5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfcmdiUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLnBvdyguNywgYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKTtcbiAgICB2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYiwgaSA9IDMwO1xuICAgIGlmICghciAmJiAhZyAmJiAhYikgcmV0dXJuIG5ldyBkM19yZ2IoaSwgaSwgaSk7XG4gICAgaWYgKHIgJiYgciA8IGkpIHIgPSBpO1xuICAgIGlmIChnICYmIGcgPCBpKSBnID0gaTtcbiAgICBpZiAoYiAmJiBiIDwgaSkgYiA9IGk7XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IoTWF0aC5taW4oMjU1LCByIC8gayksIE1hdGgubWluKDI1NSwgZyAvIGspLCBNYXRoLm1pbigyNTUsIGIgLyBrKSk7XG4gIH07XG4gIGQzX3JnYlByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHJldHVybiBuZXcgZDNfcmdiKGsgKiB0aGlzLnIsIGsgKiB0aGlzLmcsIGsgKiB0aGlzLmIpO1xuICB9O1xuICBkM19yZ2JQcm90b3R5cGUuaHNsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3JnYl9oc2wodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gIH07XG4gIGQzX3JnYlByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIiNcIiArIGQzX3JnYl9oZXgodGhpcy5yKSArIGQzX3JnYl9oZXgodGhpcy5nKSArIGQzX3JnYl9oZXgodGhpcy5iKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfcmdiX2hleCh2KSB7XG4gICAgcmV0dXJuIHYgPCAxNiA/IFwiMFwiICsgTWF0aC5tYXgoMCwgdikudG9TdHJpbmcoMTYpIDogTWF0aC5taW4oMjU1LCB2KS50b1N0cmluZygxNik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX3BhcnNlKGZvcm1hdCwgcmdiLCBoc2wpIHtcbiAgICB2YXIgciA9IDAsIGcgPSAwLCBiID0gMCwgbTEsIG0yLCBjb2xvcjtcbiAgICBtMSA9IC8oW2Etel0rKVxcKCguKilcXCkvLmV4ZWMoZm9ybWF0ID0gZm9ybWF0LnRvTG93ZXJDYXNlKCkpO1xuICAgIGlmIChtMSkge1xuICAgICAgbTIgPSBtMVsyXS5zcGxpdChcIixcIik7XG4gICAgICBzd2l0Y2ggKG0xWzFdKSB7XG4gICAgICAgY2FzZSBcImhzbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGhzbChwYXJzZUZsb2F0KG0yWzBdKSwgcGFyc2VGbG9hdChtMlsxXSkgLyAxMDAsIHBhcnNlRmxvYXQobTJbMl0pIC8gMTAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgY2FzZSBcInJnYlwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHJnYihkM19yZ2JfcGFyc2VOdW1iZXIobTJbMF0pLCBkM19yZ2JfcGFyc2VOdW1iZXIobTJbMV0pLCBkM19yZ2JfcGFyc2VOdW1iZXIobTJbMl0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sb3IgPSBkM19yZ2JfbmFtZXMuZ2V0KGZvcm1hdCkpIHtcbiAgICAgIHJldHVybiByZ2IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgfVxuICAgIGlmIChmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXQuY2hhckF0KDApID09PSBcIiNcIiAmJiAhaXNOYU4oY29sb3IgPSBwYXJzZUludChmb3JtYXQuc2xpY2UoMSksIDE2KSkpIHtcbiAgICAgIGlmIChmb3JtYXQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHIgPSAoY29sb3IgJiAzODQwKSA+PiA0O1xuICAgICAgICByID0gciA+PiA0IHwgcjtcbiAgICAgICAgZyA9IGNvbG9yICYgMjQwO1xuICAgICAgICBnID0gZyA+PiA0IHwgZztcbiAgICAgICAgYiA9IGNvbG9yICYgMTU7XG4gICAgICAgIGIgPSBiIDw8IDQgfCBiO1xuICAgICAgfSBlbHNlIGlmIChmb3JtYXQubGVuZ3RoID09PSA3KSB7XG4gICAgICAgIHIgPSAoY29sb3IgJiAxNjcxMTY4MCkgPj4gMTY7XG4gICAgICAgIGcgPSAoY29sb3IgJiA2NTI4MCkgPj4gODtcbiAgICAgICAgYiA9IGNvbG9yICYgMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiKHIsIGcsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9oc2wociwgZywgYikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyIC89IDI1NSwgZyAvPSAyNTUsIGIgLz0gMjU1KSwgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIGQgPSBtYXggLSBtaW4sIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gICAgaWYgKGQpIHtcbiAgICAgIHMgPSBsIDwgLjUgPyBkIC8gKG1heCArIG1pbikgOiBkIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgaWYgKHIgPT0gbWF4KSBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGVsc2UgaWYgKGcgPT0gbWF4KSBoID0gKGIgLSByKSAvIGQgKyAyOyBlbHNlIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICBoICo9IDYwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gTmFOO1xuICAgICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZDNfaHNsKGgsIHMsIGwpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9sYWIociwgZywgYikge1xuICAgIHIgPSBkM19yZ2JfeHl6KHIpO1xuICAgIGcgPSBkM19yZ2JfeHl6KGcpO1xuICAgIGIgPSBkM19yZ2JfeHl6KGIpO1xuICAgIHZhciB4ID0gZDNfeHl6X2xhYigoLjQxMjQ1NjQgKiByICsgLjM1NzU3NjEgKiBnICsgLjE4MDQzNzUgKiBiKSAvIGQzX2xhYl9YKSwgeSA9IGQzX3h5el9sYWIoKC4yMTI2NzI5ICogciArIC43MTUxNTIyICogZyArIC4wNzIxNzUgKiBiKSAvIGQzX2xhYl9ZKSwgeiA9IGQzX3h5el9sYWIoKC4wMTkzMzM5ICogciArIC4xMTkxOTIgKiBnICsgLjk1MDMwNDEgKiBiKSAvIGQzX2xhYl9aKTtcbiAgICByZXR1cm4gZDNfbGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX3h5eihyKSB7XG4gICAgcmV0dXJuIChyIC89IDI1NSkgPD0gLjA0MDQ1ID8gciAvIDEyLjkyIDogTWF0aC5wb3coKHIgKyAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9wYXJzZU51bWJlcihjKSB7XG4gICAgdmFyIGYgPSBwYXJzZUZsb2F0KGMpO1xuICAgIHJldHVybiBjLmNoYXJBdChjLmxlbmd0aCAtIDEpID09PSBcIiVcIiA/IE1hdGgucm91bmQoZiAqIDIuNTUpIDogZjtcbiAgfVxuICB2YXIgZDNfcmdiX25hbWVzID0gZDMubWFwKHtcbiAgICBhbGljZWJsdWU6IDE1NzkyMzgzLFxuICAgIGFudGlxdWV3aGl0ZTogMTY0NDQzNzUsXG4gICAgYXF1YTogNjU1MzUsXG4gICAgYXF1YW1hcmluZTogODM4ODU2NCxcbiAgICBhenVyZTogMTU3OTQxNzUsXG4gICAgYmVpZ2U6IDE2MTE5MjYwLFxuICAgIGJpc3F1ZTogMTY3NzAyNDQsXG4gICAgYmxhY2s6IDAsXG4gICAgYmxhbmNoZWRhbG1vbmQ6IDE2NzcyMDQ1LFxuICAgIGJsdWU6IDI1NSxcbiAgICBibHVldmlvbGV0OiA5MDU1MjAyLFxuICAgIGJyb3duOiAxMDgyNDIzNCxcbiAgICBidXJseXdvb2Q6IDE0NTk2MjMxLFxuICAgIGNhZGV0Ymx1ZTogNjI2NjUyOCxcbiAgICBjaGFydHJldXNlOiA4Mzg4MzUyLFxuICAgIGNob2NvbGF0ZTogMTM3ODk0NzAsXG4gICAgY29yYWw6IDE2NzQ0MjcyLFxuICAgIGNvcm5mbG93ZXJibHVlOiA2NTkxOTgxLFxuICAgIGNvcm5zaWxrOiAxNjc3NTM4OCxcbiAgICBjcmltc29uOiAxNDQyMzEwMCxcbiAgICBjeWFuOiA2NTUzNSxcbiAgICBkYXJrYmx1ZTogMTM5LFxuICAgIGRhcmtjeWFuOiAzNTcyMyxcbiAgICBkYXJrZ29sZGVucm9kOiAxMjA5MjkzOSxcbiAgICBkYXJrZ3JheTogMTExMTkwMTcsXG4gICAgZGFya2dyZWVuOiAyNTYwMCxcbiAgICBkYXJrZ3JleTogMTExMTkwMTcsXG4gICAgZGFya2toYWtpOiAxMjQzMzI1OSxcbiAgICBkYXJrbWFnZW50YTogOTEwOTY0MyxcbiAgICBkYXJrb2xpdmVncmVlbjogNTU5Nzk5OSxcbiAgICBkYXJrb3JhbmdlOiAxNjc0NzUyMCxcbiAgICBkYXJrb3JjaGlkOiAxMDA0MDAxMixcbiAgICBkYXJrcmVkOiA5MTA5NTA0LFxuICAgIGRhcmtzYWxtb246IDE1MzA4NDEwLFxuICAgIGRhcmtzZWFncmVlbjogOTQxOTkxOSxcbiAgICBkYXJrc2xhdGVibHVlOiA0NzM0MzQ3LFxuICAgIGRhcmtzbGF0ZWdyYXk6IDMxMDA0OTUsXG4gICAgZGFya3NsYXRlZ3JleTogMzEwMDQ5NSxcbiAgICBkYXJrdHVycXVvaXNlOiA1Mjk0NSxcbiAgICBkYXJrdmlvbGV0OiA5Njk5NTM5LFxuICAgIGRlZXBwaW5rOiAxNjcxNjk0NyxcbiAgICBkZWVwc2t5Ymx1ZTogNDkxNTEsXG4gICAgZGltZ3JheTogNjkwODI2NSxcbiAgICBkaW1ncmV5OiA2OTA4MjY1LFxuICAgIGRvZGdlcmJsdWU6IDIwMDMxOTksXG4gICAgZmlyZWJyaWNrOiAxMTY3NDE0NixcbiAgICBmbG9yYWx3aGl0ZTogMTY3NzU5MjAsXG4gICAgZm9yZXN0Z3JlZW46IDIyNjM4NDIsXG4gICAgZnVjaHNpYTogMTY3MTE5MzUsXG4gICAgZ2FpbnNib3JvOiAxNDQ3NDQ2MCxcbiAgICBnaG9zdHdoaXRlOiAxNjMxNjY3MSxcbiAgICBnb2xkOiAxNjc2NjcyMCxcbiAgICBnb2xkZW5yb2Q6IDE0MzI5MTIwLFxuICAgIGdyYXk6IDg0MjE1MDQsXG4gICAgZ3JlZW46IDMyNzY4LFxuICAgIGdyZWVueWVsbG93OiAxMTQwMzA1NSxcbiAgICBncmV5OiA4NDIxNTA0LFxuICAgIGhvbmV5ZGV3OiAxNTc5NDE2MCxcbiAgICBob3RwaW5rOiAxNjczODc0MCxcbiAgICBpbmRpYW5yZWQ6IDEzNDU4NTI0LFxuICAgIGluZGlnbzogNDkxNTMzMCxcbiAgICBpdm9yeTogMTY3NzcyMDAsXG4gICAga2hha2k6IDE1Nzg3NjYwLFxuICAgIGxhdmVuZGVyOiAxNTEzMjQxMCxcbiAgICBsYXZlbmRlcmJsdXNoOiAxNjc3MzM2NSxcbiAgICBsYXduZ3JlZW46IDgxOTA5NzYsXG4gICAgbGVtb25jaGlmZm9uOiAxNjc3NTg4NSxcbiAgICBsaWdodGJsdWU6IDExMzkzMjU0LFxuICAgIGxpZ2h0Y29yYWw6IDE1NzYxNTM2LFxuICAgIGxpZ2h0Y3lhbjogMTQ3NDU1OTksXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDE2NDQ4MjEwLFxuICAgIGxpZ2h0Z3JheTogMTM4ODIzMjMsXG4gICAgbGlnaHRncmVlbjogOTQ5ODI1NixcbiAgICBsaWdodGdyZXk6IDEzODgyMzIzLFxuICAgIGxpZ2h0cGluazogMTY3NTg0NjUsXG4gICAgbGlnaHRzYWxtb246IDE2NzUyNzYyLFxuICAgIGxpZ2h0c2VhZ3JlZW46IDIxNDI4OTAsXG4gICAgbGlnaHRza3libHVlOiA4OTAwMzQ2LFxuICAgIGxpZ2h0c2xhdGVncmF5OiA3ODMzNzUzLFxuICAgIGxpZ2h0c2xhdGVncmV5OiA3ODMzNzUzLFxuICAgIGxpZ2h0c3RlZWxibHVlOiAxMTU4NDczNCxcbiAgICBsaWdodHllbGxvdzogMTY3NzcxODQsXG4gICAgbGltZTogNjUyODAsXG4gICAgbGltZWdyZWVuOiAzMzI5MzMwLFxuICAgIGxpbmVuOiAxNjQ0NTY3MCxcbiAgICBtYWdlbnRhOiAxNjcxMTkzNSxcbiAgICBtYXJvb246IDgzODg2MDgsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogNjczNzMyMixcbiAgICBtZWRpdW1ibHVlOiAyMDUsXG4gICAgbWVkaXVtb3JjaGlkOiAxMjIxMTY2NyxcbiAgICBtZWRpdW1wdXJwbGU6IDk2NjI2ODMsXG4gICAgbWVkaXVtc2VhZ3JlZW46IDM5NzgwOTcsXG4gICAgbWVkaXVtc2xhdGVibHVlOiA4MDg3NzkwLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiA2NDE1NCxcbiAgICBtZWRpdW10dXJxdW9pc2U6IDQ3NzIzMDAsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiAxMzA0NzE3MyxcbiAgICBtaWRuaWdodGJsdWU6IDE2NDQ5MTIsXG4gICAgbWludGNyZWFtOiAxNjEyMTg1MCxcbiAgICBtaXN0eXJvc2U6IDE2NzcwMjczLFxuICAgIG1vY2Nhc2luOiAxNjc3MDIyOSxcbiAgICBuYXZham93aGl0ZTogMTY3Njg2ODUsXG4gICAgbmF2eTogMTI4LFxuICAgIG9sZGxhY2U6IDE2NjQzNTU4LFxuICAgIG9saXZlOiA4NDIxMzc2LFxuICAgIG9saXZlZHJhYjogNzA0ODczOSxcbiAgICBvcmFuZ2U6IDE2NzUzOTIwLFxuICAgIG9yYW5nZXJlZDogMTY3MjkzNDQsXG4gICAgb3JjaGlkOiAxNDMxNTczNCxcbiAgICBwYWxlZ29sZGVucm9kOiAxNTY1NzEzMCxcbiAgICBwYWxlZ3JlZW46IDEwMDI1ODgwLFxuICAgIHBhbGV0dXJxdW9pc2U6IDExNTI5OTY2LFxuICAgIHBhbGV2aW9sZXRyZWQ6IDE0MzgxMjAzLFxuICAgIHBhcGF5YXdoaXA6IDE2NzczMDc3LFxuICAgIHBlYWNocHVmZjogMTY3Njc2NzMsXG4gICAgcGVydTogMTM0Njg5OTEsXG4gICAgcGluazogMTY3NjEwMzUsXG4gICAgcGx1bTogMTQ1MjQ2MzcsXG4gICAgcG93ZGVyYmx1ZTogMTE1OTE5MTAsXG4gICAgcHVycGxlOiA4Mzg4NzM2LFxuICAgIHJlYmVjY2FwdXJwbGU6IDY2OTc4ODEsXG4gICAgcmVkOiAxNjcxMTY4MCxcbiAgICByb3N5YnJvd246IDEyMzU3NTE5LFxuICAgIHJveWFsYmx1ZTogNDI4Njk0NSxcbiAgICBzYWRkbGVicm93bjogOTEyNzE4NyxcbiAgICBzYWxtb246IDE2NDE2ODgyLFxuICAgIHNhbmR5YnJvd246IDE2MDMyODY0LFxuICAgIHNlYWdyZWVuOiAzMDUwMzI3LFxuICAgIHNlYXNoZWxsOiAxNjc3NDYzOCxcbiAgICBzaWVubmE6IDEwNTA2Nzk3LFxuICAgIHNpbHZlcjogMTI2MzIyNTYsXG4gICAgc2t5Ymx1ZTogODkwMDMzMSxcbiAgICBzbGF0ZWJsdWU6IDY5NzAwNjEsXG4gICAgc2xhdGVncmF5OiA3MzcyOTQ0LFxuICAgIHNsYXRlZ3JleTogNzM3Mjk0NCxcbiAgICBzbm93OiAxNjc3NTkzMCxcbiAgICBzcHJpbmdncmVlbjogNjU0MDcsXG4gICAgc3RlZWxibHVlOiA0NjIwOTgwLFxuICAgIHRhbjogMTM4MDg3ODAsXG4gICAgdGVhbDogMzI4OTYsXG4gICAgdGhpc3RsZTogMTQyMDQ4ODgsXG4gICAgdG9tYXRvOiAxNjczNzA5NSxcbiAgICB0dXJxdW9pc2U6IDQyNTE4NTYsXG4gICAgdmlvbGV0OiAxNTYzMTA4NixcbiAgICB3aGVhdDogMTYxMTMzMzEsXG4gICAgd2hpdGU6IDE2Nzc3MjE1LFxuICAgIHdoaXRlc21va2U6IDE2MTE5Mjg1LFxuICAgIHllbGxvdzogMTY3NzY5NjAsXG4gICAgeWVsbG93Z3JlZW46IDEwMTQ1MDc0XG4gIH0pO1xuICBkM19yZ2JfbmFtZXMuZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgZDNfcmdiX25hbWVzLnNldChrZXksIGQzX3JnYk51bWJlcih2YWx1ZSkpO1xuICB9KTtcbiAgZnVuY3Rpb24gZDNfZnVuY3Rvcih2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIgPyB2IDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9O1xuICB9XG4gIGQzLmZ1bmN0b3IgPSBkM19mdW5jdG9yO1xuICBkMy54aHIgPSBkM194aHJUeXBlKGQzX2lkZW50aXR5KTtcbiAgZnVuY3Rpb24gZDNfeGhyVHlwZShyZXNwb25zZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih1cmwsIG1pbWVUeXBlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG1pbWVUeXBlID09PSBcImZ1bmN0aW9uXCIpIGNhbGxiYWNrID0gbWltZVR5cGUsIFxuICAgICAgbWltZVR5cGUgPSBudWxsO1xuICAgICAgcmV0dXJuIGQzX3hocih1cmwsIG1pbWVUeXBlLCByZXNwb25zZSwgY2FsbGJhY2spO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfeGhyKHVybCwgbWltZVR5cGUsIHJlc3BvbnNlLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSB7fSwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaChcImJlZm9yZXNlbmRcIiwgXCJwcm9ncmVzc1wiLCBcImxvYWRcIiwgXCJlcnJvclwiKSwgaGVhZGVycyA9IHt9LCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksIHJlc3BvbnNlVHlwZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuWERvbWFpblJlcXVlc3QgJiYgIShcIndpdGhDcmVkZW50aWFsc1wiIGluIHJlcXVlc3QpICYmIC9eKGh0dHAocyk/Oik/XFwvXFwvLy50ZXN0KHVybCkpIHJlcXVlc3QgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICBcIm9ubG9hZFwiIGluIHJlcXVlc3QgPyByZXF1ZXN0Lm9ubG9hZCA9IHJlcXVlc3Qub25lcnJvciA9IHJlc3BvbmQgOiByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVxdWVzdC5yZWFkeVN0YXRlID4gMyAmJiByZXNwb25kKCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZXNwb25kKCkge1xuICAgICAgdmFyIHN0YXR1cyA9IHJlcXVlc3Quc3RhdHVzLCByZXN1bHQ7XG4gICAgICBpZiAoIXN0YXR1cyAmJiBkM194aHJIYXNSZXNwb25zZShyZXF1ZXN0KSB8fCBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlLmNhbGwoeGhyLCByZXF1ZXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRpc3BhdGNoLmVycm9yLmNhbGwoeGhyLCBlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2gubG9hZC5jYWxsKHhociwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BhdGNoLmVycm9yLmNhbGwoeGhyLCByZXF1ZXN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBvID0gZDMuZXZlbnQ7XG4gICAgICBkMy5ldmVudCA9IGV2ZW50O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGlzcGF0Y2gucHJvZ3Jlc3MuY2FsbCh4aHIsIHJlcXVlc3QpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDMuZXZlbnQgPSBvO1xuICAgICAgfVxuICAgIH07XG4gICAgeGhyLmhlYWRlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICBuYW1lID0gKG5hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gaGVhZGVyc1tuYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSBkZWxldGUgaGVhZGVyc1tuYW1lXTsgZWxzZSBoZWFkZXJzW25hbWVdID0gdmFsdWUgKyBcIlwiO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5taW1lVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtaW1lVHlwZTtcbiAgICAgIG1pbWVUeXBlID0gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiB2YWx1ZSArIFwiXCI7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByZXNwb25zZVR5cGU7XG4gICAgICByZXNwb25zZVR5cGUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICB4aHIucmVzcG9uc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzcG9uc2UgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICBbIFwiZ2V0XCIsIFwicG9zdFwiIF0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHhoclttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB4aHIuc2VuZC5hcHBseSh4aHIsIFsgbWV0aG9kIF0uY29uY2F0KGQzX2FycmF5KGFyZ3VtZW50cykpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgeGhyLnNlbmQgPSBmdW5jdGlvbihtZXRob2QsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSBjYWxsYmFjayA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICAgICAgcmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgIGlmIChtaW1lVHlwZSAhPSBudWxsICYmICEoXCJhY2NlcHRcIiBpbiBoZWFkZXJzKSkgaGVhZGVyc1tcImFjY2VwdFwiXSA9IG1pbWVUeXBlICsgXCIsKi8qXCI7XG4gICAgICBpZiAocmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKSBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgICAgIGlmIChtaW1lVHlwZSAhPSBudWxsICYmIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSkgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKG1pbWVUeXBlKTtcbiAgICAgIGlmIChyZXNwb25zZVR5cGUgIT0gbnVsbCkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgeGhyLm9uKFwiZXJyb3JcIiwgY2FsbGJhY2spLm9uKFwibG9hZFwiLCBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgICBkaXNwYXRjaC5iZWZvcmVzZW5kLmNhbGwoeGhyLCByZXF1ZXN0KTtcbiAgICAgIHJlcXVlc3Quc2VuZChkYXRhID09IG51bGwgPyBudWxsIDogZGF0YSk7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgeGhyLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgZDMucmViaW5kKHhociwgZGlzcGF0Y2gsIFwib25cIik7XG4gICAgcmV0dXJuIGNhbGxiYWNrID09IG51bGwgPyB4aHIgOiB4aHIuZ2V0KGQzX3hocl9maXhDYWxsYmFjayhjYWxsYmFjaykpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3hocl9maXhDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIHJldHVybiBjYWxsYmFjay5sZW5ndGggPT09IDEgPyBmdW5jdGlvbihlcnJvciwgcmVxdWVzdCkge1xuICAgICAgY2FsbGJhY2soZXJyb3IgPT0gbnVsbCA/IHJlcXVlc3QgOiBudWxsKTtcbiAgICB9IDogY2FsbGJhY2s7XG4gIH1cbiAgZnVuY3Rpb24gZDNfeGhySGFzUmVzcG9uc2UocmVxdWVzdCkge1xuICAgIHZhciB0eXBlID0gcmVxdWVzdC5yZXNwb25zZVR5cGU7XG4gICAgcmV0dXJuIHR5cGUgJiYgdHlwZSAhPT0gXCJ0ZXh0XCIgPyByZXF1ZXN0LnJlc3BvbnNlIDogcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gIH1cbiAgZDMuZHN2ID0gZnVuY3Rpb24oZGVsaW1pdGVyLCBtaW1lVHlwZSkge1xuICAgIHZhciByZUZvcm1hdCA9IG5ldyBSZWdFeHAoJ1tcIicgKyBkZWxpbWl0ZXIgKyBcIlxcbl1cIiksIGRlbGltaXRlckNvZGUgPSBkZWxpbWl0ZXIuY2hhckNvZGVBdCgwKTtcbiAgICBmdW5jdGlvbiBkc3YodXJsLCByb3csIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGNhbGxiYWNrID0gcm93LCByb3cgPSBudWxsO1xuICAgICAgdmFyIHhociA9IGQzX3hocih1cmwsIG1pbWVUeXBlLCByb3cgPT0gbnVsbCA/IHJlc3BvbnNlIDogdHlwZWRSZXNwb25zZShyb3cpLCBjYWxsYmFjayk7XG4gICAgICB4aHIucm93ID0gZnVuY3Rpb24oXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHhoci5yZXNwb25zZSgocm93ID0gXykgPT0gbnVsbCA/IHJlc3BvbnNlIDogdHlwZWRSZXNwb25zZShfKSkgOiByb3c7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzcG9uc2UocmVxdWVzdCkge1xuICAgICAgcmV0dXJuIGRzdi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR5cGVkUmVzcG9uc2UoZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIGRzdi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCwgZik7XG4gICAgICB9O1xuICAgIH1cbiAgICBkc3YucGFyc2UgPSBmdW5jdGlvbih0ZXh0LCBmKSB7XG4gICAgICB2YXIgbztcbiAgICAgIHJldHVybiBkc3YucGFyc2VSb3dzKHRleHQsIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgICBpZiAobykgcmV0dXJuIG8ocm93LCBpIC0gMSk7XG4gICAgICAgIHZhciBhID0gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyByb3cubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIjogZFtcIiArIGkgKyBcIl1cIjtcbiAgICAgICAgfSkuam9pbihcIixcIikgKyBcIn1cIik7XG4gICAgICAgIG8gPSBmID8gZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGYoYShyb3cpLCBpKTtcbiAgICAgICAgfSA6IGE7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGRzdi5wYXJzZVJvd3MgPSBmdW5jdGlvbih0ZXh0LCBmKSB7XG4gICAgICB2YXIgRU9MID0ge30sIEVPRiA9IHt9LCByb3dzID0gW10sIE4gPSB0ZXh0Lmxlbmd0aCwgSSA9IDAsIG4gPSAwLCB0LCBlb2w7XG4gICAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgICAgaWYgKEkgPj0gTikgcmV0dXJuIEVPRjtcbiAgICAgICAgaWYgKGVvbCkgcmV0dXJuIGVvbCA9IGZhbHNlLCBFT0w7XG4gICAgICAgIHZhciBqID0gSTtcbiAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gMzQpIHtcbiAgICAgICAgICB2YXIgaSA9IGo7XG4gICAgICAgICAgd2hpbGUgKGkrKyA8IE4pIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IDM0KSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDEpICE9PSAzNCkgYnJlYWs7XG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgSSA9IGkgKyAyO1xuICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICBpZiAoYyA9PT0gMTMpIHtcbiAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAyKSA9PT0gMTApICsrSTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDEwKSB7XG4gICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqICsgMSwgaSkucmVwbGFjZSgvXCJcIi9nLCAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoSSA8IE4pIHtcbiAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChJKyspLCBrID0gMTtcbiAgICAgICAgICBpZiAoYyA9PT0gMTApIGVvbCA9IHRydWU7IGVsc2UgaWYgKGMgPT09IDEzKSB7XG4gICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gMTApICsrSSwgKytrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyAhPT0gZGVsaW1pdGVyQ29kZSkgY29udGludWU7XG4gICAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgSSAtIGspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGopO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikge1xuICAgICAgICAgIGEucHVzaCh0KTtcbiAgICAgICAgICB0ID0gdG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiAmJiAoYSA9IGYoYSwgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIHJvd3MucHVzaChhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG4gICAgZHN2LmZvcm1hdCA9IGZ1bmN0aW9uKHJvd3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvd3NbMF0pKSByZXR1cm4gZHN2LmZvcm1hdFJvd3Mocm93cyk7XG4gICAgICB2YXIgZmllbGRTZXQgPSBuZXcgZDNfU2V0KCksIGZpZWxkcyA9IFtdO1xuICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiByb3cpIHtcbiAgICAgICAgICBpZiAoIWZpZWxkU2V0LmhhcyhmaWVsZCkpIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkU2V0LmFkZChmaWVsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gWyBmaWVsZHMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcikgXS5jb25jYXQocm93cy5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybiBmaWVsZHMubWFwKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHJvd1tmaWVsZF0pO1xuICAgICAgICB9KS5qb2luKGRlbGltaXRlcik7XG4gICAgICB9KSkuam9pbihcIlxcblwiKTtcbiAgICB9O1xuICAgIGRzdi5mb3JtYXRSb3dzID0gZnVuY3Rpb24ocm93cykge1xuICAgICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZvcm1hdFJvdyhyb3cpIHtcbiAgICAgIHJldHVybiByb3cubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHRleHQpIHtcbiAgICAgIHJldHVybiByZUZvcm1hdC50ZXN0KHRleHQpID8gJ1wiJyArIHRleHQucmVwbGFjZSgvXFxcIi9nLCAnXCJcIicpICsgJ1wiJyA6IHRleHQ7XG4gICAgfVxuICAgIHJldHVybiBkc3Y7XG4gIH07XG4gIGQzLmNzdiA9IGQzLmRzdihcIixcIiwgXCJ0ZXh0L2NzdlwiKTtcbiAgZDMudHN2ID0gZDMuZHN2KFwiXHRcIiwgXCJ0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzXCIpO1xuICB2YXIgZDNfdGltZXJfcXVldWVIZWFkLCBkM190aW1lcl9xdWV1ZVRhaWwsIGQzX3RpbWVyX2ludGVydmFsLCBkM190aW1lcl90aW1lb3V0LCBkM190aW1lcl9mcmFtZSA9IHRoaXNbZDNfdmVuZG9yU3ltYm9sKHRoaXMsIFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpXSB8fCBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDE3KTtcbiAgfTtcbiAgZDMudGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICBkM190aW1lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBmdW5jdGlvbiBkM190aW1lcihjYWxsYmFjaywgZGVsYXksIHRoZW4pIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKG4gPCAyKSBkZWxheSA9IDA7XG4gICAgaWYgKG4gPCAzKSB0aGVuID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgdGltZSA9IHRoZW4gKyBkZWxheSwgdGltZXIgPSB7XG4gICAgICBjOiBjYWxsYmFjayxcbiAgICAgIHQ6IHRpbWUsXG4gICAgICBuOiBudWxsXG4gICAgfTtcbiAgICBpZiAoZDNfdGltZXJfcXVldWVUYWlsKSBkM190aW1lcl9xdWV1ZVRhaWwubiA9IHRpbWVyOyBlbHNlIGQzX3RpbWVyX3F1ZXVlSGVhZCA9IHRpbWVyO1xuICAgIGQzX3RpbWVyX3F1ZXVlVGFpbCA9IHRpbWVyO1xuICAgIGlmICghZDNfdGltZXJfaW50ZXJ2YWwpIHtcbiAgICAgIGQzX3RpbWVyX3RpbWVvdXQgPSBjbGVhclRpbWVvdXQoZDNfdGltZXJfdGltZW91dCk7XG4gICAgICBkM190aW1lcl9pbnRlcnZhbCA9IDE7XG4gICAgICBkM190aW1lcl9mcmFtZShkM190aW1lcl9zdGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVyX3N0ZXAoKSB7XG4gICAgdmFyIG5vdyA9IGQzX3RpbWVyX21hcmsoKSwgZGVsYXkgPSBkM190aW1lcl9zd2VlcCgpIC0gbm93O1xuICAgIGlmIChkZWxheSA+IDI0KSB7XG4gICAgICBpZiAoaXNGaW5pdGUoZGVsYXkpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkM190aW1lcl90aW1lb3V0KTtcbiAgICAgICAgZDNfdGltZXJfdGltZW91dCA9IHNldFRpbWVvdXQoZDNfdGltZXJfc3RlcCwgZGVsYXkpO1xuICAgICAgfVxuICAgICAgZDNfdGltZXJfaW50ZXJ2YWwgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBkM190aW1lcl9pbnRlcnZhbCA9IDE7XG4gICAgICBkM190aW1lcl9mcmFtZShkM190aW1lcl9zdGVwKTtcbiAgICB9XG4gIH1cbiAgZDMudGltZXIuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICBkM190aW1lcl9tYXJrKCk7XG4gICAgZDNfdGltZXJfc3dlZXAoKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdGltZXJfbWFyaygpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKSwgdGltZXIgPSBkM190aW1lcl9xdWV1ZUhlYWQ7XG4gICAgd2hpbGUgKHRpbWVyKSB7XG4gICAgICBpZiAobm93ID49IHRpbWVyLnQgJiYgdGltZXIuYyhub3cgLSB0aW1lci50KSkgdGltZXIuYyA9IG51bGw7XG4gICAgICB0aW1lciA9IHRpbWVyLm47XG4gICAgfVxuICAgIHJldHVybiBub3c7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZXJfc3dlZXAoKSB7XG4gICAgdmFyIHQwLCB0MSA9IGQzX3RpbWVyX3F1ZXVlSGVhZCwgdGltZSA9IEluZmluaXR5O1xuICAgIHdoaWxlICh0MSkge1xuICAgICAgaWYgKHQxLmMpIHtcbiAgICAgICAgaWYgKHQxLnQgPCB0aW1lKSB0aW1lID0gdDEudDtcbiAgICAgICAgdDEgPSAodDAgPSB0MSkubjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQxID0gdDAgPyB0MC5uID0gdDEubiA6IGQzX3RpbWVyX3F1ZXVlSGVhZCA9IHQxLm47XG4gICAgICB9XG4gICAgfVxuICAgIGQzX3RpbWVyX3F1ZXVlVGFpbCA9IHQwO1xuICAgIHJldHVybiB0aW1lO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Zvcm1hdF9wcmVjaXNpb24oeCwgcCkge1xuICAgIHJldHVybiBwIC0gKHggPyBNYXRoLmNlaWwoTWF0aC5sb2coeCkgLyBNYXRoLkxOMTApIDogMSk7XG4gIH1cbiAgZDMucm91bmQgPSBmdW5jdGlvbih4LCBuKSB7XG4gICAgcmV0dXJuIG4gPyBNYXRoLnJvdW5kKHggKiAobiA9IE1hdGgucG93KDEwLCBuKSkpIC8gbiA6IE1hdGgucm91bmQoeCk7XG4gIH07XG4gIHZhciBkM19mb3JtYXRQcmVmaXhlcyA9IFsgXCJ5XCIsIFwielwiLCBcImFcIiwgXCJmXCIsIFwicFwiLCBcIm5cIiwgXCLCtVwiLCBcIm1cIiwgXCJcIiwgXCJrXCIsIFwiTVwiLCBcIkdcIiwgXCJUXCIsIFwiUFwiLCBcIkVcIiwgXCJaXCIsIFwiWVwiIF0ubWFwKGQzX2Zvcm1hdFByZWZpeCk7XG4gIGQzLmZvcm1hdFByZWZpeCA9IGZ1bmN0aW9uKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKHZhbHVlID0gK3ZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSAqPSAtMTtcbiAgICAgIGlmIChwcmVjaXNpb24pIHZhbHVlID0gZDMucm91bmQodmFsdWUsIGQzX2Zvcm1hdF9wcmVjaXNpb24odmFsdWUsIHByZWNpc2lvbikpO1xuICAgICAgaSA9IDEgKyBNYXRoLmZsb29yKDFlLTEyICsgTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjEwKTtcbiAgICAgIGkgPSBNYXRoLm1heCgtMjQsIE1hdGgubWluKDI0LCBNYXRoLmZsb29yKChpIC0gMSkgLyAzKSAqIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX2Zvcm1hdFByZWZpeGVzWzggKyBpIC8gM107XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Zvcm1hdFByZWZpeChkLCBpKSB7XG4gICAgdmFyIGsgPSBNYXRoLnBvdygxMCwgYWJzKDggLSBpKSAqIDMpO1xuICAgIHJldHVybiB7XG4gICAgICBzY2FsZTogaSA+IDggPyBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkIC8gaztcbiAgICAgIH0gOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkICogaztcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6IGRcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xvY2FsZV9udW1iZXJGb3JtYXQobG9jYWxlKSB7XG4gICAgdmFyIGxvY2FsZV9kZWNpbWFsID0gbG9jYWxlLmRlY2ltYWwsIGxvY2FsZV90aG91c2FuZHMgPSBsb2NhbGUudGhvdXNhbmRzLCBsb2NhbGVfZ3JvdXBpbmcgPSBsb2NhbGUuZ3JvdXBpbmcsIGxvY2FsZV9jdXJyZW5jeSA9IGxvY2FsZS5jdXJyZW5jeSwgZm9ybWF0R3JvdXAgPSBsb2NhbGVfZ3JvdXBpbmcgJiYgbG9jYWxlX3Rob3VzYW5kcyA/IGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsIHQgPSBbXSwgaiA9IDAsIGcgPSBsb2NhbGVfZ3JvdXBpbmdbMF0sIGxlbmd0aCA9IDA7XG4gICAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICAgIGcgPSBsb2NhbGVfZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBsb2NhbGVfZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKGxvY2FsZV90aG91c2FuZHMpO1xuICAgIH0gOiBkM19pZGVudGl0eTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBkM19mb3JtYXRfcmUuZXhlYyhzcGVjaWZpZXIpLCBmaWxsID0gbWF0Y2hbMV0gfHwgXCIgXCIsIGFsaWduID0gbWF0Y2hbMl0gfHwgXCI+XCIsIHNpZ24gPSBtYXRjaFszXSB8fCBcIi1cIiwgc3ltYm9sID0gbWF0Y2hbNF0gfHwgXCJcIiwgemZpbGwgPSBtYXRjaFs1XSwgd2lkdGggPSArbWF0Y2hbNl0sIGNvbW1hID0gbWF0Y2hbN10sIHByZWNpc2lvbiA9IG1hdGNoWzhdLCB0eXBlID0gbWF0Y2hbOV0sIHNjYWxlID0gMSwgcHJlZml4ID0gXCJcIiwgc3VmZml4ID0gXCJcIiwgaW50ZWdlciA9IGZhbHNlLCBleHBvbmVudCA9IHRydWU7XG4gICAgICBpZiAocHJlY2lzaW9uKSBwcmVjaXNpb24gPSArcHJlY2lzaW9uLnN1YnN0cmluZygxKTtcbiAgICAgIGlmICh6ZmlsbCB8fCBmaWxsID09PSBcIjBcIiAmJiBhbGlnbiA9PT0gXCI9XCIpIHtcbiAgICAgICAgemZpbGwgPSBmaWxsID0gXCIwXCI7XG4gICAgICAgIGFsaWduID0gXCI9XCI7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICBjb21tYSA9IHRydWU7XG4gICAgICAgIHR5cGUgPSBcImdcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBzY2FsZSA9IDEwMDtcbiAgICAgICAgc3VmZml4ID0gXCIlXCI7XG4gICAgICAgIHR5cGUgPSBcImZcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICBzY2FsZSA9IDEwMDtcbiAgICAgICAgc3VmZml4ID0gXCIlXCI7XG4gICAgICAgIHR5cGUgPSBcInJcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgY2FzZSBcInhcIjpcbiAgICAgICBjYXNlIFwiWFwiOlxuICAgICAgICBpZiAoc3ltYm9sID09PSBcIiNcIikgcHJlZml4ID0gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICBleHBvbmVudCA9IGZhbHNlO1xuXG4gICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgaW50ZWdlciA9IHRydWU7XG4gICAgICAgIHByZWNpc2lvbiA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgc2NhbGUgPSAtMTtcbiAgICAgICAgdHlwZSA9IFwiclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzeW1ib2wgPT09IFwiJFwiKSBwcmVmaXggPSBsb2NhbGVfY3VycmVuY3lbMF0sIHN1ZmZpeCA9IGxvY2FsZV9jdXJyZW5jeVsxXTtcbiAgICAgIGlmICh0eXBlID09IFwiclwiICYmICFwcmVjaXNpb24pIHR5cGUgPSBcImdcIjtcbiAgICAgIGlmIChwcmVjaXNpb24gIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZSA9PSBcImdcIikgcHJlY2lzaW9uID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpOyBlbHNlIGlmICh0eXBlID09IFwiZVwiIHx8IHR5cGUgPT0gXCJmXCIpIHByZWNpc2lvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSBkM19mb3JtYXRfdHlwZXMuZ2V0KHR5cGUpIHx8IGQzX2Zvcm1hdF90eXBlRGVmYXVsdDtcbiAgICAgIHZhciB6Y29tbWEgPSB6ZmlsbCAmJiBjb21tYTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZnVsbFN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgaWYgKGludGVnZXIgJiYgdmFsdWUgJSAxKSByZXR1cm4gXCJcIjtcbiAgICAgICAgdmFyIG5lZ2F0aXZlID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAodmFsdWUgPSAtdmFsdWUsIFwiLVwiKSA6IHNpZ24gPT09IFwiLVwiID8gXCJcIiA6IHNpZ247XG4gICAgICAgIGlmIChzY2FsZSA8IDApIHtcbiAgICAgICAgICB2YXIgdW5pdCA9IGQzLmZvcm1hdFByZWZpeCh2YWx1ZSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICB2YWx1ZSA9IHVuaXQuc2NhbGUodmFsdWUpO1xuICAgICAgICAgIGZ1bGxTdWZmaXggPSB1bml0LnN5bWJvbCArIHN1ZmZpeDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSAqPSBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHR5cGUodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICAgIHZhciBpID0gdmFsdWUubGFzdEluZGV4T2YoXCIuXCIpLCBiZWZvcmUsIGFmdGVyO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICB2YXIgaiA9IGV4cG9uZW50ID8gdmFsdWUubGFzdEluZGV4T2YoXCJlXCIpIDogLTE7XG4gICAgICAgICAgaWYgKGogPCAwKSBiZWZvcmUgPSB2YWx1ZSwgYWZ0ZXIgPSBcIlwiOyBlbHNlIGJlZm9yZSA9IHZhbHVlLnN1YnN0cmluZygwLCBqKSwgYWZ0ZXIgPSB2YWx1ZS5zdWJzdHJpbmcoaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmVmb3JlID0gdmFsdWUuc3Vic3RyaW5nKDAsIGkpO1xuICAgICAgICAgIGFmdGVyID0gbG9jYWxlX2RlY2ltYWwgKyB2YWx1ZS5zdWJzdHJpbmcoaSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghemZpbGwgJiYgY29tbWEpIGJlZm9yZSA9IGZvcm1hdEdyb3VwKGJlZm9yZSwgSW5maW5pdHkpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIGJlZm9yZS5sZW5ndGggKyBhZnRlci5sZW5ndGggKyAoemNvbW1hID8gMCA6IG5lZ2F0aXZlLmxlbmd0aCksIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheShsZW5ndGggPSB3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuICAgICAgICBpZiAoemNvbW1hKSBiZWZvcmUgPSBmb3JtYXRHcm91cChwYWRkaW5nICsgYmVmb3JlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gYWZ0ZXIubGVuZ3RoIDogSW5maW5pdHkpO1xuICAgICAgICBuZWdhdGl2ZSArPSBwcmVmaXg7XG4gICAgICAgIHZhbHVlID0gYmVmb3JlICsgYWZ0ZXI7XG4gICAgICAgIHJldHVybiAoYWxpZ24gPT09IFwiPFwiID8gbmVnYXRpdmUgKyB2YWx1ZSArIHBhZGRpbmcgOiBhbGlnbiA9PT0gXCI+XCIgPyBwYWRkaW5nICsgbmVnYXRpdmUgKyB2YWx1ZSA6IGFsaWduID09PSBcIl5cIiA/IHBhZGRpbmcuc3Vic3RyaW5nKDAsIGxlbmd0aCA+Pj0gMSkgKyBuZWdhdGl2ZSArIHZhbHVlICsgcGFkZGluZy5zdWJzdHJpbmcobGVuZ3RoKSA6IG5lZ2F0aXZlICsgKHpjb21tYSA/IHZhbHVlIDogcGFkZGluZyArIHZhbHVlKSkgKyBmdWxsU3VmZml4O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19mb3JtYXRfcmUgPSAvKD86KFtee10pPyhbPD49Xl0pKT8oWytcXC0gXSk/KFskI10pPygwKT8oXFxkKyk/KCwpPyhcXC4tP1xcZCspPyhbYS16JV0pPy9pO1xuICB2YXIgZDNfZm9ybWF0X3R5cGVzID0gZDMubWFwKHtcbiAgICBiOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50b1N0cmluZygyKTtcbiAgICB9LFxuICAgIGM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoOCk7XG4gICAgfSxcbiAgICB4OiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50b1N0cmluZygxNik7XG4gICAgfSxcbiAgICBYOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuICAgIGc6IGZ1bmN0aW9uKHgsIHApIHtcbiAgICAgIHJldHVybiB4LnRvUHJlY2lzaW9uKHApO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuIHgudG9FeHBvbmVudGlhbChwKTtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uKHgsIHApIHtcbiAgICAgIHJldHVybiB4LnRvRml4ZWQocCk7XG4gICAgfSxcbiAgICByOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4gKHggPSBkMy5yb3VuZCh4LCBkM19mb3JtYXRfcHJlY2lzaW9uKHgsIHApKSkudG9GaXhlZChNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgZDNfZm9ybWF0X3ByZWNpc2lvbih4ICogKDEgKyAxZS0xNSksIHApKSkpO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX2Zvcm1hdF90eXBlRGVmYXVsdCh4KSB7XG4gICAgcmV0dXJuIHggKyBcIlwiO1xuICB9XG4gIHZhciBkM190aW1lID0gZDMudGltZSA9IHt9LCBkM19kYXRlID0gRGF0ZTtcbiAgZnVuY3Rpb24gZDNfZGF0ZV91dGMoKSB7XG4gICAgdGhpcy5fID0gbmV3IERhdGUoYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBEYXRlLlVUQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdKTtcbiAgfVxuICBkM19kYXRlX3V0Yy5wcm90b3R5cGUgPSB7XG4gICAgZ2V0RGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ0RhdGUoKTtcbiAgICB9LFxuICAgIGdldERheTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ0RheSgpO1xuICAgIH0sXG4gICAgZ2V0RnVsbFllYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENGdWxsWWVhcigpO1xuICAgIH0sXG4gICAgZ2V0SG91cnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENIb3VycygpO1xuICAgIH0sXG4gICAgZ2V0TWlsbGlzZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgfSxcbiAgICBnZXRNaW51dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDTWludXRlcygpO1xuICAgIH0sXG4gICAgZ2V0TW9udGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENNb250aCgpO1xuICAgIH0sXG4gICAgZ2V0U2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ1NlY29uZHMoKTtcbiAgICB9LFxuICAgIGdldFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRUaW1lKCk7XG4gICAgfSxcbiAgICBnZXRUaW1lem9uZU9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy52YWx1ZU9mKCk7XG4gICAgfSxcbiAgICBzZXREYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ0RhdGUuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0RGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ0RheS5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRGdWxsWWVhcjogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENGdWxsWWVhci5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRIb3VyczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENIb3Vycy5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRNaWxsaXNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDTWlsbGlzZWNvbmRzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldE1pbnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDTWludXRlcy5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRNb250aDogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENNb250aC5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRTZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ1NlY29uZHMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRUaW1lLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIHZhciBkM190aW1lX3Byb3RvdHlwZSA9IERhdGUucHJvdG90eXBlO1xuICBmdW5jdGlvbiBkM190aW1lX2ludGVydmFsKGxvY2FsLCBzdGVwLCBudW1iZXIpIHtcbiAgICBmdW5jdGlvbiByb3VuZChkYXRlKSB7XG4gICAgICB2YXIgZDAgPSBsb2NhbChkYXRlKSwgZDEgPSBvZmZzZXQoZDAsIDEpO1xuICAgICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlaWwoZGF0ZSkge1xuICAgICAgc3RlcChkYXRlID0gbG9jYWwobmV3IGQzX2RhdGUoZGF0ZSAtIDEpKSwgMSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2Zmc2V0KGRhdGUsIGspIHtcbiAgICAgIHN0ZXAoZGF0ZSA9IG5ldyBkM19kYXRlKCtkYXRlKSwgayk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2UodDAsIHQxLCBkdCkge1xuICAgICAgdmFyIHRpbWUgPSBjZWlsKHQwKSwgdGltZXMgPSBbXTtcbiAgICAgIGlmIChkdCA+IDEpIHtcbiAgICAgICAgd2hpbGUgKHRpbWUgPCB0MSkge1xuICAgICAgICAgIGlmICghKG51bWJlcih0aW1lKSAlIGR0KSkgdGltZXMucHVzaChuZXcgRGF0ZSgrdGltZSkpO1xuICAgICAgICAgIHN0ZXAodGltZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlICh0aW1lIDwgdDEpIHRpbWVzLnB1c2gobmV3IERhdGUoK3RpbWUpKSwgc3RlcCh0aW1lLCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aW1lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2VfdXRjKHQwLCB0MSwgZHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQzX2RhdGUgPSBkM19kYXRlX3V0YztcbiAgICAgICAgdmFyIHV0YyA9IG5ldyBkM19kYXRlX3V0YygpO1xuICAgICAgICB1dGMuXyA9IHQwO1xuICAgICAgICByZXR1cm4gcmFuZ2UodXRjLCB0MSwgZHQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGxvY2FsLmZsb29yID0gbG9jYWw7XG4gICAgbG9jYWwucm91bmQgPSByb3VuZDtcbiAgICBsb2NhbC5jZWlsID0gY2VpbDtcbiAgICBsb2NhbC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgbG9jYWwucmFuZ2UgPSByYW5nZTtcbiAgICB2YXIgdXRjID0gbG9jYWwudXRjID0gZDNfdGltZV9pbnRlcnZhbF91dGMobG9jYWwpO1xuICAgIHV0Yy5mbG9vciA9IHV0YztcbiAgICB1dGMucm91bmQgPSBkM190aW1lX2ludGVydmFsX3V0Yyhyb3VuZCk7XG4gICAgdXRjLmNlaWwgPSBkM190aW1lX2ludGVydmFsX3V0YyhjZWlsKTtcbiAgICB1dGMub2Zmc2V0ID0gZDNfdGltZV9pbnRlcnZhbF91dGMob2Zmc2V0KTtcbiAgICB1dGMucmFuZ2UgPSByYW5nZV91dGM7XG4gICAgcmV0dXJuIGxvY2FsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfaW50ZXJ2YWxfdXRjKG1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRlLCBrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkM19kYXRlID0gZDNfZGF0ZV91dGM7XG4gICAgICAgIHZhciB1dGMgPSBuZXcgZDNfZGF0ZV91dGMoKTtcbiAgICAgICAgdXRjLl8gPSBkYXRlO1xuICAgICAgICByZXR1cm4gbWV0aG9kKHV0YywgaykuXztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzX2RhdGUgPSBEYXRlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDNfdGltZS55ZWFyID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZSA9IGQzX3RpbWUuZGF5KGRhdGUpO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgb2Zmc2V0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gIH0pO1xuICBkM190aW1lLnllYXJzID0gZDNfdGltZS55ZWFyLnJhbmdlO1xuICBkM190aW1lLnllYXJzLnV0YyA9IGQzX3RpbWUueWVhci51dGMucmFuZ2U7XG4gIGQzX3RpbWUuZGF5ID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIGRheSA9IG5ldyBkM19kYXRlKDJlMywgMCk7XG4gICAgZGF5LnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgcmV0dXJuIGRheTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldERhdGUoKSAtIDE7XG4gIH0pO1xuICBkM190aW1lLmRheXMgPSBkM190aW1lLmRheS5yYW5nZTtcbiAgZDNfdGltZS5kYXlzLnV0YyA9IGQzX3RpbWUuZGF5LnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5kYXlPZlllYXIgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIHllYXIgPSBkM190aW1lLnllYXIoZGF0ZSk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUgLSB5ZWFyIC0gKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHllYXIuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gODY0ZTUpO1xuICB9O1xuICBbIFwic3VuZGF5XCIsIFwibW9uZGF5XCIsIFwidHVlc2RheVwiLCBcIndlZG5lc2RheVwiLCBcInRodXJzZGF5XCIsIFwiZnJpZGF5XCIsIFwic2F0dXJkYXlcIiBdLmZvckVhY2goZnVuY3Rpb24oZGF5LCBpKSB7XG4gICAgaSA9IDcgLSBpO1xuICAgIHZhciBpbnRlcnZhbCA9IGQzX3RpbWVbZGF5XSA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgKGRhdGUgPSBkM190aW1lLmRheShkYXRlKSkuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgaSkgJSA3KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGRheSA9IGQzX3RpbWUueWVhcihkYXRlKS5nZXREYXkoKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChkM190aW1lLmRheU9mWWVhcihkYXRlKSArIChkYXkgKyBpKSAlIDcpIC8gNykgLSAoZGF5ICE9PSBpKTtcbiAgICB9KTtcbiAgICBkM190aW1lW2RheSArIFwic1wiXSA9IGludGVydmFsLnJhbmdlO1xuICAgIGQzX3RpbWVbZGF5ICsgXCJzXCJdLnV0YyA9IGludGVydmFsLnV0Yy5yYW5nZTtcbiAgICBkM190aW1lW2RheSArIFwiT2ZZZWFyXCJdID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGRheSA9IGQzX3RpbWUueWVhcihkYXRlKS5nZXREYXkoKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChkM190aW1lLmRheU9mWWVhcihkYXRlKSArIChkYXkgKyBpKSAlIDcpIC8gNyk7XG4gICAgfTtcbiAgfSk7XG4gIGQzX3RpbWUud2VlayA9IGQzX3RpbWUuc3VuZGF5O1xuICBkM190aW1lLndlZWtzID0gZDNfdGltZS5zdW5kYXkucmFuZ2U7XG4gIGQzX3RpbWUud2Vla3MudXRjID0gZDNfdGltZS5zdW5kYXkudXRjLnJhbmdlO1xuICBkM190aW1lLndlZWtPZlllYXIgPSBkM190aW1lLnN1bmRheU9mWWVhcjtcbiAgZnVuY3Rpb24gZDNfbG9jYWxlX3RpbWVGb3JtYXQobG9jYWxlKSB7XG4gICAgdmFyIGxvY2FsZV9kYXRlVGltZSA9IGxvY2FsZS5kYXRlVGltZSwgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSwgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSwgbG9jYWxlX3BlcmlvZHMgPSBsb2NhbGUucGVyaW9kcywgbG9jYWxlX2RheXMgPSBsb2NhbGUuZGF5cywgbG9jYWxlX3Nob3J0RGF5cyA9IGxvY2FsZS5zaG9ydERheXMsIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLCBsb2NhbGVfc2hvcnRNb250aHMgPSBsb2NhbGUuc2hvcnRNb250aHM7XG4gICAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXQodGVtcGxhdGUpIHtcbiAgICAgIHZhciBuID0gdGVtcGxhdGUubGVuZ3RoO1xuICAgICAgZnVuY3Rpb24gZm9ybWF0KGRhdGUpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IFtdLCBpID0gLTEsIGogPSAwLCBjLCBwLCBmO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQ29kZUF0KGkpID09PSAzNykge1xuICAgICAgICAgICAgc3RyaW5nLnB1c2godGVtcGxhdGUuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgICAgaWYgKChwID0gZDNfdGltZV9mb3JtYXRQYWRzW2MgPSB0ZW1wbGF0ZS5jaGFyQXQoKytpKV0pICE9IG51bGwpIGMgPSB0ZW1wbGF0ZS5jaGFyQXQoKytpKTtcbiAgICAgICAgICAgIGlmIChmID0gZDNfdGltZV9mb3JtYXRzW2NdKSBjID0gZihkYXRlLCBwID09IG51bGwgPyBjID09PSBcImVcIiA/IFwiIFwiIDogXCIwXCIgOiBwKTtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKGMpO1xuICAgICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcucHVzaCh0ZW1wbGF0ZS5zbGljZShqLCBpKSk7XG4gICAgICAgIHJldHVybiBzdHJpbmcuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGZvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB2YXIgZCA9IHtcbiAgICAgICAgICB5OiAxOTAwLFxuICAgICAgICAgIG06IDAsXG4gICAgICAgICAgZDogMSxcbiAgICAgICAgICBIOiAwLFxuICAgICAgICAgIE06IDAsXG4gICAgICAgICAgUzogMCxcbiAgICAgICAgICBMOiAwLFxuICAgICAgICAgIFo6IG51bGxcbiAgICAgICAgfSwgaSA9IGQzX3RpbWVfcGFyc2UoZCwgdGVtcGxhdGUsIHN0cmluZywgMCk7XG4gICAgICAgIGlmIChpICE9IHN0cmluZy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoXCJwXCIgaW4gZCkgZC5IID0gZC5IICUgMTIgKyBkLnAgKiAxMjtcbiAgICAgICAgdmFyIGxvY2FsWiA9IGQuWiAhPSBudWxsICYmIGQzX2RhdGUgIT09IGQzX2RhdGVfdXRjLCBkYXRlID0gbmV3IChsb2NhbFogPyBkM19kYXRlX3V0YyA6IGQzX2RhdGUpKCk7XG4gICAgICAgIGlmIChcImpcIiBpbiBkKSBkYXRlLnNldEZ1bGxZZWFyKGQueSwgMCwgZC5qKTsgZWxzZSBpZiAoXCJXXCIgaW4gZCB8fCBcIlVcIiBpbiBkKSB7XG4gICAgICAgICAgaWYgKCEoXCJ3XCIgaW4gZCkpIGQudyA9IFwiV1wiIGluIGQgPyAxIDogMDtcbiAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSwgMCwgMSk7XG4gICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkLnksIDAsIFwiV1wiIGluIGQgPyAoZC53ICsgNikgJSA3ICsgZC5XICogNyAtIChkYXRlLmdldERheSgpICsgNSkgJSA3IDogZC53ICsgZC5VICogNyAtIChkYXRlLmdldERheSgpICsgNikgJSA3KTtcbiAgICAgICAgfSBlbHNlIGRhdGUuc2V0RnVsbFllYXIoZC55LCBkLm0sIGQuZCk7XG4gICAgICAgIGRhdGUuc2V0SG91cnMoZC5IICsgKGQuWiAvIDEwMCB8IDApLCBkLk0gKyBkLlogJSAxMDAsIGQuUywgZC5MKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsWiA/IGRhdGUuXyA6IGRhdGU7XG4gICAgICB9O1xuICAgICAgZm9ybWF0LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlKGRhdGUsIHRlbXBsYXRlLCBzdHJpbmcsIGopIHtcbiAgICAgIHZhciBjLCBwLCB0LCBpID0gMCwgbiA9IHRlbXBsYXRlLmxlbmd0aCwgbSA9IHN0cmluZy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgaWYgKGogPj0gbSkgcmV0dXJuIC0xO1xuICAgICAgICBjID0gdGVtcGxhdGUuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBpZiAoYyA9PT0gMzcpIHtcbiAgICAgICAgICB0ID0gdGVtcGxhdGUuY2hhckF0KGkrKyk7XG4gICAgICAgICAgcCA9IGQzX3RpbWVfcGFyc2Vyc1t0IGluIGQzX3RpbWVfZm9ybWF0UGFkcyA/IHRlbXBsYXRlLmNoYXJBdChpKyspIDogdF07XG4gICAgICAgICAgaWYgKCFwIHx8IChqID0gcChkYXRlLCBzdHJpbmcsIGopKSA8IDApIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChjICE9IHN0cmluZy5jaGFyQ29kZUF0KGorKykpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBqO1xuICAgIH1cbiAgICBkM190aW1lX2Zvcm1hdC51dGMgPSBmdW5jdGlvbih0ZW1wbGF0ZSkge1xuICAgICAgdmFyIGxvY2FsID0gZDNfdGltZV9mb3JtYXQodGVtcGxhdGUpO1xuICAgICAgZnVuY3Rpb24gZm9ybWF0KGRhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkM19kYXRlID0gZDNfZGF0ZV91dGM7XG4gICAgICAgICAgdmFyIHV0YyA9IG5ldyBkM19kYXRlKCk7XG4gICAgICAgICAgdXRjLl8gPSBkYXRlO1xuICAgICAgICAgIHJldHVybiBsb2NhbCh1dGMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGQzX2RhdGUgPSBEYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3JtYXQucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkM19kYXRlID0gZDNfZGF0ZV91dGM7XG4gICAgICAgICAgdmFyIGRhdGUgPSBsb2NhbC5wYXJzZShzdHJpbmcpO1xuICAgICAgICAgIHJldHVybiBkYXRlICYmIGRhdGUuXztcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZvcm1hdC50b1N0cmluZyA9IGxvY2FsLnRvU3RyaW5nO1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9O1xuICAgIGQzX3RpbWVfZm9ybWF0Lm11bHRpID0gZDNfdGltZV9mb3JtYXQudXRjLm11bHRpID0gZDNfdGltZV9mb3JtYXRNdWx0aTtcbiAgICB2YXIgZDNfdGltZV9wZXJpb2RMb29rdXAgPSBkMy5tYXAoKSwgZDNfdGltZV9kYXlSZSA9IGQzX3RpbWVfZm9ybWF0UmUobG9jYWxlX2RheXMpLCBkM190aW1lX2RheUxvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9kYXlzKSwgZDNfdGltZV9kYXlBYmJyZXZSZSA9IGQzX3RpbWVfZm9ybWF0UmUobG9jYWxlX3Nob3J0RGF5cyksIGQzX3RpbWVfZGF5QWJicmV2TG9va3VwID0gZDNfdGltZV9mb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0RGF5cyksIGQzX3RpbWVfbW9udGhSZSA9IGQzX3RpbWVfZm9ybWF0UmUobG9jYWxlX21vbnRocyksIGQzX3RpbWVfbW9udGhMb29rdXAgPSBkM190aW1lX2Zvcm1hdExvb2t1cChsb2NhbGVfbW9udGhzKSwgZDNfdGltZV9tb250aEFiYnJldlJlID0gZDNfdGltZV9mb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLCBkM190aW1lX21vbnRoQWJicmV2TG9va3VwID0gZDNfdGltZV9mb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcbiAgICBsb2NhbGVfcGVyaW9kcy5mb3JFYWNoKGZ1bmN0aW9uKHAsIGkpIHtcbiAgICAgIGQzX3RpbWVfcGVyaW9kTG9va3VwLnNldChwLnRvTG93ZXJDYXNlKCksIGkpO1xuICAgIH0pO1xuICAgIHZhciBkM190aW1lX2Zvcm1hdHMgPSB7XG4gICAgICBhOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfc2hvcnREYXlzW2QuZ2V0RGF5KCldO1xuICAgICAgfSxcbiAgICAgIEE6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZV9kYXlzW2QuZ2V0RGF5KCldO1xuICAgICAgfSxcbiAgICAgIGI6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgICAgfSxcbiAgICAgIEI6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRNb250aCgpXTtcbiAgICAgIH0sXG4gICAgICBjOiBkM190aW1lX2Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUpLFxuICAgICAgZDogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXREYXRlKCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIGU6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBIOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldEhvdXJzKCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIEk6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBqOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZCgxICsgZDNfdGltZS5kYXlPZlllYXIoZCksIHAsIDMpO1xuICAgICAgfSxcbiAgICAgIEw6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIHAsIDMpO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0TW9udGgoKSArIDEsIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIE06IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBwOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0SG91cnMoKSA+PSAxMildO1xuICAgICAgfSxcbiAgICAgIFM6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0U2Vjb25kcygpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBVOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkM190aW1lLnN1bmRheU9mWWVhcihkKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgdzogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZC5nZXREYXkoKTtcbiAgICAgIH0sXG4gICAgICBXOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkM190aW1lLm1vbmRheU9mWWVhcihkKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgeDogZDNfdGltZV9mb3JtYXQobG9jYWxlX2RhdGUpLFxuICAgICAgWDogZDNfdGltZV9mb3JtYXQobG9jYWxlX3RpbWUpLFxuICAgICAgeTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBZOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldEZ1bGxZZWFyKCkgJSAxZTQsIHAsIDQpO1xuICAgICAgfSxcbiAgICAgIFo6IGQzX3RpbWVfem9uZSxcbiAgICAgIFwiJVwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiJVwiO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGQzX3RpbWVfcGFyc2VycyA9IHtcbiAgICAgIGE6IGQzX3RpbWVfcGFyc2VXZWVrZGF5QWJicmV2LFxuICAgICAgQTogZDNfdGltZV9wYXJzZVdlZWtkYXksXG4gICAgICBiOiBkM190aW1lX3BhcnNlTW9udGhBYmJyZXYsXG4gICAgICBCOiBkM190aW1lX3BhcnNlTW9udGgsXG4gICAgICBjOiBkM190aW1lX3BhcnNlTG9jYWxlRnVsbCxcbiAgICAgIGQ6IGQzX3RpbWVfcGFyc2VEYXksXG4gICAgICBlOiBkM190aW1lX3BhcnNlRGF5LFxuICAgICAgSDogZDNfdGltZV9wYXJzZUhvdXIyNCxcbiAgICAgIEk6IGQzX3RpbWVfcGFyc2VIb3VyMjQsXG4gICAgICBqOiBkM190aW1lX3BhcnNlRGF5T2ZZZWFyLFxuICAgICAgTDogZDNfdGltZV9wYXJzZU1pbGxpc2Vjb25kcyxcbiAgICAgIG06IGQzX3RpbWVfcGFyc2VNb250aE51bWJlcixcbiAgICAgIE06IGQzX3RpbWVfcGFyc2VNaW51dGVzLFxuICAgICAgcDogZDNfdGltZV9wYXJzZUFtUG0sXG4gICAgICBTOiBkM190aW1lX3BhcnNlU2Vjb25kcyxcbiAgICAgIFU6IGQzX3RpbWVfcGFyc2VXZWVrTnVtYmVyU3VuZGF5LFxuICAgICAgdzogZDNfdGltZV9wYXJzZVdlZWtkYXlOdW1iZXIsXG4gICAgICBXOiBkM190aW1lX3BhcnNlV2Vla051bWJlck1vbmRheSxcbiAgICAgIHg6IGQzX3RpbWVfcGFyc2VMb2NhbGVEYXRlLFxuICAgICAgWDogZDNfdGltZV9wYXJzZUxvY2FsZVRpbWUsXG4gICAgICB5OiBkM190aW1lX3BhcnNlWWVhcixcbiAgICAgIFk6IGQzX3RpbWVfcGFyc2VGdWxsWWVhcixcbiAgICAgIFo6IGQzX3RpbWVfcGFyc2Vab25lLFxuICAgICAgXCIlXCI6IGQzX3RpbWVfcGFyc2VMaXRlcmFsUGVyY2VudFxuICAgIH07XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtkYXlBYmJyZXYoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICBkM190aW1lX2RheUFiYnJldlJlLmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfZGF5QWJicmV2UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZGF0ZS53ID0gZDNfdGltZV9kYXlBYmJyZXZMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtkYXkoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICBkM190aW1lX2RheVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZGF0ZS53ID0gZDNfdGltZV9kYXlMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZU1vbnRoQWJicmV2KGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9tb250aEFiYnJldlJlLmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfbW9udGhBYmJyZXZSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkYXRlLm0gPSBkM190aW1lX21vbnRoQWJicmV2TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNb250aChkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIGQzX3RpbWVfbW9udGhSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX21vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZGF0ZS5tID0gZDNfdGltZV9tb250aExvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTG9jYWxlRnVsbChkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3BhcnNlKGRhdGUsIGQzX3RpbWVfZm9ybWF0cy5jLnRvU3RyaW5nKCksIHN0cmluZywgaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VMb2NhbGVEYXRlKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfcGFyc2UoZGF0ZSwgZDNfdGltZV9mb3JtYXRzLngudG9TdHJpbmcoKSwgc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUxvY2FsZVRpbWUoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9wYXJzZShkYXRlLCBkM190aW1lX2Zvcm1hdHMuWC50b1N0cmluZygpLCBzdHJpbmcsIGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlQW1QbShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gZDNfdGltZV9wZXJpb2RMb29rdXAuZ2V0KHN0cmluZy5zbGljZShpLCBpICs9IDIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgcmV0dXJuIG4gPT0gbnVsbCA/IC0xIDogKGRhdGUucCA9IG4sIGkpO1xuICAgIH1cbiAgICByZXR1cm4gZDNfdGltZV9mb3JtYXQ7XG4gIH1cbiAgdmFyIGQzX3RpbWVfZm9ybWF0UGFkcyA9IHtcbiAgICBcIi1cIjogXCJcIixcbiAgICBfOiBcIiBcIixcbiAgICBcIjBcIjogXCIwXCJcbiAgfSwgZDNfdGltZV9udW1iZXJSZSA9IC9eXFxzKlxcZCsvLCBkM190aW1lX3BlcmNlbnRSZSA9IC9eJS87XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0UGFkKHZhbHVlLCBmaWxsLCB3aWR0aCkge1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gXCItXCIgOiBcIlwiLCBzdHJpbmcgPSAoc2lnbiA/IC12YWx1ZSA6IHZhbHVlKSArIFwiXCIsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgcmV0dXJuIHNpZ24gKyAobGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpICsgc3RyaW5nIDogc3RyaW5nKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdFJlKG5hbWVzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBuYW1lcy5tYXAoZDMucmVxdW90ZSkuam9pbihcInxcIikgKyBcIilcIiwgXCJpXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0TG9va3VwKG5hbWVzKSB7XG4gICAgdmFyIG1hcCA9IG5ldyBkM19NYXAoKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KG5hbWVzW2ldLnRvTG93ZXJDYXNlKCksIGkpO1xuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtkYXlOdW1iZXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICAgIHJldHVybiBuID8gKGRhdGUudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJTdW5kYXkoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlV2Vla051bWJlck1vbmRheShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLlcgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VGdWxsWWVhcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA0KSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS55ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlWWVhcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS55ID0gZDNfdGltZV9leHBhbmRZZWFyKCtuWzBdKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2Vab25lKGRhdGUsIHN0cmluZywgaSkge1xuICAgIHJldHVybiAvXlsrLV1cXGR7NH0kLy50ZXN0KHN0cmluZyA9IHN0cmluZy5zbGljZShpLCBpICsgNSkpID8gKGRhdGUuWiA9IC1zdHJpbmcsIFxuICAgIGkgKyA1KSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZXhwYW5kWWVhcihkKSB7XG4gICAgcmV0dXJuIGQgKyAoZCA+IDY4ID8gMTkwMCA6IDJlMyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZU1vbnRoTnVtYmVyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLm0gPSBuWzBdIC0gMSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VEYXkoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZURheU9mWWVhcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5qID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlSG91cjI0KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLkggPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNaW51dGVzKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLk0gPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VTZWNvbmRzKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNaWxsaXNlY29uZHMoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICAgIHJldHVybiBuID8gKGRhdGUuTCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV96b25lKGQpIHtcbiAgICB2YXIgeiA9IGQuZ2V0VGltZXpvbmVPZmZzZXQoKSwgenMgPSB6ID4gMCA/IFwiLVwiIDogXCIrXCIsIHpoID0gYWJzKHopIC8gNjAgfCAwLCB6bSA9IGFicyh6KSAlIDYwO1xuICAgIHJldHVybiB6cyArIGQzX3RpbWVfZm9ybWF0UGFkKHpoLCBcIjBcIiwgMikgKyBkM190aW1lX2Zvcm1hdFBhZCh6bSwgXCIwXCIsIDIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VMaXRlcmFsUGVyY2VudChkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX3BlcmNlbnRSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9wZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0TXVsdGkoZm9ybWF0cykge1xuICAgIHZhciBuID0gZm9ybWF0cy5sZW5ndGgsIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbikgZm9ybWF0c1tpXVswXSA9IHRoaXMoZm9ybWF0c1tpXVswXSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBpID0gMCwgZiA9IGZvcm1hdHNbaV07XG4gICAgICB3aGlsZSAoIWZbMV0oZGF0ZSkpIGYgPSBmb3JtYXRzWysraV07XG4gICAgICByZXR1cm4gZlswXShkYXRlKTtcbiAgICB9O1xuICB9XG4gIGQzLmxvY2FsZSA9IGZ1bmN0aW9uKGxvY2FsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBudW1iZXJGb3JtYXQ6IGQzX2xvY2FsZV9udW1iZXJGb3JtYXQobG9jYWxlKSxcbiAgICAgIHRpbWVGb3JtYXQ6IGQzX2xvY2FsZV90aW1lRm9ybWF0KGxvY2FsZSlcbiAgICB9O1xuICB9O1xuICB2YXIgZDNfbG9jYWxlX2VuVVMgPSBkMy5sb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFsgMyBdLFxuICAgIGN1cnJlbmN5OiBbIFwiJFwiLCBcIlwiIF0sXG4gICAgZGF0ZVRpbWU6IFwiJWEgJWIgJWUgJVggJVlcIixcbiAgICBkYXRlOiBcIiVtLyVkLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFsgXCJBTVwiLCBcIlBNXCIgXSxcbiAgICBkYXlzOiBbIFwiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiBdLFxuICAgIHNob3J0RGF5czogWyBcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiIF0sXG4gICAgbW9udGhzOiBbIFwiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIiBdLFxuICAgIHNob3J0TW9udGhzOiBbIFwiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCIgXVxuICB9KTtcbiAgZDMuZm9ybWF0ID0gZDNfbG9jYWxlX2VuVVMubnVtYmVyRm9ybWF0O1xuICBkMy5nZW8gPSB7fTtcbiAgZnVuY3Rpb24gZDNfYWRkZXIoKSB7fVxuICBkM19hZGRlci5wcm90b3R5cGUgPSB7XG4gICAgczogMCxcbiAgICB0OiAwLFxuICAgIGFkZDogZnVuY3Rpb24oeSkge1xuICAgICAgZDNfYWRkZXJTdW0oeSwgdGhpcy50LCBkM19hZGRlclRlbXApO1xuICAgICAgZDNfYWRkZXJTdW0oZDNfYWRkZXJUZW1wLnMsIHRoaXMucywgdGhpcyk7XG4gICAgICBpZiAodGhpcy5zKSB0aGlzLnQgKz0gZDNfYWRkZXJUZW1wLnQ7IGVsc2UgdGhpcy5zID0gZDNfYWRkZXJUZW1wLnQ7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnMgPSB0aGlzLnQgPSAwO1xuICAgIH0sXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zO1xuICAgIH1cbiAgfTtcbiAgdmFyIGQzX2FkZGVyVGVtcCA9IG5ldyBkM19hZGRlcigpO1xuICBmdW5jdGlvbiBkM19hZGRlclN1bShhLCBiLCBvKSB7XG4gICAgdmFyIHggPSBvLnMgPSBhICsgYiwgYnYgPSB4IC0gYSwgYXYgPSB4IC0gYnY7XG4gICAgby50ID0gYSAtIGF2ICsgKGIgLSBidik7XG4gIH1cbiAgZDMuZ2VvLnN0cmVhbSA9IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICBpZiAob2JqZWN0ICYmIGQzX2dlb19zdHJlYW1PYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKSkge1xuICAgICAgZDNfZ2VvX3N0cmVhbU9iamVjdFR5cGVbb2JqZWN0LnR5cGVdKG9iamVjdCwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkM19nZW9fc3RyZWFtR2VvbWV0cnkob2JqZWN0LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cnksIGxpc3RlbmVyKSB7XG4gICAgaWYgKGdlb21ldHJ5ICYmIGQzX2dlb19zdHJlYW1HZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSkpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1HZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgdmFyIGQzX2dlb19zdHJlYW1PYmplY3RUeXBlID0ge1xuICAgIEZlYXR1cmU6IGZ1bmN0aW9uKGZlYXR1cmUsIGxpc3RlbmVyKSB7XG4gICAgICBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZmVhdHVyZS5nZW9tZXRyeSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBmZWF0dXJlcyA9IG9iamVjdC5mZWF0dXJlcywgaSA9IC0xLCBuID0gZmVhdHVyZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGQzX2dlb19zdHJlYW1HZW9tZXRyeShmZWF0dXJlc1tpXS5nZW9tZXRyeSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGQzX2dlb19zdHJlYW1HZW9tZXRyeVR5cGUgPSB7XG4gICAgU3BoZXJlOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lci5zcGhlcmUoKTtcbiAgICB9LFxuICAgIFBvaW50OiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3QuY29vcmRpbmF0ZXM7XG4gICAgICBsaXN0ZW5lci5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgICB9LFxuICAgIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIG9iamVjdCA9IGNvb3JkaW5hdGVzW2ldLCBsaXN0ZW5lci5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgICB9LFxuICAgIExpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1MaW5lKG9iamVjdC5jb29yZGluYXRlcywgbGlzdGVuZXIsIDApO1xuICAgIH0sXG4gICAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIsIDApO1xuICAgIH0sXG4gICAgUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgZDNfZ2VvX3N0cmVhbVBvbHlnb24ob2JqZWN0LmNvb3JkaW5hdGVzLCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGQzX2dlb19zdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBnZW9tZXRyaWVzID0gb2JqZWN0Lmdlb21ldHJpZXMsIGkgPSAtMSwgbiA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGQzX2dlb19zdHJlYW1HZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fc3RyZWFtTGluZShjb29yZGluYXRlcywgbGlzdGVuZXIsIGNsb3NlZCkge1xuICAgIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGggLSBjbG9zZWQsIGNvb3JkaW5hdGU7XG4gICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIucG9pbnQoY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVsyXSk7XG4gICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19zdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzLCBsaXN0ZW5lcikge1xuICAgIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgbGlzdGVuZXIucG9seWdvblN0YXJ0KCk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGQzX2dlb19zdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBsaXN0ZW5lciwgMSk7XG4gICAgbGlzdGVuZXIucG9seWdvbkVuZCgpO1xuICB9XG4gIGQzLmdlby5hcmVhID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZDNfZ2VvX2FyZWFTdW0gPSAwO1xuICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBkM19nZW9fYXJlYSk7XG4gICAgcmV0dXJuIGQzX2dlb19hcmVhU3VtO1xuICB9O1xuICB2YXIgZDNfZ2VvX2FyZWFTdW0sIGQzX2dlb19hcmVhUmluZ1N1bSA9IG5ldyBkM19hZGRlcigpO1xuICB2YXIgZDNfZ2VvX2FyZWEgPSB7XG4gICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19hcmVhU3VtICs9IDQgKiDPgDtcbiAgICB9LFxuICAgIHBvaW50OiBkM19ub29wLFxuICAgIGxpbmVTdGFydDogZDNfbm9vcCxcbiAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fYXJlYVJpbmdTdW0ucmVzZXQoKTtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVTdGFydCA9IGQzX2dlb19hcmVhUmluZ1N0YXJ0O1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJlYSA9IDIgKiBkM19nZW9fYXJlYVJpbmdTdW07XG4gICAgICBkM19nZW9fYXJlYVN1bSArPSBhcmVhIDwgMCA/IDQgKiDPgCArIGFyZWEgOiBhcmVhO1xuICAgICAgZDNfZ2VvX2FyZWEubGluZVN0YXJ0ID0gZDNfZ2VvX2FyZWEubGluZUVuZCA9IGQzX2dlb19hcmVhLnBvaW50ID0gZDNfbm9vcDtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19hcmVhUmluZ1N0YXJ0KCkge1xuICAgIHZhciDOuzAwLCDPhjAwLCDOuzAsIGNvc8+GMCwgc2luz4YwO1xuICAgIGQzX2dlb19hcmVhLnBvaW50ID0gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICBkM19nZW9fYXJlYS5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIM67MCA9ICjOuzAwID0gzrspICogZDNfcmFkaWFucywgY29zz4YwID0gTWF0aC5jb3Moz4YgPSAoz4YwMCA9IM+GKSAqIGQzX3JhZGlhbnMgLyAyICsgz4AgLyA0KSwgXG4gICAgICBzaW7PhjAgPSBNYXRoLnNpbijPhik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQozrssIM+GKSB7XG4gICAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgICAgz4YgPSDPhiAqIGQzX3JhZGlhbnMgLyAyICsgz4AgLyA0O1xuICAgICAgdmFyIGTOuyA9IM67IC0gzrswLCBzZM67ID0gZM67ID49IDAgPyAxIDogLTEsIGFkzrsgPSBzZM67ICogZM67LCBjb3PPhiA9IE1hdGguY29zKM+GKSwgc2luz4YgPSBNYXRoLnNpbijPhiksIGsgPSBzaW7PhjAgKiBzaW7PhiwgdSA9IGNvc8+GMCAqIGNvc8+GICsgayAqIE1hdGguY29zKGFkzrspLCB2ID0gayAqIHNkzrsgKiBNYXRoLnNpbihhZM67KTtcbiAgICAgIGQzX2dlb19hcmVhUmluZ1N1bS5hZGQoTWF0aC5hdGFuMih2LCB1KSk7XG4gICAgICDOuzAgPSDOuywgY29zz4YwID0gY29zz4YsIHNpbs+GMCA9IHNpbs+GO1xuICAgIH1cbiAgICBkM19nZW9fYXJlYS5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0UG9pbnQozrswMCwgz4YwMCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuKHNwaGVyaWNhbCkge1xuICAgIHZhciDOuyA9IHNwaGVyaWNhbFswXSwgz4YgPSBzcGhlcmljYWxbMV0sIGNvc8+GID0gTWF0aC5jb3Moz4YpO1xuICAgIHJldHVybiBbIGNvc8+GICogTWF0aC5jb3MozrspLCBjb3PPhiAqIE1hdGguc2luKM67KSwgTWF0aC5zaW4oz4YpIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbkRvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuQ3Jvc3MoYSwgYikge1xuICAgIHJldHVybiBbIGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF0gXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuQWRkKGEsIGIpIHtcbiAgICBhWzBdICs9IGJbMF07XG4gICAgYVsxXSArPSBiWzFdO1xuICAgIGFbMl0gKz0gYlsyXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuU2NhbGUodmVjdG9yLCBrKSB7XG4gICAgcmV0dXJuIFsgdmVjdG9yWzBdICogaywgdmVjdG9yWzFdICogaywgdmVjdG9yWzJdICogayBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoZCkge1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV0gKyBkWzJdICogZFsyXSk7XG4gICAgZFswXSAvPSBsO1xuICAgIGRbMV0gLz0gbDtcbiAgICBkWzJdIC89IGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3NwaGVyaWNhbChjYXJ0ZXNpYW4pIHtcbiAgICByZXR1cm4gWyBNYXRoLmF0YW4yKGNhcnRlc2lhblsxXSwgY2FydGVzaWFuWzBdKSwgZDNfYXNpbihjYXJ0ZXNpYW5bMl0pIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYWJzKGFbMF0gLSBiWzBdKSA8IM61ICYmIGFicyhhWzFdIC0gYlsxXSkgPCDOtTtcbiAgfVxuICBkMy5nZW8uYm91bmRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIM67MCwgz4YwLCDOuzEsIM+GMSwgzrtfLCDOu19fLCDPhl9fLCBwMCwgZM67U3VtLCByYW5nZXMsIHJhbmdlO1xuICAgIHZhciBib3VuZCA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGJvdW5kLnBvaW50ID0gcmluZ1BvaW50O1xuICAgICAgICBib3VuZC5saW5lU3RhcnQgPSByaW5nU3RhcnQ7XG4gICAgICAgIGJvdW5kLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICBkzrtTdW0gPSAwO1xuICAgICAgICBkM19nZW9fYXJlYS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZDNfZ2VvX2FyZWEucG9seWdvbkVuZCgpO1xuICAgICAgICBib3VuZC5wb2ludCA9IHBvaW50O1xuICAgICAgICBib3VuZC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGJvdW5kLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBpZiAoZDNfZ2VvX2FyZWFSaW5nU3VtIDwgMCkgzrswID0gLSjOuzEgPSAxODApLCDPhjAgPSAtKM+GMSA9IDkwKTsgZWxzZSBpZiAoZM67U3VtID4gzrUpIM+GMSA9IDkwOyBlbHNlIGlmIChkzrtTdW0gPCAtzrUpIM+GMCA9IC05MDtcbiAgICAgICAgcmFuZ2VbMF0gPSDOuzAsIHJhbmdlWzFdID0gzrsxO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcG9pbnQozrssIM+GKSB7XG4gICAgICByYW5nZXMucHVzaChyYW5nZSA9IFsgzrswID0gzrssIM67MSA9IM67IF0pO1xuICAgICAgaWYgKM+GIDwgz4YwKSDPhjAgPSDPhjtcbiAgICAgIGlmICjPhiA+IM+GMSkgz4YxID0gz4Y7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVQb2ludCjOuywgz4YpIHtcbiAgICAgIHZhciBwID0gZDNfZ2VvX2NhcnRlc2lhbihbIM67ICogZDNfcmFkaWFucywgz4YgKiBkM19yYWRpYW5zIF0pO1xuICAgICAgaWYgKHAwKSB7XG4gICAgICAgIHZhciBub3JtYWwgPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MocDAsIHApLCBlcXVhdG9yaWFsID0gWyBub3JtYWxbMV0sIC1ub3JtYWxbMF0sIDAgXSwgaW5mbGVjdGlvbiA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhlcXVhdG9yaWFsLCBub3JtYWwpO1xuICAgICAgICBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGluZmxlY3Rpb24pO1xuICAgICAgICBpbmZsZWN0aW9uID0gZDNfZ2VvX3NwaGVyaWNhbChpbmZsZWN0aW9uKTtcbiAgICAgICAgdmFyIGTOuyA9IM67IC0gzrtfLCBzID0gZM67ID4gMCA/IDEgOiAtMSwgzrtpID0gaW5mbGVjdGlvblswXSAqIGQzX2RlZ3JlZXMgKiBzLCBhbnRpbWVyaWRpYW4gPSBhYnMoZM67KSA+IDE4MDtcbiAgICAgICAgaWYgKGFudGltZXJpZGlhbiBeIChzICogzrtfIDwgzrtpICYmIM67aSA8IHMgKiDOuykpIHtcbiAgICAgICAgICB2YXIgz4ZpID0gaW5mbGVjdGlvblsxXSAqIGQzX2RlZ3JlZXM7XG4gICAgICAgICAgaWYgKM+GaSA+IM+GMSkgz4YxID0gz4ZpO1xuICAgICAgICB9IGVsc2UgaWYgKM67aSA9ICjOu2kgKyAzNjApICUgMzYwIC0gMTgwLCBhbnRpbWVyaWRpYW4gXiAocyAqIM67XyA8IM67aSAmJiDOu2kgPCBzICogzrspKSB7XG4gICAgICAgICAgdmFyIM+GaSA9IC1pbmZsZWN0aW9uWzFdICogZDNfZGVncmVlcztcbiAgICAgICAgICBpZiAoz4ZpIDwgz4YwKSDPhjAgPSDPhmk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKM+GIDwgz4YwKSDPhjAgPSDPhjtcbiAgICAgICAgICBpZiAoz4YgPiDPhjEpIM+GMSA9IM+GO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnRpbWVyaWRpYW4pIHtcbiAgICAgICAgICBpZiAozrsgPCDOu18pIHtcbiAgICAgICAgICAgIGlmIChhbmdsZSjOuzAsIM67KSA+IGFuZ2xlKM67MCwgzrsxKSkgzrsxID0gzrs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbmdsZSjOuywgzrsxKSA+IGFuZ2xlKM67MCwgzrsxKSkgzrswID0gzrs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICjOuzEgPj0gzrswKSB7XG4gICAgICAgICAgICBpZiAozrsgPCDOuzApIM67MCA9IM67O1xuICAgICAgICAgICAgaWYgKM67ID4gzrsxKSDOuzEgPSDOuztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKM67ID4gzrtfKSB7XG4gICAgICAgICAgICAgIGlmIChhbmdsZSjOuzAsIM67KSA+IGFuZ2xlKM67MCwgzrsxKSkgzrsxID0gzrs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYW5nbGUozrssIM67MSkgPiBhbmdsZSjOuzAsIM67MSkpIM67MCA9IM67O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnQozrssIM+GKTtcbiAgICAgIH1cbiAgICAgIHAwID0gcCwgzrtfID0gzrs7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIGJvdW5kLnBvaW50ID0gbGluZVBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgcmFuZ2VbMF0gPSDOuzAsIHJhbmdlWzFdID0gzrsxO1xuICAgICAgYm91bmQucG9pbnQgPSBwb2ludDtcbiAgICAgIHAwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmluZ1BvaW50KM67LCDPhikge1xuICAgICAgaWYgKHAwKSB7XG4gICAgICAgIHZhciBkzrsgPSDOuyAtIM67XztcbiAgICAgICAgZM67U3VtICs9IGFicyhkzrspID4gMTgwID8gZM67ICsgKGTOuyA+IDAgPyAzNjAgOiAtMzYwKSA6IGTOuztcbiAgICAgIH0gZWxzZSDOu19fID0gzrssIM+GX18gPSDPhjtcbiAgICAgIGQzX2dlb19hcmVhLnBvaW50KM67LCDPhik7XG4gICAgICBsaW5lUG9pbnQozrssIM+GKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgZDNfZ2VvX2FyZWEubGluZVN0YXJ0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICByaW5nUG9pbnQozrtfXywgz4ZfXyk7XG4gICAgICBkM19nZW9fYXJlYS5saW5lRW5kKCk7XG4gICAgICBpZiAoYWJzKGTOu1N1bSkgPiDOtSkgzrswID0gLSjOuzEgPSAxODApO1xuICAgICAgcmFuZ2VbMF0gPSDOuzAsIHJhbmdlWzFdID0gzrsxO1xuICAgICAgcDAgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbmdsZSjOuzAsIM67MSkge1xuICAgICAgcmV0dXJuICjOuzEgLT0gzrswKSA8IDAgPyDOuzEgKyAzNjAgOiDOuzE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVSYW5nZXMoYSwgYikge1xuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3aXRoaW5SYW5nZSh4LCByYW5nZSkge1xuICAgICAgcmV0dXJuIHJhbmdlWzBdIDw9IHJhbmdlWzFdID8gcmFuZ2VbMF0gPD0geCAmJiB4IDw9IHJhbmdlWzFdIDogeCA8IHJhbmdlWzBdIHx8IHJhbmdlWzFdIDwgeDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgIM+GMSA9IM67MSA9IC0ozrswID0gz4YwID0gSW5maW5pdHkpO1xuICAgICAgcmFuZ2VzID0gW107XG4gICAgICBkMy5nZW8uc3RyZWFtKGZlYXR1cmUsIGJvdW5kKTtcbiAgICAgIHZhciBuID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgIGlmIChuKSB7XG4gICAgICAgIHJhbmdlcy5zb3J0KGNvbXBhcmVSYW5nZXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgYSA9IHJhbmdlc1swXSwgYiwgbWVyZ2VkID0gWyBhIF07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBiID0gcmFuZ2VzW2ldO1xuICAgICAgICAgIGlmICh3aXRoaW5SYW5nZShiWzBdLCBhKSB8fCB3aXRoaW5SYW5nZShiWzFdLCBhKSkge1xuICAgICAgICAgICAgaWYgKGFuZ2xlKGFbMF0sIGJbMV0pID4gYW5nbGUoYVswXSwgYVsxXSkpIGFbMV0gPSBiWzFdO1xuICAgICAgICAgICAgaWYgKGFuZ2xlKGJbMF0sIGFbMV0pID4gYW5nbGUoYVswXSwgYVsxXSkpIGFbMF0gPSBiWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXJnZWQucHVzaChhID0gYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBiZXN0ID0gLUluZmluaXR5LCBkzrs7XG4gICAgICAgIGZvciAodmFyIG4gPSBtZXJnZWQubGVuZ3RoIC0gMSwgaSA9IDAsIGEgPSBtZXJnZWRbbl0sIGI7IGkgPD0gbjsgYSA9IGIsICsraSkge1xuICAgICAgICAgIGIgPSBtZXJnZWRbaV07XG4gICAgICAgICAgaWYgKChkzrsgPSBhbmdsZShhWzFdLCBiWzBdKSkgPiBiZXN0KSBiZXN0ID0gZM67LCDOuzAgPSBiWzBdLCDOuzEgPSBhWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByYW5nZXMgPSByYW5nZSA9IG51bGw7XG4gICAgICByZXR1cm4gzrswID09PSBJbmZpbml0eSB8fCDPhjAgPT09IEluZmluaXR5ID8gWyBbIE5hTiwgTmFOIF0sIFsgTmFOLCBOYU4gXSBdIDogWyBbIM67MCwgz4YwIF0sIFsgzrsxLCDPhjEgXSBdO1xuICAgIH07XG4gIH0oKTtcbiAgZDMuZ2VvLmNlbnRyb2lkID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZDNfZ2VvX2NlbnRyb2lkVzAgPSBkM19nZW9fY2VudHJvaWRXMSA9IGQzX2dlb19jZW50cm9pZFgwID0gZDNfZ2VvX2NlbnRyb2lkWTAgPSBkM19nZW9fY2VudHJvaWRaMCA9IGQzX2dlb19jZW50cm9pZFgxID0gZDNfZ2VvX2NlbnRyb2lkWTEgPSBkM19nZW9fY2VudHJvaWRaMSA9IGQzX2dlb19jZW50cm9pZFgyID0gZDNfZ2VvX2NlbnRyb2lkWTIgPSBkM19nZW9fY2VudHJvaWRaMiA9IDA7XG4gICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIGQzX2dlb19jZW50cm9pZCk7XG4gICAgdmFyIHggPSBkM19nZW9fY2VudHJvaWRYMiwgeSA9IGQzX2dlb19jZW50cm9pZFkyLCB6ID0gZDNfZ2VvX2NlbnRyb2lkWjIsIG0gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG4gICAgaWYgKG0gPCDOtTIpIHtcbiAgICAgIHggPSBkM19nZW9fY2VudHJvaWRYMSwgeSA9IGQzX2dlb19jZW50cm9pZFkxLCB6ID0gZDNfZ2VvX2NlbnRyb2lkWjE7XG4gICAgICBpZiAoZDNfZ2VvX2NlbnRyb2lkVzEgPCDOtSkgeCA9IGQzX2dlb19jZW50cm9pZFgwLCB5ID0gZDNfZ2VvX2NlbnRyb2lkWTAsIHogPSBkM19nZW9fY2VudHJvaWRaMDtcbiAgICAgIG0gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG4gICAgICBpZiAobSA8IM61MikgcmV0dXJuIFsgTmFOLCBOYU4gXTtcbiAgICB9XG4gICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5LCB4KSAqIGQzX2RlZ3JlZXMsIGQzX2FzaW4oeiAvIE1hdGguc3FydChtKSkgKiBkM19kZWdyZWVzIF07XG4gIH07XG4gIHZhciBkM19nZW9fY2VudHJvaWRXMCwgZDNfZ2VvX2NlbnRyb2lkVzEsIGQzX2dlb19jZW50cm9pZFgwLCBkM19nZW9fY2VudHJvaWRZMCwgZDNfZ2VvX2NlbnRyb2lkWjAsIGQzX2dlb19jZW50cm9pZFgxLCBkM19nZW9fY2VudHJvaWRZMSwgZDNfZ2VvX2NlbnRyb2lkWjEsIGQzX2dlb19jZW50cm9pZFgyLCBkM19nZW9fY2VudHJvaWRZMiwgZDNfZ2VvX2NlbnRyb2lkWjI7XG4gIHZhciBkM19nZW9fY2VudHJvaWQgPSB7XG4gICAgc3BoZXJlOiBkM19ub29wLFxuICAgIHBvaW50OiBkM19nZW9fY2VudHJvaWRQb2ludCxcbiAgICBsaW5lU3RhcnQ6IGQzX2dlb19jZW50cm9pZExpbmVTdGFydCxcbiAgICBsaW5lRW5kOiBkM19nZW9fY2VudHJvaWRMaW5lRW5kLFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fY2VudHJvaWQubGluZVN0YXJ0ID0gZDNfZ2VvX2NlbnRyb2lkUmluZ1N0YXJ0O1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fY2VudHJvaWQubGluZVN0YXJ0ID0gZDNfZ2VvX2NlbnRyb2lkTGluZVN0YXJ0O1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NlbnRyb2lkUG9pbnQozrssIM+GKSB7XG4gICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKTtcbiAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWihjb3PPhiAqIE1hdGguY29zKM67KSwgY29zz4YgKiBNYXRoLnNpbijOuyksIE1hdGguc2luKM+GKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooeCwgeSwgeikge1xuICAgICsrZDNfZ2VvX2NlbnRyb2lkVzA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWDAgKz0gKHggLSBkM19nZW9fY2VudHJvaWRYMCkgLyBkM19nZW9fY2VudHJvaWRXMDtcbiAgICBkM19nZW9fY2VudHJvaWRZMCArPSAoeSAtIGQzX2dlb19jZW50cm9pZFkwKSAvIGQzX2dlb19jZW50cm9pZFcwO1xuICAgIGQzX2dlb19jZW50cm9pZFowICs9ICh6IC0gZDNfZ2VvX2NlbnRyb2lkWjApIC8gZDNfZ2VvX2NlbnRyb2lkVzA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NlbnRyb2lkTGluZVN0YXJ0KCkge1xuICAgIHZhciB4MCwgeTAsIHowO1xuICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpO1xuICAgICAgeDAgPSBjb3PPhiAqIE1hdGguY29zKM67KTtcbiAgICAgIHkwID0gY29zz4YgKiBNYXRoLnNpbijOuyk7XG4gICAgICB6MCA9IE1hdGguc2luKM+GKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpLCB4ID0gY29zz4YgKiBNYXRoLmNvcyjOuyksIHkgPSBjb3PPhiAqIE1hdGguc2luKM67KSwgeiA9IE1hdGguc2luKM+GKSwgdyA9IE1hdGguYXRhbjIoTWF0aC5zcXJ0KCh3ID0geTAgKiB6IC0gejAgKiB5KSAqIHcgKyAodyA9IHowICogeCAtIHgwICogeikgKiB3ICsgKHcgPSB4MCAqIHkgLSB5MCAqIHgpICogdyksIHgwICogeCArIHkwICogeSArIHowICogeik7XG4gICAgICBkM19nZW9fY2VudHJvaWRXMSArPSB3O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooeDAsIHkwLCB6MCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZExpbmVFbmQoKSB7XG4gICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gZDNfZ2VvX2NlbnRyb2lkUG9pbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICAgIHZhciDOuzAwLCDPhjAwLCB4MCwgeTAsIHowO1xuICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgzrswMCA9IM67LCDPhjAwID0gz4Y7XG4gICAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyk7XG4gICAgICB4MCA9IGNvc8+GICogTWF0aC5jb3MozrspO1xuICAgICAgeTAgPSBjb3PPhiAqIE1hdGguc2luKM67KTtcbiAgICAgIHowID0gTWF0aC5zaW4oz4YpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooeDAsIHkwLCB6MCk7XG4gICAgfTtcbiAgICBkM19nZW9fY2VudHJvaWQubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KM67MDAsIM+GMDApO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVFbmQgPSBkM19nZW9fY2VudHJvaWRMaW5lRW5kO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gZDNfZ2VvX2NlbnRyb2lkUG9pbnQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQozrssIM+GKSB7XG4gICAgICDOuyAqPSBkM19yYWRpYW5zO1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyksIHggPSBjb3PPhiAqIE1hdGguY29zKM67KSwgeSA9IGNvc8+GICogTWF0aC5zaW4ozrspLCB6ID0gTWF0aC5zaW4oz4YpLCBjeCA9IHkwICogeiAtIHowICogeSwgY3kgPSB6MCAqIHggLSB4MCAqIHosIGN6ID0geDAgKiB5IC0geTAgKiB4LCBtID0gTWF0aC5zcXJ0KGN4ICogY3ggKyBjeSAqIGN5ICsgY3ogKiBjeiksIHUgPSB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHosIHYgPSBtICYmIC1kM19hY29zKHUpIC8gbSwgdyA9IE1hdGguYXRhbjIobSwgdSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMiArPSB2ICogY3g7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMiArPSB2ICogY3k7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMiArPSB2ICogY3o7XG4gICAgICBkM19nZW9fY2VudHJvaWRXMSArPSB3O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooeDAsIHkwLCB6MCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jb21wb3NlKGEsIGIpIHtcbiAgICBmdW5jdGlvbiBjb21wb3NlKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID0gYSh4LCB5KSwgYih4WzBdLCB4WzFdKTtcbiAgICB9XG4gICAgaWYgKGEuaW52ZXJ0ICYmIGIuaW52ZXJ0KSBjb21wb3NlLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiB4ID0gYi5pbnZlcnQoeCwgeSksIHggJiYgYS5pbnZlcnQoeFswXSwgeFsxXSk7XG4gICAgfTtcbiAgICByZXR1cm4gY29tcG9zZTtcbiAgfVxuICBmdW5jdGlvbiBkM190cnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwUG9seWdvbihzZWdtZW50cywgY29tcGFyZSwgY2xpcFN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgc3ViamVjdCA9IFtdLCBjbGlwID0gW107XG4gICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgICBpZiAoKG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEpIDw9IDApIHJldHVybjtcbiAgICAgIHZhciBuLCBwMCA9IHNlZ21lbnRbMF0sIHAxID0gc2VnbWVudFtuXTtcbiAgICAgIGlmIChkM19nZW9fc3BoZXJpY2FsRXF1YWwocDAsIHAxKSkge1xuICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIGxpc3RlbmVyLnBvaW50KChwMCA9IHNlZ21lbnRbaV0pWzBdLCBwMFsxXSk7XG4gICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGEgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAwLCBzZWdtZW50LCBudWxsLCB0cnVlKSwgYiA9IG5ldyBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocDAsIG51bGwsIGEsIGZhbHNlKTtcbiAgICAgIGEubyA9IGI7XG4gICAgICBzdWJqZWN0LnB1c2goYSk7XG4gICAgICBjbGlwLnB1c2goYik7XG4gICAgICBhID0gbmV3IGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwMSwgc2VnbWVudCwgbnVsbCwgZmFsc2UpO1xuICAgICAgYiA9IG5ldyBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocDEsIG51bGwsIGEsIHRydWUpO1xuICAgICAgYS5vID0gYjtcbiAgICAgIHN1YmplY3QucHVzaChhKTtcbiAgICAgIGNsaXAucHVzaChiKTtcbiAgICB9KTtcbiAgICBjbGlwLnNvcnQoY29tcGFyZSk7XG4gICAgZDNfZ2VvX2NsaXBQb2x5Z29uTGlua0NpcmN1bGFyKHN1YmplY3QpO1xuICAgIGQzX2dlb19jbGlwUG9seWdvbkxpbmtDaXJjdWxhcihjbGlwKTtcbiAgICBpZiAoIXN1YmplY3QubGVuZ3RoKSByZXR1cm47XG4gICAgZm9yICh2YXIgaSA9IDAsIGVudHJ5ID0gY2xpcFN0YXJ0SW5zaWRlLCBuID0gY2xpcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNsaXBbaV0uZSA9IGVudHJ5ID0gIWVudHJ5O1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBzdWJqZWN0WzBdLCBwb2ludHMsIHBvaW50O1xuICAgIHdoaWxlICgxKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHN0YXJ0LCBpc1N1YmplY3QgPSB0cnVlO1xuICAgICAgd2hpbGUgKGN1cnJlbnQudikgaWYgKChjdXJyZW50ID0gY3VycmVudC5uKSA9PT0gc3RhcnQpIHJldHVybjtcbiAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgZG8ge1xuICAgICAgICBjdXJyZW50LnYgPSBjdXJyZW50Lm8udiA9IHRydWU7XG4gICAgICAgIGlmIChjdXJyZW50LmUpIHtcbiAgICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyArK2kpIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50Lm4ueCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQucC56O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgbGlzdGVuZXIucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQucC54LCAtMSwgbGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm87XG4gICAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgICAgaXNTdWJqZWN0ID0gIWlzU3ViamVjdDtcbiAgICAgIH0gd2hpbGUgKCFjdXJyZW50LnYpO1xuICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFBvbHlnb25MaW5rQ2lyY3VsYXIoYXJyYXkpIHtcbiAgICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSkgcmV0dXJuO1xuICAgIHZhciBuLCBpID0gMCwgYSA9IGFycmF5WzBdLCBiO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhLm4gPSBiID0gYXJyYXlbaV07XG4gICAgICBiLnAgPSBhO1xuICAgICAgYSA9IGI7XG4gICAgfVxuICAgIGEubiA9IGIgPSBhcnJheVswXTtcbiAgICBiLnAgPSBhO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwb2ludCwgcG9pbnRzLCBvdGhlciwgZW50cnkpIHtcbiAgICB0aGlzLnggPSBwb2ludDtcbiAgICB0aGlzLnogPSBwb2ludHM7XG4gICAgdGhpcy5vID0gb3RoZXI7XG4gICAgdGhpcy5lID0gZW50cnk7XG4gICAgdGhpcy52ID0gZmFsc2U7XG4gICAgdGhpcy5uID0gdGhpcy5wID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcChwb2ludFZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgY2xpcFN0YXJ0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHJvdGF0ZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaW5lID0gY2xpcExpbmUobGlzdGVuZXIpLCByb3RhdGVkQ2xpcFN0YXJ0ID0gcm90YXRlLmludmVydChjbGlwU3RhcnRbMF0sIGNsaXBTdGFydFsxXSk7XG4gICAgICB2YXIgY2xpcCA9IHtcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRSaW5nO1xuICAgICAgICAgIGNsaXAubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICAgIGNsaXAubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgICBjbGlwLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgICBjbGlwLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICAgIHNlZ21lbnRzID0gZDMubWVyZ2Uoc2VnbWVudHMpO1xuICAgICAgICAgIHZhciBjbGlwU3RhcnRJbnNpZGUgPSBkM19nZW9fcG9pbnRJblBvbHlnb24ocm90YXRlZENsaXBTdGFydCwgcG9seWdvbik7XG4gICAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb19jbGlwUG9seWdvbihzZWdtZW50cywgZDNfZ2VvX2NsaXBTb3J0LCBjbGlwU3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGlwU3RhcnRJbnNpZGUpIHtcbiAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvbHlnb25TdGFydGVkKSBsaXN0ZW5lci5wb2x5Z29uRW5kKCksIHBvbHlnb25TdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIGxpc3RlbmVyLnBvbHlnb25FbmQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHBvaW50KM67LCDPhikge1xuICAgICAgICB2YXIgcG9pbnQgPSByb3RhdGUozrssIM+GKTtcbiAgICAgICAgaWYgKHBvaW50VmlzaWJsZSjOuyA9IHBvaW50WzBdLCDPhiA9IHBvaW50WzFdKSkgbGlzdGVuZXIucG9pbnQozrssIM+GKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBvaW50TGluZSjOuywgz4YpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKM67LCDPhik7XG4gICAgICAgIGxpbmUucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50TGluZTtcbiAgICAgICAgbGluZS5saW5lU3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgbGluZS5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICB2YXIgc2VnbWVudHM7XG4gICAgICB2YXIgYnVmZmVyID0gZDNfZ2VvX2NsaXBCdWZmZXJMaXN0ZW5lcigpLCByaW5nTGlzdGVuZXIgPSBjbGlwTGluZShidWZmZXIpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlLCBwb2x5Z29uLCByaW5nO1xuICAgICAgZnVuY3Rpb24gcG9pbnRSaW5nKM67LCDPhikge1xuICAgICAgICByaW5nLnB1c2goWyDOuywgz4YgXSk7XG4gICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZSjOuywgz4YpO1xuICAgICAgICByaW5nTGlzdGVuZXIucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgICAgcmluZ0xpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICByaW5nID0gW107XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgICBwb2ludFJpbmcocmluZ1swXVswXSwgcmluZ1swXVsxXSk7XG4gICAgICAgIHJpbmdMaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgIHZhciBjbGVhbiA9IHJpbmdMaXN0ZW5lci5jbGVhbigpLCByaW5nU2VnbWVudHMgPSBidWZmZXIuYnVmZmVyKCksIHNlZ21lbnQsIG4gPSByaW5nU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICByaW5nLnBvcCgpO1xuICAgICAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gICAgICAgIHJpbmcgPSBudWxsO1xuICAgICAgICBpZiAoIW4pIHJldHVybjtcbiAgICAgICAgaWYgKGNsZWFuICYgMSkge1xuICAgICAgICAgIHNlZ21lbnQgPSByaW5nU2VnbWVudHNbMF07XG4gICAgICAgICAgdmFyIG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEsIGkgPSAtMSwgcG9pbnQ7XG4gICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikgbGlzdGVuZXIucG9pbnQoKHBvaW50ID0gc2VnbWVudFtpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuID4gMSAmJiBjbGVhbiAmIDIpIHJpbmdTZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5wb3AoKS5jb25jYXQocmluZ1NlZ21lbnRzLnNoaWZ0KCkpKTtcbiAgICAgICAgc2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMuZmlsdGVyKGQzX2dlb19jbGlwU2VnbWVudExlbmd0aDEpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGlwO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBTZWdtZW50TGVuZ3RoMShzZWdtZW50KSB7XG4gICAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcEJ1ZmZlckxpc3RlbmVyKCkge1xuICAgIHZhciBsaW5lcyA9IFtdLCBsaW5lO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsaW5lcy5wdXNoKGxpbmUgPSBbXSk7XG4gICAgICB9LFxuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgICBsaW5lLnB1c2goWyDOuywgz4YgXSk7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICAgIGJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBsaW5lcztcbiAgICAgICAgbGluZXMgPSBbXTtcbiAgICAgICAgbGluZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICB9LFxuICAgICAgcmVqb2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwU29ydChhLCBiKSB7XG4gICAgcmV0dXJuICgoYSA9IGEueClbMF0gPCAwID8gYVsxXSAtIGhhbGbPgCAtIM61IDogaGFsZs+AIC0gYVsxXSkgLSAoKGIgPSBiLngpWzBdIDwgMCA/IGJbMV0gLSBoYWxmz4AgLSDOtSA6IGhhbGbPgCAtIGJbMV0pO1xuICB9XG4gIHZhciBkM19nZW9fY2xpcEFudGltZXJpZGlhbiA9IGQzX2dlb19jbGlwKGQzX3RydWUsIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuTGluZSwgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZSwgWyAtz4AsIC3PgCAvIDIgXSk7XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuTGluZShsaXN0ZW5lcikge1xuICAgIHZhciDOuzAgPSBOYU4sIM+GMCA9IE5hTiwgc867MCA9IE5hTiwgY2xlYW47XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICBjbGVhbiA9IDE7XG4gICAgICB9LFxuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKM67MSwgz4YxKSB7XG4gICAgICAgIHZhciBzzrsxID0gzrsxID4gMCA/IM+AIDogLc+ALCBkzrsgPSBhYnMozrsxIC0gzrswKTtcbiAgICAgICAgaWYgKGFicyhkzrsgLSDPgCkgPCDOtSkge1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KM67MCwgz4YwID0gKM+GMCArIM+GMSkgLyAyID4gMCA/IGhhbGbPgCA6IC1oYWxmz4ApO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHPOuzAsIM+GMCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHPOuzEsIM+GMCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQozrsxLCDPhjApO1xuICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzzrswICE9PSBzzrsxICYmIGTOuyA+PSDPgCkge1xuICAgICAgICAgIGlmIChhYnMozrswIC0gc867MCkgPCDOtSkgzrswIC09IHPOuzAgKiDOtTtcbiAgICAgICAgICBpZiAoYWJzKM67MSAtIHPOuzEpIDwgzrUpIM67MSAtPSBzzrsxICogzrU7XG4gICAgICAgICAgz4YwID0gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QozrswLCDPhjAsIM67MSwgz4YxKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrswLCDPhjApO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrsxLCDPhjApO1xuICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lci5wb2ludCjOuzAgPSDOuzEsIM+GMCA9IM+GMSk7XG4gICAgICAgIHPOuzAgPSBzzrsxO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgIM67MCA9IM+GMCA9IE5hTjtcbiAgICAgIH0sXG4gICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAyIC0gY2xlYW47XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcEFudGltZXJpZGlhbkludGVyc2VjdCjOuzAsIM+GMCwgzrsxLCDPhjEpIHtcbiAgICB2YXIgY29zz4YwLCBjb3PPhjEsIHNpbs67MF/OuzEgPSBNYXRoLnNpbijOuzAgLSDOuzEpO1xuICAgIHJldHVybiBhYnMoc2luzrswX867MSkgPiDOtSA/IE1hdGguYXRhbigoTWF0aC5zaW4oz4YwKSAqIChjb3PPhjEgPSBNYXRoLmNvcyjPhjEpKSAqIE1hdGguc2luKM67MSkgLSBNYXRoLnNpbijPhjEpICogKGNvc8+GMCA9IE1hdGguY29zKM+GMCkpICogTWF0aC5zaW4ozrswKSkgLyAoY29zz4YwICogY29zz4YxICogc2luzrswX867MSkpIDogKM+GMCArIM+GMSkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgbGlzdGVuZXIpIHtcbiAgICB2YXIgz4Y7XG4gICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgz4YgPSBkaXJlY3Rpb24gKiBoYWxmz4A7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtz4AsIM+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KDAsIM+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KM+ALCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCjPgCwgMCk7XG4gICAgICBsaXN0ZW5lci5wb2ludCjPgCwgLc+GKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KDAsIC3Phik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtz4AsIC3Phik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtz4AsIDApO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCDPhik7XG4gICAgfSBlbHNlIGlmIChhYnMoZnJvbVswXSAtIHRvWzBdKSA+IM61KSB7XG4gICAgICB2YXIgcyA9IGZyb21bMF0gPCB0b1swXSA/IM+AIDogLc+AO1xuICAgICAgz4YgPSBkaXJlY3Rpb24gKiBzIC8gMjtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC1zLCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgwLCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludChzLCDPhik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3RlbmVyLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wb2ludEluUG9seWdvbihwb2ludCwgcG9seWdvbikge1xuICAgIHZhciBtZXJpZGlhbiA9IHBvaW50WzBdLCBwYXJhbGxlbCA9IHBvaW50WzFdLCBtZXJpZGlhbk5vcm1hbCA9IFsgTWF0aC5zaW4obWVyaWRpYW4pLCAtTWF0aC5jb3MobWVyaWRpYW4pLCAwIF0sIHBvbGFyQW5nbGUgPSAwLCB3aW5kaW5nID0gMDtcbiAgICBkM19nZW9fYXJlYVJpbmdTdW0ucmVzZXQoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgcmluZyA9IHBvbHlnb25baV0sIG0gPSByaW5nLmxlbmd0aDtcbiAgICAgIGlmICghbSkgY29udGludWU7XG4gICAgICB2YXIgcG9pbnQwID0gcmluZ1swXSwgzrswID0gcG9pbnQwWzBdLCDPhjAgPSBwb2ludDBbMV0gLyAyICsgz4AgLyA0LCBzaW7PhjAgPSBNYXRoLnNpbijPhjApLCBjb3PPhjAgPSBNYXRoLmNvcyjPhjApLCBqID0gMTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChqID09PSBtKSBqID0gMDtcbiAgICAgICAgcG9pbnQgPSByaW5nW2pdO1xuICAgICAgICB2YXIgzrsgPSBwb2ludFswXSwgz4YgPSBwb2ludFsxXSAvIDIgKyDPgCAvIDQsIHNpbs+GID0gTWF0aC5zaW4oz4YpLCBjb3PPhiA9IE1hdGguY29zKM+GKSwgZM67ID0gzrsgLSDOuzAsIHNkzrsgPSBkzrsgPj0gMCA/IDEgOiAtMSwgYWTOuyA9IHNkzrsgKiBkzrssIGFudGltZXJpZGlhbiA9IGFkzrsgPiDPgCwgayA9IHNpbs+GMCAqIHNpbs+GO1xuICAgICAgICBkM19nZW9fYXJlYVJpbmdTdW0uYWRkKE1hdGguYXRhbjIoayAqIHNkzrsgKiBNYXRoLnNpbihhZM67KSwgY29zz4YwICogY29zz4YgKyBrICogTWF0aC5jb3MoYWTOuykpKTtcbiAgICAgICAgcG9sYXJBbmdsZSArPSBhbnRpbWVyaWRpYW4gPyBkzrsgKyBzZM67ICogz4QgOiBkzrs7XG4gICAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiDOuzAgPj0gbWVyaWRpYW4gXiDOuyA+PSBtZXJpZGlhbikge1xuICAgICAgICAgIHZhciBhcmMgPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MoZDNfZ2VvX2NhcnRlc2lhbihwb2ludDApLCBkM19nZW9fY2FydGVzaWFuKHBvaW50KSk7XG4gICAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShhcmMpO1xuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MobWVyaWRpYW5Ob3JtYWwsIGFyYyk7XG4gICAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShpbnRlcnNlY3Rpb24pO1xuICAgICAgICAgIHZhciDPhmFyYyA9IChhbnRpbWVyaWRpYW4gXiBkzrsgPj0gMCA/IC0xIDogMSkgKiBkM19hc2luKGludGVyc2VjdGlvblsyXSk7XG4gICAgICAgICAgaWYgKHBhcmFsbGVsID4gz4ZhcmMgfHwgcGFyYWxsZWwgPT09IM+GYXJjICYmIChhcmNbMF0gfHwgYXJjWzFdKSkge1xuICAgICAgICAgICAgd2luZGluZyArPSBhbnRpbWVyaWRpYW4gXiBkzrsgPj0gMCA/IDEgOiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqKyspIGJyZWFrO1xuICAgICAgICDOuzAgPSDOuywgc2luz4YwID0gc2luz4YsIGNvc8+GMCA9IGNvc8+GLCBwb2ludDAgPSBwb2ludDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChwb2xhckFuZ2xlIDwgLc61IHx8IHBvbGFyQW5nbGUgPCDOtSAmJiBkM19nZW9fYXJlYVJpbmdTdW0gPCAtzrUpIF4gd2luZGluZyAmIDE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBDaXJjbGUocmFkaXVzKSB7XG4gICAgdmFyIGNyID0gTWF0aC5jb3MocmFkaXVzKSwgc21hbGxSYWRpdXMgPSBjciA+IDAsIG5vdEhlbWlzcGhlcmUgPSBhYnMoY3IpID4gzrUsIGludGVycG9sYXRlID0gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKHJhZGl1cywgNiAqIGQzX3JhZGlhbnMpO1xuICAgIHJldHVybiBkM19nZW9fY2xpcCh2aXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHNtYWxsUmFkaXVzID8gWyAwLCAtcmFkaXVzIF0gOiBbIC3PgCwgcmFkaXVzIC0gz4AgXSk7XG4gICAgZnVuY3Rpb24gdmlzaWJsZSjOuywgz4YpIHtcbiAgICAgIHJldHVybiBNYXRoLmNvcyjOuykgKiBNYXRoLmNvcyjPhikgPiBjcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xpcExpbmUobGlzdGVuZXIpIHtcbiAgICAgIHZhciBwb2ludDAsIGMwLCB2MCwgdjAwLCBjbGVhbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdjAwID0gdjAgPSBmYWxzZTtcbiAgICAgICAgICBjbGVhbiA9IDE7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgICAgICB2YXIgcG9pbnQxID0gWyDOuywgz4YgXSwgcG9pbnQyLCB2ID0gdmlzaWJsZSjOuywgz4YpLCBjID0gc21hbGxSYWRpdXMgPyB2ID8gMCA6IGNvZGUozrssIM+GKSA6IHYgPyBjb2RlKM67ICsgKM67IDwgMCA/IM+AIDogLc+AKSwgz4YpIDogMDtcbiAgICAgICAgICBpZiAoIXBvaW50MCAmJiAodjAwID0gdjAgPSB2KSkgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgaWYgKGQzX2dlb19zcGhlcmljYWxFcXVhbChwb2ludDAsIHBvaW50MikgfHwgZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHBvaW50MSwgcG9pbnQyKSkge1xuICAgICAgICAgICAgICBwb2ludDFbMF0gKz0gzrU7XG4gICAgICAgICAgICAgIHBvaW50MVsxXSArPSDOtTtcbiAgICAgICAgICAgICAgdiA9IHZpc2libGUocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDApO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50MCA9IHBvaW50MjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vdEhlbWlzcGhlcmUgJiYgcG9pbnQwICYmIHNtYWxsUmFkaXVzIF4gdikge1xuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICBpZiAoIShjICYgYzApICYmICh0ID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwLCB0cnVlKSkpIHtcbiAgICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgICBpZiAoc21hbGxSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2ICYmICghcG9pbnQwIHx8ICFkM19nZW9fc3BoZXJpY2FsRXF1YWwocG9pbnQwLCBwb2ludDEpKSkge1xuICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludDAgPSBwb2ludDEsIHYwID0gdiwgYzAgPSBjO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodjApIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBwb2ludDAgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGNsZWFuIHwgKHYwMCAmJiB2MCkgPDwgMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIHR3bykge1xuICAgICAgdmFyIHBhID0gZDNfZ2VvX2NhcnRlc2lhbihhKSwgcGIgPSBkM19nZW9fY2FydGVzaWFuKGIpO1xuICAgICAgdmFyIG4xID0gWyAxLCAwLCAwIF0sIG4yID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKHBhLCBwYiksIG4ybjIgPSBkM19nZW9fY2FydGVzaWFuRG90KG4yLCBuMiksIG4xbjIgPSBuMlswXSwgZGV0ZXJtaW5hbnQgPSBuMm4yIC0gbjFuMiAqIG4xbjI7XG4gICAgICBpZiAoIWRldGVybWluYW50KSByZXR1cm4gIXR3byAmJiBhO1xuICAgICAgdmFyIGMxID0gY3IgKiBuMm4yIC8gZGV0ZXJtaW5hbnQsIGMyID0gLWNyICogbjFuMiAvIGRldGVybWluYW50LCBuMXhuMiA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhuMSwgbjIpLCBBID0gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKG4xLCBjMSksIEIgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUobjIsIGMyKTtcbiAgICAgIGQzX2dlb19jYXJ0ZXNpYW5BZGQoQSwgQik7XG4gICAgICB2YXIgdSA9IG4xeG4yLCB3ID0gZDNfZ2VvX2NhcnRlc2lhbkRvdChBLCB1KSwgdXUgPSBkM19nZW9fY2FydGVzaWFuRG90KHUsIHUpLCB0MiA9IHcgKiB3IC0gdXUgKiAoZDNfZ2VvX2NhcnRlc2lhbkRvdChBLCBBKSAtIDEpO1xuICAgICAgaWYgKHQyIDwgMCkgcmV0dXJuO1xuICAgICAgdmFyIHQgPSBNYXRoLnNxcnQodDIpLCBxID0gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKHUsICgtdyAtIHQpIC8gdXUpO1xuICAgICAgZDNfZ2VvX2NhcnRlc2lhbkFkZChxLCBBKTtcbiAgICAgIHEgPSBkM19nZW9fc3BoZXJpY2FsKHEpO1xuICAgICAgaWYgKCF0d28pIHJldHVybiBxO1xuICAgICAgdmFyIM67MCA9IGFbMF0sIM67MSA9IGJbMF0sIM+GMCA9IGFbMV0sIM+GMSA9IGJbMV0sIHo7XG4gICAgICBpZiAozrsxIDwgzrswKSB6ID0gzrswLCDOuzAgPSDOuzEsIM67MSA9IHo7XG4gICAgICB2YXIgzrTOuyA9IM67MSAtIM67MCwgcG9sYXIgPSBhYnMozrTOuyAtIM+AKSA8IM61LCBtZXJpZGlhbiA9IHBvbGFyIHx8IM60zrsgPCDOtTtcbiAgICAgIGlmICghcG9sYXIgJiYgz4YxIDwgz4YwKSB6ID0gz4YwLCDPhjAgPSDPhjEsIM+GMSA9IHo7XG4gICAgICBpZiAobWVyaWRpYW4gPyBwb2xhciA/IM+GMCArIM+GMSA+IDAgXiBxWzFdIDwgKGFicyhxWzBdIC0gzrswKSA8IM61ID8gz4YwIDogz4YxKSA6IM+GMCA8PSBxWzFdICYmIHFbMV0gPD0gz4YxIDogzrTOuyA+IM+AIF4gKM67MCA8PSBxWzBdICYmIHFbMF0gPD0gzrsxKSkge1xuICAgICAgICB2YXIgcTEgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUodSwgKC13ICsgdCkgLyB1dSk7XG4gICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5BZGQocTEsIEEpO1xuICAgICAgICByZXR1cm4gWyBxLCBkM19nZW9fc3BoZXJpY2FsKHExKSBdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb2RlKM67LCDPhikge1xuICAgICAgdmFyIHIgPSBzbWFsbFJhZGl1cyA/IHJhZGl1cyA6IM+AIC0gcmFkaXVzLCBjb2RlID0gMDtcbiAgICAgIGlmICjOuyA8IC1yKSBjb2RlIHw9IDE7IGVsc2UgaWYgKM67ID4gcikgY29kZSB8PSAyO1xuICAgICAgaWYgKM+GIDwgLXIpIGNvZGUgfD0gNDsgZWxzZSBpZiAoz4YgPiByKSBjb2RlIHw9IDg7XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9jbGlwTGluZSh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHJldHVybiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgYSA9IGxpbmUuYSwgYiA9IGxpbmUuYiwgYXggPSBhLngsIGF5ID0gYS55LCBieCA9IGIueCwgYnkgPSBiLnksIHQwID0gMCwgdDEgPSAxLCBkeCA9IGJ4IC0gYXgsIGR5ID0gYnkgLSBheSwgcjtcbiAgICAgIHIgPSB4MCAtIGF4O1xuICAgICAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeDtcbiAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgICAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH1cbiAgICAgIHIgPSB4MSAtIGF4O1xuICAgICAgaWYgKCFkeCAmJiByIDwgMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeDtcbiAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgICAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH1cbiAgICAgIHIgPSB5MCAtIGF5O1xuICAgICAgaWYgKCFkeSAmJiByID4gMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeTtcbiAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgICAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH1cbiAgICAgIHIgPSB5MSAtIGF5O1xuICAgICAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xuICAgICAgciAvPSBkeTtcbiAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgICAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH1cbiAgICAgIGlmICh0MCA+IDApIGxpbmUuYSA9IHtcbiAgICAgICAgeDogYXggKyB0MCAqIGR4LFxuICAgICAgICB5OiBheSArIHQwICogZHlcbiAgICAgIH07XG4gICAgICBpZiAodDEgPCAxKSBsaW5lLmIgPSB7XG4gICAgICAgIHg6IGF4ICsgdDEgKiBkeCxcbiAgICAgICAgeTogYXkgKyB0MSAqIGR5XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZ2VvX2NsaXBFeHRlbnRNQVggPSAxZTk7XG4gIGQzLmdlby5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHgwLCB5MCwgeDEsIHkxLCBzdHJlYW0sIGNsaXAsIGNsaXBFeHRlbnQgPSB7XG4gICAgICBzdHJlYW06IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtID0gY2xpcChvdXRwdXQpO1xuICAgICAgICBzdHJlYW0udmFsaWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIGV4dGVudDogZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIFsgeDAsIHkwIF0sIFsgeDEsIHkxIF0gXTtcbiAgICAgICAgY2xpcCA9IGQzX2dlb19jbGlwRXh0ZW50KHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pO1xuICAgICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZSwgc3RyZWFtID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNsaXBFeHRlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gY2xpcEV4dGVudC5leHRlbnQoWyBbIDAsIDAgXSwgWyA5NjAsIDUwMCBdIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fY2xpcEV4dGVudCh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHJldHVybiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3RlbmVyXyA9IGxpc3RlbmVyLCBidWZmZXJMaXN0ZW5lciA9IGQzX2dlb19jbGlwQnVmZmVyTGlzdGVuZXIoKSwgY2xpcExpbmUgPSBkM19nZW9tX2NsaXBMaW5lKHgwLCB5MCwgeDEsIHkxKSwgc2VnbWVudHMsIHBvbHlnb24sIHJpbmc7XG4gICAgICB2YXIgY2xpcCA9IHtcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsaXN0ZW5lciA9IGJ1ZmZlckxpc3RlbmVyO1xuICAgICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgICAgIGNsZWFuID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcl87XG4gICAgICAgICAgc2VnbWVudHMgPSBkMy5tZXJnZShzZWdtZW50cyk7XG4gICAgICAgICAgdmFyIGNsaXBTdGFydEluc2lkZSA9IGluc2lkZVBvbHlnb24oWyB4MCwgeTEgXSksIGluc2lkZSA9IGNsZWFuICYmIGNsaXBTdGFydEluc2lkZSwgdmlzaWJsZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaW5zaWRlIHx8IHZpc2libGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgICBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGNvbXBhcmUsIGNsaXBTdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gcmluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBpbnNpZGVQb2x5Z29uKHApIHtcbiAgICAgICAgdmFyIHduID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoLCB5ID0gcFsxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMSwgdiA9IHBvbHlnb25baV0sIG0gPSB2Lmxlbmd0aCwgYSA9IHZbMF0sIGI7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgIGIgPSB2W2pdO1xuICAgICAgICAgICAgaWYgKGFbMV0gPD0geSkge1xuICAgICAgICAgICAgICBpZiAoYlsxXSA+IHkgJiYgZDNfY3Jvc3MyZChhLCBiLCBwKSA+IDApICsrd247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYlsxXSA8PSB5ICYmIGQzX2Nyb3NzMmQoYSwgYiwgcCkgPCAwKSAtLXduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3biAhPT0gMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBhID0gMCwgYTEgPSAwO1xuICAgICAgICBpZiAoZnJvbSA9PSBudWxsIHx8IChhID0gY29ybmVyKGZyb20sIGRpcmVjdGlvbikpICE9PSAoYTEgPSBjb3JuZXIodG8sIGRpcmVjdGlvbikpIHx8IGNvbXBhcmVQb2ludHMoZnJvbSwgdG8pIDwgMCBeIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2ludChhID09PSAwIHx8IGEgPT09IDMgPyB4MCA6IHgxLCBhID4gMSA/IHkxIDogeTApO1xuICAgICAgICAgIH0gd2hpbGUgKChhID0gKGEgKyBkaXJlY3Rpb24gKyA0KSAlIDQpICE9PSBhMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcG9pbnRWaXNpYmxlKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHgwIDw9IHggJiYgeCA8PSB4MSAmJiB5MCA8PSB5ICYmIHkgPD0geTE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICAgIGlmIChwb2ludFZpc2libGUoeCwgeSkpIGxpc3RlbmVyLnBvaW50KHgsIHkpO1xuICAgICAgfVxuICAgICAgdmFyIHhfXywgeV9fLCB2X18sIHhfLCB5Xywgdl8sIGZpcnN0LCBjbGVhbjtcbiAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgaWYgKHBvbHlnb24pIHBvbHlnb24ucHVzaChyaW5nID0gW10pO1xuICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgIHZfID0gZmFsc2U7XG4gICAgICAgIHhfID0geV8gPSBOYU47XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgICBsaW5lUG9pbnQoeF9fLCB5X18pO1xuICAgICAgICAgIGlmICh2X18gJiYgdl8pIGJ1ZmZlckxpc3RlbmVyLnJlam9pbigpO1xuICAgICAgICAgIHNlZ21lbnRzLnB1c2goYnVmZmVyTGlzdGVuZXIuYnVmZmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgaWYgKHZfKSBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xuICAgICAgICB4ID0gTWF0aC5tYXgoLWQzX2dlb19jbGlwRXh0ZW50TUFYLCBNYXRoLm1pbihkM19nZW9fY2xpcEV4dGVudE1BWCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoLWQzX2dlb19jbGlwRXh0ZW50TUFYLCBNYXRoLm1pbihkM19nZW9fY2xpcEV4dGVudE1BWCwgeSkpO1xuICAgICAgICB2YXIgdiA9IHBvaW50VmlzaWJsZSh4LCB5KTtcbiAgICAgICAgaWYgKHBvbHlnb24pIHJpbmcucHVzaChbIHgsIHkgXSk7XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgIHhfXyA9IHgsIHlfXyA9IHksIHZfXyA9IHY7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgJiYgdl8pIGxpc3RlbmVyLnBvaW50KHgsIHkpOyBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsID0ge1xuICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgeDogeF8sXG4gICAgICAgICAgICAgICAgeTogeV9cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNsaXBMaW5lKGwpKSB7XG4gICAgICAgICAgICAgIGlmICghdl8pIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChsLmEueCwgbC5hLnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KGwuYi54LCBsLmIueSk7XG4gICAgICAgICAgICAgIGlmICghdikgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2KSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeF8gPSB4LCB5XyA9IHksIHZfID0gdjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGlwO1xuICAgIH07XG4gICAgZnVuY3Rpb24gY29ybmVyKHAsIGRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgzrUgPyBkaXJlY3Rpb24gPiAwID8gMCA6IDMgOiBhYnMocFswXSAtIHgxKSA8IM61ID8gZGlyZWN0aW9uID4gMCA/IDIgOiAxIDogYWJzKHBbMV0gLSB5MCkgPCDOtSA/IGRpcmVjdGlvbiA+IDAgPyAxIDogMCA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhhLngsIGIueCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVQb2ludHMoYSwgYikge1xuICAgICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLCBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICAgIHJldHVybiBjYSAhPT0gY2IgPyBjYSAtIGNiIDogY2EgPT09IDAgPyBiWzFdIC0gYVsxXSA6IGNhID09PSAxID8gYVswXSAtIGJbMF0gOiBjYSA9PT0gMiA/IGFbMV0gLSBiWzFdIDogYlswXSAtIGFbMF07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jb25pYyhwcm9qZWN0QXQpIHtcbiAgICB2YXIgz4YwID0gMCwgz4YxID0gz4AgLyAzLCBtID0gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCksIHAgPSBtKM+GMCwgz4YxKTtcbiAgICBwLnBhcmFsbGVscyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgz4YwIC8gz4AgKiAxODAsIM+GMSAvIM+AICogMTgwIF07XG4gICAgICByZXR1cm4gbSjPhjAgPSBfWzBdICogz4AgLyAxODAsIM+GMSA9IF9bMV0gKiDPgCAvIDE4MCk7XG4gICAgfTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY29uaWNFcXVhbEFyZWEoz4YwLCDPhjEpIHtcbiAgICB2YXIgc2luz4YwID0gTWF0aC5zaW4oz4YwKSwgbiA9IChzaW7PhjAgKyBNYXRoLnNpbijPhjEpKSAvIDIsIEMgPSAxICsgc2luz4YwICogKDIgKiBuIC0gc2luz4YwKSwgz4EwID0gTWF0aC5zcXJ0KEMpIC8gbjtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKM67LCDPhikge1xuICAgICAgdmFyIM+BID0gTWF0aC5zcXJ0KEMgLSAyICogbiAqIE1hdGguc2luKM+GKSkgLyBuO1xuICAgICAgcmV0dXJuIFsgz4EgKiBNYXRoLnNpbijOuyAqPSBuKSwgz4EwIC0gz4EgKiBNYXRoLmNvcyjOuykgXTtcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EwX3kgPSDPgTAgLSB5O1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4LCDPgTBfeSkgLyBuLCBkM19hc2luKChDIC0gKHggKiB4ICsgz4EwX3kgKiDPgTBfeSkgKiBuICogbikgLyAoMiAqIG4pKSBdO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH1cbiAgKGQzLmdlby5jb25pY0VxdWFsQXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fY29uaWMoZDNfZ2VvX2NvbmljRXF1YWxBcmVhKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2NvbmljRXF1YWxBcmVhO1xuICBkMy5nZW8uYWxiZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLmdlby5jb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbIDk2LCAwIF0pLmNlbnRlcihbIC0uNiwgMzguNyBdKS5wYXJhbGxlbHMoWyAyOS41LCA0NS41IF0pLnNjYWxlKDEwNzApO1xuICB9O1xuICBkMy5nZW8uYWxiZXJzVXNhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxvd2VyNDggPSBkMy5nZW8uYWxiZXJzKCk7XG4gICAgdmFyIGFsYXNrYSA9IGQzLmdlby5jb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbIDE1NCwgMCBdKS5jZW50ZXIoWyAtMiwgNTguNSBdKS5wYXJhbGxlbHMoWyA1NSwgNjUgXSk7XG4gICAgdmFyIGhhd2FpaSA9IGQzLmdlby5jb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbIDE1NywgMCBdKS5jZW50ZXIoWyAtMywgMTkuOSBdKS5wYXJhbGxlbHMoWyA4LCAxOCBdKTtcbiAgICB2YXIgcG9pbnQsIHBvaW50U3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcG9pbnQgPSBbIHgsIHkgXTtcbiAgICAgIH1cbiAgICB9LCBsb3dlcjQ4UG9pbnQsIGFsYXNrYVBvaW50LCBoYXdhaWlQb2ludDtcbiAgICBmdW5jdGlvbiBhbGJlcnNVc2EoY29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIChsb3dlcjQ4UG9pbnQoeCwgeSksIHBvaW50KSB8fCAoYWxhc2thUG9pbnQoeCwgeSksIHBvaW50KSB8fCBoYXdhaWlQb2ludCh4LCB5KTtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgYWxiZXJzVXNhLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgdCA9IGxvd2VyNDgudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICByZXR1cm4gKHkgPj0gLjEyICYmIHkgPCAuMjM0ICYmIHggPj0gLS40MjUgJiYgeCA8IC0uMjE0ID8gYWxhc2thIDogeSA+PSAuMTY2ICYmIHkgPCAuMjM0ICYmIHggPj0gLS4yMTQgJiYgeCA8IC0uMTE1ID8gaGF3YWlpIDogbG93ZXI0OCkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICB9O1xuICAgIGFsYmVyc1VzYS5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHZhciBsb3dlcjQ4U3RyZWFtID0gbG93ZXI0OC5zdHJlYW0oc3RyZWFtKSwgYWxhc2thU3RyZWFtID0gYWxhc2thLnN0cmVhbShzdHJlYW0pLCBoYXdhaWlTdHJlYW0gPSBoYXdhaWkuc3RyZWFtKHN0cmVhbSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnNwaGVyZSgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5zcGhlcmUoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0uc3BoZXJlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBhbGJlcnNVc2EucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC5wcmVjaXNpb24oKTtcbiAgICAgIGxvd2VyNDgucHJlY2lzaW9uKF8pO1xuICAgICAgYWxhc2thLnByZWNpc2lvbihfKTtcbiAgICAgIGhhd2FpaS5wcmVjaXNpb24oXyk7XG4gICAgICByZXR1cm4gYWxiZXJzVXNhO1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC5zY2FsZSgpO1xuICAgICAgbG93ZXI0OC5zY2FsZShfKTtcbiAgICAgIGFsYXNrYS5zY2FsZShfICogLjM1KTtcbiAgICAgIGhhd2FpaS5zY2FsZShfKTtcbiAgICAgIHJldHVybiBhbGJlcnNVc2EudHJhbnNsYXRlKGxvd2VyNDgudHJhbnNsYXRlKCkpO1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgudHJhbnNsYXRlKCk7XG4gICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICBsb3dlcjQ4UG9pbnQgPSBsb3dlcjQ4LnRyYW5zbGF0ZShfKS5jbGlwRXh0ZW50KFsgWyB4IC0gLjQ1NSAqIGssIHkgLSAuMjM4ICogayBdLCBbIHggKyAuNDU1ICogaywgeSArIC4yMzggKiBrIF0gXSkuc3RyZWFtKHBvaW50U3RyZWFtKS5wb2ludDtcbiAgICAgIGFsYXNrYVBvaW50ID0gYWxhc2thLnRyYW5zbGF0ZShbIHggLSAuMzA3ICogaywgeSArIC4yMDEgKiBrIF0pLmNsaXBFeHRlbnQoWyBbIHggLSAuNDI1ICogayArIM61LCB5ICsgLjEyICogayArIM61IF0sIFsgeCAtIC4yMTQgKiBrIC0gzrUsIHkgKyAuMjM0ICogayAtIM61IF0gXSkuc3RyZWFtKHBvaW50U3RyZWFtKS5wb2ludDtcbiAgICAgIGhhd2FpaVBvaW50ID0gaGF3YWlpLnRyYW5zbGF0ZShbIHggLSAuMjA1ICogaywgeSArIC4yMTIgKiBrIF0pLmNsaXBFeHRlbnQoWyBbIHggLSAuMjE0ICogayArIM61LCB5ICsgLjE2NiAqIGsgKyDOtSBdLCBbIHggLSAuMTE1ICogayAtIM61LCB5ICsgLjIzNCAqIGsgLSDOtSBdIF0pLnN0cmVhbShwb2ludFN0cmVhbSkucG9pbnQ7XG4gICAgICByZXR1cm4gYWxiZXJzVXNhO1xuICAgIH07XG4gICAgcmV0dXJuIGFsYmVyc1VzYS5zY2FsZSgxMDcwKTtcbiAgfTtcbiAgdmFyIGQzX2dlb19wYXRoQXJlYVN1bSwgZDNfZ2VvX3BhdGhBcmVhUG9seWdvbiwgZDNfZ2VvX3BhdGhBcmVhID0ge1xuICAgIHBvaW50OiBkM19ub29wLFxuICAgIGxpbmVTdGFydDogZDNfbm9vcCxcbiAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWFQb2x5Z29uID0gMDtcbiAgICAgIGQzX2dlb19wYXRoQXJlYS5saW5lU3RhcnQgPSBkM19nZW9fcGF0aEFyZWFSaW5nU3RhcnQ7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYS5saW5lU3RhcnQgPSBkM19nZW9fcGF0aEFyZWEubGluZUVuZCA9IGQzX2dlb19wYXRoQXJlYS5wb2ludCA9IGQzX25vb3A7XG4gICAgICBkM19nZW9fcGF0aEFyZWFTdW0gKz0gYWJzKGQzX2dlb19wYXRoQXJlYVBvbHlnb24gLyAyKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQXJlYVJpbmdTdGFydCgpIHtcbiAgICB2YXIgeDAwLCB5MDAsIHgwLCB5MDtcbiAgICBkM19nZW9fcGF0aEFyZWEucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWEucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICB4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCh4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWFQb2x5Z29uICs9IHkwICogeCAtIHgwICogeTtcbiAgICAgIHgwID0geCwgeTAgPSB5O1xuICAgIH1cbiAgICBkM19nZW9fcGF0aEFyZWEubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KHgwMCwgeTAwKTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19nZW9fcGF0aEJvdW5kc1gwLCBkM19nZW9fcGF0aEJvdW5kc1kwLCBkM19nZW9fcGF0aEJvdW5kc1gxLCBkM19nZW9fcGF0aEJvdW5kc1kxO1xuICB2YXIgZDNfZ2VvX3BhdGhCb3VuZHMgPSB7XG4gICAgcG9pbnQ6IGQzX2dlb19wYXRoQm91bmRzUG9pbnQsXG4gICAgbGluZVN0YXJ0OiBkM19ub29wLFxuICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgcG9seWdvblN0YXJ0OiBkM19ub29wLFxuICAgIHBvbHlnb25FbmQ6IGQzX25vb3BcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhCb3VuZHNQb2ludCh4LCB5KSB7XG4gICAgaWYgKHggPCBkM19nZW9fcGF0aEJvdW5kc1gwKSBkM19nZW9fcGF0aEJvdW5kc1gwID0geDtcbiAgICBpZiAoeCA+IGQzX2dlb19wYXRoQm91bmRzWDEpIGQzX2dlb19wYXRoQm91bmRzWDEgPSB4O1xuICAgIGlmICh5IDwgZDNfZ2VvX3BhdGhCb3VuZHNZMCkgZDNfZ2VvX3BhdGhCb3VuZHNZMCA9IHk7XG4gICAgaWYgKHkgPiBkM19nZW9fcGF0aEJvdW5kc1kxKSBkM19nZW9fcGF0aEJvdW5kc1kxID0geTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aEJ1ZmZlcigpIHtcbiAgICB2YXIgcG9pbnRDaXJjbGUgPSBkM19nZW9fcGF0aEJ1ZmZlckNpcmNsZSg0LjUpLCBidWZmZXIgPSBbXTtcbiAgICB2YXIgc3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnRMaW5lU3RhcnQ7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kID0gbGluZUVuZFBvbHlnb247XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICB9LFxuICAgICAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcG9pbnRDaXJjbGUgPSBkM19nZW9fcGF0aEJ1ZmZlckNpcmNsZShfKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBidWZmZXIuam9pbihcIlwiKTtcbiAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICBidWZmZXIucHVzaChcIk1cIiwgeCwgXCIsXCIsIHksIHBvaW50Q2lyY2xlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lU3RhcnQoeCwgeSkge1xuICAgICAgYnVmZmVyLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lKHgsIHkpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiTFwiLCB4LCBcIixcIiwgeSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZFBvbHlnb24oKSB7XG4gICAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhCdWZmZXJDaXJjbGUocmFkaXVzKSB7XG4gICAgcmV0dXJuIFwibTAsXCIgKyByYWRpdXMgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIC0yICogcmFkaXVzICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAyICogcmFkaXVzICsgXCJ6XCI7XG4gIH1cbiAgdmFyIGQzX2dlb19wYXRoQ2VudHJvaWQgPSB7XG4gICAgcG9pbnQ6IGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCxcbiAgICBsaW5lU3RhcnQ6IGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lU3RhcnQsXG4gICAgbGluZUVuZDogZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVFbmQsXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZVN0YXJ0ID0gZDNfZ2VvX3BhdGhDZW50cm9pZFJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZVN0YXJ0ID0gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVTdGFydDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZUVuZCA9IGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lRW5kO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgsIHkpIHtcbiAgICBkM19nZW9fY2VudHJvaWRYMCArPSB4O1xuICAgIGQzX2dlb19jZW50cm9pZFkwICs9IHk7XG4gICAgKytkM19nZW9fY2VudHJvaWRaMDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkTGluZVN0YXJ0KCkge1xuICAgIHZhciB4MCwgeTA7XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KHgsIHkpIHtcbiAgICAgIHZhciBkeCA9IHggLSB4MCwgZHkgPSB5IC0geTAsIHogPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMSArPSB6O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVFbmQoKSB7XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICAgIHZhciB4MDAsIHkwMCwgeDAsIHkwO1xuICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCh4LCB5KSB7XG4gICAgICB2YXIgZHggPSB4IC0geDAsIGR5ID0geSAtIHkwLCB6ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHogKiAoeDAgKyB4KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB6ICogKHkwICsgeSkgLyAyO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gejtcbiAgICAgIHogPSB5MCAqIHggLSB4MCAqIHk7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMiArPSB6ICogKHgwICsgeCk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMiArPSB6ICogKHkwICsgeSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMiArPSB6ICogMztcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG4gICAgfVxuICAgIGQzX2dlb19wYXRoQ2VudHJvaWQubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KHgwMCwgeTAwKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ29udGV4dChjb250ZXh0KSB7XG4gICAgdmFyIHBvaW50UmFkaXVzID0gNC41O1xuICAgIHZhciBzdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmVTdGFydDtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kUG9seWdvbjtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIH0sXG4gICAgICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgICAgICBwb2ludFJhZGl1cyA9IF87XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgcmVzdWx0OiBkM19ub29wXG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4ICsgcG9pbnRSYWRpdXMsIHkpO1xuICAgICAgY29udGV4dC5hcmMoeCwgeSwgcG9pbnRSYWRpdXMsIDAsIM+EKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lU3RhcnQoeCwgeSkge1xuICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50TGluZSh4LCB5KSB7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kUG9seWdvbigpIHtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3Jlc2FtcGxlKHByb2plY3QpIHtcbiAgICB2YXIgzrQyID0gLjUsIGNvc01pbkRpc3RhbmNlID0gTWF0aC5jb3MoMzAgKiBkM19yYWRpYW5zKSwgbWF4RGVwdGggPSAxNjtcbiAgICBmdW5jdGlvbiByZXNhbXBsZShzdHJlYW0pIHtcbiAgICAgIHJldHVybiAobWF4RGVwdGggPyByZXNhbXBsZVJlY3Vyc2l2ZSA6IHJlc2FtcGxlTm9uZSkoc3RyZWFtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzYW1wbGVOb25lKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIGQzX2dlb190cmFuc2Zvcm1Qb2ludChzdHJlYW0sIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZVJlY3Vyc2l2ZShzdHJlYW0pIHtcbiAgICAgIHZhciDOuzAwLCDPhjAwLCB4MDAsIHkwMCwgYTAwLCBiMDAsIGMwMCwgzrswLCB4MCwgeTAsIGEwLCBiMCwgYzA7XG4gICAgICB2YXIgcmVzYW1wbGUgPSB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgIHJlc2FtcGxlLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICByZXNhbXBsZS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgIHgwID0gTmFOO1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZVBvaW50KM67LCDPhikge1xuICAgICAgICB2YXIgYyA9IGQzX2dlb19jYXJ0ZXNpYW4oWyDOuywgz4YgXSksIHAgPSBwcm9qZWN0KM67LCDPhik7XG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MCA9IHBbMF0sIHkwID0gcFsxXSwgzrswID0gzrssIGEwID0gY1swXSwgYjAgPSBjWzFdLCBjMCA9IGNbMl0sIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeDAsIHkwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICAgIGxpbmVTdGFydCgpO1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgICAgcmVzYW1wbGUubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nUG9pbnQozrssIM+GKSB7XG4gICAgICAgIGxpbmVQb2ludCjOuzAwID0gzrssIM+GMDAgPSDPhiksIHgwMCA9IHgwLCB5MDAgPSB5MCwgYTAwID0gYTAsIGIwMCA9IGIwLCBjMDAgPSBjMDtcbiAgICAgICAgcmVzYW1wbGUucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIM67MCwgYTAsIGIwLCBjMCwgeDAwLCB5MDAsIM67MDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgICByZXNhbXBsZS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgbGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc2FtcGxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIM67MCwgYTAsIGIwLCBjMCwgeDEsIHkxLCDOuzEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pIHtcbiAgICAgIHZhciBkeCA9IHgxIC0geDAsIGR5ID0geTEgLSB5MCwgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGlmIChkMiA+IDQgKiDOtDIgJiYgZGVwdGgtLSkge1xuICAgICAgICB2YXIgYSA9IGEwICsgYTEsIGIgPSBiMCArIGIxLCBjID0gYzAgKyBjMSwgbSA9IE1hdGguc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpLCDPhjIgPSBNYXRoLmFzaW4oYyAvPSBtKSwgzrsyID0gYWJzKGFicyhjKSAtIDEpIDwgzrUgfHwgYWJzKM67MCAtIM67MSkgPCDOtSA/ICjOuzAgKyDOuzEpIC8gMiA6IE1hdGguYXRhbjIoYiwgYSksIHAgPSBwcm9qZWN0KM67Miwgz4YyKSwgeDIgPSBwWzBdLCB5MiA9IHBbMV0sIGR4MiA9IHgyIC0geDAsIGR5MiA9IHkyIC0geTAsIGR6ID0gZHkgKiBkeDIgLSBkeCAqIGR5MjtcbiAgICAgICAgaWYgKGR6ICogZHogLyBkMiA+IM60MiB8fCBhYnMoKGR4ICogZHgyICsgZHkgKiBkeTIpIC8gZDIgLSAuNSkgPiAuMyB8fCBhMCAqIGExICsgYjAgKiBiMSArIGMwICogYzEgPCBjb3NNaW5EaXN0YW5jZSkge1xuICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MiwgeTIsIM67MiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICAgIHN0cmVhbS5wb2ludCh4MiwgeTIpO1xuICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgyLCB5MiwgzrsyLCBhLCBiLCBjLCB4MSwgeTEsIM67MSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzYW1wbGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gTWF0aC5zcXJ0KM60Mik7XG4gICAgICBtYXhEZXB0aCA9ICjOtDIgPSBfICogXykgPiAwICYmIDE2O1xuICAgICAgcmV0dXJuIHJlc2FtcGxlO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2FtcGxlO1xuICB9XG4gIGQzLmdlby5wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBvaW50UmFkaXVzID0gNC41LCBwcm9qZWN0aW9uLCBjb250ZXh0LCBwcm9qZWN0U3RyZWFtLCBjb250ZXh0U3RyZWFtLCBjYWNoZVN0cmVhbTtcbiAgICBmdW5jdGlvbiBwYXRoKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK3BvaW50UmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICBpZiAoIWNhY2hlU3RyZWFtIHx8ICFjYWNoZVN0cmVhbS52YWxpZCkgY2FjaGVTdHJlYW0gPSBwcm9qZWN0U3RyZWFtKGNvbnRleHRTdHJlYW0pO1xuICAgICAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgY2FjaGVTdHJlYW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRleHRTdHJlYW0ucmVzdWx0KCk7XG4gICAgfVxuICAgIHBhdGguYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhU3VtID0gMDtcbiAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBwcm9qZWN0U3RyZWFtKGQzX2dlb19wYXRoQXJlYSkpO1xuICAgICAgcmV0dXJuIGQzX2dlb19wYXRoQXJlYVN1bTtcbiAgICB9O1xuICAgIHBhdGguY2VudHJvaWQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgwID0gZDNfZ2VvX2NlbnRyb2lkWTAgPSBkM19nZW9fY2VudHJvaWRaMCA9IGQzX2dlb19jZW50cm9pZFgxID0gZDNfZ2VvX2NlbnRyb2lkWTEgPSBkM19nZW9fY2VudHJvaWRaMSA9IGQzX2dlb19jZW50cm9pZFgyID0gZDNfZ2VvX2NlbnRyb2lkWTIgPSBkM19nZW9fY2VudHJvaWRaMiA9IDA7XG4gICAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgcHJvamVjdFN0cmVhbShkM19nZW9fcGF0aENlbnRyb2lkKSk7XG4gICAgICByZXR1cm4gZDNfZ2VvX2NlbnRyb2lkWjIgPyBbIGQzX2dlb19jZW50cm9pZFgyIC8gZDNfZ2VvX2NlbnRyb2lkWjIsIGQzX2dlb19jZW50cm9pZFkyIC8gZDNfZ2VvX2NlbnRyb2lkWjIgXSA6IGQzX2dlb19jZW50cm9pZFoxID8gWyBkM19nZW9fY2VudHJvaWRYMSAvIGQzX2dlb19jZW50cm9pZFoxLCBkM19nZW9fY2VudHJvaWRZMSAvIGQzX2dlb19jZW50cm9pZFoxIF0gOiBkM19nZW9fY2VudHJvaWRaMCA/IFsgZDNfZ2VvX2NlbnRyb2lkWDAgLyBkM19nZW9fY2VudHJvaWRaMCwgZDNfZ2VvX2NlbnRyb2lkWTAgLyBkM19nZW9fY2VudHJvaWRaMCBdIDogWyBOYU4sIE5hTiBdO1xuICAgIH07XG4gICAgcGF0aC5ib3VuZHMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGQzX2dlb19wYXRoQm91bmRzWDEgPSBkM19nZW9fcGF0aEJvdW5kc1kxID0gLShkM19nZW9fcGF0aEJvdW5kc1gwID0gZDNfZ2VvX3BhdGhCb3VuZHNZMCA9IEluZmluaXR5KTtcbiAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBwcm9qZWN0U3RyZWFtKGQzX2dlb19wYXRoQm91bmRzKSk7XG4gICAgICByZXR1cm4gWyBbIGQzX2dlb19wYXRoQm91bmRzWDAsIGQzX2dlb19wYXRoQm91bmRzWTAgXSwgWyBkM19nZW9fcGF0aEJvdW5kc1gxLCBkM19nZW9fcGF0aEJvdW5kc1kxIF0gXTtcbiAgICB9O1xuICAgIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByb2plY3Rpb247XG4gICAgICBwcm9qZWN0U3RyZWFtID0gKHByb2plY3Rpb24gPSBfKSA/IF8uc3RyZWFtIHx8IGQzX2dlb19wYXRoUHJvamVjdFN0cmVhbShfKSA6IGQzX2lkZW50aXR5O1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwYXRoLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuICAgICAgY29udGV4dFN0cmVhbSA9IChjb250ZXh0ID0gXykgPT0gbnVsbCA/IG5ldyBkM19nZW9fcGF0aEJ1ZmZlcigpIDogbmV3IGQzX2dlb19wYXRoQ29udGV4dChfKTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHBhdGgucG9pbnRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwb2ludFJhZGl1cztcbiAgICAgIHBvaW50UmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiAoY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrXyksICtfKTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgucHJvamVjdGlvbihkMy5nZW8uYWxiZXJzVXNhKCkpLmNvbnRleHQobnVsbCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoUHJvamVjdFN0cmVhbShwcm9qZWN0KSB7XG4gICAgdmFyIHJlc2FtcGxlID0gZDNfZ2VvX3Jlc2FtcGxlKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0KFsgeCAqIGQzX2RlZ3JlZXMsIHkgKiBkM19kZWdyZWVzIF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvblJhZGlhbnMocmVzYW1wbGUoc3RyZWFtKSk7XG4gICAgfTtcbiAgfVxuICBkMy5nZW8udHJhbnNmb3JtID0gZnVuY3Rpb24obWV0aG9kcykge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJlYW06IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gbmV3IGQzX2dlb190cmFuc2Zvcm0oc3RyZWFtKTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBtZXRob2RzKSB0cmFuc2Zvcm1ba10gPSBtZXRob2RzW2tdO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb190cmFuc2Zvcm0oc3RyZWFtKSB7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gIH1cbiAgZDNfZ2VvX3RyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHgsIHkpO1xuICAgIH0sXG4gICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnNwaGVyZSgpO1xuICAgIH0sXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIH0sXG4gICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5saW5lRW5kKCk7XG4gICAgfSxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb190cmFuc2Zvcm1Qb2ludChzdHJlYW0sIHBvaW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5zcGhlcmUoKTtcbiAgICAgIH0sXG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICB9LFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDMuZ2VvLnByb2plY3Rpb24gPSBkM19nZW9fcHJvamVjdGlvbjtcbiAgZDMuZ2VvLnByb2plY3Rpb25NdXRhdG9yID0gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yO1xuICBmdW5jdGlvbiBkM19nZW9fcHJvamVjdGlvbihwcm9qZWN0KSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uTXV0YXRvcihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0O1xuICAgIH0pKCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCkge1xuICAgIHZhciBwcm9qZWN0LCByb3RhdGUsIHByb2plY3RSb3RhdGUsIHByb2plY3RSZXNhbXBsZSA9IGQzX2dlb19yZXNhbXBsZShmdW5jdGlvbih4LCB5KSB7XG4gICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgIHJldHVybiBbIHhbMF0gKiBrICsgzrR4LCDOtHkgLSB4WzFdICogayBdO1xuICAgIH0pLCBrID0gMTUwLCB4ID0gNDgwLCB5ID0gMjUwLCDOuyA9IDAsIM+GID0gMCwgzrTOuyA9IDAsIM60z4YgPSAwLCDOtM6zID0gMCwgzrR4LCDOtHksIHByZWNsaXAgPSBkM19nZW9fY2xpcEFudGltZXJpZGlhbiwgcG9zdGNsaXAgPSBkM19pZGVudGl0eSwgY2xpcEFuZ2xlID0gbnVsbCwgY2xpcEV4dGVudCA9IG51bGwsIHN0cmVhbTtcbiAgICBmdW5jdGlvbiBwcm9qZWN0aW9uKHBvaW50KSB7XG4gICAgICBwb2ludCA9IHByb2plY3RSb3RhdGUocG9pbnRbMF0gKiBkM19yYWRpYW5zLCBwb2ludFsxXSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIFsgcG9pbnRbMF0gKiBrICsgzrR4LCDOtHkgLSBwb2ludFsxXSAqIGsgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52ZXJ0KHBvaW50KSB7XG4gICAgICBwb2ludCA9IHByb2plY3RSb3RhdGUuaW52ZXJ0KChwb2ludFswXSAtIM60eCkgLyBrLCAozrR5IC0gcG9pbnRbMV0pIC8gayk7XG4gICAgICByZXR1cm4gcG9pbnQgJiYgWyBwb2ludFswXSAqIGQzX2RlZ3JlZXMsIHBvaW50WzFdICogZDNfZGVncmVlcyBdO1xuICAgIH1cbiAgICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgaWYgKHN0cmVhbSkgc3RyZWFtLnZhbGlkID0gZmFsc2U7XG4gICAgICBzdHJlYW0gPSBkM19nZW9fcHJvamVjdGlvblJhZGlhbnMocHJlY2xpcChyb3RhdGUsIHByb2plY3RSZXNhbXBsZShwb3N0Y2xpcChvdXRwdXQpKSkpO1xuICAgICAgc3RyZWFtLnZhbGlkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLmNsaXBBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBBbmdsZTtcbiAgICAgIHByZWNsaXAgPSBfID09IG51bGwgPyAoY2xpcEFuZ2xlID0gXywgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW4pIDogZDNfZ2VvX2NsaXBDaXJjbGUoKGNsaXBBbmdsZSA9ICtfKSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGludmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBFeHRlbnQ7XG4gICAgICBjbGlwRXh0ZW50ID0gXztcbiAgICAgIHBvc3RjbGlwID0gXyA/IGQzX2dlb19jbGlwRXh0ZW50KF9bMF1bMF0sIF9bMF1bMV0sIF9bMV1bMF0sIF9bMV1bMV0pIDogZDNfaWRlbnRpdHk7XG4gICAgICByZXR1cm4gaW52YWxpZGF0ZSgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGs7XG4gICAgICBrID0gK187XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyB4LCB5IF07XG4gICAgICB4ID0gK19bMF07XG4gICAgICB5ID0gK19bMV07XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyDOuyAqIGQzX2RlZ3JlZXMsIM+GICogZDNfZGVncmVlcyBdO1xuICAgICAgzrsgPSBfWzBdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIM+GID0gX1sxXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyDOtM67ICogZDNfZGVncmVlcywgzrTPhiAqIGQzX2RlZ3JlZXMsIM60zrMgKiBkM19kZWdyZWVzIF07XG4gICAgICDOtM67ID0gX1swXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICDOtM+GID0gX1sxXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICDOtM6zID0gXy5sZW5ndGggPiAyID8gX1syXSAlIDM2MCAqIGQzX3JhZGlhbnMgOiAwO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBkMy5yZWJpbmQocHJvamVjdGlvbiwgcHJvamVjdFJlc2FtcGxlLCBcInByZWNpc2lvblwiKTtcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHByb2plY3RSb3RhdGUgPSBkM19nZW9fY29tcG9zZShyb3RhdGUgPSBkM19nZW9fcm90YXRpb24ozrTOuywgzrTPhiwgzrTOsyksIHByb2plY3QpO1xuICAgICAgdmFyIGNlbnRlciA9IHByb2plY3QozrssIM+GKTtcbiAgICAgIM60eCA9IHggLSBjZW50ZXJbMF0gKiBrO1xuICAgICAgzrR5ID0geSArIGNlbnRlclsxXSAqIGs7XG4gICAgICByZXR1cm4gaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgICAgaWYgKHN0cmVhbSkgc3RyZWFtLnZhbGlkID0gZmFsc2UsIHN0cmVhbSA9IG51bGw7XG4gICAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcHJvamVjdCA9IHByb2plY3RBdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcHJvamVjdGlvbi5pbnZlcnQgPSBwcm9qZWN0LmludmVydCAmJiBpbnZlcnQ7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wcm9qZWN0aW9uUmFkaWFucyhzdHJlYW0pIHtcbiAgICByZXR1cm4gZDNfZ2VvX3RyYW5zZm9ybVBvaW50KHN0cmVhbSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgc3RyZWFtLnBvaW50KHggKiBkM19yYWRpYW5zLCB5ICogZDNfcmFkaWFucyk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcijOuywgz4YpIHtcbiAgICByZXR1cm4gWyDOuywgz4YgXTtcbiAgfVxuICAoZDMuZ2VvLmVxdWlyZWN0YW5ndWxhciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fZXF1aXJlY3Rhbmd1bGFyKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhci5pbnZlcnQgPSBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyO1xuICBkMy5nZW8ucm90YXRpb24gPSBmdW5jdGlvbihyb3RhdGUpIHtcbiAgICByb3RhdGUgPSBkM19nZW9fcm90YXRpb24ocm90YXRlWzBdICUgMzYwICogZDNfcmFkaWFucywgcm90YXRlWzFdICogZDNfcmFkaWFucywgcm90YXRlLmxlbmd0aCA+IDIgPyByb3RhdGVbMl0gKiBkM19yYWRpYW5zIDogMCk7XG4gICAgZnVuY3Rpb24gZm9yd2FyZChjb29yZGluYXRlcykge1xuICAgICAgY29vcmRpbmF0ZXMgPSByb3RhdGUoY29vcmRpbmF0ZXNbMF0gKiBkM19yYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICBjb29yZGluYXRlcyA9IHJvdGF0ZS5pbnZlcnQoY29vcmRpbmF0ZXNbMF0gKiBkM19yYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGQzX2RlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19pZGVudGl0eVJvdGF0aW9uKM67LCDPhikge1xuICAgIHJldHVybiBbIM67ID4gz4AgPyDOuyAtIM+EIDogzrsgPCAtz4AgPyDOuyArIM+EIDogzrssIM+GIF07XG4gIH1cbiAgZDNfZ2VvX2lkZW50aXR5Um90YXRpb24uaW52ZXJ0ID0gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcjtcbiAgZnVuY3Rpb24gZDNfZ2VvX3JvdGF0aW9uKM60zrssIM60z4YsIM60zrMpIHtcbiAgICByZXR1cm4gzrTOuyA/IM60z4YgfHwgzrTOsyA/IGQzX2dlb19jb21wb3NlKGQzX2dlb19yb3RhdGlvbs67KM60zrspLCBkM19nZW9fcm90YXRpb27Phs6zKM60z4YsIM60zrMpKSA6IGQzX2dlb19yb3RhdGlvbs67KM60zrspIDogzrTPhiB8fCDOtM6zID8gZDNfZ2VvX3JvdGF0aW9uz4bOsyjOtM+GLCDOtM6zKSA6IGQzX2dlb19pZGVudGl0eVJvdGF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19mb3J3YXJkUm90YXRpb27OuyjOtM67KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgcmV0dXJuIM67ICs9IM60zrssIFsgzrsgPiDPgCA/IM67IC0gz4QgOiDOuyA8IC3PgCA/IM67ICsgz4QgOiDOuywgz4YgXTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19yb3RhdGlvbs67KM60zrspIHtcbiAgICB2YXIgcm90YXRpb24gPSBkM19nZW9fZm9yd2FyZFJvdGF0aW9uzrsozrTOuyk7XG4gICAgcm90YXRpb24uaW52ZXJ0ID0gZDNfZ2VvX2ZvcndhcmRSb3RhdGlvbs67KC3OtM67KTtcbiAgICByZXR1cm4gcm90YXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3JvdGF0aW9uz4bOsyjOtM+GLCDOtM6zKSB7XG4gICAgdmFyIGNvc860z4YgPSBNYXRoLmNvcyjOtM+GKSwgc2luzrTPhiA9IE1hdGguc2luKM60z4YpLCBjb3POtM6zID0gTWF0aC5jb3MozrTOsyksIHNpbs60zrMgPSBNYXRoLnNpbijOtM6zKTtcbiAgICBmdW5jdGlvbiByb3RhdGlvbijOuywgz4YpIHtcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GKSwgeCA9IE1hdGguY29zKM67KSAqIGNvc8+GLCB5ID0gTWF0aC5zaW4ozrspICogY29zz4YsIHogPSBNYXRoLnNpbijPhiksIGsgPSB6ICogY29zzrTPhiArIHggKiBzaW7OtM+GO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5ICogY29zzrTOsyAtIGsgKiBzaW7OtM6zLCB4ICogY29zzrTPhiAtIHogKiBzaW7OtM+GKSwgZDNfYXNpbihrICogY29zzrTOsyArIHkgKiBzaW7OtM6zKSBdO1xuICAgIH1cbiAgICByb3RhdGlvbi5pbnZlcnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GKSwgeCA9IE1hdGguY29zKM67KSAqIGNvc8+GLCB5ID0gTWF0aC5zaW4ozrspICogY29zz4YsIHogPSBNYXRoLnNpbijPhiksIGsgPSB6ICogY29zzrTOsyAtIHkgKiBzaW7OtM6zO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5ICogY29zzrTOsyArIHogKiBzaW7OtM6zLCB4ICogY29zzrTPhiArIGsgKiBzaW7OtM+GKSwgZDNfYXNpbihrICogY29zzrTPhiAtIHggKiBzaW7OtM+GKSBdO1xuICAgIH07XG4gICAgcmV0dXJuIHJvdGF0aW9uO1xuICB9XG4gIGQzLmdlby5jaXJjbGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ2luID0gWyAwLCAwIF0sIGFuZ2xlLCBwcmVjaXNpb24gPSA2LCBpbnRlcnBvbGF0ZTtcbiAgICBmdW5jdGlvbiBjaXJjbGUoKSB7XG4gICAgICB2YXIgY2VudGVyID0gdHlwZW9mIG9yaWdpbiA9PT0gXCJmdW5jdGlvblwiID8gb3JpZ2luLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBvcmlnaW4sIHJvdGF0ZSA9IGQzX2dlb19yb3RhdGlvbigtY2VudGVyWzBdICogZDNfcmFkaWFucywgLWNlbnRlclsxXSAqIGQzX3JhZGlhbnMsIDApLmludmVydCwgcmluZyA9IFtdO1xuICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwge1xuICAgICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgIHJpbmcucHVzaCh4ID0gcm90YXRlKHgsIHkpKTtcbiAgICAgICAgICB4WzBdICo9IGQzX2RlZ3JlZXMsIHhbMV0gKj0gZDNfZGVncmVlcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgcmluZyBdXG4gICAgICB9O1xuICAgIH1cbiAgICBjaXJjbGUub3JpZ2luID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZ2luO1xuICAgICAgb3JpZ2luID0geDtcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfTtcbiAgICBjaXJjbGUuYW5nbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhbmdsZTtcbiAgICAgIGludGVycG9sYXRlID0gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKChhbmdsZSA9ICt4KSAqIGQzX3JhZGlhbnMsIHByZWNpc2lvbiAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9O1xuICAgIGNpcmNsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcmVjaXNpb247XG4gICAgICBpbnRlcnBvbGF0ZSA9IGQzX2dlb19jaXJjbGVJbnRlcnBvbGF0ZShhbmdsZSAqIGQzX3JhZGlhbnMsIChwcmVjaXNpb24gPSArXykgKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfTtcbiAgICByZXR1cm4gY2lyY2xlLmFuZ2xlKDkwKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKHJhZGl1cywgcHJlY2lzaW9uKSB7XG4gICAgdmFyIGNyID0gTWF0aC5jb3MocmFkaXVzKSwgc3IgPSBNYXRoLnNpbihyYWRpdXMpO1xuICAgIHJldHVybiBmdW5jdGlvbihmcm9tLCB0bywgZGlyZWN0aW9uLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIHN0ZXAgPSBkaXJlY3Rpb24gKiBwcmVjaXNpb247XG4gICAgICBpZiAoZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGZyb20gPSBkM19nZW9fY2lyY2xlQW5nbGUoY3IsIGZyb20pO1xuICAgICAgICB0byA9IGQzX2dlb19jaXJjbGVBbmdsZShjciwgdG8pO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCA/IGZyb20gPCB0byA6IGZyb20gPiB0bykgZnJvbSArPSBkaXJlY3Rpb24gKiDPhDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb20gPSByYWRpdXMgKyBkaXJlY3Rpb24gKiDPhDtcbiAgICAgICAgdG8gPSByYWRpdXMgLSAuNSAqIHN0ZXA7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwb2ludCwgdCA9IGZyb207IGRpcmVjdGlvbiA+IDAgPyB0ID4gdG8gOiB0IDwgdG87IHQgLT0gc3RlcCkge1xuICAgICAgICBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBkM19nZW9fc3BoZXJpY2FsKFsgY3IsIC1zciAqIE1hdGguY29zKHQpLCAtc3IgKiBNYXRoLnNpbih0KSBdKSlbMF0sIHBvaW50WzFdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jaXJjbGVBbmdsZShjciwgcG9pbnQpIHtcbiAgICB2YXIgYSA9IGQzX2dlb19jYXJ0ZXNpYW4ocG9pbnQpO1xuICAgIGFbMF0gLT0gY3I7XG4gICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShhKTtcbiAgICB2YXIgYW5nbGUgPSBkM19hY29zKC1hWzFdKTtcbiAgICByZXR1cm4gKCgtYVsyXSA8IDAgPyAtYW5nbGUgOiBhbmdsZSkgKyAyICogTWF0aC5QSSAtIM61KSAlICgyICogTWF0aC5QSSk7XG4gIH1cbiAgZDMuZ2VvLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciDOlM67ID0gKGJbMF0gLSBhWzBdKSAqIGQzX3JhZGlhbnMsIM+GMCA9IGFbMV0gKiBkM19yYWRpYW5zLCDPhjEgPSBiWzFdICogZDNfcmFkaWFucywgc2luzpTOuyA9IE1hdGguc2luKM6UzrspLCBjb3POlM67ID0gTWF0aC5jb3MozpTOuyksIHNpbs+GMCA9IE1hdGguc2luKM+GMCksIGNvc8+GMCA9IE1hdGguY29zKM+GMCksIHNpbs+GMSA9IE1hdGguc2luKM+GMSksIGNvc8+GMSA9IE1hdGguY29zKM+GMSksIHQ7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoTWF0aC5zcXJ0KCh0ID0gY29zz4YxICogc2luzpTOuykgKiB0ICsgKHQgPSBjb3PPhjAgKiBzaW7PhjEgLSBzaW7PhjAgKiBjb3PPhjEgKiBjb3POlM67KSAqIHQpLCBzaW7PhjAgKiBzaW7PhjEgKyBjb3PPhjAgKiBjb3PPhjEgKiBjb3POlM67KTtcbiAgfTtcbiAgZDMuZ2VvLmdyYXRpY3VsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4MSwgeDAsIFgxLCBYMCwgeTEsIHkwLCBZMSwgWTAsIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLCB4LCB5LCBYLCBZLCBwcmVjaXNpb24gPSAyLjU7XG4gICAgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IGxpbmVzKClcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKE1hdGguY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKS5jb25jYXQoZDMucmFuZ2UoTWF0aC5jZWlsKFkwIC8gRFkpICogRFksIFkxLCBEWSkubWFwKFkpKS5jb25jYXQoZDMucmFuZ2UoTWF0aC5jZWlsKHgwIC8gZHgpICogZHgsIHgxLCBkeCkuZmlsdGVyKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGFicyh4ICUgRFgpID4gzrU7XG4gICAgICB9KS5tYXAoeCkpLmNvbmNhdChkMy5yYW5nZShNYXRoLmNlaWwoeTAgLyBkeSkgKiBkeSwgeTEsIGR5KS5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gYWJzKHkgJSBEWSkgPiDOtTtcbiAgICAgIH0pLm1hcCh5KSk7XG4gICAgfVxuICAgIGdyYXRpY3VsZS5saW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxpbmVzKCkubWFwKGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5vdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgWChYMCkuY29uY2F0KFkoWTEpLnNsaWNlKDEpLCBYKFgxKS5yZXZlcnNlKCkuc2xpY2UoMSksIFkoWTApLnJldmVyc2UoKS5zbGljZSgxKSkgXVxuICAgICAgfTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUubWlub3JFeHRlbnQoKTtcbiAgICAgIHJldHVybiBncmF0aWN1bGUubWFqb3JFeHRlbnQoXykubWlub3JFeHRlbnQoXyk7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWFqb3JFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIFsgWDAsIFkwIF0sIFsgWDEsIFkxIF0gXTtcbiAgICAgIFgwID0gK19bMF1bMF0sIFgxID0gK19bMV1bMF07XG4gICAgICBZMCA9ICtfWzBdWzFdLCBZMSA9ICtfWzFdWzFdO1xuICAgICAgaWYgKFgwID4gWDEpIF8gPSBYMCwgWDAgPSBYMSwgWDEgPSBfO1xuICAgICAgaWYgKFkwID4gWTEpIF8gPSBZMCwgWTAgPSBZMSwgWTEgPSBfO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5taW5vckV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgWyB4MCwgeTAgXSwgWyB4MSwgeTEgXSBdO1xuICAgICAgeDAgPSArX1swXVswXSwgeDEgPSArX1sxXVswXTtcbiAgICAgIHkwID0gK19bMF1bMV0sIHkxID0gK19bMV1bMV07XG4gICAgICBpZiAoeDAgPiB4MSkgXyA9IHgwLCB4MCA9IHgxLCB4MSA9IF87XG4gICAgICBpZiAoeTAgPiB5MSkgXyA9IHkwLCB5MCA9IHkxLCB5MSA9IF87XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLnN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUubWlub3JTdGVwKCk7XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLm1ham9yU3RlcChfKS5taW5vclN0ZXAoXyk7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWFqb3JTdGVwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBEWCwgRFkgXTtcbiAgICAgIERYID0gK19bMF0sIERZID0gK19bMV07XG4gICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm1pbm9yU3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgZHgsIGR5IF07XG4gICAgICBkeCA9ICtfWzBdLCBkeSA9ICtfWzFdO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcmVjaXNpb247XG4gICAgICBwcmVjaXNpb24gPSArXztcbiAgICAgIHggPSBkM19nZW9fZ3JhdGljdWxlWCh5MCwgeTEsIDkwKTtcbiAgICAgIHkgPSBkM19nZW9fZ3JhdGljdWxlWSh4MCwgeDEsIHByZWNpc2lvbik7XG4gICAgICBYID0gZDNfZ2VvX2dyYXRpY3VsZVgoWTAsIFkxLCA5MCk7XG4gICAgICBZID0gZDNfZ2VvX2dyYXRpY3VsZVkoWDAsIFgxLCBwcmVjaXNpb24pO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICB9O1xuICAgIHJldHVybiBncmF0aWN1bGUubWFqb3JFeHRlbnQoWyBbIC0xODAsIC05MCArIM61IF0sIFsgMTgwLCA5MCAtIM61IF0gXSkubWlub3JFeHRlbnQoWyBbIC0xODAsIC04MCAtIM61IF0sIFsgMTgwLCA4MCArIM61IF0gXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19ncmF0aWN1bGVYKHkwLCB5MSwgZHkpIHtcbiAgICB2YXIgeSA9IGQzLnJhbmdlKHkwLCB5MSAtIM61LCBkeSkuY29uY2F0KHkxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHkubWFwKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIFsgeCwgeSBdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fZ3JhdGljdWxlWSh4MCwgeDEsIGR4KSB7XG4gICAgdmFyIHggPSBkMy5yYW5nZSh4MCwgeDEgLSDOtSwgZHgpLmNvbmNhdCh4MSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB4Lm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBbIHgsIHkgXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc291cmNlKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGFyZ2V0KGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH1cbiAgZDMuZ2VvLmdyZWF0QXJjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IGQzX3NvdXJjZSwgc291cmNlXywgdGFyZ2V0ID0gZDNfdGFyZ2V0LCB0YXJnZXRfO1xuICAgIGZ1bmN0aW9uIGdyZWF0QXJjKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbIHNvdXJjZV8gfHwgc291cmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRhcmdldF8gfHwgdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgXVxuICAgICAgfTtcbiAgICB9XG4gICAgZ3JlYXRBcmMuZGlzdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkMy5nZW8uZGlzdGFuY2Uoc291cmNlXyB8fCBzb3VyY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGFyZ2V0XyB8fCB0YXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBncmVhdEFyYy5zb3VyY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3VyY2U7XG4gICAgICBzb3VyY2UgPSBfLCBzb3VyY2VfID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IG51bGwgOiBfO1xuICAgICAgcmV0dXJuIGdyZWF0QXJjO1xuICAgIH07XG4gICAgZ3JlYXRBcmMudGFyZ2V0ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgdGFyZ2V0ID0gXywgdGFyZ2V0XyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBudWxsIDogXztcbiAgICAgIHJldHVybiBncmVhdEFyYztcbiAgICB9O1xuICAgIGdyZWF0QXJjLnByZWNpc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBncmVhdEFyYyA6IDA7XG4gICAgfTtcbiAgICByZXR1cm4gZ3JlYXRBcmM7XG4gIH07XG4gIGQzLmdlby5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGQzX2dlb19pbnRlcnBvbGF0ZShzb3VyY2VbMF0gKiBkM19yYWRpYW5zLCBzb3VyY2VbMV0gKiBkM19yYWRpYW5zLCB0YXJnZXRbMF0gKiBkM19yYWRpYW5zLCB0YXJnZXRbMV0gKiBkM19yYWRpYW5zKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2ludGVycG9sYXRlKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgdmFyIGN5MCA9IE1hdGguY29zKHkwKSwgc3kwID0gTWF0aC5zaW4oeTApLCBjeTEgPSBNYXRoLmNvcyh5MSksIHN5MSA9IE1hdGguc2luKHkxKSwga3gwID0gY3kwICogTWF0aC5jb3MoeDApLCBreTAgPSBjeTAgKiBNYXRoLnNpbih4MCksIGt4MSA9IGN5MSAqIE1hdGguY29zKHgxKSwga3kxID0gY3kxICogTWF0aC5zaW4oeDEpLCBkID0gMiAqIE1hdGguYXNpbihNYXRoLnNxcnQoZDNfaGF2ZXJzaW4oeTEgLSB5MCkgKyBjeTAgKiBjeTEgKiBkM19oYXZlcnNpbih4MSAtIHgwKSkpLCBrID0gMSAvIE1hdGguc2luKGQpO1xuICAgIHZhciBpbnRlcnBvbGF0ZSA9IGQgPyBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgQiA9IE1hdGguc2luKHQgKj0gZCkgKiBrLCBBID0gTWF0aC5zaW4oZCAtIHQpICogaywgeCA9IEEgKiBreDAgKyBCICoga3gxLCB5ID0gQSAqIGt5MCArIEIgKiBreTEsIHogPSBBICogc3kwICsgQiAqIHN5MTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSwgeCkgKiBkM19kZWdyZWVzLCBNYXRoLmF0YW4yKHosIE1hdGguc3FydCh4ICogeCArIHkgKiB5KSkgKiBkM19kZWdyZWVzIF07XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFsgeDAgKiBkM19kZWdyZWVzLCB5MCAqIGQzX2RlZ3JlZXMgXTtcbiAgICB9O1xuICAgIGludGVycG9sYXRlLmRpc3RhbmNlID0gZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGU7XG4gIH1cbiAgZDMuZ2VvLmxlbmd0aCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19sZW5ndGhTdW0gPSAwO1xuICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBkM19nZW9fbGVuZ3RoKTtcbiAgICByZXR1cm4gZDNfZ2VvX2xlbmd0aFN1bTtcbiAgfTtcbiAgdmFyIGQzX2dlb19sZW5ndGhTdW07XG4gIHZhciBkM19nZW9fbGVuZ3RoID0ge1xuICAgIHNwaGVyZTogZDNfbm9vcCxcbiAgICBwb2ludDogZDNfbm9vcCxcbiAgICBsaW5lU3RhcnQ6IGQzX2dlb19sZW5ndGhMaW5lU3RhcnQsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGQzX25vb3AsXG4gICAgcG9seWdvbkVuZDogZDNfbm9vcFxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fbGVuZ3RoTGluZVN0YXJ0KCkge1xuICAgIHZhciDOuzAsIHNpbs+GMCwgY29zz4YwO1xuICAgIGQzX2dlb19sZW5ndGgucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67MCA9IM67ICogZDNfcmFkaWFucywgc2luz4YwID0gTWF0aC5zaW4oz4YgKj0gZDNfcmFkaWFucyksIGNvc8+GMCA9IE1hdGguY29zKM+GKTtcbiAgICAgIGQzX2dlb19sZW5ndGgucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgfTtcbiAgICBkM19nZW9fbGVuZ3RoLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19sZW5ndGgucG9pbnQgPSBkM19nZW9fbGVuZ3RoLmxpbmVFbmQgPSBkM19ub29wO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgdmFyIHNpbs+GID0gTWF0aC5zaW4oz4YgKj0gZDNfcmFkaWFucyksIGNvc8+GID0gTWF0aC5jb3Moz4YpLCB0ID0gYWJzKCjOuyAqPSBkM19yYWRpYW5zKSAtIM67MCksIGNvc86UzrsgPSBNYXRoLmNvcyh0KTtcbiAgICAgIGQzX2dlb19sZW5ndGhTdW0gKz0gTWF0aC5hdGFuMihNYXRoLnNxcnQoKHQgPSBjb3PPhiAqIE1hdGguc2luKHQpKSAqIHQgKyAodCA9IGNvc8+GMCAqIHNpbs+GIC0gc2luz4YwICogY29zz4YgKiBjb3POlM67KSAqIHQpLCBzaW7PhjAgKiBzaW7PhiArIGNvc8+GMCAqIGNvc8+GICogY29zzpTOuyk7XG4gICAgICDOuzAgPSDOuywgc2luz4YwID0gc2luz4YsIGNvc8+GMCA9IGNvc8+GO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fYXppbXV0aGFsKHNjYWxlLCBhbmdsZSkge1xuICAgIGZ1bmN0aW9uIGF6aW11dGhhbCjOuywgz4YpIHtcbiAgICAgIHZhciBjb3POuyA9IE1hdGguY29zKM67KSwgY29zz4YgPSBNYXRoLmNvcyjPhiksIGsgPSBzY2FsZShjb3POuyAqIGNvc8+GKTtcbiAgICAgIHJldHVybiBbIGsgKiBjb3PPhiAqIE1hdGguc2luKM67KSwgayAqIE1hdGguc2luKM+GKSBdO1xuICAgIH1cbiAgICBhemltdXRoYWwuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIM+BID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpLCBjID0gYW5nbGUoz4EpLCBzaW5jID0gTWF0aC5zaW4oYyksIGNvc2MgPSBNYXRoLmNvcyhjKTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCAqIHNpbmMsIM+BICogY29zYyksIE1hdGguYXNpbijPgSAmJiB5ICogc2luYyAvIM+BKSBdO1xuICAgIH07XG4gICAgcmV0dXJuIGF6aW11dGhhbDtcbiAgfVxuICB2YXIgZDNfZ2VvX2F6aW11dGhhbEVxdWFsQXJlYSA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoMiAvICgxICsgY29zzrtjb3PPhikpO1xuICB9LCBmdW5jdGlvbijPgSkge1xuICAgIHJldHVybiAyICogTWF0aC5hc2luKM+BIC8gMik7XG4gIH0pO1xuICAoZDMuZ2VvLmF6aW11dGhhbEVxdWFsQXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fYXppbXV0aGFsRXF1YWxBcmVhKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2F6aW11dGhhbEVxdWFsQXJlYTtcbiAgdmFyIGQzX2dlb19hemltdXRoYWxFcXVpZGlzdGFudCA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHZhciBjID0gTWF0aC5hY29zKGNvc867Y29zz4YpO1xuICAgIHJldHVybiBjICYmIGMgLyBNYXRoLnNpbihjKTtcbiAgfSwgZDNfaWRlbnRpdHkpO1xuICAoZDMuZ2VvLmF6aW11dGhhbEVxdWlkaXN0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19hemltdXRoYWxFcXVpZGlzdGFudCk7XG4gIH0pLnJhdyA9IGQzX2dlb19hemltdXRoYWxFcXVpZGlzdGFudDtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljQ29uZm9ybWFsKM+GMCwgz4YxKSB7XG4gICAgdmFyIGNvc8+GMCA9IE1hdGguY29zKM+GMCksIHQgPSBmdW5jdGlvbijPhikge1xuICAgICAgcmV0dXJuIE1hdGgudGFuKM+AIC8gNCArIM+GIC8gMik7XG4gICAgfSwgbiA9IM+GMCA9PT0gz4YxID8gTWF0aC5zaW4oz4YwKSA6IE1hdGgubG9nKGNvc8+GMCAvIE1hdGguY29zKM+GMSkpIC8gTWF0aC5sb2codCjPhjEpIC8gdCjPhjApKSwgRiA9IGNvc8+GMCAqIE1hdGgucG93KHQoz4YwKSwgbikgLyBuO1xuICAgIGlmICghbikgcmV0dXJuIGQzX2dlb19tZXJjYXRvcjtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKM67LCDPhikge1xuICAgICAgaWYgKEYgPiAwKSB7XG4gICAgICAgIGlmICjPhiA8IC1oYWxmz4AgKyDOtSkgz4YgPSAtaGFsZs+AICsgzrU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoz4YgPiBoYWxmz4AgLSDOtSkgz4YgPSBoYWxmz4AgLSDOtTtcbiAgICAgIH1cbiAgICAgIHZhciDPgSA9IEYgLyBNYXRoLnBvdyh0KM+GKSwgbik7XG4gICAgICByZXR1cm4gWyDPgSAqIE1hdGguc2luKG4gKiDOuyksIEYgLSDPgSAqIE1hdGguY29zKG4gKiDOuykgXTtcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EwX3kgPSBGIC0geSwgz4EgPSBkM19zZ24obikgKiBNYXRoLnNxcnQoeCAqIHggKyDPgTBfeSAqIM+BMF95KTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCwgz4EwX3kpIC8gbiwgMiAqIE1hdGguYXRhbihNYXRoLnBvdyhGIC8gz4EsIDEgLyBuKSkgLSBoYWxmz4AgXTtcbiAgICB9O1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG4gIChkMy5nZW8uY29uaWNDb25mb3JtYWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2NvbmljKGQzX2dlb19jb25pY0NvbmZvcm1hbCk7XG4gIH0pLnJhdyA9IGQzX2dlb19jb25pY0NvbmZvcm1hbDtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljRXF1aWRpc3RhbnQoz4YwLCDPhjEpIHtcbiAgICB2YXIgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgbiA9IM+GMCA9PT0gz4YxID8gTWF0aC5zaW4oz4YwKSA6IChjb3PPhjAgLSBNYXRoLmNvcyjPhjEpKSAvICjPhjEgLSDPhjApLCBHID0gY29zz4YwIC8gbiArIM+GMDtcbiAgICBpZiAoYWJzKG4pIDwgzrUpIHJldHVybiBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQozrssIM+GKSB7XG4gICAgICB2YXIgz4EgPSBHIC0gz4Y7XG4gICAgICByZXR1cm4gWyDPgSAqIE1hdGguc2luKG4gKiDOuyksIEcgLSDPgSAqIE1hdGguY29zKG4gKiDOuykgXTtcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EwX3kgPSBHIC0geTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCwgz4EwX3kpIC8gbiwgRyAtIGQzX3NnbihuKSAqIE1hdGguc3FydCh4ICogeCArIM+BMF95ICogz4EwX3kpIF07XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuICAoZDMuZ2VvLmNvbmljRXF1aWRpc3RhbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2NvbmljKGQzX2dlb19jb25pY0VxdWlkaXN0YW50KTtcbiAgfSkucmF3ID0gZDNfZ2VvX2NvbmljRXF1aWRpc3RhbnQ7XG4gIHZhciBkM19nZW9fZ25vbW9uaWMgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKGNvc867Y29zz4YpIHtcbiAgICByZXR1cm4gMSAvIGNvc867Y29zz4Y7XG4gIH0sIE1hdGguYXRhbik7XG4gIChkMy5nZW8uZ25vbW9uaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX2dub21vbmljKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2dub21vbmljO1xuICBmdW5jdGlvbiBkM19nZW9fbWVyY2F0b3IozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgzrssIE1hdGgubG9nKE1hdGgudGFuKM+AIC8gNCArIM+GIC8gMikpIF07XG4gIH1cbiAgZDNfZ2VvX21lcmNhdG9yLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gWyB4LCAyICogTWF0aC5hdGFuKE1hdGguZXhwKHkpKSAtIGhhbGbPgCBdO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fbWVyY2F0b3JQcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgICB2YXIgbSA9IGQzX2dlb19wcm9qZWN0aW9uKHByb2plY3QpLCBzY2FsZSA9IG0uc2NhbGUsIHRyYW5zbGF0ZSA9IG0udHJhbnNsYXRlLCBjbGlwRXh0ZW50ID0gbS5jbGlwRXh0ZW50LCBjbGlwQXV0bztcbiAgICBtLnNjYWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHNjYWxlLmFwcGx5KG0sIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdiA9PT0gbSA/IGNsaXBBdXRvID8gbS5jbGlwRXh0ZW50KG51bGwpIDogbSA6IHY7XG4gICAgfTtcbiAgICBtLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB0cmFuc2xhdGUuYXBwbHkobSwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB2ID09PSBtID8gY2xpcEF1dG8gPyBtLmNsaXBFeHRlbnQobnVsbCkgOiBtIDogdjtcbiAgICB9O1xuICAgIG0uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHZhciB2ID0gY2xpcEV4dGVudC5hcHBseShtLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHYgPT09IG0pIHtcbiAgICAgICAgaWYgKGNsaXBBdXRvID0gXyA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGsgPSDPgCAqIHNjYWxlKCksIHQgPSB0cmFuc2xhdGUoKTtcbiAgICAgICAgICBjbGlwRXh0ZW50KFsgWyB0WzBdIC0gaywgdFsxXSAtIGsgXSwgWyB0WzBdICsgaywgdFsxXSArIGsgXSBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjbGlwQXV0bykge1xuICAgICAgICB2ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgcmV0dXJuIG0uY2xpcEV4dGVudChudWxsKTtcbiAgfVxuICAoZDMuZ2VvLm1lcmNhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19tZXJjYXRvclByb2plY3Rpb24oZDNfZ2VvX21lcmNhdG9yKTtcbiAgfSkucmF3ID0gZDNfZ2VvX21lcmNhdG9yO1xuICB2YXIgZDNfZ2VvX29ydGhvZ3JhcGhpYyA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sIE1hdGguYXNpbik7XG4gIChkMy5nZW8ub3J0aG9ncmFwaGljID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19vcnRob2dyYXBoaWMpO1xuICB9KS5yYXcgPSBkM19nZW9fb3J0aG9ncmFwaGljO1xuICB2YXIgZDNfZ2VvX3N0ZXJlb2dyYXBoaWMgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKGNvc867Y29zz4YpIHtcbiAgICByZXR1cm4gMSAvICgxICsgY29zzrtjb3PPhik7XG4gIH0sIGZ1bmN0aW9uKM+BKSB7XG4gICAgcmV0dXJuIDIgKiBNYXRoLmF0YW4oz4EpO1xuICB9KTtcbiAgKGQzLmdlby5zdGVyZW9ncmFwaGljID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19zdGVyZW9ncmFwaGljKTtcbiAgfSkucmF3ID0gZDNfZ2VvX3N0ZXJlb2dyYXBoaWM7XG4gIGZ1bmN0aW9uIGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3IozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgTWF0aC5sb2coTWF0aC50YW4oz4AgLyA0ICsgz4YgLyAyKSksIC3OuyBdO1xuICB9XG4gIGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3IuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbIC15LCAyICogTWF0aC5hdGFuKE1hdGguZXhwKHgpKSAtIGhhbGbPgCBdO1xuICB9O1xuICAoZDMuZ2VvLnRyYW5zdmVyc2VNZXJjYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9qZWN0aW9uID0gZDNfZ2VvX21lcmNhdG9yUHJvamVjdGlvbihkM19nZW9fdHJhbnN2ZXJzZU1lcmNhdG9yKSwgY2VudGVyID0gcHJvamVjdGlvbi5jZW50ZXIsIHJvdGF0ZSA9IHByb2plY3Rpb24ucm90YXRlO1xuICAgIHByb2plY3Rpb24uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIF8gPyBjZW50ZXIoWyAtX1sxXSwgX1swXSBdKSA6IChfID0gY2VudGVyKCksIFsgX1sxXSwgLV9bMF0gXSk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBfID8gcm90YXRlKFsgX1swXSwgX1sxXSwgXy5sZW5ndGggPiAyID8gX1syXSArIDkwIDogOTAgXSkgOiAoXyA9IHJvdGF0ZSgpLCBcbiAgICAgIFsgX1swXSwgX1sxXSwgX1syXSAtIDkwIF0pO1xuICAgIH07XG4gICAgcmV0dXJuIHJvdGF0ZShbIDAsIDAsIDkwIF0pO1xuICB9KS5yYXcgPSBkM19nZW9fdHJhbnN2ZXJzZU1lcmNhdG9yO1xuICBkMy5nZW9tID0ge307XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9pbnRYKGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3BvaW50WShkKSB7XG4gICAgcmV0dXJuIGRbMV07XG4gIH1cbiAgZDMuZ2VvbS5odWxsID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBodWxsKHZlcnRpY2VzKTtcbiAgICBmdW5jdGlvbiBodWxsKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDMpIHJldHVybiBbXTtcbiAgICAgIHZhciBmeCA9IGQzX2Z1bmN0b3IoeCksIGZ5ID0gZDNfZnVuY3Rvcih5KSwgaSwgbiA9IGRhdGEubGVuZ3RoLCBwb2ludHMgPSBbXSwgZmxpcHBlZFBvaW50cyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBwb2ludHMucHVzaChbICtmeC5jYWxsKHRoaXMsIGRhdGFbaV0sIGkpLCArZnkuY2FsbCh0aGlzLCBkYXRhW2ldLCBpKSwgaSBdKTtcbiAgICAgIH1cbiAgICAgIHBvaW50cy5zb3J0KGQzX2dlb21faHVsbE9yZGVyKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGZsaXBwZWRQb2ludHMucHVzaChbIHBvaW50c1tpXVswXSwgLXBvaW50c1tpXVsxXSBdKTtcbiAgICAgIHZhciB1cHBlciA9IGQzX2dlb21faHVsbFVwcGVyKHBvaW50cyksIGxvd2VyID0gZDNfZ2VvbV9odWxsVXBwZXIoZmxpcHBlZFBvaW50cyk7XG4gICAgICB2YXIgc2tpcExlZnQgPSBsb3dlclswXSA9PT0gdXBwZXJbMF0sIHNraXBSaWdodCA9IGxvd2VyW2xvd2VyLmxlbmd0aCAtIDFdID09PSB1cHBlclt1cHBlci5sZW5ndGggLSAxXSwgcG9seWdvbiA9IFtdO1xuICAgICAgZm9yIChpID0gdXBwZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHBvbHlnb24ucHVzaChkYXRhW3BvaW50c1t1cHBlcltpXV1bMl1dKTtcbiAgICAgIGZvciAoaSA9ICtza2lwTGVmdDsgaSA8IGxvd2VyLmxlbmd0aCAtIHNraXBSaWdodDsgKytpKSBwb2x5Z29uLnB1c2goZGF0YVtwb2ludHNbbG93ZXJbaV1dWzJdXSk7XG4gICAgICByZXR1cm4gcG9seWdvbjtcbiAgICB9XG4gICAgaHVsbC54ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IF8sIGh1bGwpIDogeDtcbiAgICB9O1xuICAgIGh1bGwueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBfLCBodWxsKSA6IHk7XG4gICAgfTtcbiAgICByZXR1cm4gaHVsbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9odWxsVXBwZXIocG9pbnRzKSB7XG4gICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoLCBodWxsID0gWyAwLCAxIF0sIGhzID0gMjtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IG47IGkrKykge1xuICAgICAgd2hpbGUgKGhzID4gMSAmJiBkM19jcm9zczJkKHBvaW50c1todWxsW2hzIC0gMl1dLCBwb2ludHNbaHVsbFtocyAtIDFdXSwgcG9pbnRzW2ldKSA8PSAwKSAtLWhzO1xuICAgICAgaHVsbFtocysrXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBodWxsLnNsaWNlKDAsIGhzKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX2h1bGxPcmRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdO1xuICB9XG4gIGQzLmdlb20ucG9seWdvbiA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgZDNfc3ViY2xhc3MoY29vcmRpbmF0ZXMsIGQzX2dlb21fcG9seWdvblByb3RvdHlwZSk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICB9O1xuICB2YXIgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlID0gZDMuZ2VvbS5wb2x5Z29uLnByb3RvdHlwZSA9IFtdO1xuICBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCwgYSwgYiA9IHRoaXNbbiAtIDFdLCBhcmVhID0gMDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gdGhpc1tpXTtcbiAgICAgIGFyZWEgKz0gYVsxXSAqIGJbMF0gLSBhWzBdICogYlsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZWEgKiAuNTtcbiAgfTtcbiAgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlLmNlbnRyb2lkID0gZnVuY3Rpb24oaykge1xuICAgIHZhciBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCwgeCA9IDAsIHkgPSAwLCBhLCBiID0gdGhpc1tuIC0gMV0sIGM7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSBrID0gLTEgLyAoNiAqIHRoaXMuYXJlYSgpKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYSA9IGI7XG4gICAgICBiID0gdGhpc1tpXTtcbiAgICAgIGMgPSBhWzBdICogYlsxXSAtIGJbMF0gKiBhWzFdO1xuICAgICAgeCArPSAoYVswXSArIGJbMF0pICogYztcbiAgICAgIHkgKz0gKGFbMV0gKyBiWzFdKSAqIGM7XG4gICAgfVxuICAgIHJldHVybiBbIHggKiBrLCB5ICogayBdO1xuICB9O1xuICBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uKHN1YmplY3QpIHtcbiAgICB2YXIgaW5wdXQsIGNsb3NlZCA9IGQzX2dlb21fcG9seWdvbkNsb3NlZChzdWJqZWN0KSwgaSA9IC0xLCBuID0gdGhpcy5sZW5ndGggLSBkM19nZW9tX3BvbHlnb25DbG9zZWQodGhpcyksIGosIG0sIGEgPSB0aGlzW24gLSAxXSwgYiwgYywgZDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaW5wdXQgPSBzdWJqZWN0LnNsaWNlKCk7XG4gICAgICBzdWJqZWN0Lmxlbmd0aCA9IDA7XG4gICAgICBiID0gdGhpc1tpXTtcbiAgICAgIGMgPSBpbnB1dFsobSA9IGlucHV0Lmxlbmd0aCAtIGNsb3NlZCkgLSAxXTtcbiAgICAgIGogPSAtMTtcbiAgICAgIHdoaWxlICgrK2ogPCBtKSB7XG4gICAgICAgIGQgPSBpbnB1dFtqXTtcbiAgICAgICAgaWYgKGQzX2dlb21fcG9seWdvbkluc2lkZShkLCBhLCBiKSkge1xuICAgICAgICAgIGlmICghZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKGMsIGEsIGIpKSB7XG4gICAgICAgICAgICBzdWJqZWN0LnB1c2goZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KGMsIGQsIGEsIGIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3ViamVjdC5wdXNoKGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGQzX2dlb21fcG9seWdvbkluc2lkZShjLCBhLCBiKSkge1xuICAgICAgICAgIHN1YmplY3QucHVzaChkM19nZW9tX3BvbHlnb25JbnRlcnNlY3QoYywgZCwgYSwgYikpO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBkO1xuICAgICAgfVxuICAgICAgaWYgKGNsb3NlZCkgc3ViamVjdC5wdXNoKHN1YmplY3RbMF0pO1xuICAgICAgYSA9IGI7XG4gICAgfVxuICAgIHJldHVybiBzdWJqZWN0O1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3BvbHlnb25JbnNpZGUocCwgYSwgYikge1xuICAgIHJldHVybiAoYlswXSAtIGFbMF0pICogKHBbMV0gLSBhWzFdKSA8IChiWzFdIC0gYVsxXSkgKiAocFswXSAtIGFbMF0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9seWdvbkludGVyc2VjdChjLCBkLCBhLCBiKSB7XG4gICAgdmFyIHgxID0gY1swXSwgeDMgPSBhWzBdLCB4MjEgPSBkWzBdIC0geDEsIHg0MyA9IGJbMF0gLSB4MywgeTEgPSBjWzFdLCB5MyA9IGFbMV0sIHkyMSA9IGRbMV0gLSB5MSwgeTQzID0gYlsxXSAtIHkzLCB1YSA9ICh4NDMgKiAoeTEgLSB5MykgLSB5NDMgKiAoeDEgLSB4MykpIC8gKHk0MyAqIHgyMSAtIHg0MyAqIHkyMSk7XG4gICAgcmV0dXJuIFsgeDEgKyB1YSAqIHgyMSwgeTEgKyB1YSAqIHkyMSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9seWdvbkNsb3NlZChjb29yZGluYXRlcykge1xuICAgIHZhciBhID0gY29vcmRpbmF0ZXNbMF0sIGIgPSBjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gIShhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXSk7XG4gIH1cbiAgdmFyIGQzX2dlb21fdm9yb25vaUVkZ2VzLCBkM19nZW9tX3Zvcm9ub2lDZWxscywgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcywgZDNfZ2VvbV92b3Jvbm9pQmVhY2hQb29sID0gW10sIGQzX2dlb21fdm9yb25vaUZpcnN0Q2lyY2xlLCBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLCBkM19nZW9tX3Zvcm9ub2lDaXJjbGVQb29sID0gW107XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUJlYWNoKCkge1xuICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZSh0aGlzKTtcbiAgICB0aGlzLmVkZ2UgPSB0aGlzLnNpdGUgPSB0aGlzLmNpcmNsZSA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQmVhY2goc2l0ZSkge1xuICAgIHZhciBiZWFjaCA9IGQzX2dlb21fdm9yb25vaUJlYWNoUG9vbC5wb3AoKSB8fCBuZXcgZDNfZ2VvbV92b3Jvbm9pQmVhY2goKTtcbiAgICBiZWFjaC5zaXRlID0gc2l0ZTtcbiAgICByZXR1cm4gYmVhY2g7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2goYmVhY2gpIHtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUoYmVhY2gpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMucmVtb3ZlKGJlYWNoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaFBvb2wucHVzaChiZWFjaCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKGJlYWNoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZW1vdmVCZWFjaChiZWFjaCkge1xuICAgIHZhciBjaXJjbGUgPSBiZWFjaC5jaXJjbGUsIHggPSBjaXJjbGUueCwgeSA9IGNpcmNsZS5jeSwgdmVydGV4ID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9LCBwcmV2aW91cyA9IGJlYWNoLlAsIG5leHQgPSBiZWFjaC5OLCBkaXNhcHBlYXJpbmcgPSBbIGJlYWNoIF07XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2goYmVhY2gpO1xuICAgIHZhciBsQXJjID0gcHJldmlvdXM7XG4gICAgd2hpbGUgKGxBcmMuY2lyY2xlICYmIGFicyh4IC0gbEFyYy5jaXJjbGUueCkgPCDOtSAmJiBhYnMoeSAtIGxBcmMuY2lyY2xlLmN5KSA8IM61KSB7XG4gICAgICBwcmV2aW91cyA9IGxBcmMuUDtcbiAgICAgIGRpc2FwcGVhcmluZy51bnNoaWZ0KGxBcmMpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2gobEFyYyk7XG4gICAgICBsQXJjID0gcHJldmlvdXM7XG4gICAgfVxuICAgIGRpc2FwcGVhcmluZy51bnNoaWZ0KGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShsQXJjKTtcbiAgICB2YXIgckFyYyA9IG5leHQ7XG4gICAgd2hpbGUgKHJBcmMuY2lyY2xlICYmIGFicyh4IC0gckFyYy5jaXJjbGUueCkgPCDOtSAmJiBhYnMoeSAtIHJBcmMuY2lyY2xlLmN5KSA8IM61KSB7XG4gICAgICBuZXh0ID0gckFyYy5OO1xuICAgICAgZGlzYXBwZWFyaW5nLnB1c2gockFyYyk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChyQXJjKTtcbiAgICAgIHJBcmMgPSBuZXh0O1xuICAgIH1cbiAgICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUockFyYyk7XG4gICAgdmFyIG5BcmNzID0gZGlzYXBwZWFyaW5nLmxlbmd0aCwgaUFyYztcbiAgICBmb3IgKGlBcmMgPSAxOyBpQXJjIDwgbkFyY3M7ICsraUFyYykge1xuICAgICAgckFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjXTtcbiAgICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbaUFyYyAtIDFdO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxBcmMuc2l0ZSwgckFyYy5zaXRlLCB2ZXJ0ZXgpO1xuICAgIH1cbiAgICBsQXJjID0gZGlzYXBwZWFyaW5nWzBdO1xuICAgIHJBcmMgPSBkaXNhcHBlYXJpbmdbbkFyY3MgLSAxXTtcbiAgICByQXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxBcmMuc2l0ZSwgckFyYy5zaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUockFyYyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQWRkQmVhY2goc2l0ZSkge1xuICAgIHZhciB4ID0gc2l0ZS54LCBkaXJlY3RyaXggPSBzaXRlLnksIGxBcmMsIHJBcmMsIGR4bCwgZHhyLCBub2RlID0gZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5fO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBkeGwgPSBkM19nZW9tX3Zvcm9ub2lMZWZ0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpIC0geDtcbiAgICAgIGlmIChkeGwgPiDOtSkgbm9kZSA9IG5vZGUuTDsgZWxzZSB7XG4gICAgICAgIGR4ciA9IHggLSBkM19nZW9tX3Zvcm9ub2lSaWdodEJyZWFrUG9pbnQobm9kZSwgZGlyZWN0cml4KTtcbiAgICAgICAgaWYgKGR4ciA+IM61KSB7XG4gICAgICAgICAgaWYgKCFub2RlLlIpIHtcbiAgICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLlI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGR4bCA+IC3OtSkge1xuICAgICAgICAgICAgbEFyYyA9IG5vZGUuUDtcbiAgICAgICAgICAgIHJBcmMgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZHhyID4gLc61KSB7XG4gICAgICAgICAgICBsQXJjID0gbm9kZTtcbiAgICAgICAgICAgIHJBcmMgPSBub2RlLk47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxBcmMgPSByQXJjID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5ld0FyYyA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUJlYWNoKHNpdGUpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMuaW5zZXJ0KGxBcmMsIG5ld0FyYyk7XG4gICAgaWYgKCFsQXJjICYmICFyQXJjKSByZXR1cm47XG4gICAgaWYgKGxBcmMgPT09IHJBcmMpIHtcbiAgICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShsQXJjKTtcbiAgICAgIHJBcmMgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCZWFjaChsQXJjLnNpdGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5pbnNlcnQobmV3QXJjLCByQXJjKTtcbiAgICAgIG5ld0FyYy5lZGdlID0gckFyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShsQXJjKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShyQXJjKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFyQXJjKSB7XG4gICAgICBuZXdBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobEFyYy5zaXRlLCBuZXdBcmMuc2l0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUockFyYyk7XG4gICAgdmFyIGxTaXRlID0gbEFyYy5zaXRlLCBheCA9IGxTaXRlLngsIGF5ID0gbFNpdGUueSwgYnggPSBzaXRlLnggLSBheCwgYnkgPSBzaXRlLnkgLSBheSwgclNpdGUgPSByQXJjLnNpdGUsIGN4ID0gclNpdGUueCAtIGF4LCBjeSA9IHJTaXRlLnkgLSBheSwgZCA9IDIgKiAoYnggKiBjeSAtIGJ5ICogY3gpLCBoYiA9IGJ4ICogYnggKyBieSAqIGJ5LCBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LCB2ZXJ0ZXggPSB7XG4gICAgICB4OiAoY3kgKiBoYiAtIGJ5ICogaGMpIC8gZCArIGF4LFxuICAgICAgeTogKGJ4ICogaGMgLSBjeCAqIGhiKSAvIGQgKyBheVxuICAgIH07XG4gICAgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxTaXRlLCByU2l0ZSwgdmVydGV4KTtcbiAgICBuZXdBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobFNpdGUsIHNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgckFyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShzaXRlLCByU2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKHJBcmMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUxlZnRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XG4gICAgdmFyIHNpdGUgPSBhcmMuc2l0ZSwgcmZvY3ggPSBzaXRlLngsIHJmb2N5ID0gc2l0ZS55LCBwYnkyID0gcmZvY3kgLSBkaXJlY3RyaXg7XG4gICAgaWYgKCFwYnkyKSByZXR1cm4gcmZvY3g7XG4gICAgdmFyIGxBcmMgPSBhcmMuUDtcbiAgICBpZiAoIWxBcmMpIHJldHVybiAtSW5maW5pdHk7XG4gICAgc2l0ZSA9IGxBcmMuc2l0ZTtcbiAgICB2YXIgbGZvY3ggPSBzaXRlLngsIGxmb2N5ID0gc2l0ZS55LCBwbGJ5MiA9IGxmb2N5IC0gZGlyZWN0cml4O1xuICAgIGlmICghcGxieTIpIHJldHVybiBsZm9jeDtcbiAgICB2YXIgaGwgPSBsZm9jeCAtIHJmb2N4LCBhYnkyID0gMSAvIHBieTIgLSAxIC8gcGxieTIsIGIgPSBobCAvIHBsYnkyO1xuICAgIGlmIChhYnkyKSByZXR1cm4gKC1iICsgTWF0aC5zcXJ0KGIgKiBiIC0gMiAqIGFieTIgKiAoaGwgKiBobCAvICgtMiAqIHBsYnkyKSAtIGxmb2N5ICsgcGxieTIgLyAyICsgcmZvY3kgLSBwYnkyIC8gMikpKSAvIGFieTIgKyByZm9jeDtcbiAgICByZXR1cm4gKHJmb2N4ICsgbGZvY3gpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSaWdodEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgICB2YXIgckFyYyA9IGFyYy5OO1xuICAgIGlmIChyQXJjKSByZXR1cm4gZDNfZ2VvbV92b3Jvbm9pTGVmdEJyZWFrUG9pbnQockFyYywgZGlyZWN0cml4KTtcbiAgICB2YXIgc2l0ZSA9IGFyYy5zaXRlO1xuICAgIHJldHVybiBzaXRlLnkgPT09IGRpcmVjdHJpeCA/IHNpdGUueCA6IEluZmluaXR5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNlbGwoc2l0ZSkge1xuICAgIHRoaXMuc2l0ZSA9IHNpdGU7XG4gICAgdGhpcy5lZGdlcyA9IFtdO1xuICB9XG4gIGQzX2dlb21fdm9yb25vaUNlbGwucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGFsZkVkZ2VzID0gdGhpcy5lZGdlcywgaUhhbGZFZGdlID0gaGFsZkVkZ2VzLmxlbmd0aCwgZWRnZTtcbiAgICB3aGlsZSAoaUhhbGZFZGdlLS0pIHtcbiAgICAgIGVkZ2UgPSBoYWxmRWRnZXNbaUhhbGZFZGdlXS5lZGdlO1xuICAgICAgaWYgKCFlZGdlLmIgfHwgIWVkZ2UuYSkgaGFsZkVkZ2VzLnNwbGljZShpSGFsZkVkZ2UsIDEpO1xuICAgIH1cbiAgICBoYWxmRWRnZXMuc29ydChkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZU9yZGVyKTtcbiAgICByZXR1cm4gaGFsZkVkZ2VzLmxlbmd0aDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2xvc2VDZWxscyhleHRlbnQpIHtcbiAgICB2YXIgeDAgPSBleHRlbnRbMF1bMF0sIHgxID0gZXh0ZW50WzFdWzBdLCB5MCA9IGV4dGVudFswXVsxXSwgeTEgPSBleHRlbnRbMV1bMV0sIHgyLCB5MiwgeDMsIHkzLCBjZWxscyA9IGQzX2dlb21fdm9yb25vaUNlbGxzLCBpQ2VsbCA9IGNlbGxzLmxlbmd0aCwgY2VsbCwgaUhhbGZFZGdlLCBoYWxmRWRnZXMsIG5IYWxmRWRnZXMsIHN0YXJ0LCBlbmQ7XG4gICAgd2hpbGUgKGlDZWxsLS0pIHtcbiAgICAgIGNlbGwgPSBjZWxsc1tpQ2VsbF07XG4gICAgICBpZiAoIWNlbGwgfHwgIWNlbGwucHJlcGFyZSgpKSBjb250aW51ZTtcbiAgICAgIGhhbGZFZGdlcyA9IGNlbGwuZWRnZXM7XG4gICAgICBuSGFsZkVkZ2VzID0gaGFsZkVkZ2VzLmxlbmd0aDtcbiAgICAgIGlIYWxmRWRnZSA9IDA7XG4gICAgICB3aGlsZSAoaUhhbGZFZGdlIDwgbkhhbGZFZGdlcykge1xuICAgICAgICBlbmQgPSBoYWxmRWRnZXNbaUhhbGZFZGdlXS5lbmQoKSwgeDMgPSBlbmQueCwgeTMgPSBlbmQueTtcbiAgICAgICAgc3RhcnQgPSBoYWxmRWRnZXNbKytpSGFsZkVkZ2UgJSBuSGFsZkVkZ2VzXS5zdGFydCgpLCB4MiA9IHN0YXJ0LngsIHkyID0gc3RhcnQueTtcbiAgICAgICAgaWYgKGFicyh4MyAtIHgyKSA+IM61IHx8IGFicyh5MyAtIHkyKSA+IM61KSB7XG4gICAgICAgICAgaGFsZkVkZ2VzLnNwbGljZShpSGFsZkVkZ2UsIDAsIG5ldyBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShkM19nZW9tX3Zvcm9ub2lDcmVhdGVCb3JkZXJFZGdlKGNlbGwuc2l0ZSwgZW5kLCBhYnMoeDMgLSB4MCkgPCDOtSAmJiB5MSAtIHkzID4gzrUgPyB7XG4gICAgICAgICAgICB4OiB4MCxcbiAgICAgICAgICAgIHk6IGFicyh4MiAtIHgwKSA8IM61ID8geTIgOiB5MVxuICAgICAgICAgIH0gOiBhYnMoeTMgLSB5MSkgPCDOtSAmJiB4MSAtIHgzID4gzrUgPyB7XG4gICAgICAgICAgICB4OiBhYnMoeTIgLSB5MSkgPCDOtSA/IHgyIDogeDEsXG4gICAgICAgICAgICB5OiB5MVxuICAgICAgICAgIH0gOiBhYnMoeDMgLSB4MSkgPCDOtSAmJiB5MyAtIHkwID4gzrUgPyB7XG4gICAgICAgICAgICB4OiB4MSxcbiAgICAgICAgICAgIHk6IGFicyh4MiAtIHgxKSA8IM61ID8geTIgOiB5MFxuICAgICAgICAgIH0gOiBhYnMoeTMgLSB5MCkgPCDOtSAmJiB4MyAtIHgwID4gzrUgPyB7XG4gICAgICAgICAgICB4OiBhYnMoeTIgLSB5MCkgPCDOtSA/IHgyIDogeDAsXG4gICAgICAgICAgICB5OiB5MFxuICAgICAgICAgIH0gOiBudWxsKSwgY2VsbC5zaXRlLCBudWxsKSk7XG4gICAgICAgICAgKytuSGFsZkVkZ2VzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUhhbGZFZGdlT3JkZXIoYSwgYikge1xuICAgIHJldHVybiBiLmFuZ2xlIC0gYS5hbmdsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDaXJjbGUoKSB7XG4gICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKHRoaXMpO1xuICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMuYXJjID0gdGhpcy5zaXRlID0gdGhpcy5jeSA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGFyYykge1xuICAgIHZhciBsQXJjID0gYXJjLlAsIHJBcmMgPSBhcmMuTjtcbiAgICBpZiAoIWxBcmMgfHwgIXJBcmMpIHJldHVybjtcbiAgICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsIGNTaXRlID0gYXJjLnNpdGUsIHJTaXRlID0gckFyYy5zaXRlO1xuICAgIGlmIChsU2l0ZSA9PT0gclNpdGUpIHJldHVybjtcbiAgICB2YXIgYnggPSBjU2l0ZS54LCBieSA9IGNTaXRlLnksIGF4ID0gbFNpdGUueCAtIGJ4LCBheSA9IGxTaXRlLnkgLSBieSwgY3ggPSByU2l0ZS54IC0gYngsIGN5ID0gclNpdGUueSAtIGJ5O1xuICAgIHZhciBkID0gMiAqIChheCAqIGN5IC0gYXkgKiBjeCk7XG4gICAgaWYgKGQgPj0gLc61MikgcmV0dXJuO1xuICAgIHZhciBoYSA9IGF4ICogYXggKyBheSAqIGF5LCBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LCB4ID0gKGN5ICogaGEgLSBheSAqIGhjKSAvIGQsIHkgPSAoYXggKiBoYyAtIGN4ICogaGEpIC8gZCwgY3kgPSB5ICsgYnk7XG4gICAgdmFyIGNpcmNsZSA9IGQzX2dlb21fdm9yb25vaUNpcmNsZVBvb2wucG9wKCkgfHwgbmV3IGQzX2dlb21fdm9yb25vaUNpcmNsZSgpO1xuICAgIGNpcmNsZS5hcmMgPSBhcmM7XG4gICAgY2lyY2xlLnNpdGUgPSBjU2l0ZTtcbiAgICBjaXJjbGUueCA9IHggKyBieDtcbiAgICBjaXJjbGUueSA9IGN5ICsgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIGNpcmNsZS5jeSA9IGN5O1xuICAgIGFyYy5jaXJjbGUgPSBjaXJjbGU7XG4gICAgdmFyIGJlZm9yZSA9IG51bGwsIG5vZGUgPSBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLl87XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChjaXJjbGUueSA8IG5vZGUueSB8fCBjaXJjbGUueSA9PT0gbm9kZS55ICYmIGNpcmNsZS54IDw9IG5vZGUueCkge1xuICAgICAgICBpZiAobm9kZS5MKSBub2RlID0gbm9kZS5MOyBlbHNlIHtcbiAgICAgICAgICBiZWZvcmUgPSBub2RlLlA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlLlIpIG5vZGUgPSBub2RlLlI7IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSA9IG5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcy5pbnNlcnQoYmVmb3JlLCBjaXJjbGUpO1xuICAgIGlmICghYmVmb3JlKSBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZSA9IGNpcmNsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUoYXJjKSB7XG4gICAgdmFyIGNpcmNsZSA9IGFyYy5jaXJjbGU7XG4gICAgaWYgKGNpcmNsZSkge1xuICAgICAgaWYgKCFjaXJjbGUuUCkgZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGUgPSBjaXJjbGUuTjtcbiAgICAgIGQzX2dlb21fdm9yb25vaUNpcmNsZXMucmVtb3ZlKGNpcmNsZSk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVQb29sLnB1c2goY2lyY2xlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZShjaXJjbGUpO1xuICAgICAgYXJjLmNpcmNsZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNsaXBFZGdlcyhleHRlbnQpIHtcbiAgICB2YXIgZWRnZXMgPSBkM19nZW9tX3Zvcm9ub2lFZGdlcywgY2xpcCA9IGQzX2dlb21fY2xpcExpbmUoZXh0ZW50WzBdWzBdLCBleHRlbnRbMF1bMV0sIGV4dGVudFsxXVswXSwgZXh0ZW50WzFdWzFdKSwgaSA9IGVkZ2VzLmxlbmd0aCwgZTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBlID0gZWRnZXNbaV07XG4gICAgICBpZiAoIWQzX2dlb21fdm9yb25vaUNvbm5lY3RFZGdlKGUsIGV4dGVudCkgfHwgIWNsaXAoZSkgfHwgYWJzKGUuYS54IC0gZS5iLngpIDwgzrUgJiYgYWJzKGUuYS55IC0gZS5iLnkpIDwgzrUpIHtcbiAgICAgICAgZS5hID0gZS5iID0gbnVsbDtcbiAgICAgICAgZWRnZXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDb25uZWN0RWRnZShlZGdlLCBleHRlbnQpIHtcbiAgICB2YXIgdmIgPSBlZGdlLmI7XG4gICAgaWYgKHZiKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgdmEgPSBlZGdlLmEsIHgwID0gZXh0ZW50WzBdWzBdLCB4MSA9IGV4dGVudFsxXVswXSwgeTAgPSBleHRlbnRbMF1bMV0sIHkxID0gZXh0ZW50WzFdWzFdLCBsU2l0ZSA9IGVkZ2UubCwgclNpdGUgPSBlZGdlLnIsIGx4ID0gbFNpdGUueCwgbHkgPSBsU2l0ZS55LCByeCA9IHJTaXRlLngsIHJ5ID0gclNpdGUueSwgZnggPSAobHggKyByeCkgLyAyLCBmeSA9IChseSArIHJ5KSAvIDIsIGZtLCBmYjtcbiAgICBpZiAocnkgPT09IGx5KSB7XG4gICAgICBpZiAoZnggPCB4MCB8fCBmeCA+PSB4MSkgcmV0dXJuO1xuICAgICAgaWYgKGx4ID4gcngpIHtcbiAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTBcbiAgICAgICAgfTsgZWxzZSBpZiAodmEueSA+PSB5MSkgcmV0dXJuO1xuICAgICAgICB2YiA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTFcbiAgICAgICAgfTsgZWxzZSBpZiAodmEueSA8IHkwKSByZXR1cm47XG4gICAgICAgIHZiID0ge1xuICAgICAgICAgIHg6IGZ4LFxuICAgICAgICAgIHk6IHkwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZtID0gKGx4IC0gcngpIC8gKHJ5IC0gbHkpO1xuICAgICAgZmIgPSBmeSAtIGZtICogZng7XG4gICAgICBpZiAoZm0gPCAtMSB8fCBmbSA+IDEpIHtcbiAgICAgICAgaWYgKGx4ID4gcngpIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6ICh5MCAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTBcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS55ID49IHkxKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiAoeTEgLSBmYikgLyBmbSxcbiAgICAgICAgICAgIHk6IHkxXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6ICh5MSAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTFcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS55IDwgeTApIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6ICh5MCAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobHkgPCByeSkge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogeDAsXG4gICAgICAgICAgICB5OiBmbSAqIHgwICsgZmJcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS54ID49IHgxKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiB4MSxcbiAgICAgICAgICAgIHk6IGZtICogeDEgKyBmYlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgICB4OiB4MSxcbiAgICAgICAgICAgIHk6IGZtICogeDEgKyBmYlxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnggPCB4MCkgcmV0dXJuO1xuICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgeDogeDAsXG4gICAgICAgICAgICB5OiBmbSAqIHgwICsgZmJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVkZ2UuYSA9IHZhO1xuICAgIGVkZ2UuYiA9IHZiO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUVkZ2UobFNpdGUsIHJTaXRlKSB7XG4gICAgdGhpcy5sID0gbFNpdGU7XG4gICAgdGhpcy5yID0gclNpdGU7XG4gICAgdGhpcy5hID0gdGhpcy5iID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxTaXRlLCByU2l0ZSwgdmEsIHZiKSB7XG4gICAgdmFyIGVkZ2UgPSBuZXcgZDNfZ2VvbV92b3Jvbm9pRWRnZShsU2l0ZSwgclNpdGUpO1xuICAgIGQzX2dlb21fdm9yb25vaUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgaWYgKHZhKSBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKGVkZ2UsIGxTaXRlLCByU2l0ZSwgdmEpO1xuICAgIGlmICh2YikgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChlZGdlLCByU2l0ZSwgbFNpdGUsIHZiKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDZWxsc1tsU2l0ZS5pXS5lZGdlcy5wdXNoKG5ldyBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShlZGdlLCBsU2l0ZSwgclNpdGUpKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDZWxsc1tyU2l0ZS5pXS5lZGdlcy5wdXNoKG5ldyBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShlZGdlLCByU2l0ZSwgbFNpdGUpKTtcbiAgICByZXR1cm4gZWRnZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCb3JkZXJFZGdlKGxTaXRlLCB2YSwgdmIpIHtcbiAgICB2YXIgZWRnZSA9IG5ldyBkM19nZW9tX3Zvcm9ub2lFZGdlKGxTaXRlLCBudWxsKTtcbiAgICBlZGdlLmEgPSB2YTtcbiAgICBlZGdlLmIgPSB2YjtcbiAgICBkM19nZW9tX3Zvcm9ub2lFZGdlcy5wdXNoKGVkZ2UpO1xuICAgIHJldHVybiBlZGdlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQoZWRnZSwgbFNpdGUsIHJTaXRlLCB2ZXJ0ZXgpIHtcbiAgICBpZiAoIWVkZ2UuYSAmJiAhZWRnZS5iKSB7XG4gICAgICBlZGdlLmEgPSB2ZXJ0ZXg7XG4gICAgICBlZGdlLmwgPSBsU2l0ZTtcbiAgICAgIGVkZ2UuciA9IHJTaXRlO1xuICAgIH0gZWxzZSBpZiAoZWRnZS5sID09PSByU2l0ZSkge1xuICAgICAgZWRnZS5iID0gdmVydGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGdlLmEgPSB2ZXJ0ZXg7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGVkZ2UsIGxTaXRlLCByU2l0ZSkge1xuICAgIHZhciB2YSA9IGVkZ2UuYSwgdmIgPSBlZGdlLmI7XG4gICAgdGhpcy5lZGdlID0gZWRnZTtcbiAgICB0aGlzLnNpdGUgPSBsU2l0ZTtcbiAgICB0aGlzLmFuZ2xlID0gclNpdGUgPyBNYXRoLmF0YW4yKHJTaXRlLnkgLSBsU2l0ZS55LCByU2l0ZS54IC0gbFNpdGUueCkgOiBlZGdlLmwgPT09IGxTaXRlID8gTWF0aC5hdGFuMih2Yi54IC0gdmEueCwgdmEueSAtIHZiLnkpIDogTWF0aC5hdGFuMih2YS54IC0gdmIueCwgdmIueSAtIHZhLnkpO1xuICB9XG4gIGQzX2dlb21fdm9yb25vaUhhbGZFZGdlLnByb3RvdHlwZSA9IHtcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlLmwgPT09IHRoaXMuc2l0ZSA/IHRoaXMuZWRnZS5hIDogdGhpcy5lZGdlLmI7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZS5sID09PSB0aGlzLnNpdGUgPyB0aGlzLmVkZ2UuYiA6IHRoaXMuZWRnZS5hO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlKCkge1xuICAgIHRoaXMuXyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKG5vZGUpIHtcbiAgICBub2RlLlUgPSBub2RlLkMgPSBub2RlLkwgPSBub2RlLlIgPSBub2RlLlAgPSBub2RlLk4gPSBudWxsO1xuICB9XG4gIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrVHJlZS5wcm90b3R5cGUgPSB7XG4gICAgaW5zZXJ0OiBmdW5jdGlvbihhZnRlciwgbm9kZSkge1xuICAgICAgdmFyIHBhcmVudCwgZ3JhbmRwYSwgdW5jbGU7XG4gICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgbm9kZS5QID0gYWZ0ZXI7XG4gICAgICAgIG5vZGUuTiA9IGFmdGVyLk47XG4gICAgICAgIGlmIChhZnRlci5OKSBhZnRlci5OLlAgPSBub2RlO1xuICAgICAgICBhZnRlci5OID0gbm9kZTtcbiAgICAgICAgaWYgKGFmdGVyLlIpIHtcbiAgICAgICAgICBhZnRlciA9IGFmdGVyLlI7XG4gICAgICAgICAgd2hpbGUgKGFmdGVyLkwpIGFmdGVyID0gYWZ0ZXIuTDtcbiAgICAgICAgICBhZnRlci5MID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZnRlci5SID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fKSB7XG4gICAgICAgIGFmdGVyID0gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tGaXJzdCh0aGlzLl8pO1xuICAgICAgICBub2RlLlAgPSBudWxsO1xuICAgICAgICBub2RlLk4gPSBhZnRlcjtcbiAgICAgICAgYWZ0ZXIuUCA9IGFmdGVyLkwgPSBub2RlO1xuICAgICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuUCA9IG5vZGUuTiA9IG51bGw7XG4gICAgICAgIHRoaXMuXyA9IG5vZGU7XG4gICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBub2RlLkwgPSBub2RlLlIgPSBudWxsO1xuICAgICAgbm9kZS5VID0gcGFyZW50O1xuICAgICAgbm9kZS5DID0gdHJ1ZTtcbiAgICAgIGFmdGVyID0gbm9kZTtcbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LkMpIHtcbiAgICAgICAgZ3JhbmRwYSA9IHBhcmVudC5VO1xuICAgICAgICBpZiAocGFyZW50ID09PSBncmFuZHBhLkwpIHtcbiAgICAgICAgICB1bmNsZSA9IGdyYW5kcGEuUjtcbiAgICAgICAgICBpZiAodW5jbGUgJiYgdW5jbGUuQykge1xuICAgICAgICAgICAgcGFyZW50LkMgPSB1bmNsZS5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBncmFuZHBhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5SKSB7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcbiAgICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5jbGUgPSBncmFuZHBhLkw7XG4gICAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFmdGVyID09PSBwYXJlbnQuTCkge1xuICAgICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgZ3JhbmRwYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICB9XG4gICAgICB0aGlzLl8uQyA9IGZhbHNlO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5OKSBub2RlLk4uUCA9IG5vZGUuUDtcbiAgICAgIGlmIChub2RlLlApIG5vZGUuUC5OID0gbm9kZS5OO1xuICAgICAgbm9kZS5OID0gbm9kZS5QID0gbnVsbDtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLlUsIHNpYmxpbmcsIGxlZnQgPSBub2RlLkwsIHJpZ2h0ID0gbm9kZS5SLCBuZXh0LCByZWQ7XG4gICAgICBpZiAoIWxlZnQpIG5leHQgPSByaWdodDsgZWxzZSBpZiAoIXJpZ2h0KSBuZXh0ID0gbGVmdDsgZWxzZSBuZXh0ID0gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tGaXJzdChyaWdodCk7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQuTCA9PT0gbm9kZSkgcGFyZW50LkwgPSBuZXh0OyBlbHNlIHBhcmVudC5SID0gbmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuXyA9IG5leHQ7XG4gICAgICB9XG4gICAgICBpZiAobGVmdCAmJiByaWdodCkge1xuICAgICAgICByZWQgPSBuZXh0LkM7XG4gICAgICAgIG5leHQuQyA9IG5vZGUuQztcbiAgICAgICAgbmV4dC5MID0gbGVmdDtcbiAgICAgICAgbGVmdC5VID0gbmV4dDtcbiAgICAgICAgaWYgKG5leHQgIT09IHJpZ2h0KSB7XG4gICAgICAgICAgcGFyZW50ID0gbmV4dC5VO1xuICAgICAgICAgIG5leHQuVSA9IG5vZGUuVTtcbiAgICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgICAgIHBhcmVudC5MID0gbm9kZTtcbiAgICAgICAgICBuZXh0LlIgPSByaWdodDtcbiAgICAgICAgICByaWdodC5VID0gbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0LlUgPSBwYXJlbnQ7XG4gICAgICAgICAgcGFyZW50ID0gbmV4dDtcbiAgICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWQgPSBub2RlLkM7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUpIG5vZGUuVSA9IHBhcmVudDtcbiAgICAgIGlmIChyZWQpIHJldHVybjtcbiAgICAgIGlmIChub2RlICYmIG5vZGUuQykge1xuICAgICAgICBub2RlLkMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG8ge1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5fKSBicmVhaztcbiAgICAgICAgaWYgKG5vZGUgPT09IHBhcmVudC5MKSB7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMgfHwgc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICBpZiAoIXNpYmxpbmcuUiB8fCAhc2libGluZy5SLkMpIHtcbiAgICAgICAgICAgICAgc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHNpYmxpbmcuUi5DID0gZmFsc2U7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2libGluZy5MICYmIHNpYmxpbmcuTC5DIHx8IHNpYmxpbmcuUiAmJiBzaWJsaW5nLlIuQykge1xuICAgICAgICAgICAgaWYgKCFzaWJsaW5nLkwgfHwgIXNpYmxpbmcuTC5DKSB7XG4gICAgICAgICAgICAgIHNpYmxpbmcuUi5DID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHNpYmxpbmcuTC5DID0gZmFsc2U7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5fO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5VO1xuICAgICAgfSB3aGlsZSAoIW5vZGUuQyk7XG4gICAgICBpZiAobm9kZSkgbm9kZS5DID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodHJlZSwgbm9kZSkge1xuICAgIHZhciBwID0gbm9kZSwgcSA9IG5vZGUuUiwgcGFyZW50ID0gcC5VO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuTCA9PT0gcCkgcGFyZW50LkwgPSBxOyBlbHNlIHBhcmVudC5SID0gcTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZS5fID0gcTtcbiAgICB9XG4gICAgcS5VID0gcGFyZW50O1xuICAgIHAuVSA9IHE7XG4gICAgcC5SID0gcS5MO1xuICAgIGlmIChwLlIpIHAuUi5VID0gcDtcbiAgICBxLkwgPSBwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodHJlZSwgbm9kZSkge1xuICAgIHZhciBwID0gbm9kZSwgcSA9IG5vZGUuTCwgcGFyZW50ID0gcC5VO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuTCA9PT0gcCkgcGFyZW50LkwgPSBxOyBlbHNlIHBhcmVudC5SID0gcTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZS5fID0gcTtcbiAgICB9XG4gICAgcS5VID0gcGFyZW50O1xuICAgIHAuVSA9IHE7XG4gICAgcC5MID0gcS5SO1xuICAgIGlmIChwLkwpIHAuTC5VID0gcDtcbiAgICBxLlIgPSBwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrRmlyc3Qobm9kZSkge1xuICAgIHdoaWxlIChub2RlLkwpIG5vZGUgPSBub2RlLkw7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pKHNpdGVzLCBiYm94KSB7XG4gICAgdmFyIHNpdGUgPSBzaXRlcy5zb3J0KGQzX2dlb21fdm9yb25vaVZlcnRleE9yZGVyKS5wb3AoKSwgeDAsIHkwLCBjaXJjbGU7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRWRnZXMgPSBbXTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDZWxscyA9IG5ldyBBcnJheShzaXRlcy5sZW5ndGgpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMgPSBuZXcgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlKCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcyA9IG5ldyBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY2lyY2xlID0gZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGU7XG4gICAgICBpZiAoc2l0ZSAmJiAoIWNpcmNsZSB8fCBzaXRlLnkgPCBjaXJjbGUueSB8fCBzaXRlLnkgPT09IGNpcmNsZS55ICYmIHNpdGUueCA8IGNpcmNsZS54KSkge1xuICAgICAgICBpZiAoc2l0ZS54ICE9PSB4MCB8fCBzaXRlLnkgIT09IHkwKSB7XG4gICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pQ2VsbHNbc2l0ZS5pXSA9IG5ldyBkM19nZW9tX3Zvcm9ub2lDZWxsKHNpdGUpO1xuICAgICAgICAgIGQzX2dlb21fdm9yb25vaUFkZEJlYWNoKHNpdGUpO1xuICAgICAgICAgIHgwID0gc2l0ZS54LCB5MCA9IHNpdGUueTtcbiAgICAgICAgfVxuICAgICAgICBzaXRlID0gc2l0ZXMucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKGNpcmNsZSkge1xuICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZW1vdmVCZWFjaChjaXJjbGUuYXJjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmJveCkgZDNfZ2VvbV92b3Jvbm9pQ2xpcEVkZ2VzKGJib3gpLCBkM19nZW9tX3Zvcm9ub2lDbG9zZUNlbGxzKGJib3gpO1xuICAgIHZhciBkaWFncmFtID0ge1xuICAgICAgY2VsbHM6IGQzX2dlb21fdm9yb25vaUNlbGxzLFxuICAgICAgZWRnZXM6IGQzX2dlb21fdm9yb25vaUVkZ2VzXG4gICAgfTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzID0gZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcyA9IGQzX2dlb21fdm9yb25vaUVkZ2VzID0gZDNfZ2VvbV92b3Jvbm9pQ2VsbHMgPSBudWxsO1xuICAgIHJldHVybiBkaWFncmFtO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVZlcnRleE9yZGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYi55IC0gYS55IHx8IGIueCAtIGEueDtcbiAgfVxuICBkMy5nZW9tLnZvcm9ub2kgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFksIGZ4ID0geCwgZnkgPSB5LCBjbGlwRXh0ZW50ID0gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudDtcbiAgICBpZiAocG9pbnRzKSByZXR1cm4gdm9yb25vaShwb2ludHMpO1xuICAgIGZ1bmN0aW9uIHZvcm9ub2koZGF0YSkge1xuICAgICAgdmFyIHBvbHlnb25zID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKSwgeDAgPSBjbGlwRXh0ZW50WzBdWzBdLCB5MCA9IGNsaXBFeHRlbnRbMF1bMV0sIHgxID0gY2xpcEV4dGVudFsxXVswXSwgeTEgPSBjbGlwRXh0ZW50WzFdWzFdO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pKHNpdGVzKGRhdGEpLCBjbGlwRXh0ZW50KS5jZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGkpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gY2VsbC5lZGdlcywgc2l0ZSA9IGNlbGwuc2l0ZSwgcG9seWdvbiA9IHBvbHlnb25zW2ldID0gZWRnZXMubGVuZ3RoID8gZWRnZXMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgcyA9IGUuc3RhcnQoKTtcbiAgICAgICAgICByZXR1cm4gWyBzLngsIHMueSBdO1xuICAgICAgICB9KSA6IHNpdGUueCA+PSB4MCAmJiBzaXRlLnggPD0geDEgJiYgc2l0ZS55ID49IHkwICYmIHNpdGUueSA8PSB5MSA/IFsgWyB4MCwgeTEgXSwgWyB4MSwgeTEgXSwgWyB4MSwgeTAgXSwgWyB4MCwgeTAgXSBdIDogW107XG4gICAgICAgIHBvbHlnb24ucG9pbnQgPSBkYXRhW2ldO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcG9seWdvbnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpdGVzKGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZChmeChkLCBpKSAvIM61KSAqIM61LFxuICAgICAgICAgIHk6IE1hdGgucm91bmQoZnkoZCwgaSkgLyDOtSkgKiDOtSxcbiAgICAgICAgICBpOiBpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgdm9yb25vaS5saW5rcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkM19nZW9tX3Zvcm9ub2koc2l0ZXMoZGF0YSkpLmVkZ2VzLmZpbHRlcihmdW5jdGlvbihlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLmwgJiYgZWRnZS5yO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IGRhdGFbZWRnZS5sLmldLFxuICAgICAgICAgIHRhcmdldDogZGF0YVtlZGdlLnIuaV1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdm9yb25vaS50cmlhbmdsZXMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgdHJpYW5nbGVzID0gW107XG4gICAgICBkM19nZW9tX3Zvcm9ub2koc2l0ZXMoZGF0YSkpLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaSkge1xuICAgICAgICB2YXIgc2l0ZSA9IGNlbGwuc2l0ZSwgZWRnZXMgPSBjZWxsLmVkZ2VzLnNvcnQoZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2VPcmRlciksIGogPSAtMSwgbSA9IGVkZ2VzLmxlbmd0aCwgZTAsIHMwLCBlMSA9IGVkZ2VzW20gLSAxXS5lZGdlLCBzMSA9IGUxLmwgPT09IHNpdGUgPyBlMS5yIDogZTEubDtcbiAgICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgICBlMCA9IGUxO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgZTEgPSBlZGdlc1tqXS5lZGdlO1xuICAgICAgICAgIHMxID0gZTEubCA9PT0gc2l0ZSA/IGUxLnIgOiBlMS5sO1xuICAgICAgICAgIGlmIChpIDwgczAuaSAmJiBpIDwgczEuaSAmJiBkM19nZW9tX3Zvcm9ub2lUcmlhbmdsZUFyZWEoc2l0ZSwgczAsIHMxKSA8IDApIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKFsgZGF0YVtpXSwgZGF0YVtzMC5pXSwgZGF0YVtzMS5pXSBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRyaWFuZ2xlcztcbiAgICB9O1xuICAgIHZvcm9ub2kueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZ4ID0gZDNfZnVuY3Rvcih4ID0gXyksIHZvcm9ub2kpIDogeDtcbiAgICB9O1xuICAgIHZvcm9ub2kueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZ5ID0gZDNfZnVuY3Rvcih5ID0gXyksIHZvcm9ub2kpIDogeTtcbiAgICB9O1xuICAgIHZvcm9ub2kuY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBFeHRlbnQgPT09IGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQgPyBudWxsIDogY2xpcEV4dGVudDtcbiAgICAgIGNsaXBFeHRlbnQgPSBfID09IG51bGwgPyBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50IDogXztcbiAgICAgIHJldHVybiB2b3Jvbm9pO1xuICAgIH07XG4gICAgdm9yb25vaS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEV4dGVudCA9PT0gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA/IG51bGwgOiBjbGlwRXh0ZW50ICYmIGNsaXBFeHRlbnRbMV07XG4gICAgICByZXR1cm4gdm9yb25vaS5jbGlwRXh0ZW50KF8gJiYgWyBbIDAsIDAgXSwgXyBdKTtcbiAgICB9O1xuICAgIHJldHVybiB2b3Jvbm9pO1xuICB9O1xuICB2YXIgZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA9IFsgWyAtMWU2LCAtMWU2IF0sIFsgMWU2LCAxZTYgXSBdO1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lUcmlhbmdsZUFyZWEoYSwgYiwgYykge1xuICAgIHJldHVybiAoYS54IC0gYy54KSAqIChiLnkgLSBhLnkpIC0gKGEueCAtIGIueCkgKiAoYy55IC0gYS55KTtcbiAgfVxuICBkMy5nZW9tLmRlbGF1bmF5ID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICByZXR1cm4gZDMuZ2VvbS52b3Jvbm9pKCkudHJpYW5nbGVzKHZlcnRpY2VzKTtcbiAgfTtcbiAgZDMuZ2VvbS5xdWFkdHJlZSA9IGZ1bmN0aW9uKHBvaW50cywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFksIGNvbXBhdDtcbiAgICBpZiAoY29tcGF0ID0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgeCA9IGQzX2dlb21fcXVhZHRyZWVDb21wYXRYO1xuICAgICAgeSA9IGQzX2dlb21fcXVhZHRyZWVDb21wYXRZO1xuICAgICAgaWYgKGNvbXBhdCA9PT0gMykge1xuICAgICAgICB5MiA9IHkxO1xuICAgICAgICB4MiA9IHgxO1xuICAgICAgICB5MSA9IHgxID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBxdWFkdHJlZShwb2ludHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWFkdHJlZShkYXRhKSB7XG4gICAgICB2YXIgZCwgZnggPSBkM19mdW5jdG9yKHgpLCBmeSA9IGQzX2Z1bmN0b3IoeSksIHhzLCB5cywgaSwgbiwgeDFfLCB5MV8sIHgyXywgeTJfO1xuICAgICAgaWYgKHgxICE9IG51bGwpIHtcbiAgICAgICAgeDFfID0geDEsIHkxXyA9IHkxLCB4Ml8gPSB4MiwgeTJfID0geTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4Ml8gPSB5Ml8gPSAtKHgxXyA9IHkxXyA9IEluZmluaXR5KTtcbiAgICAgICAgeHMgPSBbXSwgeXMgPSBbXTtcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoY29tcGF0KSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgZCA9IGRhdGFbaV07XG4gICAgICAgICAgaWYgKGQueCA8IHgxXykgeDFfID0gZC54O1xuICAgICAgICAgIGlmIChkLnkgPCB5MV8pIHkxXyA9IGQueTtcbiAgICAgICAgICBpZiAoZC54ID4geDJfKSB4Ml8gPSBkLng7XG4gICAgICAgICAgaWYgKGQueSA+IHkyXykgeTJfID0gZC55O1xuICAgICAgICAgIHhzLnB1c2goZC54KTtcbiAgICAgICAgICB5cy5wdXNoKGQueSk7XG4gICAgICAgIH0gZWxzZSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgdmFyIHhfID0gK2Z4KGQgPSBkYXRhW2ldLCBpKSwgeV8gPSArZnkoZCwgaSk7XG4gICAgICAgICAgaWYgKHhfIDwgeDFfKSB4MV8gPSB4XztcbiAgICAgICAgICBpZiAoeV8gPCB5MV8pIHkxXyA9IHlfO1xuICAgICAgICAgIGlmICh4XyA+IHgyXykgeDJfID0geF87XG4gICAgICAgICAgaWYgKHlfID4geTJfKSB5Ml8gPSB5XztcbiAgICAgICAgICB4cy5wdXNoKHhfKTtcbiAgICAgICAgICB5cy5wdXNoKHlfKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGR4ID0geDJfIC0geDFfLCBkeSA9IHkyXyAtIHkxXztcbiAgICAgIGlmIChkeCA+IGR5KSB5Ml8gPSB5MV8gKyBkeDsgZWxzZSB4Ml8gPSB4MV8gKyBkeTtcbiAgICAgIGZ1bmN0aW9uIGluc2VydChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybjtcbiAgICAgICAgaWYgKG4ubGVhZikge1xuICAgICAgICAgIHZhciBueCA9IG4ueCwgbnkgPSBuLnk7XG4gICAgICAgICAgaWYgKG54ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChhYnMobnggLSB4KSArIGFicyhueSAtIHkpIDwgLjAxKSB7XG4gICAgICAgICAgICAgIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBuUG9pbnQgPSBuLnBvaW50O1xuICAgICAgICAgICAgICBuLnggPSBuLnkgPSBuLnBvaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgblBvaW50LCBueCwgbnksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuLnggPSB4LCBuLnkgPSB5LCBuLnBvaW50ID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgeG0gPSAoeDEgKyB4MikgKiAuNSwgeW0gPSAoeTEgKyB5MikgKiAuNSwgcmlnaHQgPSB4ID49IHhtLCBiZWxvdyA9IHkgPj0geW0sIGkgPSBiZWxvdyA8PCAxIHwgcmlnaHQ7XG4gICAgICAgIG4ubGVhZiA9IGZhbHNlO1xuICAgICAgICBuID0gbi5ub2Rlc1tpXSB8fCAobi5ub2Rlc1tpXSA9IGQzX2dlb21fcXVhZHRyZWVOb2RlKCkpO1xuICAgICAgICBpZiAocmlnaHQpIHgxID0geG07IGVsc2UgeDIgPSB4bTtcbiAgICAgICAgaWYgKGJlbG93KSB5MSA9IHltOyBlbHNlIHkyID0geW07XG4gICAgICAgIGluc2VydChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICB9XG4gICAgICB2YXIgcm9vdCA9IGQzX2dlb21fcXVhZHRyZWVOb2RlKCk7XG4gICAgICByb290LmFkZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgaW5zZXJ0KHJvb3QsIGQsICtmeChkLCArK2kpLCArZnkoZCwgaSksIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICB9O1xuICAgICAgcm9vdC52aXNpdCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIHJvb3QsIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICB9O1xuICAgICAgcm9vdC5maW5kID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGQzX2dlb21fcXVhZHRyZWVGaW5kKHJvb3QsIHBvaW50WzBdLCBwb2ludFsxXSwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgIH07XG4gICAgICBpID0gLTE7XG4gICAgICBpZiAoeDEgPT0gbnVsbCkge1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIGluc2VydChyb290LCBkYXRhW2ldLCB4c1tpXSwgeXNbaV0sIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICAgIH1cbiAgICAgICAgLS1pO1xuICAgICAgfSBlbHNlIGRhdGEuZm9yRWFjaChyb290LmFkZCk7XG4gICAgICB4cyA9IHlzID0gZGF0YSA9IGQgPSBudWxsO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHF1YWR0cmVlLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gXywgcXVhZHRyZWUpIDogeDtcbiAgICB9O1xuICAgIHF1YWR0cmVlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gXywgcXVhZHRyZWUpIDogeTtcbiAgICB9O1xuICAgIHF1YWR0cmVlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxID09IG51bGwgPyBudWxsIDogWyBbIHgxLCB5MSBdLCBbIHgyLCB5MiBdIF07XG4gICAgICBpZiAoXyA9PSBudWxsKSB4MSA9IHkxID0geDIgPSB5MiA9IG51bGw7IGVsc2UgeDEgPSArX1swXVswXSwgeTEgPSArX1swXVsxXSwgeDIgPSArX1sxXVswXSwgXG4gICAgICB5MiA9ICtfWzFdWzFdO1xuICAgICAgcmV0dXJuIHF1YWR0cmVlO1xuICAgIH07XG4gICAgcXVhZHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxID09IG51bGwgPyBudWxsIDogWyB4MiAtIHgxLCB5MiAtIHkxIF07XG4gICAgICBpZiAoXyA9PSBudWxsKSB4MSA9IHkxID0geDIgPSB5MiA9IG51bGw7IGVsc2UgeDEgPSB5MSA9IDAsIHgyID0gK19bMF0sIHkyID0gK19bMV07XG4gICAgICByZXR1cm4gcXVhZHRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gcXVhZHRyZWU7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVDb21wYXRYKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVDb21wYXRZKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVOb2RlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWFmOiB0cnVlLFxuICAgICAgbm9kZXM6IFtdLFxuICAgICAgcG9pbnQ6IG51bGwsXG4gICAgICB4OiBudWxsLFxuICAgICAgeTogbnVsbFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIG5vZGUsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgaWYgKCFmKG5vZGUsIHgxLCB5MSwgeDIsIHkyKSkge1xuICAgICAgdmFyIHN4ID0gKHgxICsgeDIpICogLjUsIHN5ID0gKHkxICsgeTIpICogLjUsIGNoaWxkcmVuID0gbm9kZS5ub2RlcztcbiAgICAgIGlmIChjaGlsZHJlblswXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzBdLCB4MSwgeTEsIHN4LCBzeSk7XG4gICAgICBpZiAoY2hpbGRyZW5bMV0pIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBjaGlsZHJlblsxXSwgc3gsIHkxLCB4Miwgc3kpO1xuICAgICAgaWYgKGNoaWxkcmVuWzJdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bMl0sIHgxLCBzeSwgc3gsIHkyKTtcbiAgICAgIGlmIChjaGlsZHJlblszXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzNdLCBzeCwgc3ksIHgyLCB5Mik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVGaW5kKHJvb3QsIHgsIHksIHgwLCB5MCwgeDMsIHkzKSB7XG4gICAgdmFyIG1pbkRpc3RhbmNlMiA9IEluZmluaXR5LCBjbG9zZXN0UG9pbnQ7XG4gICAgKGZ1bmN0aW9uIGZpbmQobm9kZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIGlmICh4MSA+IHgzIHx8IHkxID4geTMgfHwgeDIgPCB4MCB8fCB5MiA8IHkwKSByZXR1cm47XG4gICAgICBpZiAocG9pbnQgPSBub2RlLnBvaW50KSB7XG4gICAgICAgIHZhciBwb2ludCwgZHggPSB4IC0gbm9kZS54LCBkeSA9IHkgLSBub2RlLnksIGRpc3RhbmNlMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBpZiAoZGlzdGFuY2UyIDwgbWluRGlzdGFuY2UyKSB7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlMiA9IGRpc3RhbmNlMik7XG4gICAgICAgICAgeDAgPSB4IC0gZGlzdGFuY2UsIHkwID0geSAtIGRpc3RhbmNlO1xuICAgICAgICAgIHgzID0geCArIGRpc3RhbmNlLCB5MyA9IHkgKyBkaXN0YW5jZTtcbiAgICAgICAgICBjbG9zZXN0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5ub2RlcywgeG0gPSAoeDEgKyB4MikgKiAuNSwgeW0gPSAoeTEgKyB5MikgKiAuNSwgcmlnaHQgPSB4ID49IHhtLCBiZWxvdyA9IHkgPj0geW07XG4gICAgICBmb3IgKHZhciBpID0gYmVsb3cgPDwgMSB8IHJpZ2h0LCBqID0gaSArIDQ7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgaWYgKG5vZGUgPSBjaGlsZHJlbltpICYgM10pIHN3aXRjaCAoaSAmIDMpIHtcbiAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBmaW5kKG5vZGUsIHgxLCB5MSwgeG0sIHltKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGZpbmQobm9kZSwgeG0sIHkxLCB4MiwgeW0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZmluZChub2RlLCB4MSwgeW0sIHhtLCB5Mik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmaW5kKG5vZGUsIHhtLCB5bSwgeDIsIHkyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKHJvb3QsIHgwLCB5MCwgeDMsIHkzKTtcbiAgICByZXR1cm4gY2xvc2VzdFBvaW50O1xuICB9XG4gIGQzLmludGVycG9sYXRlUmdiID0gZDNfaW50ZXJwb2xhdGVSZ2I7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlUmdiKGEsIGIpIHtcbiAgICBhID0gZDMucmdiKGEpO1xuICAgIGIgPSBkMy5yZ2IoYik7XG4gICAgdmFyIGFyID0gYS5yLCBhZyA9IGEuZywgYWIgPSBhLmIsIGJyID0gYi5yIC0gYXIsIGJnID0gYi5nIC0gYWcsIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBcIiNcIiArIGQzX3JnYl9oZXgoTWF0aC5yb3VuZChhciArIGJyICogdCkpICsgZDNfcmdiX2hleChNYXRoLnJvdW5kKGFnICsgYmcgKiB0KSkgKyBkM19yZ2JfaGV4KE1hdGgucm91bmQoYWIgKyBiYiAqIHQpKTtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlT2JqZWN0ID0gZDNfaW50ZXJwb2xhdGVPYmplY3Q7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlT2JqZWN0KGEsIGIpIHtcbiAgICB2YXIgaSA9IHt9LCBjID0ge30sIGs7XG4gICAgZm9yIChrIGluIGEpIHtcbiAgICAgIGlmIChrIGluIGIpIHtcbiAgICAgICAgaVtrXSA9IGQzX2ludGVycG9sYXRlKGFba10sIGJba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY1trXSA9IGFba107XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayBpbiBiKSB7XG4gICAgICBpZiAoIShrIGluIGEpKSB7XG4gICAgICAgIGNba10gPSBiW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgZm9yIChrIGluIGkpIGNba10gPSBpW2tdKHQpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZU51bWJlciA9IGQzX2ludGVycG9sYXRlTnVtYmVyO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZU51bWJlcihhLCBiKSB7XG4gICAgYSA9ICthLCBiID0gK2I7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVTdHJpbmcgPSBkM19pbnRlcnBvbGF0ZVN0cmluZztcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVTdHJpbmcoYSwgYikge1xuICAgIHZhciBiaSA9IGQzX2ludGVycG9sYXRlX251bWJlckEubGFzdEluZGV4ID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQi5sYXN0SW5kZXggPSAwLCBhbSwgYm0sIGJzLCBpID0gLTEsIHMgPSBbXSwgcSA9IFtdO1xuICAgIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuICAgIHdoaWxlICgoYW0gPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJBLmV4ZWMoYSkpICYmIChibSA9IGQzX2ludGVycG9sYXRlX251bWJlckIuZXhlYyhiKSkpIHtcbiAgICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkge1xuICAgICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IGVsc2Ugc1srK2ldID0gYnM7XG4gICAgICB9XG4gICAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHtcbiAgICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IGVsc2Ugc1srK2ldID0gYm07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzWysraV0gPSBudWxsO1xuICAgICAgICBxLnB1c2goe1xuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIoYW0sIGJtKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJpID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQi5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIHJldHVybiBzLmxlbmd0aCA8IDIgPyBxWzBdID8gKGIgPSBxWzBdLngsIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgICB9KSA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH0pO1xuICB9XG4gIHZhciBkM19pbnRlcnBvbGF0ZV9udW1iZXJBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLCBkM19pbnRlcnBvbGF0ZV9udW1iZXJCID0gbmV3IFJlZ0V4cChkM19pbnRlcnBvbGF0ZV9udW1iZXJBLnNvdXJjZSwgXCJnXCIpO1xuICBkMy5pbnRlcnBvbGF0ZSA9IGQzX2ludGVycG9sYXRlO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgdmFyIGkgPSBkMy5pbnRlcnBvbGF0b3JzLmxlbmd0aCwgZjtcbiAgICB3aGlsZSAoLS1pID49IDAgJiYgIShmID0gZDMuaW50ZXJwb2xhdG9yc1tpXShhLCBiKSkpIDtcbiAgICByZXR1cm4gZjtcbiAgfVxuICBkMy5pbnRlcnBvbGF0b3JzID0gWyBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgYjtcbiAgICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBkM19yZ2JfbmFtZXMuaGFzKGIudG9Mb3dlckNhc2UoKSkgfHwgL14oI3xyZ2JcXCh8aHNsXFwoKS9pLnRlc3QoYikgPyBkM19pbnRlcnBvbGF0ZVJnYiA6IGQzX2ludGVycG9sYXRlU3RyaW5nIDogYiBpbnN0YW5jZW9mIGQzX2NvbG9yID8gZDNfaW50ZXJwb2xhdGVSZ2IgOiBBcnJheS5pc0FycmF5KGIpID8gZDNfaW50ZXJwb2xhdGVBcnJheSA6IHQgPT09IFwib2JqZWN0XCIgJiYgaXNOYU4oYikgPyBkM19pbnRlcnBvbGF0ZU9iamVjdCA6IGQzX2ludGVycG9sYXRlTnVtYmVyKShhLCBiKTtcbiAgfSBdO1xuICBkMy5pbnRlcnBvbGF0ZUFycmF5ID0gZDNfaW50ZXJwb2xhdGVBcnJheTtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVBcnJheShhLCBiKSB7XG4gICAgdmFyIHggPSBbXSwgYyA9IFtdLCBuYSA9IGEubGVuZ3RoLCBuYiA9IGIubGVuZ3RoLCBuMCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCksIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG4wOyArK2kpIHgucHVzaChkM19pbnRlcnBvbGF0ZShhW2ldLCBiW2ldKSk7XG4gICAgZm9yICg7aSA8IG5hOyArK2kpIGNbaV0gPSBhW2ldO1xuICAgIGZvciAoO2kgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IG4wOyArK2kpIGNbaV0gPSB4W2ldKHQpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZWFzZV9kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2lkZW50aXR5O1xuICB9O1xuICB2YXIgZDNfZWFzZSA9IGQzLm1hcCh7XG4gICAgbGluZWFyOiBkM19lYXNlX2RlZmF1bHQsXG4gICAgcG9seTogZDNfZWFzZV9wb2x5LFxuICAgIHF1YWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfcXVhZDtcbiAgICB9LFxuICAgIGN1YmljOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX2N1YmljO1xuICAgIH0sXG4gICAgc2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX3NpbjtcbiAgICB9LFxuICAgIGV4cDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9leHA7XG4gICAgfSxcbiAgICBjaXJjbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfY2lyY2xlO1xuICAgIH0sXG4gICAgZWxhc3RpYzogZDNfZWFzZV9lbGFzdGljLFxuICAgIGJhY2s6IGQzX2Vhc2VfYmFjayxcbiAgICBib3VuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfYm91bmNlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBkM19lYXNlX21vZGUgPSBkMy5tYXAoe1xuICAgIFwiaW5cIjogZDNfaWRlbnRpdHksXG4gICAgb3V0OiBkM19lYXNlX3JldmVyc2UsXG4gICAgXCJpbi1vdXRcIjogZDNfZWFzZV9yZWZsZWN0LFxuICAgIFwib3V0LWluXCI6IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX3JlZmxlY3QoZDNfZWFzZV9yZXZlcnNlKGYpKTtcbiAgICB9XG4gIH0pO1xuICBkMy5lYXNlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gbmFtZS5pbmRleE9mKFwiLVwiKSwgdCA9IGkgPj0gMCA/IG5hbWUuc2xpY2UoMCwgaSkgOiBuYW1lLCBtID0gaSA+PSAwID8gbmFtZS5zbGljZShpICsgMSkgOiBcImluXCI7XG4gICAgdCA9IGQzX2Vhc2UuZ2V0KHQpIHx8IGQzX2Vhc2VfZGVmYXVsdDtcbiAgICBtID0gZDNfZWFzZV9tb2RlLmdldChtKSB8fCBkM19pZGVudGl0eTtcbiAgICByZXR1cm4gZDNfZWFzZV9jbGFtcChtKHQuYXBwbHkobnVsbCwgZDNfYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfY2xhbXAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdCA8PSAwID8gMCA6IHQgPj0gMSA/IDEgOiBmKHQpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9yZXZlcnNlKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIDEgLSBmKDEgLSB0KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfcmVmbGVjdChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAuNSAqICh0IDwgLjUgPyBmKDIgKiB0KSA6IDIgLSBmKDIgLSAyICogdCkpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9xdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9jdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2N1YmljSW5PdXQodCkge1xuICAgIGlmICh0IDw9IDApIHJldHVybiAwO1xuICAgIGlmICh0ID49IDEpIHJldHVybiAxO1xuICAgIHZhciB0MiA9IHQgKiB0LCB0MyA9IHQyICogdDtcbiAgICByZXR1cm4gNCAqICh0IDwgLjUgPyB0MyA6IDMgKiAodCAtIHQyKSArIHQzIC0gLjc1KTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3BvbHkoZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3codCwgZSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3Npbih0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZs+AKTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2V4cCh0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9jaXJjbGUodCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9lbGFzdGljKGEsIHApIHtcbiAgICB2YXIgcztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHAgPSAuNDU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHMgPSBwIC8gz4QgKiBNYXRoLmFzaW4oMSAvIGEpOyBlbHNlIGEgPSAxLCBzID0gcCAvIDQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAxICsgYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIM+EIC8gcCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2JhY2socykge1xuICAgIGlmICghcykgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9ib3VuY2UodCkge1xuICAgIHJldHVybiB0IDwgMSAvIDIuNzUgPyA3LjU2MjUgKiB0ICogdCA6IHQgPCAyIC8gMi43NSA/IDcuNTYyNSAqICh0IC09IDEuNSAvIDIuNzUpICogdCArIC43NSA6IHQgPCAyLjUgLyAyLjc1ID8gNy41NjI1ICogKHQgLT0gMi4yNSAvIDIuNzUpICogdCArIC45Mzc1IDogNy41NjI1ICogKHQgLT0gMi42MjUgLyAyLjc1KSAqIHQgKyAuOTg0Mzc1O1xuICB9XG4gIGQzLmludGVycG9sYXRlSGNsID0gZDNfaW50ZXJwb2xhdGVIY2w7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlSGNsKGEsIGIpIHtcbiAgICBhID0gZDMuaGNsKGEpO1xuICAgIGIgPSBkMy5oY2woYik7XG4gICAgdmFyIGFoID0gYS5oLCBhYyA9IGEuYywgYWwgPSBhLmwsIGJoID0gYi5oIC0gYWgsIGJjID0gYi5jIC0gYWMsIGJsID0gYi5sIC0gYWw7XG4gICAgaWYgKGlzTmFOKGJjKSkgYmMgPSAwLCBhYyA9IGlzTmFOKGFjKSA/IGIuYyA6IGFjO1xuICAgIGlmIChpc05hTihiaCkpIGJoID0gMCwgYWggPSBpc05hTihhaCkgPyBiLmggOiBhaDsgZWxzZSBpZiAoYmggPiAxODApIGJoIC09IDM2MDsgZWxzZSBpZiAoYmggPCAtMTgwKSBiaCArPSAzNjA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19oY2xfbGFiKGFoICsgYmggKiB0LCBhYyArIGJjICogdCwgYWwgKyBibCAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlSHNsID0gZDNfaW50ZXJwb2xhdGVIc2w7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlSHNsKGEsIGIpIHtcbiAgICBhID0gZDMuaHNsKGEpO1xuICAgIGIgPSBkMy5oc2woYik7XG4gICAgdmFyIGFoID0gYS5oLCBhcyA9IGEucywgYWwgPSBhLmwsIGJoID0gYi5oIC0gYWgsIGJzID0gYi5zIC0gYXMsIGJsID0gYi5sIC0gYWw7XG4gICAgaWYgKGlzTmFOKGJzKSkgYnMgPSAwLCBhcyA9IGlzTmFOKGFzKSA/IGIucyA6IGFzO1xuICAgIGlmIChpc05hTihiaCkpIGJoID0gMCwgYWggPSBpc05hTihhaCkgPyBiLmggOiBhaDsgZWxzZSBpZiAoYmggPiAxODApIGJoIC09IDM2MDsgZWxzZSBpZiAoYmggPCAtMTgwKSBiaCArPSAzNjA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19oc2xfcmdiKGFoICsgYmggKiB0LCBhcyArIGJzICogdCwgYWwgKyBibCAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlTGFiID0gZDNfaW50ZXJwb2xhdGVMYWI7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlTGFiKGEsIGIpIHtcbiAgICBhID0gZDMubGFiKGEpO1xuICAgIGIgPSBkMy5sYWIoYik7XG4gICAgdmFyIGFsID0gYS5sLCBhYSA9IGEuYSwgYWIgPSBhLmIsIGJsID0gYi5sIC0gYWwsIGJhID0gYi5hIC0gYWEsIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19sYWJfcmdiKGFsICsgYmwgKiB0LCBhYSArIGJhICogdCwgYWIgKyBiYiAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlUm91bmQgPSBkM19pbnRlcnBvbGF0ZVJvdW5kO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVJvdW5kKGEsIGIpIHtcbiAgICBiIC09IGE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKyBiICogdCk7XG4gICAgfTtcbiAgfVxuICBkMy50cmFuc2Zvcm0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZyA9IGQzX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhkMy5ucy5wcmVmaXguc3ZnLCBcImdcIik7XG4gICAgcmV0dXJuIChkMy50cmFuc2Zvcm0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmcgIT0gbnVsbCkge1xuICAgICAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBzdHJpbmcpO1xuICAgICAgICB2YXIgdCA9IGcudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZDNfdHJhbnNmb3JtKHQgPyB0Lm1hdHJpeCA6IGQzX3RyYW5zZm9ybUlkZW50aXR5KTtcbiAgICB9KShzdHJpbmcpO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2Zvcm0obSkge1xuICAgIHZhciByMCA9IFsgbS5hLCBtLmIgXSwgcjEgPSBbIG0uYywgbS5kIF0sIGt4ID0gZDNfdHJhbnNmb3JtTm9ybWFsaXplKHIwKSwga3ogPSBkM190cmFuc2Zvcm1Eb3QocjAsIHIxKSwga3kgPSBkM190cmFuc2Zvcm1Ob3JtYWxpemUoZDNfdHJhbnNmb3JtQ29tYmluZShyMSwgcjAsIC1reikpIHx8IDA7XG4gICAgaWYgKHIwWzBdICogcjFbMV0gPCByMVswXSAqIHIwWzFdKSB7XG4gICAgICByMFswXSAqPSAtMTtcbiAgICAgIHIwWzFdICo9IC0xO1xuICAgICAga3ggKj0gLTE7XG4gICAgICBreiAqPSAtMTtcbiAgICB9XG4gICAgdGhpcy5yb3RhdGUgPSAoa3ggPyBNYXRoLmF0YW4yKHIwWzFdLCByMFswXSkgOiBNYXRoLmF0YW4yKC1yMVswXSwgcjFbMV0pKSAqIGQzX2RlZ3JlZXM7XG4gICAgdGhpcy50cmFuc2xhdGUgPSBbIG0uZSwgbS5mIF07XG4gICAgdGhpcy5zY2FsZSA9IFsga3gsIGt5IF07XG4gICAgdGhpcy5za2V3ID0ga3kgPyBNYXRoLmF0YW4yKGt6LCBreSkgKiBkM19kZWdyZWVzIDogMDtcbiAgfVxuICBkM190cmFuc2Zvcm0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy50cmFuc2xhdGUgKyBcIilyb3RhdGUoXCIgKyB0aGlzLnJvdGF0ZSArIFwiKXNrZXdYKFwiICsgdGhpcy5za2V3ICsgXCIpc2NhbGUoXCIgKyB0aGlzLnNjYWxlICsgXCIpXCI7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybURvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJhbnNmb3JtTm9ybWFsaXplKGEpIHtcbiAgICB2YXIgayA9IE1hdGguc3FydChkM190cmFuc2Zvcm1Eb3QoYSwgYSkpO1xuICAgIGlmIChrKSB7XG4gICAgICBhWzBdIC89IGs7XG4gICAgICBhWzFdIC89IGs7XG4gICAgfVxuICAgIHJldHVybiBrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybUNvbWJpbmUoYSwgYiwgaykge1xuICAgIGFbMF0gKz0gayAqIGJbMF07XG4gICAgYVsxXSArPSBrICogYlsxXTtcbiAgICByZXR1cm4gYTtcbiAgfVxuICB2YXIgZDNfdHJhbnNmb3JtSWRlbnRpdHkgPSB7XG4gICAgYTogMSxcbiAgICBiOiAwLFxuICAgIGM6IDAsXG4gICAgZDogMSxcbiAgICBlOiAwLFxuICAgIGY6IDBcbiAgfTtcbiAgZDMuaW50ZXJwb2xhdGVUcmFuc2Zvcm0gPSBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybTtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIixcIiA6IFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVUcmFuc2xhdGUodGEsIHRiLCBzLCBxKSB7XG4gICAgaWYgKHRhWzBdICE9PSB0YlswXSB8fCB0YVsxXSAhPT0gdGJbMV0pIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogaSAtIDQsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHRhWzBdLCB0YlswXSlcbiAgICAgIH0sIHtcbiAgICAgICAgaTogaSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHRhWzFdLCB0YlsxXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGJbMF0gfHwgdGJbMV0pIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHRiICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVJvdGF0ZShyYSwgcmIsIHMsIHEpIHtcbiAgICBpZiAocmEgIT09IHJiKSB7XG4gICAgICBpZiAocmEgLSByYiA+IDE4MCkgcmIgKz0gMzYwOyBlbHNlIGlmIChyYiAtIHJhID4gMTgwKSByYSArPSAzNjA7XG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgXCIpXCIpIC0gMixcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIocmEsIHJiKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChyYikge1xuICAgICAgcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJyb3RhdGUoXCIgKyByYiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVTa2V3KHdhLCB3YiwgcywgcSkge1xuICAgIGlmICh3YSAhPT0gd2IpIHtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2tld1goXCIsIG51bGwsIFwiKVwiKSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHdhLCB3YilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAod2IpIHtcbiAgICAgIHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2tld1goXCIgKyB3YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVTY2FsZShrYSwga2IsIHMsIHEpIHtcbiAgICBpZiAoa2FbMF0gIT09IGtiWzBdIHx8IGthWzFdICE9PSBrYlsxXSkge1xuICAgICAgdmFyIGkgPSBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogaSAtIDQsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKGthWzBdLCBrYlswXSlcbiAgICAgIH0sIHtcbiAgICAgICAgaTogaSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKGthWzFdLCBrYlsxXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoa2JbMF0gIT09IDEgfHwga2JbMV0gIT09IDEpIHtcbiAgICAgIHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2NhbGUoXCIgKyBrYiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm0oYSwgYikge1xuICAgIHZhciBzID0gW10sIHEgPSBbXTtcbiAgICBhID0gZDMudHJhbnNmb3JtKGEpLCBiID0gZDMudHJhbnNmb3JtKGIpO1xuICAgIGQzX2ludGVycG9sYXRlVHJhbnNsYXRlKGEudHJhbnNsYXRlLCBiLnRyYW5zbGF0ZSwgcywgcSk7XG4gICAgZDNfaW50ZXJwb2xhdGVSb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBkM19pbnRlcnBvbGF0ZVNrZXcoYS5za2V3LCBiLnNrZXcsIHMsIHEpO1xuICAgIGQzX2ludGVycG9sYXRlU2NhbGUoYS5zY2FsZSwgYi5zY2FsZSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3VuaW50ZXJwb2xhdGVOdW1iZXIoYSwgYikge1xuICAgIGIgPSAoYiAtPSBhID0gK2EpIHx8IDEgLyBiO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gKHggLSBhKSAvIGI7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM191bmludGVycG9sYXRlQ2xhbXAoYSwgYikge1xuICAgIGIgPSAoYiAtPSBhID0gK2EpIHx8IDEgLyBiO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHggLSBhKSAvIGIpKTtcbiAgICB9O1xuICB9XG4gIGQzLmxheW91dCA9IHt9O1xuICBkMy5sYXlvdXQuYnVuZGxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpbmtzKSB7XG4gICAgICB2YXIgcGF0aHMgPSBbXSwgaSA9IC0xLCBuID0gbGlua3MubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHBhdGhzLnB1c2goZDNfbGF5b3V0X2J1bmRsZVBhdGgobGlua3NbaV0pKTtcbiAgICAgIHJldHVybiBwYXRocztcbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfYnVuZGxlUGF0aChsaW5rKSB7XG4gICAgdmFyIHN0YXJ0ID0gbGluay5zb3VyY2UsIGVuZCA9IGxpbmsudGFyZ2V0LCBsY2EgPSBkM19sYXlvdXRfYnVuZGxlTGVhc3RDb21tb25BbmNlc3RvcihzdGFydCwgZW5kKSwgcG9pbnRzID0gWyBzdGFydCBdO1xuICAgIHdoaWxlIChzdGFydCAhPT0gbGNhKSB7XG4gICAgICBzdGFydCA9IHN0YXJ0LnBhcmVudDtcbiAgICAgIHBvaW50cy5wdXNoKHN0YXJ0KTtcbiAgICB9XG4gICAgdmFyIGsgPSBwb2ludHMubGVuZ3RoO1xuICAgIHdoaWxlIChlbmQgIT09IGxjYSkge1xuICAgICAgcG9pbnRzLnNwbGljZShrLCAwLCBlbmQpO1xuICAgICAgZW5kID0gZW5kLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfYnVuZGxlQW5jZXN0b3JzKG5vZGUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gW10sIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gcGFyZW50O1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG4gICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfYnVuZGxlTGVhc3RDb21tb25BbmNlc3RvcihhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhO1xuICAgIHZhciBhTm9kZXMgPSBkM19sYXlvdXRfYnVuZGxlQW5jZXN0b3JzKGEpLCBiTm9kZXMgPSBkM19sYXlvdXRfYnVuZGxlQW5jZXN0b3JzKGIpLCBhTm9kZSA9IGFOb2Rlcy5wb3AoKSwgYk5vZGUgPSBiTm9kZXMucG9wKCksIHNoYXJlZE5vZGUgPSBudWxsO1xuICAgIHdoaWxlIChhTm9kZSA9PT0gYk5vZGUpIHtcbiAgICAgIHNoYXJlZE5vZGUgPSBhTm9kZTtcbiAgICAgIGFOb2RlID0gYU5vZGVzLnBvcCgpO1xuICAgICAgYk5vZGUgPSBiTm9kZXMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBzaGFyZWROb2RlO1xuICB9XG4gIGQzLmxheW91dC5jaG9yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaG9yZCA9IHt9LCBjaG9yZHMsIGdyb3VwcywgbWF0cml4LCBuLCBwYWRkaW5nID0gMCwgc29ydEdyb3Vwcywgc29ydFN1Ymdyb3Vwcywgc29ydENob3JkcztcbiAgICBmdW5jdGlvbiByZWxheW91dCgpIHtcbiAgICAgIHZhciBzdWJncm91cHMgPSB7fSwgZ3JvdXBTdW1zID0gW10sIGdyb3VwSW5kZXggPSBkMy5yYW5nZShuKSwgc3ViZ3JvdXBJbmRleCA9IFtdLCBrLCB4LCB4MCwgaSwgajtcbiAgICAgIGNob3JkcyA9IFtdO1xuICAgICAgZ3JvdXBzID0gW107XG4gICAgICBrID0gMCwgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgeCA9IDAsIGogPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgICB4ICs9IG1hdHJpeFtpXVtqXTtcbiAgICAgICAgfVxuICAgICAgICBncm91cFN1bXMucHVzaCh4KTtcbiAgICAgICAgc3ViZ3JvdXBJbmRleC5wdXNoKGQzLnJhbmdlKG4pKTtcbiAgICAgICAgayArPSB4O1xuICAgICAgfVxuICAgICAgaWYgKHNvcnRHcm91cHMpIHtcbiAgICAgICAgZ3JvdXBJbmRleC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gc29ydEdyb3Vwcyhncm91cFN1bXNbYV0sIGdyb3VwU3Vtc1tiXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNvcnRTdWJncm91cHMpIHtcbiAgICAgICAgc3ViZ3JvdXBJbmRleC5mb3JFYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICBkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRTdWJncm91cHMobWF0cml4W2ldW2FdLCBtYXRyaXhbaV1bYl0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGsgPSAoz4QgLSBwYWRkaW5nICogbikgLyBrO1xuICAgICAgeCA9IDAsIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIHgwID0geCwgaiA9IC0xO1xuICAgICAgICB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICAgIHZhciBkaSA9IGdyb3VwSW5kZXhbaV0sIGRqID0gc3ViZ3JvdXBJbmRleFtkaV1bal0sIHYgPSBtYXRyaXhbZGldW2RqXSwgYTAgPSB4LCBhMSA9IHggKz0gdiAqIGs7XG4gICAgICAgICAgc3ViZ3JvdXBzW2RpICsgXCItXCIgKyBkal0gPSB7XG4gICAgICAgICAgICBpbmRleDogZGksXG4gICAgICAgICAgICBzdWJpbmRleDogZGosXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBhMCxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBncm91cHNbZGldID0ge1xuICAgICAgICAgIGluZGV4OiBkaSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiB4MCxcbiAgICAgICAgICBlbmRBbmdsZTogeCxcbiAgICAgICAgICB2YWx1ZTogZ3JvdXBTdW1zW2RpXVxuICAgICAgICB9O1xuICAgICAgICB4ICs9IHBhZGRpbmc7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBqID0gaSAtIDE7XG4gICAgICAgIHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHN1Ymdyb3Vwc1tpICsgXCItXCIgKyBqXSwgdGFyZ2V0ID0gc3ViZ3JvdXBzW2ogKyBcIi1cIiArIGldO1xuICAgICAgICAgIGlmIChzb3VyY2UudmFsdWUgfHwgdGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICBjaG9yZHMucHVzaChzb3VyY2UudmFsdWUgPCB0YXJnZXQudmFsdWUgPyB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGFyZ2V0LFxuICAgICAgICAgICAgICB0YXJnZXQ6IHNvdXJjZVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzb3J0Q2hvcmRzKSByZXNvcnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb3J0KCkge1xuICAgICAgY2hvcmRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gc29ydENob3JkcygoYS5zb3VyY2UudmFsdWUgKyBhLnRhcmdldC52YWx1ZSkgLyAyLCAoYi5zb3VyY2UudmFsdWUgKyBiLnRhcmdldC52YWx1ZSkgLyAyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjaG9yZC5tYXRyaXggPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXRyaXg7XG4gICAgICBuID0gKG1hdHJpeCA9IHgpICYmIG1hdHJpeC5sZW5ndGg7XG4gICAgICBjaG9yZHMgPSBncm91cHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZGRpbmc7XG4gICAgICBwYWRkaW5nID0geDtcbiAgICAgIGNob3JkcyA9IGdyb3VwcyA9IG51bGw7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zb3J0R3JvdXBzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydEdyb3VwcztcbiAgICAgIHNvcnRHcm91cHMgPSB4O1xuICAgICAgY2hvcmRzID0gZ3JvdXBzID0gbnVsbDtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvcnRTdWJncm91cHMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0U3ViZ3JvdXBzO1xuICAgICAgc29ydFN1Ymdyb3VwcyA9IHg7XG4gICAgICBjaG9yZHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc29ydENob3JkcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnRDaG9yZHM7XG4gICAgICBzb3J0Q2hvcmRzID0geDtcbiAgICAgIGlmIChjaG9yZHMpIHJlc29ydCgpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuY2hvcmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWNob3JkcykgcmVsYXlvdXQoKTtcbiAgICAgIHJldHVybiBjaG9yZHM7XG4gICAgfTtcbiAgICBjaG9yZC5ncm91cHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghZ3JvdXBzKSByZWxheW91dCgpO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9O1xuICAgIHJldHVybiBjaG9yZDtcbiAgfTtcbiAgZDMubGF5b3V0LmZvcmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZvcmNlID0ge30sIGV2ZW50ID0gZDMuZGlzcGF0Y2goXCJzdGFydFwiLCBcInRpY2tcIiwgXCJlbmRcIiksIHRpbWVyLCBzaXplID0gWyAxLCAxIF0sIGRyYWcsIGFscGhhLCBmcmljdGlvbiA9IC45LCBsaW5rRGlzdGFuY2UgPSBkM19sYXlvdXRfZm9yY2VMaW5rRGlzdGFuY2UsIGxpbmtTdHJlbmd0aCA9IGQzX2xheW91dF9mb3JjZUxpbmtTdHJlbmd0aCwgY2hhcmdlID0gLTMwLCBjaGFyZ2VEaXN0YW5jZTIgPSBkM19sYXlvdXRfZm9yY2VDaGFyZ2VEaXN0YW5jZTIsIGdyYXZpdHkgPSAuMSwgdGhldGEyID0gLjY0LCBub2RlcyA9IFtdLCBsaW5rcyA9IFtdLCBkaXN0YW5jZXMsIHN0cmVuZ3RocywgY2hhcmdlcztcbiAgICBmdW5jdGlvbiByZXB1bHNlKG5vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihxdWFkLCB4MSwgXywgeDIpIHtcbiAgICAgICAgaWYgKHF1YWQucG9pbnQgIT09IG5vZGUpIHtcbiAgICAgICAgICB2YXIgZHggPSBxdWFkLmN4IC0gbm9kZS54LCBkeSA9IHF1YWQuY3kgLSBub2RlLnksIGR3ID0geDIgLSB4MSwgZG4gPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICBpZiAoZHcgKiBkdyAvIHRoZXRhMiA8IGRuKSB7XG4gICAgICAgICAgICBpZiAoZG4gPCBjaGFyZ2VEaXN0YW5jZTIpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBxdWFkLmNoYXJnZSAvIGRuO1xuICAgICAgICAgICAgICBub2RlLnB4IC09IGR4ICogaztcbiAgICAgICAgICAgICAgbm9kZS5weSAtPSBkeSAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHF1YWQucG9pbnQgJiYgZG4gJiYgZG4gPCBjaGFyZ2VEaXN0YW5jZTIpIHtcbiAgICAgICAgICAgIHZhciBrID0gcXVhZC5wb2ludENoYXJnZSAvIGRuO1xuICAgICAgICAgICAgbm9kZS5weCAtPSBkeCAqIGs7XG4gICAgICAgICAgICBub2RlLnB5IC09IGR5ICogaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFxdWFkLmNoYXJnZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZvcmNlLnRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgoYWxwaGEgKj0gLjk5KSA8IC4wMDUpIHtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICBldmVudC5lbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZW5kXCIsXG4gICAgICAgICAgYWxwaGE6IGFscGhhID0gMFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IG5vZGVzLmxlbmd0aCwgbSA9IGxpbmtzLmxlbmd0aCwgcSwgaSwgbywgcywgdCwgbCwgaywgeCwgeTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgbyA9IGxpbmtzW2ldO1xuICAgICAgICBzID0gby5zb3VyY2U7XG4gICAgICAgIHQgPSBvLnRhcmdldDtcbiAgICAgICAgeCA9IHQueCAtIHMueDtcbiAgICAgICAgeSA9IHQueSAtIHMueTtcbiAgICAgICAgaWYgKGwgPSB4ICogeCArIHkgKiB5KSB7XG4gICAgICAgICAgbCA9IGFscGhhICogc3RyZW5ndGhzW2ldICogKChsID0gTWF0aC5zcXJ0KGwpKSAtIGRpc3RhbmNlc1tpXSkgLyBsO1xuICAgICAgICAgIHggKj0gbDtcbiAgICAgICAgICB5ICo9IGw7XG4gICAgICAgICAgdC54IC09IHggKiAoayA9IHMud2VpZ2h0ICsgdC53ZWlnaHQgPyBzLndlaWdodCAvIChzLndlaWdodCArIHQud2VpZ2h0KSA6IC41KTtcbiAgICAgICAgICB0LnkgLT0geSAqIGs7XG4gICAgICAgICAgcy54ICs9IHggKiAoayA9IDEgLSBrKTtcbiAgICAgICAgICBzLnkgKz0geSAqIGs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrID0gYWxwaGEgKiBncmF2aXR5KSB7XG4gICAgICAgIHggPSBzaXplWzBdIC8gMjtcbiAgICAgICAgeSA9IHNpemVbMV0gLyAyO1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIGlmIChrKSB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIG8gPSBub2Rlc1tpXTtcbiAgICAgICAgICBvLnggKz0gKHggLSBvLngpICogaztcbiAgICAgICAgICBvLnkgKz0gKHkgLSBvLnkpICogaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoYXJnZSkge1xuICAgICAgICBkM19sYXlvdXRfZm9yY2VBY2N1bXVsYXRlKHEgPSBkMy5nZW9tLnF1YWR0cmVlKG5vZGVzKSwgYWxwaGEsIGNoYXJnZXMpO1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaWYgKCEobyA9IG5vZGVzW2ldKS5maXhlZCkge1xuICAgICAgICAgICAgcS52aXNpdChyZXB1bHNlKG8pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIG8gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG8uZml4ZWQpIHtcbiAgICAgICAgICBvLnggPSBvLnB4O1xuICAgICAgICAgIG8ueSA9IG8ucHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby54IC09IChvLnB4IC0gKG8ucHggPSBvLngpKSAqIGZyaWN0aW9uO1xuICAgICAgICAgIG8ueSAtPSAoby5weSAtIChvLnB5ID0gby55KSkgKiBmcmljdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnQudGljayh7XG4gICAgICAgIHR5cGU6IFwidGlja1wiLFxuICAgICAgICBhbHBoYTogYWxwaGFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yY2Uubm9kZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlcztcbiAgICAgIG5vZGVzID0geDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmxpbmtzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua3M7XG4gICAgICBsaW5rcyA9IHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UubGlua0Rpc3RhbmNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua0Rpc3RhbmNlO1xuICAgICAgbGlua0Rpc3RhbmNlID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmRpc3RhbmNlID0gZm9yY2UubGlua0Rpc3RhbmNlO1xuICAgIGZvcmNlLmxpbmtTdHJlbmd0aCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmtTdHJlbmd0aDtcbiAgICAgIGxpbmtTdHJlbmd0aCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5mcmljdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZyaWN0aW9uO1xuICAgICAgZnJpY3Rpb24gPSAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmNoYXJnZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNoYXJnZTtcbiAgICAgIGNoYXJnZSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5jaGFyZ2VEaXN0YW5jZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIE1hdGguc3FydChjaGFyZ2VEaXN0YW5jZTIpO1xuICAgICAgY2hhcmdlRGlzdGFuY2UyID0geCAqIHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5ncmF2aXR5ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3Jhdml0eTtcbiAgICAgIGdyYXZpdHkgPSAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLnRoZXRhID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gTWF0aC5zcXJ0KHRoZXRhMik7XG4gICAgICB0aGV0YTIgPSB4ICogeDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmFscGhhID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYWxwaGE7XG4gICAgICB4ID0gK3g7XG4gICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgaWYgKHggPiAwKSB7XG4gICAgICAgICAgYWxwaGEgPSB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVyLmMgPSBudWxsLCB0aW1lci50ID0gTmFOLCB0aW1lciA9IG51bGw7XG4gICAgICAgICAgZXZlbnQuZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW5kXCIsXG4gICAgICAgICAgICBhbHBoYTogYWxwaGEgPSAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoeCA+IDApIHtcbiAgICAgICAgZXZlbnQuc3RhcnQoe1xuICAgICAgICAgIHR5cGU6IFwic3RhcnRcIixcbiAgICAgICAgICBhbHBoYTogYWxwaGEgPSB4XG4gICAgICAgIH0pO1xuICAgICAgICB0aW1lciA9IGQzX3RpbWVyKGZvcmNlLnRpY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2Uuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBtID0gbGlua3MubGVuZ3RoLCB3ID0gc2l6ZVswXSwgaCA9IHNpemVbMV0sIG5laWdoYm9ycywgbztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgKG8gPSBub2Rlc1tpXSkuaW5kZXggPSBpO1xuICAgICAgICBvLndlaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIG8gPSBsaW5rc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnNvdXJjZSA9PSBcIm51bWJlclwiKSBvLnNvdXJjZSA9IG5vZGVzW28uc291cmNlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnRhcmdldCA9PSBcIm51bWJlclwiKSBvLnRhcmdldCA9IG5vZGVzW28udGFyZ2V0XTtcbiAgICAgICAgKytvLnNvdXJjZS53ZWlnaHQ7XG4gICAgICAgICsrby50YXJnZXQud2VpZ2h0O1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBvID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChpc05hTihvLngpKSBvLnggPSBwb3NpdGlvbihcInhcIiwgdyk7XG4gICAgICAgIGlmIChpc05hTihvLnkpKSBvLnkgPSBwb3NpdGlvbihcInlcIiwgaCk7XG4gICAgICAgIGlmIChpc05hTihvLnB4KSkgby5weCA9IG8ueDtcbiAgICAgICAgaWYgKGlzTmFOKG8ucHkpKSBvLnB5ID0gby55O1xuICAgICAgfVxuICAgICAgZGlzdGFuY2VzID0gW107XG4gICAgICBpZiAodHlwZW9mIGxpbmtEaXN0YW5jZSA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBkaXN0YW5jZXNbaV0gPSArbGlua0Rpc3RhbmNlLmNhbGwodGhpcywgbGlua3NbaV0sIGkpOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIGRpc3RhbmNlc1tpXSA9IGxpbmtEaXN0YW5jZTtcbiAgICAgIHN0cmVuZ3RocyA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rU3RyZW5ndGggPT09IFwiZnVuY3Rpb25cIikgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc3RyZW5ndGhzW2ldID0gK2xpbmtTdHJlbmd0aC5jYWxsKHRoaXMsIGxpbmtzW2ldLCBpKTsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBzdHJlbmd0aHNbaV0gPSBsaW5rU3RyZW5ndGg7XG4gICAgICBjaGFyZ2VzID0gW107XG4gICAgICBpZiAodHlwZW9mIGNoYXJnZSA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGFyZ2VzW2ldID0gK2NoYXJnZS5jYWxsKHRoaXMsIG5vZGVzW2ldLCBpKTsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGFyZ2VzW2ldID0gY2hhcmdlO1xuICAgICAgZnVuY3Rpb24gcG9zaXRpb24oZGltZW5zaW9uLCBzaXplKSB7XG4gICAgICAgIGlmICghbmVpZ2hib3JzKSB7XG4gICAgICAgICAgbmVpZ2hib3JzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgIG5laWdoYm9yc1tqXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGxpbmtzW2pdO1xuICAgICAgICAgICAgbmVpZ2hib3JzW28uc291cmNlLmluZGV4XS5wdXNoKG8udGFyZ2V0KTtcbiAgICAgICAgICAgIG5laWdoYm9yc1tvLnRhcmdldC5pbmRleF0ucHVzaChvLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gbmVpZ2hib3JzW2ldLCBqID0gLTEsIGwgPSBjYW5kaWRhdGVzLmxlbmd0aCwgeDtcbiAgICAgICAgd2hpbGUgKCsraiA8IGwpIGlmICghaXNOYU4oeCA9IGNhbmRpZGF0ZXNbal1bZGltZW5zaW9uXSkpIHJldHVybiB4O1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIHNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yY2UucmVzdW1lKCk7XG4gICAgfTtcbiAgICBmb3JjZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmb3JjZS5hbHBoYSguMSk7XG4gICAgfTtcbiAgICBmb3JjZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9yY2UuYWxwaGEoMCk7XG4gICAgfTtcbiAgICBmb3JjZS5kcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWRyYWcpIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCkub3JpZ2luKGQzX2lkZW50aXR5KS5vbihcImRyYWdzdGFydC5mb3JjZVwiLCBkM19sYXlvdXRfZm9yY2VEcmFnc3RhcnQpLm9uKFwiZHJhZy5mb3JjZVwiLCBkcmFnbW92ZSkub24oXCJkcmFnZW5kLmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZURyYWdlbmQpO1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZHJhZztcbiAgICAgIHRoaXMub24oXCJtb3VzZW92ZXIuZm9yY2VcIiwgZDNfbGF5b3V0X2ZvcmNlTW91c2VvdmVyKS5vbihcIm1vdXNlb3V0LmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZU1vdXNlb3V0KS5jYWxsKGRyYWcpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZHJhZ21vdmUoZCkge1xuICAgICAgZC5weCA9IGQzLmV2ZW50LngsIGQucHkgPSBkMy5ldmVudC55O1xuICAgICAgZm9yY2UucmVzdW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBkMy5yZWJpbmQoZm9yY2UsIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VEcmFnc3RhcnQoZCkge1xuICAgIGQuZml4ZWQgfD0gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VEcmFnZW5kKGQpIHtcbiAgICBkLmZpeGVkICY9IH42O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZU1vdXNlb3ZlcihkKSB7XG4gICAgZC5maXhlZCB8PSA0O1xuICAgIGQucHggPSBkLngsIGQucHkgPSBkLnk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlTW91c2VvdXQoZCkge1xuICAgIGQuZml4ZWQgJj0gfjQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlQWNjdW11bGF0ZShxdWFkLCBhbHBoYSwgY2hhcmdlcykge1xuICAgIHZhciBjeCA9IDAsIGN5ID0gMDtcbiAgICBxdWFkLmNoYXJnZSA9IDA7XG4gICAgaWYgKCFxdWFkLmxlYWYpIHtcbiAgICAgIHZhciBub2RlcyA9IHF1YWQubm9kZXMsIG4gPSBub2Rlcy5sZW5ndGgsIGkgPSAtMSwgYztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGMgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKGMgPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIGQzX2xheW91dF9mb3JjZUFjY3VtdWxhdGUoYywgYWxwaGEsIGNoYXJnZXMpO1xuICAgICAgICBxdWFkLmNoYXJnZSArPSBjLmNoYXJnZTtcbiAgICAgICAgY3ggKz0gYy5jaGFyZ2UgKiBjLmN4O1xuICAgICAgICBjeSArPSBjLmNoYXJnZSAqIGMuY3k7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWFkLnBvaW50KSB7XG4gICAgICBpZiAoIXF1YWQubGVhZikge1xuICAgICAgICBxdWFkLnBvaW50LnggKz0gTWF0aC5yYW5kb20oKSAtIC41O1xuICAgICAgICBxdWFkLnBvaW50LnkgKz0gTWF0aC5yYW5kb20oKSAtIC41O1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBhbHBoYSAqIGNoYXJnZXNbcXVhZC5wb2ludC5pbmRleF07XG4gICAgICBxdWFkLmNoYXJnZSArPSBxdWFkLnBvaW50Q2hhcmdlID0gaztcbiAgICAgIGN4ICs9IGsgKiBxdWFkLnBvaW50Lng7XG4gICAgICBjeSArPSBrICogcXVhZC5wb2ludC55O1xuICAgIH1cbiAgICBxdWFkLmN4ID0gY3ggLyBxdWFkLmNoYXJnZTtcbiAgICBxdWFkLmN5ID0gY3kgLyBxdWFkLmNoYXJnZTtcbiAgfVxuICB2YXIgZDNfbGF5b3V0X2ZvcmNlTGlua0Rpc3RhbmNlID0gMjAsIGQzX2xheW91dF9mb3JjZUxpbmtTdHJlbmd0aCA9IDEsIGQzX2xheW91dF9mb3JjZUNoYXJnZURpc3RhbmNlMiA9IEluZmluaXR5O1xuICBkMy5sYXlvdXQuaGllcmFyY2h5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvcnQgPSBkM19sYXlvdXRfaGllcmFyY2h5U29ydCwgY2hpbGRyZW4gPSBkM19sYXlvdXRfaGllcmFyY2h5Q2hpbGRyZW4sIHZhbHVlID0gZDNfbGF5b3V0X2hpZXJhcmNoeVZhbHVlO1xuICAgIGZ1bmN0aW9uIGhpZXJhcmNoeShyb290KSB7XG4gICAgICB2YXIgc3RhY2sgPSBbIHJvb3QgXSwgbm9kZXMgPSBbXSwgbm9kZTtcbiAgICAgIHJvb3QuZGVwdGggPSAwO1xuICAgICAgd2hpbGUgKChub2RlID0gc3RhY2sucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKChjaGlsZHMgPSBjaGlsZHJlbi5jYWxsKGhpZXJhcmNoeSwgbm9kZSwgbm9kZS5kZXB0aCkpICYmIChuID0gY2hpbGRzLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgbiwgY2hpbGRzLCBjaGlsZDtcbiAgICAgICAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goY2hpbGQgPSBjaGlsZHNbbl0pO1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIGNoaWxkLmRlcHRoID0gbm9kZS5kZXB0aCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSkgbm9kZS52YWx1ZSA9IDA7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUpIG5vZGUudmFsdWUgPSArdmFsdWUuY2FsbChoaWVyYXJjaHksIG5vZGUsIG5vZGUuZGVwdGgpIHx8IDA7XG4gICAgICAgICAgZGVsZXRlIG5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcywgcGFyZW50O1xuICAgICAgICBpZiAoc29ydCAmJiAoY2hpbGRzID0gbm9kZS5jaGlsZHJlbikpIGNoaWxkcy5zb3J0KHNvcnQpO1xuICAgICAgICBpZiAodmFsdWUgJiYgKHBhcmVudCA9IG5vZGUucGFyZW50KSkgcGFyZW50LnZhbHVlICs9IG5vZGUudmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgaGllcmFyY2h5LnNvcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0O1xuICAgICAgc29ydCA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LmNoaWxkcmVuID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2hpbGRyZW47XG4gICAgICBjaGlsZHJlbiA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LnZhbHVlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LnJldmFsdWUgPSBmdW5jdGlvbihyb290KSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikgbm9kZS52YWx1ZSA9IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIHBhcmVudDtcbiAgICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIG5vZGUudmFsdWUgPSArdmFsdWUuY2FsbChoaWVyYXJjaHksIG5vZGUsIG5vZGUuZGVwdGgpIHx8IDA7XG4gICAgICAgICAgaWYgKHBhcmVudCA9IG5vZGUucGFyZW50KSBwYXJlbnQudmFsdWUgKz0gbm9kZS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICAgIHJldHVybiBoaWVyYXJjaHk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQob2JqZWN0LCBoaWVyYXJjaHkpIHtcbiAgICBkMy5yZWJpbmQob2JqZWN0LCBoaWVyYXJjaHksIFwic29ydFwiLCBcImNoaWxkcmVuXCIsIFwidmFsdWVcIik7XG4gICAgb2JqZWN0Lm5vZGVzID0gb2JqZWN0O1xuICAgIG9iamVjdC5saW5rcyA9IGQzX2xheW91dF9oaWVyYXJjaHlMaW5rcztcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShub2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IFsgbm9kZSBdO1xuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgIGlmICgoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIG4sIGNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoLS1uID49IDApIG5vZGVzLnB1c2goY2hpbGRyZW5bbl0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihub2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IFsgbm9kZSBdLCBub2RlczIgPSBbXTtcbiAgICB3aGlsZSAoKG5vZGUgPSBub2Rlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgbm9kZXMyLnB1c2gobm9kZSk7XG4gICAgICBpZiAoKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4sIGNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzMi5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlDaGlsZHJlbihkKSB7XG4gICAgcmV0dXJuIGQuY2hpbGRyZW47XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVZhbHVlKGQpIHtcbiAgICByZXR1cm4gZC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5U29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlMaW5rcyhub2Rlcykge1xuICAgIHJldHVybiBkMy5tZXJnZShub2Rlcy5tYXAoZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICByZXR1cm4gKHBhcmVudC5jaGlsZHJlbiB8fCBbXSkubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBwYXJlbnQsXG4gICAgICAgICAgdGFyZ2V0OiBjaGlsZFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG4gIGQzLmxheW91dC5wYXJ0aXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLCBzaXplID0gWyAxLCAxIF07XG4gICAgZnVuY3Rpb24gcG9zaXRpb24obm9kZSwgeCwgZHgsIGR5KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgbm9kZS54ID0geDtcbiAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBkeTtcbiAgICAgIG5vZGUuZHggPSBkeDtcbiAgICAgIG5vZGUuZHkgPSBkeTtcbiAgICAgIGlmIChjaGlsZHJlbiAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbiwgYywgZDtcbiAgICAgICAgZHggPSBub2RlLnZhbHVlID8gZHggLyBub2RlLnZhbHVlIDogMDtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBwb3NpdGlvbihjID0gY2hpbGRyZW5baV0sIHgsIGQgPSBjLnZhbHVlICogZHgsIGR5KTtcbiAgICAgICAgICB4ICs9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVwdGgobm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiwgZCA9IDA7XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG47XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBkID0gTWF0aC5tYXgoZCwgZGVwdGgoY2hpbGRyZW5baV0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxICsgZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydGl0aW9uKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgcG9zaXRpb24obm9kZXNbMF0sIDAsIHNpemVbMF0sIHNpemVbMV0gLyBkZXB0aChub2Rlc1swXSkpO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBwYXJ0aXRpb24uc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0geDtcbiAgICAgIHJldHVybiBwYXJ0aXRpb247XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZChwYXJ0aXRpb24sIGhpZXJhcmNoeSk7XG4gIH07XG4gIGQzLmxheW91dC5waWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBOdW1iZXIsIHNvcnQgPSBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUsIHN0YXJ0QW5nbGUgPSAwLCBlbmRBbmdsZSA9IM+ELCBwYWRBbmdsZSA9IDA7XG4gICAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIHZhbHVlcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICt2YWx1ZS5jYWxsKHBpZSwgZCwgaSk7XG4gICAgICB9KSwgYSA9ICsodHlwZW9mIHN0YXJ0QW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHN0YXJ0QW5nbGUpLCBkYSA9ICh0eXBlb2YgZW5kQW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBlbmRBbmdsZSkgLSBhLCBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgKyh0eXBlb2YgcGFkQW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwYWRBbmdsZSkpLCBwYSA9IHAgKiAoZGEgPCAwID8gLTEgOiAxKSwgc3VtID0gZDMuc3VtKHZhbHVlcyksIGsgPSBzdW0gPyAoZGEgLSBuICogcGEpIC8gc3VtIDogMCwgaW5kZXggPSBkMy5yYW5nZShuKSwgYXJjcyA9IFtdLCB2O1xuICAgICAgaWYgKHNvcnQgIT0gbnVsbCkgaW5kZXguc29ydChzb3J0ID09PSBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUgPyBmdW5jdGlvbihpLCBqKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbal0gLSB2YWx1ZXNbaV07XG4gICAgICB9IDogZnVuY3Rpb24oaSwgaikge1xuICAgICAgICByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTtcbiAgICAgIH0pO1xuICAgICAgaW5kZXguZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGFyY3NbaV0gPSB7XG4gICAgICAgICAgZGF0YTogZGF0YVtpXSxcbiAgICAgICAgICB2YWx1ZTogdiA9IHZhbHVlc1tpXSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiBhLFxuICAgICAgICAgIGVuZEFuZ2xlOiBhICs9IHYgKiBrICsgcGEsXG4gICAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFyY3M7XG4gICAgfVxuICAgIHBpZS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFsdWUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5zb3J0ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydDtcbiAgICAgIHNvcnQgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhcnRBbmdsZTtcbiAgICAgIHN0YXJ0QW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZEFuZ2xlO1xuICAgICAgcGFkQW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHJldHVybiBwaWU7XG4gIH07XG4gIHZhciBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUgPSB7fTtcbiAgZDMubGF5b3V0LnN0YWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IGQzX2lkZW50aXR5LCBvcmRlciA9IGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdCwgb2Zmc2V0ID0gZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybywgb3V0ID0gZDNfbGF5b3V0X3N0YWNrT3V0LCB4ID0gZDNfbGF5b3V0X3N0YWNrWCwgeSA9IGQzX2xheW91dF9zdGFja1k7XG4gICAgZnVuY3Rpb24gc3RhY2soZGF0YSwgaW5kZXgpIHtcbiAgICAgIGlmICghKG4gPSBkYXRhLmxlbmd0aCkpIHJldHVybiBkYXRhO1xuICAgICAgdmFyIHNlcmllcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5jYWxsKHN0YWNrLCBkLCBpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvaW50cyA9IHNlcmllcy5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZC5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgIHJldHVybiBbIHguY2FsbChzdGFjaywgdiwgaSksIHkuY2FsbChzdGFjaywgdiwgaSkgXTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBvcmRlcnMgPSBvcmRlci5jYWxsKHN0YWNrLCBwb2ludHMsIGluZGV4KTtcbiAgICAgIHNlcmllcyA9IGQzLnBlcm11dGUoc2VyaWVzLCBvcmRlcnMpO1xuICAgICAgcG9pbnRzID0gZDMucGVybXV0ZShwb2ludHMsIG9yZGVycyk7XG4gICAgICB2YXIgb2Zmc2V0cyA9IG9mZnNldC5jYWxsKHN0YWNrLCBwb2ludHMsIGluZGV4KTtcbiAgICAgIHZhciBtID0gc2VyaWVzWzBdLmxlbmd0aCwgbiwgaSwgaiwgbztcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgb3V0LmNhbGwoc3RhY2ssIHNlcmllc1swXVtqXSwgbyA9IG9mZnNldHNbal0sIHBvaW50c1swXVtqXVsxXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBvdXQuY2FsbChzdGFjaywgc2VyaWVzW2ldW2pdLCBvICs9IHBvaW50c1tpIC0gMV1bal1bMV0sIHBvaW50c1tpXVtqXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBzdGFjay52YWx1ZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZXM7XG4gICAgICB2YWx1ZXMgPSB4O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sub3JkZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmRlcjtcbiAgICAgIG9yZGVyID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBkM19sYXlvdXRfc3RhY2tPcmRlcnMuZ2V0KHgpIHx8IGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdDtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLm9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9mZnNldDtcbiAgICAgIG9mZnNldCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogZDNfbGF5b3V0X3N0YWNrT2Zmc2V0cy5nZXQoeCkgfHwgZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybztcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLnggPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgICAgeCA9IHo7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay55ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICAgIHkgPSB6O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sub3V0ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0O1xuICAgICAgb3V0ID0gejtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrWChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tZKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja091dChkLCB5MCwgeSkge1xuICAgIGQueTAgPSB5MDtcbiAgICBkLnkgPSB5O1xuICB9XG4gIHZhciBkM19sYXlvdXRfc3RhY2tPcmRlcnMgPSBkMy5tYXAoe1xuICAgIFwiaW5zaWRlLW91dFwiOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCBpLCBqLCBtYXggPSBkYXRhLm1hcChkM19sYXlvdXRfc3RhY2tNYXhJbmRleCksIHN1bXMgPSBkYXRhLm1hcChkM19sYXlvdXRfc3RhY2tSZWR1Y2VTdW0pLCBpbmRleCA9IGQzLnJhbmdlKG4pLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gbWF4W2FdIC0gbWF4W2JdO1xuICAgICAgfSksIHRvcCA9IDAsIGJvdHRvbSA9IDAsIHRvcHMgPSBbXSwgYm90dG9tcyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBqID0gaW5kZXhbaV07XG4gICAgICAgIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgICAgICB0b3AgKz0gc3Vtc1tqXTtcbiAgICAgICAgICB0b3BzLnB1c2goaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm90dG9tICs9IHN1bXNbal07XG4gICAgICAgICAgYm90dG9tcy5wdXNoKGopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYm90dG9tcy5yZXZlcnNlKCkuY29uY2F0KHRvcHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKGRhdGEubGVuZ3RoKS5yZXZlcnNlKCk7XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogZDNfbGF5b3V0X3N0YWNrT3JkZXJEZWZhdWx0XG4gIH0pO1xuICB2YXIgZDNfbGF5b3V0X3N0YWNrT2Zmc2V0cyA9IGQzLm1hcCh7XG4gICAgc2lsaG91ZXR0ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgbSA9IGRhdGFbMF0ubGVuZ3RoLCBzdW1zID0gW10sIG1heCA9IDAsIGksIGosIG8sIHkwID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG8gPSAwOyBpIDwgbjsgaSsrKSBvICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGlmIChvID4gbWF4KSBtYXggPSBvO1xuICAgICAgICBzdW1zLnB1c2gobyk7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIHkwW2pdID0gKG1heCAtIHN1bXNbal0pIC8gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5MDtcbiAgICB9LFxuICAgIHdpZ2dsZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgeCA9IGRhdGFbMF0sIG0gPSB4Lmxlbmd0aCwgaSwgaiwgaywgczEsIHMyLCBzMywgZHgsIG8sIG8wLCB5MCA9IFtdO1xuICAgICAgeTBbMF0gPSBvID0gbzAgPSAwO1xuICAgICAgZm9yIChqID0gMTsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKGkgPSAwLCBzMSA9IDA7IGkgPCBuOyArK2kpIHMxICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGZvciAoaSA9IDAsIHMyID0gMCwgZHggPSB4W2pdWzBdIC0geFtqIC0gMV1bMF07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBmb3IgKGsgPSAwLCBzMyA9IChkYXRhW2ldW2pdWzFdIC0gZGF0YVtpXVtqIC0gMV1bMV0pIC8gKDIgKiBkeCk7IGsgPCBpOyArK2spIHtcbiAgICAgICAgICAgIHMzICs9IChkYXRhW2tdW2pdWzFdIC0gZGF0YVtrXVtqIC0gMV1bMV0pIC8gZHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMyICs9IHMzICogZGF0YVtpXVtqXVsxXTtcbiAgICAgICAgfVxuICAgICAgICB5MFtqXSA9IG8gLT0gczEgPyBzMiAvIHMxICogZHggOiAwO1xuICAgICAgICBpZiAobyA8IG8wKSBvMCA9IG87XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB5MFtqXSAtPSBvMDtcbiAgICAgIHJldHVybiB5MDtcbiAgICB9LFxuICAgIGV4cGFuZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgbSA9IGRhdGFbMF0ubGVuZ3RoLCBrID0gMSAvIG4sIGksIGosIG8sIHkwID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG8gPSAwOyBpIDwgbjsgaSsrKSBvICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGlmIChvKSBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBkYXRhW2ldW2pdWzFdIC89IG87IGVsc2UgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZGF0YVtpXVtqXVsxXSA9IGs7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB5MFtqXSA9IDA7XG4gICAgICByZXR1cm4geTA7XG4gICAgfSxcbiAgICB6ZXJvOiBkM19sYXlvdXRfc3RhY2tPZmZzZXRaZXJvXG4gIH0pO1xuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tPcmRlckRlZmF1bHQoZGF0YSkge1xuICAgIHJldHVybiBkMy5yYW5nZShkYXRhLmxlbmd0aCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybyhkYXRhKSB7XG4gICAgdmFyIGogPSAtMSwgbSA9IGRhdGFbMF0ubGVuZ3RoLCB5MCA9IFtdO1xuICAgIHdoaWxlICgrK2ogPCBtKSB5MFtqXSA9IDA7XG4gICAgcmV0dXJuIHkwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja01heEluZGV4KGFycmF5KSB7XG4gICAgdmFyIGkgPSAxLCBqID0gMCwgdiA9IGFycmF5WzBdWzFdLCBrLCBuID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAoO2kgPCBuOyArK2kpIHtcbiAgICAgIGlmICgoayA9IGFycmF5W2ldWzFdKSA+IHYpIHtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIHYgPSBrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gajtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tSZWR1Y2VTdW0oZCkge1xuICAgIHJldHVybiBkLnJlZHVjZShkM19sYXlvdXRfc3RhY2tTdW0sIDApO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja1N1bShwLCBkKSB7XG4gICAgcmV0dXJuIHAgKyBkWzFdO1xuICB9XG4gIGQzLmxheW91dC5oaXN0b2dyYW0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnJlcXVlbmN5ID0gdHJ1ZSwgdmFsdWVyID0gTnVtYmVyLCByYW5nZXIgPSBkM19sYXlvdXRfaGlzdG9ncmFtUmFuZ2UsIGJpbm5lciA9IGQzX2xheW91dF9oaXN0b2dyYW1CaW5TdHVyZ2VzO1xuICAgIGZ1bmN0aW9uIGhpc3RvZ3JhbShkYXRhLCBpKSB7XG4gICAgICB2YXIgYmlucyA9IFtdLCB2YWx1ZXMgPSBkYXRhLm1hcCh2YWx1ZXIsIHRoaXMpLCByYW5nZSA9IHJhbmdlci5jYWxsKHRoaXMsIHZhbHVlcywgaSksIHRocmVzaG9sZHMgPSBiaW5uZXIuY2FsbCh0aGlzLCByYW5nZSwgdmFsdWVzLCBpKSwgYmluLCBpID0gLTEsIG4gPSB2YWx1ZXMubGVuZ3RoLCBtID0gdGhyZXNob2xkcy5sZW5ndGggLSAxLCBrID0gZnJlcXVlbmN5ID8gMSA6IDEgLyBuLCB4O1xuICAgICAgd2hpbGUgKCsraSA8IG0pIHtcbiAgICAgICAgYmluID0gYmluc1tpXSA9IFtdO1xuICAgICAgICBiaW4uZHggPSB0aHJlc2hvbGRzW2kgKyAxXSAtIChiaW4ueCA9IHRocmVzaG9sZHNbaV0pO1xuICAgICAgICBiaW4ueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAobSA+IDApIHtcbiAgICAgICAgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIHggPSB2YWx1ZXNbaV07XG4gICAgICAgICAgaWYgKHggPj0gcmFuZ2VbMF0gJiYgeCA8PSByYW5nZVsxXSkge1xuICAgICAgICAgICAgYmluID0gYmluc1tkMy5iaXNlY3QodGhyZXNob2xkcywgeCwgMSwgbSkgLSAxXTtcbiAgICAgICAgICAgIGJpbi55ICs9IGs7XG4gICAgICAgICAgICBiaW4ucHVzaChkYXRhW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5zO1xuICAgIH1cbiAgICBoaXN0b2dyYW0udmFsdWUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZXI7XG4gICAgICB2YWx1ZXIgPSB4O1xuICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9O1xuICAgIGhpc3RvZ3JhbS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlcjtcbiAgICAgIHJhbmdlciA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgaGlzdG9ncmFtLmJpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiaW5uZXI7XG4gICAgICBiaW5uZXIgPSB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiA/IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBkM19sYXlvdXRfaGlzdG9ncmFtQmluRml4ZWQocmFuZ2UsIHgpO1xuICAgICAgfSA6IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgaGlzdG9ncmFtLmZyZXF1ZW5jeSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZyZXF1ZW5jeTtcbiAgICAgIGZyZXF1ZW5jeSA9ICEheDtcbiAgICAgIHJldHVybiBoaXN0b2dyYW07XG4gICAgfTtcbiAgICByZXR1cm4gaGlzdG9ncmFtO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfaGlzdG9ncmFtQmluU3R1cmdlcyhyYW5nZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaXN0b2dyYW1CaW5GaXhlZChyYW5nZSwgTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIgKyAxKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpbkZpeGVkKHJhbmdlLCBuKSB7XG4gICAgdmFyIHggPSAtMSwgYiA9ICtyYW5nZVswXSwgbSA9IChyYW5nZVsxXSAtIGIpIC8gbiwgZiA9IFtdO1xuICAgIHdoaWxlICgrK3ggPD0gbikgZlt4XSA9IG0gKiB4ICsgYjtcbiAgICByZXR1cm4gZjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGlzdG9ncmFtUmFuZ2UodmFsdWVzKSB7XG4gICAgcmV0dXJuIFsgZDMubWluKHZhbHVlcyksIGQzLm1heCh2YWx1ZXMpIF07XG4gIH1cbiAgZDMubGF5b3V0LnBhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLnNvcnQoZDNfbGF5b3V0X3BhY2tTb3J0KSwgcGFkZGluZyA9IDAsIHNpemUgPSBbIDEsIDEgXSwgcmFkaXVzO1xuICAgIGZ1bmN0aW9uIHBhY2soZCwgaSkge1xuICAgICAgdmFyIG5vZGVzID0gaGllcmFyY2h5LmNhbGwodGhpcywgZCwgaSksIHJvb3QgPSBub2Rlc1swXSwgdyA9IHNpemVbMF0sIGggPSBzaXplWzFdLCByID0gcmFkaXVzID09IG51bGwgPyBNYXRoLnNxcnQgOiB0eXBlb2YgcmFkaXVzID09PSBcImZ1bmN0aW9uXCIgPyByYWRpdXMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJhZGl1cztcbiAgICAgIH07XG4gICAgICByb290LnggPSByb290LnkgPSAwO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24oZCkge1xuICAgICAgICBkLnIgPSArcihkLnZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZDNfbGF5b3V0X3BhY2tTaWJsaW5ncyk7XG4gICAgICBpZiAocGFkZGluZykge1xuICAgICAgICB2YXIgZHIgPSBwYWRkaW5nICogKHJhZGl1cyA/IDEgOiBNYXRoLm1heCgyICogcm9vdC5yIC8gdywgMiAqIHJvb3QuciAvIGgpKSAvIDI7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBkLnIgKz0gZHI7XG4gICAgICAgIH0pO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBkM19sYXlvdXRfcGFja1NpYmxpbmdzKTtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGQuciAtPSBkcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkM19sYXlvdXRfcGFja1RyYW5zZm9ybShyb290LCB3IC8gMiwgaCAvIDIsIHJhZGl1cyA/IDEgOiAxIC8gTWF0aC5tYXgoMiAqIHJvb3QuciAvIHcsIDIgKiByb290LnIgLyBoKSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHBhY2suc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0gXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcGFjay5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYWRpdXM7XG4gICAgICByYWRpdXMgPSBfID09IG51bGwgfHwgdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiArXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcGFjay5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkZGluZztcbiAgICAgIHBhZGRpbmcgPSArXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQocGFjaywgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYS52YWx1ZSAtIGIudmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tJbnNlcnQoYSwgYikge1xuICAgIHZhciBjID0gYS5fcGFja19uZXh0O1xuICAgIGEuX3BhY2tfbmV4dCA9IGI7XG4gICAgYi5fcGFja19wcmV2ID0gYTtcbiAgICBiLl9wYWNrX25leHQgPSBjO1xuICAgIGMuX3BhY2tfcHJldiA9IGI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tTcGxpY2UoYSwgYikge1xuICAgIGEuX3BhY2tfbmV4dCA9IGI7XG4gICAgYi5fcGFja19wcmV2ID0gYTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoYSwgYikge1xuICAgIHZhciBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnksIGRyID0gYS5yICsgYi5yO1xuICAgIHJldHVybiAuOTk5ICogZHIgKiBkciA+IGR4ICogZHggKyBkeSAqIGR5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrU2libGluZ3Mobm9kZSkge1xuICAgIGlmICghKG5vZGVzID0gbm9kZS5jaGlsZHJlbikgfHwgIShuID0gbm9kZXMubGVuZ3RoKSkgcmV0dXJuO1xuICAgIHZhciBub2RlcywgeE1pbiA9IEluZmluaXR5LCB4TWF4ID0gLUluZmluaXR5LCB5TWluID0gSW5maW5pdHksIHlNYXggPSAtSW5maW5pdHksIGEsIGIsIGMsIGksIGosIGssIG47XG4gICAgZnVuY3Rpb24gYm91bmQobm9kZSkge1xuICAgICAgeE1pbiA9IE1hdGgubWluKG5vZGUueCAtIG5vZGUuciwgeE1pbik7XG4gICAgICB4TWF4ID0gTWF0aC5tYXgobm9kZS54ICsgbm9kZS5yLCB4TWF4KTtcbiAgICAgIHlNaW4gPSBNYXRoLm1pbihub2RlLnkgLSBub2RlLnIsIHlNaW4pO1xuICAgICAgeU1heCA9IE1hdGgubWF4KG5vZGUueSArIG5vZGUuciwgeU1heCk7XG4gICAgfVxuICAgIG5vZGVzLmZvckVhY2goZDNfbGF5b3V0X3BhY2tMaW5rKTtcbiAgICBhID0gbm9kZXNbMF07XG4gICAgYS54ID0gLWEucjtcbiAgICBhLnkgPSAwO1xuICAgIGJvdW5kKGEpO1xuICAgIGlmIChuID4gMSkge1xuICAgICAgYiA9IG5vZGVzWzFdO1xuICAgICAgYi54ID0gYi5yO1xuICAgICAgYi55ID0gMDtcbiAgICAgIGJvdW5kKGIpO1xuICAgICAgaWYgKG4gPiAyKSB7XG4gICAgICAgIGMgPSBub2Rlc1syXTtcbiAgICAgICAgZDNfbGF5b3V0X3BhY2tQbGFjZShhLCBiLCBjKTtcbiAgICAgICAgYm91bmQoYyk7XG4gICAgICAgIGQzX2xheW91dF9wYWNrSW5zZXJ0KGEsIGMpO1xuICAgICAgICBhLl9wYWNrX3ByZXYgPSBjO1xuICAgICAgICBkM19sYXlvdXRfcGFja0luc2VydChjLCBiKTtcbiAgICAgICAgYiA9IGEuX3BhY2tfbmV4dDtcbiAgICAgICAgZm9yIChpID0gMzsgaSA8IG47IGkrKykge1xuICAgICAgICAgIGQzX2xheW91dF9wYWNrUGxhY2UoYSwgYiwgYyA9IG5vZGVzW2ldKTtcbiAgICAgICAgICB2YXIgaXNlY3QgPSAwLCBzMSA9IDEsIHMyID0gMTtcbiAgICAgICAgICBmb3IgKGogPSBiLl9wYWNrX25leHQ7IGogIT09IGI7IGogPSBqLl9wYWNrX25leHQsIHMxKyspIHtcbiAgICAgICAgICAgIGlmIChkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoaiwgYykpIHtcbiAgICAgICAgICAgICAgaXNlY3QgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzZWN0ID09IDEpIHtcbiAgICAgICAgICAgIGZvciAoayA9IGEuX3BhY2tfcHJldjsgayAhPT0gai5fcGFja19wcmV2OyBrID0gay5fcGFja19wcmV2LCBzMisrKSB7XG4gICAgICAgICAgICAgIGlmIChkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoaywgYykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNlY3QpIHtcbiAgICAgICAgICAgIGlmIChzMSA8IHMyIHx8IHMxID09IHMyICYmIGIuciA8IGEucikgZDNfbGF5b3V0X3BhY2tTcGxpY2UoYSwgYiA9IGopOyBlbHNlIGQzX2xheW91dF9wYWNrU3BsaWNlKGEgPSBrLCBiKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDNfbGF5b3V0X3BhY2tJbnNlcnQoYSwgYyk7XG4gICAgICAgICAgICBiID0gYztcbiAgICAgICAgICAgIGJvdW5kKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY3ggPSAoeE1pbiArIHhNYXgpIC8gMiwgY3kgPSAoeU1pbiArIHlNYXgpIC8gMiwgY3IgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGMgPSBub2Rlc1tpXTtcbiAgICAgIGMueCAtPSBjeDtcbiAgICAgIGMueSAtPSBjeTtcbiAgICAgIGNyID0gTWF0aC5tYXgoY3IsIGMuciArIE1hdGguc3FydChjLnggKiBjLnggKyBjLnkgKiBjLnkpKTtcbiAgICB9XG4gICAgbm9kZS5yID0gY3I7XG4gICAgbm9kZXMuZm9yRWFjaChkM19sYXlvdXRfcGFja1VubGluayk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tMaW5rKG5vZGUpIHtcbiAgICBub2RlLl9wYWNrX25leHQgPSBub2RlLl9wYWNrX3ByZXYgPSBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrVW5saW5rKG5vZGUpIHtcbiAgICBkZWxldGUgbm9kZS5fcGFja19uZXh0O1xuICAgIGRlbGV0ZSBub2RlLl9wYWNrX3ByZXY7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tUcmFuc2Zvcm0obm9kZSwgeCwgeSwgaykge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgbm9kZS54ID0geCArPSBrICogbm9kZS54O1xuICAgIG5vZGUueSA9IHkgKz0gayAqIG5vZGUueTtcbiAgICBub2RlLnIgKj0gaztcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfbGF5b3V0X3BhY2tUcmFuc2Zvcm0oY2hpbGRyZW5baV0sIHgsIHksIGspO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1BsYWNlKGEsIGIsIGMpIHtcbiAgICB2YXIgZGIgPSBhLnIgKyBjLnIsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgICBpZiAoZGIgJiYgKGR4IHx8IGR5KSkge1xuICAgICAgdmFyIGRhID0gYi5yICsgYy5yLCBkYyA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgZGEgKj0gZGE7XG4gICAgICBkYiAqPSBkYjtcbiAgICAgIHZhciB4ID0gLjUgKyAoZGIgLSBkYSkgLyAoMiAqIGRjKSwgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCAyICogZGEgKiAoZGIgKyBkYykgLSAoZGIgLT0gZGMpICogZGIgLSBkYSAqIGRhKSkgLyAoMiAqIGRjKTtcbiAgICAgIGMueCA9IGEueCArIHggKiBkeCArIHkgKiBkeTtcbiAgICAgIGMueSA9IGEueSArIHggKiBkeSAtIHkgKiBkeDtcbiAgICB9IGVsc2Uge1xuICAgICAgYy54ID0gYS54ICsgZGI7XG4gICAgICBjLnkgPSBhLnk7XG4gICAgfVxuICB9XG4gIGQzLmxheW91dC50cmVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKS5zb3J0KG51bGwpLnZhbHVlKG51bGwpLCBzZXBhcmF0aW9uID0gZDNfbGF5b3V0X3RyZWVTZXBhcmF0aW9uLCBzaXplID0gWyAxLCAxIF0sIG5vZGVTaXplID0gbnVsbDtcbiAgICBmdW5jdGlvbiB0cmVlKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpLCByb290MCA9IG5vZGVzWzBdLCByb290MSA9IHdyYXBUcmVlKHJvb3QwKTtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QxLCBmaXJzdFdhbGspLCByb290MS5wYXJlbnQubSA9IC1yb290MS56O1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QxLCBzZWNvbmRXYWxrKTtcbiAgICAgIGlmIChub2RlU2l6ZSkgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QwLCBzaXplTm9kZSk7IGVsc2Uge1xuICAgICAgICB2YXIgbGVmdCA9IHJvb3QwLCByaWdodCA9IHJvb3QwLCBib3R0b20gPSByb290MDtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QwLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUueCA8IGxlZnQueCkgbGVmdCA9IG5vZGU7XG4gICAgICAgICAgaWYgKG5vZGUueCA+IHJpZ2h0LngpIHJpZ2h0ID0gbm9kZTtcbiAgICAgICAgICBpZiAobm9kZS5kZXB0aCA+IGJvdHRvbS5kZXB0aCkgYm90dG9tID0gbm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0eCA9IHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMiAtIGxlZnQueCwga3ggPSBzaXplWzBdIC8gKHJpZ2h0LnggKyBzZXBhcmF0aW9uKHJpZ2h0LCBsZWZ0KSAvIDIgKyB0eCksIGt5ID0gc2l6ZVsxXSAvIChib3R0b20uZGVwdGggfHwgMSk7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290MCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIG5vZGUueCA9IChub2RlLnggKyB0eCkgKiBreDtcbiAgICAgICAgICBub2RlLnkgPSBub2RlLmRlcHRoICoga3k7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cmFwVHJlZShyb290MCkge1xuICAgICAgdmFyIHJvb3QxID0ge1xuICAgICAgICBBOiBudWxsLFxuICAgICAgICBjaGlsZHJlbjogWyByb290MCBdXG4gICAgICB9LCBxdWV1ZSA9IFsgcm9vdDEgXSwgbm9kZTE7XG4gICAgICB3aGlsZSAoKG5vZGUxID0gcXVldWUucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRyZW4gPSBub2RlMS5jaGlsZHJlbiwgY2hpbGQsIGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgcXVldWUucHVzaCgoY2hpbGRyZW5baV0gPSBjaGlsZCA9IHtcbiAgICAgICAgICAgIF86IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgcGFyZW50OiBub2RlMSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAoY2hpbGQgPSBjaGlsZHJlbltpXS5jaGlsZHJlbikgJiYgY2hpbGQuc2xpY2UoKSB8fCBbXSxcbiAgICAgICAgICAgIEE6IG51bGwsXG4gICAgICAgICAgICBhOiBudWxsLFxuICAgICAgICAgICAgejogMCxcbiAgICAgICAgICAgIG06IDAsXG4gICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgIHQ6IG51bGwsXG4gICAgICAgICAgICBpOiBpXG4gICAgICAgICAgfSkuYSA9IGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvb3QxLmNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaXJzdFdhbGsodikge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbiwgc2libGluZ3MgPSB2LnBhcmVudC5jaGlsZHJlbiwgdyA9IHYuaSA/IHNpYmxpbmdzW3YuaSAtIDFdIDogbnVsbDtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgZDNfbGF5b3V0X3RyZWVTaGlmdCh2KTtcbiAgICAgICAgdmFyIG1pZHBvaW50ID0gKGNoaWxkcmVuWzBdLnogKyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS56KSAvIDI7XG4gICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICAgICAgdi5tID0gdi56IC0gbWlkcG9pbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdi56ID0gbWlkcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodykge1xuICAgICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICAgIH1cbiAgICAgIHYucGFyZW50LkEgPSBhcHBvcnRpb24odiwgdywgdi5wYXJlbnQuQSB8fCBzaWJsaW5nc1swXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlY29uZFdhbGsodikge1xuICAgICAgdi5fLnggPSB2LnogKyB2LnBhcmVudC5tO1xuICAgICAgdi5tICs9IHYucGFyZW50Lm07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcG9ydGlvbih2LCB3LCBhbmNlc3Rvcikge1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgdmFyIHZpcCA9IHYsIHZvcCA9IHYsIHZpbSA9IHcsIHZvbSA9IHZpcC5wYXJlbnQuY2hpbGRyZW5bMF0sIHNpcCA9IHZpcC5tLCBzb3AgPSB2b3AubSwgc2ltID0gdmltLm0sIHNvbSA9IHZvbS5tLCBzaGlmdDtcbiAgICAgICAgd2hpbGUgKHZpbSA9IGQzX2xheW91dF90cmVlUmlnaHQodmltKSwgdmlwID0gZDNfbGF5b3V0X3RyZWVMZWZ0KHZpcCksIHZpbSAmJiB2aXApIHtcbiAgICAgICAgICB2b20gPSBkM19sYXlvdXRfdHJlZUxlZnQodm9tKTtcbiAgICAgICAgICB2b3AgPSBkM19sYXlvdXRfdHJlZVJpZ2h0KHZvcCk7XG4gICAgICAgICAgdm9wLmEgPSB2O1xuICAgICAgICAgIHNoaWZ0ID0gdmltLnogKyBzaW0gLSB2aXAueiAtIHNpcCArIHNlcGFyYXRpb24odmltLl8sIHZpcC5fKTtcbiAgICAgICAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICAgICAgICBkM19sYXlvdXRfdHJlZU1vdmUoZDNfbGF5b3V0X3RyZWVBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICAgICAgc2lwICs9IHNoaWZ0O1xuICAgICAgICAgICAgc29wICs9IHNoaWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaW0gKz0gdmltLm07XG4gICAgICAgICAgc2lwICs9IHZpcC5tO1xuICAgICAgICAgIHNvbSArPSB2b20ubTtcbiAgICAgICAgICBzb3AgKz0gdm9wLm07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpbSAmJiAhZDNfbGF5b3V0X3RyZWVSaWdodCh2b3ApKSB7XG4gICAgICAgICAgdm9wLnQgPSB2aW07XG4gICAgICAgICAgdm9wLm0gKz0gc2ltIC0gc29wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXAgJiYgIWQzX2xheW91dF90cmVlTGVmdCh2b20pKSB7XG4gICAgICAgICAgdm9tLnQgPSB2aXA7XG4gICAgICAgICAgdm9tLm0gKz0gc2lwIC0gc29tO1xuICAgICAgICAgIGFuY2VzdG9yID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFuY2VzdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaXplTm9kZShub2RlKSB7XG4gICAgICBub2RlLnggKj0gc2l6ZVswXTtcbiAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBzaXplWzFdO1xuICAgIH1cbiAgICB0cmVlLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzZXBhcmF0aW9uO1xuICAgICAgc2VwYXJhdGlvbiA9IHg7XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9O1xuICAgIHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gbnVsbCA6IHNpemU7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgPT0gbnVsbCA/IHNpemVOb2RlIDogbnVsbDtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH07XG4gICAgdHJlZS5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gc2l6ZSA6IG51bGw7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgPT0gbnVsbCA/IG51bGwgOiBzaXplTm9kZTtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQodHJlZSwgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVTZXBhcmF0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wYXJlbnQgPT0gYi5wYXJlbnQgPyAxIDogMjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZUxlZnQodikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuWzBdIDogdi50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlUmlnaHQodikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sIG47XG4gICAgcmV0dXJuIChuID0gY2hpbGRyZW4ubGVuZ3RoKSA/IGNoaWxkcmVuW24gLSAxXSA6IHYudDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZU1vdmUod20sIHdwLCBzaGlmdCkge1xuICAgIHZhciBjaGFuZ2UgPSBzaGlmdCAvICh3cC5pIC0gd20uaSk7XG4gICAgd3AuYyAtPSBjaGFuZ2U7XG4gICAgd3AucyArPSBzaGlmdDtcbiAgICB3bS5jICs9IGNoYW5nZTtcbiAgICB3cC56ICs9IHNoaWZ0O1xuICAgIHdwLm0gKz0gc2hpZnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVTaGlmdCh2KSB7XG4gICAgdmFyIHNoaWZ0ID0gMCwgY2hhbmdlID0gMCwgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLCBpID0gY2hpbGRyZW4ubGVuZ3RoLCB3O1xuICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgdyA9IGNoaWxkcmVuW2ldO1xuICAgICAgdy56ICs9IHNoaWZ0O1xuICAgICAgdy5tICs9IHNoaWZ0O1xuICAgICAgc2hpZnQgKz0gdy5zICsgKGNoYW5nZSArPSB3LmMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZUFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpIHtcbiAgICByZXR1cm4gdmltLmEucGFyZW50ID09PSB2LnBhcmVudCA/IHZpbS5hIDogYW5jZXN0b3I7XG4gIH1cbiAgZDMubGF5b3V0LmNsdXN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLnNvcnQobnVsbCkudmFsdWUobnVsbCksIHNlcGFyYXRpb24gPSBkM19sYXlvdXRfdHJlZVNlcGFyYXRpb24sIHNpemUgPSBbIDEsIDEgXSwgbm9kZVNpemUgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjbHVzdGVyKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpLCByb290ID0gbm9kZXNbMF0sIHByZXZpb3VzTm9kZSwgeCA9IDA7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlLnggPSBkM19sYXlvdXRfY2x1c3RlclgoY2hpbGRyZW4pO1xuICAgICAgICAgIG5vZGUueSA9IGQzX2xheW91dF9jbHVzdGVyWShjaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS54ID0gcHJldmlvdXNOb2RlID8geCArPSBzZXBhcmF0aW9uKG5vZGUsIHByZXZpb3VzTm9kZSkgOiAwO1xuICAgICAgICAgIG5vZGUueSA9IDA7XG4gICAgICAgICAgcHJldmlvdXNOb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgbGVmdCA9IGQzX2xheW91dF9jbHVzdGVyTGVmdChyb290KSwgcmlnaHQgPSBkM19sYXlvdXRfY2x1c3RlclJpZ2h0KHJvb3QpLCB4MCA9IGxlZnQueCAtIHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMiwgeDEgPSByaWdodC54ICsgc2VwYXJhdGlvbihyaWdodCwgbGVmdCkgLyAyO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgbm9kZVNpemUgPyBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUueCA9IChub2RlLnggLSByb290LngpICogc2l6ZVswXTtcbiAgICAgICAgbm9kZS55ID0gKHJvb3QueSAtIG5vZGUueSkgKiBzaXplWzFdO1xuICAgICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHgwKSAvICh4MSAtIHgwKSAqIHNpemVbMF07XG4gICAgICAgIG5vZGUueSA9ICgxIC0gKHJvb3QueSA/IG5vZGUueSAvIHJvb3QueSA6IDEpKSAqIHNpemVbMV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgY2x1c3Rlci5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2VwYXJhdGlvbjtcbiAgICAgIHNlcGFyYXRpb24gPSB4O1xuICAgICAgcmV0dXJuIGNsdXN0ZXI7XG4gICAgfTtcbiAgICBjbHVzdGVyLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IG51bGwgOiBzaXplO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpID09IG51bGw7XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9O1xuICAgIGNsdXN0ZXIubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IHNpemUgOiBudWxsO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpICE9IG51bGw7XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKGNsdXN0ZXIsIGhpZXJhcmNoeSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyWShjaGlsZHJlbikge1xuICAgIHJldHVybiAxICsgZDMubWF4KGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJYKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbih4LCBjaGlsZCkge1xuICAgICAgcmV0dXJuIHggKyBjaGlsZC54O1xuICAgIH0sIDApIC8gY2hpbGRyZW4ubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyTGVmdChub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID8gZDNfbGF5b3V0X2NsdXN0ZXJMZWZ0KGNoaWxkcmVuWzBdKSA6IG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJSaWdodChub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiwgbjtcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpID8gZDNfbGF5b3V0X2NsdXN0ZXJSaWdodChjaGlsZHJlbltuIC0gMV0pIDogbm9kZTtcbiAgfVxuICBkMy5sYXlvdXQudHJlZW1hcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCksIHJvdW5kID0gTWF0aC5yb3VuZCwgc2l6ZSA9IFsgMSwgMSBdLCBwYWRkaW5nID0gbnVsbCwgcGFkID0gZDNfbGF5b3V0X3RyZWVtYXBQYWROdWxsLCBzdGlja3kgPSBmYWxzZSwgc3RpY2tpZXMsIG1vZGUgPSBcInNxdWFyaWZ5XCIsIHJhdGlvID0gLjUgKiAoMSArIE1hdGguc3FydCg1KSk7XG4gICAgZnVuY3Rpb24gc2NhbGUoY2hpbGRyZW4sIGspIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBjaGlsZHJlbi5sZW5ndGgsIGNoaWxkLCBhcmVhO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYXJlYSA9IChjaGlsZCA9IGNoaWxkcmVuW2ldKS52YWx1ZSAqIChrIDwgMCA/IDAgOiBrKTtcbiAgICAgICAgY2hpbGQuYXJlYSA9IGlzTmFOKGFyZWEpIHx8IGFyZWEgPD0gMCA/IDAgOiBhcmVhO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzcXVhcmlmeShub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmVjdCA9IHBhZChub2RlKSwgcm93ID0gW10sIHJlbWFpbmluZyA9IGNoaWxkcmVuLnNsaWNlKCksIGNoaWxkLCBiZXN0ID0gSW5maW5pdHksIHNjb3JlLCB1ID0gbW9kZSA9PT0gXCJzbGljZVwiID8gcmVjdC5keCA6IG1vZGUgPT09IFwiZGljZVwiID8gcmVjdC5keSA6IG1vZGUgPT09IFwic2xpY2UtZGljZVwiID8gbm9kZS5kZXB0aCAmIDEgPyByZWN0LmR5IDogcmVjdC5keCA6IE1hdGgubWluKHJlY3QuZHgsIHJlY3QuZHkpLCBuO1xuICAgICAgICBzY2FsZShyZW1haW5pbmcsIHJlY3QuZHggKiByZWN0LmR5IC8gbm9kZS52YWx1ZSk7XG4gICAgICAgIHJvdy5hcmVhID0gMDtcbiAgICAgICAgd2hpbGUgKChuID0gcmVtYWluaW5nLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgcm93LnB1c2goY2hpbGQgPSByZW1haW5pbmdbbiAtIDFdKTtcbiAgICAgICAgICByb3cuYXJlYSArPSBjaGlsZC5hcmVhO1xuICAgICAgICAgIGlmIChtb2RlICE9PSBcInNxdWFyaWZ5XCIgfHwgKHNjb3JlID0gd29yc3Qocm93LCB1KSkgPD0gYmVzdCkge1xuICAgICAgICAgICAgcmVtYWluaW5nLnBvcCgpO1xuICAgICAgICAgICAgYmVzdCA9IHNjb3JlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3cuYXJlYSAtPSByb3cucG9wKCkuYXJlYTtcbiAgICAgICAgICAgIHBvc2l0aW9uKHJvdywgdSwgcmVjdCwgZmFsc2UpO1xuICAgICAgICAgICAgdSA9IE1hdGgubWluKHJlY3QuZHgsIHJlY3QuZHkpO1xuICAgICAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgICAgIGJlc3QgPSBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdy5sZW5ndGgpIHtcbiAgICAgICAgICBwb3NpdGlvbihyb3csIHUsIHJlY3QsIHRydWUpO1xuICAgICAgICAgIHJvdy5sZW5ndGggPSByb3cuYXJlYSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChzcXVhcmlmeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0aWNraWZ5KG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWN0ID0gcGFkKG5vZGUpLCByZW1haW5pbmcgPSBjaGlsZHJlbi5zbGljZSgpLCBjaGlsZCwgcm93ID0gW107XG4gICAgICAgIHNjYWxlKHJlbWFpbmluZywgcmVjdC5keCAqIHJlY3QuZHkgLyBub2RlLnZhbHVlKTtcbiAgICAgICAgcm93LmFyZWEgPSAwO1xuICAgICAgICB3aGlsZSAoY2hpbGQgPSByZW1haW5pbmcucG9wKCkpIHtcbiAgICAgICAgICByb3cucHVzaChjaGlsZCk7XG4gICAgICAgICAgcm93LmFyZWEgKz0gY2hpbGQuYXJlYTtcbiAgICAgICAgICBpZiAoY2hpbGQueiAhPSBudWxsKSB7XG4gICAgICAgICAgICBwb3NpdGlvbihyb3csIGNoaWxkLnogPyByZWN0LmR4IDogcmVjdC5keSwgcmVjdCwgIXJlbWFpbmluZy5sZW5ndGgpO1xuICAgICAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChzdGlja2lmeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdvcnN0KHJvdywgdSkge1xuICAgICAgdmFyIHMgPSByb3cuYXJlYSwgciwgcm1heCA9IDAsIHJtaW4gPSBJbmZpbml0eSwgaSA9IC0xLCBuID0gcm93Lmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmICghKHIgPSByb3dbaV0uYXJlYSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAociA8IHJtaW4pIHJtaW4gPSByO1xuICAgICAgICBpZiAociA+IHJtYXgpIHJtYXggPSByO1xuICAgICAgfVxuICAgICAgcyAqPSBzO1xuICAgICAgdSAqPSB1O1xuICAgICAgcmV0dXJuIHMgPyBNYXRoLm1heCh1ICogcm1heCAqIHJhdGlvIC8gcywgcyAvICh1ICogcm1pbiAqIHJhdGlvKSkgOiBJbmZpbml0eTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9zaXRpb24ocm93LCB1LCByZWN0LCBmbHVzaCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHJvdy5sZW5ndGgsIHggPSByZWN0LngsIHkgPSByZWN0LnksIHYgPSB1ID8gcm91bmQocm93LmFyZWEgLyB1KSA6IDAsIG87XG4gICAgICBpZiAodSA9PSByZWN0LmR4KSB7XG4gICAgICAgIGlmIChmbHVzaCB8fCB2ID4gcmVjdC5keSkgdiA9IHJlY3QuZHk7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgbyA9IHJvd1tpXTtcbiAgICAgICAgICBvLnggPSB4O1xuICAgICAgICAgIG8ueSA9IHk7XG4gICAgICAgICAgby5keSA9IHY7XG4gICAgICAgICAgeCArPSBvLmR4ID0gTWF0aC5taW4ocmVjdC54ICsgcmVjdC5keCAtIHgsIHYgPyByb3VuZChvLmFyZWEgLyB2KSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIG8ueiA9IHRydWU7XG4gICAgICAgIG8uZHggKz0gcmVjdC54ICsgcmVjdC5keCAtIHg7XG4gICAgICAgIHJlY3QueSArPSB2O1xuICAgICAgICByZWN0LmR5IC09IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmx1c2ggfHwgdiA+IHJlY3QuZHgpIHYgPSByZWN0LmR4O1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIG8gPSByb3dbaV07XG4gICAgICAgICAgby54ID0geDtcbiAgICAgICAgICBvLnkgPSB5O1xuICAgICAgICAgIG8uZHggPSB2O1xuICAgICAgICAgIHkgKz0gby5keSA9IE1hdGgubWluKHJlY3QueSArIHJlY3QuZHkgLSB5LCB2ID8gcm91bmQoby5hcmVhIC8gdikgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBvLnogPSBmYWxzZTtcbiAgICAgICAgby5keSArPSByZWN0LnkgKyByZWN0LmR5IC0geTtcbiAgICAgICAgcmVjdC54ICs9IHY7XG4gICAgICAgIHJlY3QuZHggLT0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJlZW1hcChkKSB7XG4gICAgICB2YXIgbm9kZXMgPSBzdGlja2llcyB8fCBoaWVyYXJjaHkoZCksIHJvb3QgPSBub2Rlc1swXTtcbiAgICAgIHJvb3QueCA9IHJvb3QueSA9IDA7XG4gICAgICBpZiAocm9vdC52YWx1ZSkgcm9vdC5keCA9IHNpemVbMF0sIHJvb3QuZHkgPSBzaXplWzFdOyBlbHNlIHJvb3QuZHggPSByb290LmR5ID0gMDtcbiAgICAgIGlmIChzdGlja2llcykgaGllcmFyY2h5LnJldmFsdWUocm9vdCk7XG4gICAgICBzY2FsZShbIHJvb3QgXSwgcm9vdC5keCAqIHJvb3QuZHkgLyByb290LnZhbHVlKTtcbiAgICAgIChzdGlja2llcyA/IHN0aWNraWZ5IDogc3F1YXJpZnkpKHJvb3QpO1xuICAgICAgaWYgKHN0aWNreSkgc3RpY2tpZXMgPSBub2RlcztcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdHJlZW1hcC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSB4O1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRkaW5nO1xuICAgICAgZnVuY3Rpb24gcGFkRnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcCA9IHguY2FsbCh0cmVlbWFwLCBub2RlLCBub2RlLmRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHAgPT0gbnVsbCA/IGQzX2xheW91dF90cmVlbWFwUGFkTnVsbChub2RlKSA6IGQzX2xheW91dF90cmVlbWFwUGFkKG5vZGUsIHR5cGVvZiBwID09PSBcIm51bWJlclwiID8gWyBwLCBwLCBwLCBwIF0gOiBwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhZENvbnN0YW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGQzX2xheW91dF90cmVlbWFwUGFkKG5vZGUsIHgpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGU7XG4gICAgICBwYWQgPSAocGFkZGluZyA9IHgpID09IG51bGwgPyBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwgOiAodHlwZSA9IHR5cGVvZiB4KSA9PT0gXCJmdW5jdGlvblwiID8gcGFkRnVuY3Rpb24gOiB0eXBlID09PSBcIm51bWJlclwiID8gKHggPSBbIHgsIHgsIHgsIHggXSwgXG4gICAgICBwYWRDb25zdGFudCkgOiBwYWRDb25zdGFudDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJvdW5kICE9IE51bWJlcjtcbiAgICAgIHJvdW5kID0geCA/IE1hdGgucm91bmQgOiBOdW1iZXI7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAuc3RpY2t5ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RpY2t5O1xuICAgICAgc3RpY2t5ID0geDtcbiAgICAgIHN0aWNraWVzID0gbnVsbDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5yYXRpbyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhdGlvO1xuICAgICAgcmF0aW8gPSB4O1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLm1vZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtb2RlO1xuICAgICAgbW9kZSA9IHggKyBcIlwiO1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZCh0cmVlbWFwLCBoaWVyYXJjaHkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwobm9kZSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBub2RlLngsXG4gICAgICB5OiBub2RlLnksXG4gICAgICBkeDogbm9kZS5keCxcbiAgICAgIGR5OiBub2RlLmR5XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZW1hcFBhZChub2RlLCBwYWRkaW5nKSB7XG4gICAgdmFyIHggPSBub2RlLnggKyBwYWRkaW5nWzNdLCB5ID0gbm9kZS55ICsgcGFkZGluZ1swXSwgZHggPSBub2RlLmR4IC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sIGR5ID0gbm9kZS5keSAtIHBhZGRpbmdbMF0gLSBwYWRkaW5nWzJdO1xuICAgIGlmIChkeCA8IDApIHtcbiAgICAgIHggKz0gZHggLyAyO1xuICAgICAgZHggPSAwO1xuICAgIH1cbiAgICBpZiAoZHkgPCAwKSB7XG4gICAgICB5ICs9IGR5IC8gMjtcbiAgICAgIGR5ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgZHg6IGR4LFxuICAgICAgZHk6IGR5XG4gICAgfTtcbiAgfVxuICBkMy5yYW5kb20gPSB7XG4gICAgbm9ybWFsOiBmdW5jdGlvbijCtSwgz4MpIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChuIDwgMikgz4MgPSAxO1xuICAgICAgaWYgKG4gPCAxKSDCtSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4LCB5LCByO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgeCA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgICAgICB5ID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgICAgICAgIHIgPSB4ICogeCArIHkgKiB5O1xuICAgICAgICB9IHdoaWxlICghciB8fCByID4gMSk7XG4gICAgICAgIHJldHVybiDCtSArIM+DICogeCAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgbG9nTm9ybWFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYW5kb20gPSBkMy5yYW5kb20ubm9ybWFsLmFwcGx5KGQzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5leHAocmFuZG9tKCkpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGJhdGVzOiBmdW5jdGlvbihtKSB7XG4gICAgICB2YXIgcmFuZG9tID0gZDMucmFuZG9tLmlyd2luSGFsbChtKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRvbSgpIC8gbTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBpcndpbkhhbGw6IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGogPSAwOyBqIDwgbTsgaisrKSBzICs9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGQzLnNjYWxlID0ge307XG4gIGZ1bmN0aW9uIGQzX3NjYWxlRXh0ZW50KGRvbWFpbikge1xuICAgIHZhciBzdGFydCA9IGRvbWFpblswXSwgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHN0YXJ0IDwgc3RvcCA/IFsgc3RhcnQsIHN0b3AgXSA6IFsgc3RvcCwgc3RhcnQgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZVJhbmdlKHNjYWxlKSB7XG4gICAgcmV0dXJuIHNjYWxlLnJhbmdlRXh0ZW50ID8gc2NhbGUucmFuZ2VFeHRlbnQoKSA6IGQzX3NjYWxlRXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2JpbGluZWFyKGRvbWFpbiwgcmFuZ2UsIHVuaW50ZXJwb2xhdGUsIGludGVycG9sYXRlKSB7XG4gICAgdmFyIHUgPSB1bmludGVycG9sYXRlKGRvbWFpblswXSwgZG9tYWluWzFdKSwgaSA9IGludGVycG9sYXRlKHJhbmdlWzBdLCByYW5nZVsxXSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBpKHUoeCkpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbmljZShkb21haW4sIG5pY2UpIHtcbiAgICB2YXIgaTAgPSAwLCBpMSA9IGRvbWFpbi5sZW5ndGggLSAxLCB4MCA9IGRvbWFpbltpMF0sIHgxID0gZG9tYWluW2kxXSwgZHg7XG4gICAgaWYgKHgxIDwgeDApIHtcbiAgICAgIGR4ID0gaTAsIGkwID0gaTEsIGkxID0gZHg7XG4gICAgICBkeCA9IHgwLCB4MCA9IHgxLCB4MSA9IGR4O1xuICAgIH1cbiAgICBkb21haW5baTBdID0gbmljZS5mbG9vcih4MCk7XG4gICAgZG9tYWluW2kxXSA9IG5pY2UuY2VpbCh4MSk7XG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9uaWNlU3RlcChzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXAgPyB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih4IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh4IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgfVxuICAgIH0gOiBkM19zY2FsZV9uaWNlSWRlbnRpdHk7XG4gIH1cbiAgdmFyIGQzX3NjYWxlX25pY2VJZGVudGl0eSA9IHtcbiAgICBmbG9vcjogZDNfaWRlbnRpdHksXG4gICAgY2VpbDogZDNfaWRlbnRpdHlcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcG9seWxpbmVhcihkb21haW4sIHJhbmdlLCB1bmludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSkge1xuICAgIHZhciB1ID0gW10sIGkgPSBbXSwgaiA9IDAsIGsgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMTtcbiAgICBpZiAoZG9tYWluW2tdIDwgZG9tYWluWzBdKSB7XG4gICAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB3aGlsZSAoKytqIDw9IGspIHtcbiAgICAgIHUucHVzaCh1bmludGVycG9sYXRlKGRvbWFpbltqIC0gMV0sIGRvbWFpbltqXSkpO1xuICAgICAgaS5wdXNoKGludGVycG9sYXRlKHJhbmdlW2ogLSAxXSwgcmFuZ2Vbal0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBqID0gZDMuYmlzZWN0KGRvbWFpbiwgeCwgMSwgaykgLSAxO1xuICAgICAgcmV0dXJuIGlbal0odVtqXSh4KSk7XG4gICAgfTtcbiAgfVxuICBkMy5zY2FsZS5saW5lYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyKFsgMCwgMSBdLCBbIDAsIDEgXSwgZDNfaW50ZXJwb2xhdGUsIGZhbHNlKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlLCBjbGFtcCkge1xuICAgIHZhciBvdXRwdXQsIGlucHV0O1xuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICB2YXIgbGluZWFyID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSA+IDIgPyBkM19zY2FsZV9wb2x5bGluZWFyIDogZDNfc2NhbGVfYmlsaW5lYXIsIHVuaW50ZXJwb2xhdGUgPSBjbGFtcCA/IGQzX3VuaW50ZXJwb2xhdGVDbGFtcCA6IGQzX3VuaW50ZXJwb2xhdGVOdW1iZXI7XG4gICAgICBvdXRwdXQgPSBsaW5lYXIoZG9tYWluLCByYW5nZSwgdW5pbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUpO1xuICAgICAgaW5wdXQgPSBsaW5lYXIocmFuZ2UsIGRvbWFpbiwgdW5pbnRlcnBvbGF0ZSwgZDNfaW50ZXJwb2xhdGUpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gb3V0cHV0KHgpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gaW5wdXQoeSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSB4Lm1hcChOdW1iZXIpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBzY2FsZS5yYW5nZSh4KS5pbnRlcnBvbGF0ZShkM19pbnRlcnBvbGF0ZVJvdW5kKTtcbiAgICB9O1xuICAgIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xhbXA7XG4gICAgICBjbGFtcCA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgICAgIGludGVycG9sYXRlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG0sIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpO1xuICAgIH07XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIGQzX3NjYWxlX2xpbmVhck5pY2UoZG9tYWluLCBtKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlLCBjbGFtcCk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKSB7XG4gICAgcmV0dXJuIGQzLnJlYmluZChzY2FsZSwgbGluZWFyLCBcInJhbmdlXCIsIFwicmFuZ2VSb3VuZFwiLCBcImludGVycG9sYXRlXCIsIFwiY2xhbXBcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyTmljZShkb21haW4sIG0pIHtcbiAgICBkM19zY2FsZV9uaWNlKGRvbWFpbiwgZDNfc2NhbGVfbmljZVN0ZXAoZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSlbMl0pKTtcbiAgICBkM19zY2FsZV9uaWNlKGRvbWFpbiwgZDNfc2NhbGVfbmljZVN0ZXAoZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSlbMl0pKTtcbiAgICByZXR1cm4gZG9tYWluO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pIHtcbiAgICBpZiAobSA9PSBudWxsKSBtID0gMTA7XG4gICAgdmFyIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KGRvbWFpbiksIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF0sIHN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhzcGFuIC8gbSkgLyBNYXRoLkxOMTApKSwgZXJyID0gbSAvIHNwYW4gKiBzdGVwO1xuICAgIGlmIChlcnIgPD0gLjE1KSBzdGVwICo9IDEwOyBlbHNlIGlmIChlcnIgPD0gLjM1KSBzdGVwICo9IDU7IGVsc2UgaWYgKGVyciA8PSAuNzUpIHN0ZXAgKj0gMjtcbiAgICBleHRlbnRbMF0gPSBNYXRoLmNlaWwoZXh0ZW50WzBdIC8gc3RlcCkgKiBzdGVwO1xuICAgIGV4dGVudFsxXSA9IE1hdGguZmxvb3IoZXh0ZW50WzFdIC8gc3RlcCkgKiBzdGVwICsgc3RlcCAqIC41O1xuICAgIGV4dGVudFsyXSA9IHN0ZXA7XG4gICAgcmV0dXJuIGV4dGVudDtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pIHtcbiAgICByZXR1cm4gZDMucmFuZ2UuYXBwbHkoZDMsIGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KSB7XG4gICAgdmFyIHJhbmdlID0gZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSk7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgdmFyIG1hdGNoID0gZDNfZm9ybWF0X3JlLmV4ZWMoZm9ybWF0KTtcbiAgICAgIG1hdGNoLnNoaWZ0KCk7XG4gICAgICBpZiAobWF0Y2hbOF0gPT09IFwic1wiKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBkMy5mb3JtYXRQcmVmaXgoTWF0aC5tYXgoYWJzKHJhbmdlWzBdKSwgYWJzKHJhbmdlWzFdKSkpO1xuICAgICAgICBpZiAoIW1hdGNoWzddKSBtYXRjaFs3XSA9IFwiLlwiICsgZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHByZWZpeC5zY2FsZShyYW5nZVsyXSkpO1xuICAgICAgICBtYXRjaFs4XSA9IFwiZlwiO1xuICAgICAgICBmb3JtYXQgPSBkMy5mb3JtYXQobWF0Y2guam9pbihcIlwiKSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdChwcmVmaXguc2NhbGUoZCkpICsgcHJlZml4LnN5bWJvbDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF0Y2hbN10pIG1hdGNoWzddID0gXCIuXCIgKyBkM19zY2FsZV9saW5lYXJGb3JtYXRQcmVjaXNpb24obWF0Y2hbOF0sIHJhbmdlKTtcbiAgICAgIGZvcm1hdCA9IG1hdGNoLmpvaW4oXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1hdCA9IFwiLC5cIiArIGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihyYW5nZVsyXSkgKyBcImZcIjtcbiAgICB9XG4gICAgcmV0dXJuIGQzLmZvcm1hdChmb3JtYXQpO1xuICB9XG4gIHZhciBkM19zY2FsZV9saW5lYXJGb3JtYXRTaWduaWZpY2FudCA9IHtcbiAgICBzOiAxLFxuICAgIGc6IDEsXG4gICAgcDogMSxcbiAgICByOiAxLFxuICAgIGU6IDFcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIC1NYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMCArIC4wMSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyRm9ybWF0UHJlY2lzaW9uKHR5cGUsIHJhbmdlKSB7XG4gICAgdmFyIHAgPSBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24ocmFuZ2VbMl0pO1xuICAgIHJldHVybiB0eXBlIGluIGQzX3NjYWxlX2xpbmVhckZvcm1hdFNpZ25pZmljYW50ID8gTWF0aC5hYnMocCAtIGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihNYXRoLm1heChhYnMocmFuZ2VbMF0pLCBhYnMocmFuZ2VbMV0pKSkpICsgKyh0eXBlICE9PSBcImVcIikgOiBwIC0gKHR5cGUgPT09IFwiJVwiKSAqIDI7XG4gIH1cbiAgZDMuc2NhbGUubG9nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xvZyhkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oWyAwLCAxIF0pLCAxMCwgdHJ1ZSwgWyAxLCAxMCBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfbG9nKGxpbmVhciwgYmFzZSwgcG9zaXRpdmUsIGRvbWFpbikge1xuICAgIGZ1bmN0aW9uIGxvZyh4KSB7XG4gICAgICByZXR1cm4gKHBvc2l0aXZlID8gTWF0aC5sb2coeCA8IDAgPyAwIDogeCkgOiAtTWF0aC5sb2coeCA+IDAgPyAwIDogLXgpKSAvIE1hdGgubG9nKGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3coeCkge1xuICAgICAgcmV0dXJuIHBvc2l0aXZlID8gTWF0aC5wb3coYmFzZSwgeCkgOiAtTWF0aC5wb3coYmFzZSwgLXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gbGluZWFyKGxvZyh4KSk7XG4gICAgfVxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBwb3cobGluZWFyLmludmVydCh4KSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBwb3NpdGl2ZSA9IHhbMF0gPj0gMDtcbiAgICAgIGxpbmVhci5kb21haW4oKGRvbWFpbiA9IHgubWFwKE51bWJlcikpLm1hcChsb2cpKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLmJhc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiYXNlO1xuICAgICAgYmFzZSA9ICtfO1xuICAgICAgbGluZWFyLmRvbWFpbihkb21haW4ubWFwKGxvZykpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5pY2VkID0gZDNfc2NhbGVfbmljZShkb21haW4ubWFwKGxvZyksIHBvc2l0aXZlID8gTWF0aCA6IGQzX3NjYWxlX2xvZ05pY2VOZWdhdGl2ZSk7XG4gICAgICBsaW5lYXIuZG9tYWluKG5pY2VkKTtcbiAgICAgIGRvbWFpbiA9IG5pY2VkLm1hcChwb3cpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBleHRlbnQgPSBkM19zY2FsZUV4dGVudChkb21haW4pLCB0aWNrcyA9IFtdLCB1ID0gZXh0ZW50WzBdLCB2ID0gZXh0ZW50WzFdLCBpID0gTWF0aC5mbG9vcihsb2codSkpLCBqID0gTWF0aC5jZWlsKGxvZyh2KSksIG4gPSBiYXNlICUgMSA/IDIgOiBiYXNlO1xuICAgICAgaWYgKGlzRmluaXRlKGogLSBpKSkge1xuICAgICAgICBpZiAocG9zaXRpdmUpIHtcbiAgICAgICAgICBmb3IgKDtpIDwgajsgaSsrKSBmb3IgKHZhciBrID0gMTsgayA8IG47IGsrKykgdGlja3MucHVzaChwb3coaSkgKiBrKTtcbiAgICAgICAgICB0aWNrcy5wdXNoKHBvdyhpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja3MucHVzaChwb3coaSkpO1xuICAgICAgICAgIGZvciAoO2krKyA8IGo7ICkgZm9yICh2YXIgayA9IG4gLSAxOyBrID4gMDsgay0tKSB0aWNrcy5wdXNoKHBvdyhpKSAqIGspO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IHRpY2tzW2ldIDwgdTsgaSsrKSB7fVxuICAgICAgICBmb3IgKGogPSB0aWNrcy5sZW5ndGg7IHRpY2tzW2ogLSAxXSA+IHY7IGotLSkge31cbiAgICAgICAgdGlja3MgPSB0aWNrcy5zbGljZShpLCBqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aWNrcztcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihuLCBmb3JtYXQpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGQzX3NjYWxlX2xvZ0Zvcm1hdDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgZm9ybWF0ID0gZDNfc2NhbGVfbG9nRm9ybWF0OyBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9PSBcImZ1bmN0aW9uXCIpIGZvcm1hdCA9IGQzLmZvcm1hdChmb3JtYXQpO1xuICAgICAgdmFyIGsgPSBNYXRoLm1heCgxLCBiYXNlICogbiAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBpID0gZCAvIHBvdyhNYXRoLnJvdW5kKGxvZyhkKSkpO1xuICAgICAgICBpZiAoaSAqIGJhc2UgPCBiYXNlIC0gLjUpIGkgKj0gYmFzZTtcbiAgICAgICAgcmV0dXJuIGkgPD0gayA/IGZvcm1hdChkKSA6IFwiXCI7XG4gICAgICB9O1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xvZyhsaW5lYXIuY29weSgpLCBiYXNlLCBwb3NpdGl2ZSwgZG9tYWluKTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcik7XG4gIH1cbiAgdmFyIGQzX3NjYWxlX2xvZ0Zvcm1hdCA9IGQzLmZvcm1hdChcIi4wZVwiKSwgZDNfc2NhbGVfbG9nTmljZU5lZ2F0aXZlID0ge1xuICAgIGZsb29yOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gLU1hdGguY2VpbCgteCk7XG4gICAgfSxcbiAgICBjZWlsOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gLU1hdGguZmxvb3IoLXgpO1xuICAgIH1cbiAgfTtcbiAgZDMuc2NhbGUucG93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX3BvdyhkMy5zY2FsZS5saW5lYXIoKSwgMSwgWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9wb3cobGluZWFyLCBleHBvbmVudCwgZG9tYWluKSB7XG4gICAgdmFyIHBvd3AgPSBkM19zY2FsZV9wb3dQb3coZXhwb25lbnQpLCBwb3diID0gZDNfc2NhbGVfcG93UG93KDEgLyBleHBvbmVudCk7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIGxpbmVhcihwb3dwKHgpKTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHBvd2IobGluZWFyLmludmVydCh4KSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBsaW5lYXIuZG9tYWluKChkb21haW4gPSB4Lm1hcChOdW1iZXIpKS5tYXAocG93cCkpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja3MoZG9tYWluLCBtKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihtLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gc2NhbGUuZG9tYWluKGQzX3NjYWxlX2xpbmVhck5pY2UoZG9tYWluLCBtKSk7XG4gICAgfTtcbiAgICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGV4cG9uZW50O1xuICAgICAgcG93cCA9IGQzX3NjYWxlX3Bvd1BvdyhleHBvbmVudCA9IHgpO1xuICAgICAgcG93YiA9IGQzX3NjYWxlX3Bvd1BvdygxIC8gZXhwb25lbnQpO1xuICAgICAgbGluZWFyLmRvbWFpbihkb21haW4ubWFwKHBvd3ApKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9wb3cobGluZWFyLmNvcHkoKSwgZXhwb25lbnQsIGRvbWFpbik7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyUmViaW5kKHNjYWxlLCBsaW5lYXIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3Bvd1BvdyhlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZSkgOiBNYXRoLnBvdyh4LCBlKTtcbiAgICB9O1xuICB9XG4gIGQzLnNjYWxlLnNxcnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUucG93KCkuZXhwb25lbnQoLjUpO1xuICB9O1xuICBkMy5zY2FsZS5vcmRpbmFsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX29yZGluYWwoW10sIHtcbiAgICAgIHQ6IFwicmFuZ2VcIixcbiAgICAgIGE6IFsgW10gXVxuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9vcmRpbmFsKGRvbWFpbiwgcmFuZ2VyKSB7XG4gICAgdmFyIGluZGV4LCByYW5nZSwgcmFuZ2VCYW5kO1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiByYW5nZVsoKGluZGV4LmdldCh4KSB8fCAocmFuZ2VyLnQgPT09IFwicmFuZ2VcIiA/IGluZGV4LnNldCh4LCBkb21haW4ucHVzaCh4KSkgOiBOYU4pKSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcHMoc3RhcnQsIHN0ZXApIHtcbiAgICAgIHJldHVybiBkMy5yYW5nZShkb21haW4ubGVuZ3RoKS5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gc3RhcnQgKyBzdGVwICogaTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSBbXTtcbiAgICAgIGluZGV4ID0gbmV3IGQzX01hcCgpO1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHgubGVuZ3RoLCB4aTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWluZGV4Lmhhcyh4aSA9IHhbaV0pKSBpbmRleC5zZXQoeGksIGRvbWFpbi5wdXNoKHhpKSk7XG4gICAgICByZXR1cm4gc2NhbGVbcmFuZ2VyLnRdLmFwcGx5KHNjYWxlLCByYW5nZXIuYSk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmFuZ2VCYW5kID0gMDtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVwiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZVBvaW50cyA9IGZ1bmN0aW9uKHgsIHBhZGRpbmcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcGFkZGluZyA9IDA7XG4gICAgICB2YXIgc3RhcnQgPSB4WzBdLCBzdG9wID0geFsxXSwgc3RlcCA9IGRvbWFpbi5sZW5ndGggPCAyID8gKHN0YXJ0ID0gKHN0YXJ0ICsgc3RvcCkgLyAyLCBcbiAgICAgIDApIDogKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIDEgKyBwYWRkaW5nKTtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBzdGVwICogcGFkZGluZyAvIDIsIHN0ZXApO1xuICAgICAgcmFuZ2VCYW5kID0gMDtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVBvaW50c1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZVJvdW5kUG9pbnRzID0gZnVuY3Rpb24oeCwgcGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIHZhciBzdGFydCA9IHhbMF0sIHN0b3AgPSB4WzFdLCBzdGVwID0gZG9tYWluLmxlbmd0aCA8IDIgPyAoc3RhcnQgPSBzdG9wID0gTWF0aC5yb3VuZCgoc3RhcnQgKyBzdG9wKSAvIDIpLCBcbiAgICAgIDApIDogKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIDEgKyBwYWRkaW5nKSB8IDA7XG4gICAgICByYW5nZSA9IHN0ZXBzKHN0YXJ0ICsgTWF0aC5yb3VuZChzdGVwICogcGFkZGluZyAvIDIgKyAoc3RvcCAtIHN0YXJ0IC0gKGRvbWFpbi5sZW5ndGggLSAxICsgcGFkZGluZykgKiBzdGVwKSAvIDIpLCBzdGVwKTtcbiAgICAgIHJhbmdlQmFuZCA9IDA7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VSb3VuZFBvaW50c1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZUJhbmRzID0gZnVuY3Rpb24oeCwgcGFkZGluZywgb3V0ZXJQYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBvdXRlclBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgdmFyIHJldmVyc2UgPSB4WzFdIDwgeFswXSwgc3RhcnQgPSB4W3JldmVyc2UgLSAwXSwgc3RvcCA9IHhbMSAtIHJldmVyc2VdLCBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIHBhZGRpbmcgKyAyICogb3V0ZXJQYWRkaW5nKTtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBzdGVwICogb3V0ZXJQYWRkaW5nLCBzdGVwKTtcbiAgICAgIGlmIChyZXZlcnNlKSByYW5nZS5yZXZlcnNlKCk7XG4gICAgICByYW5nZUJhbmQgPSBzdGVwICogKDEgLSBwYWRkaW5nKTtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZUJhbmRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUm91bmRCYW5kcyA9IGZ1bmN0aW9uKHgsIHBhZGRpbmcsIG91dGVyUGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgb3V0ZXJQYWRkaW5nID0gcGFkZGluZztcbiAgICAgIHZhciByZXZlcnNlID0geFsxXSA8IHhbMF0sIHN0YXJ0ID0geFtyZXZlcnNlIC0gMF0sIHN0b3AgPSB4WzEgLSByZXZlcnNlXSwgc3RlcCA9IE1hdGguZmxvb3IoKHN0b3AgLSBzdGFydCkgLyAoZG9tYWluLmxlbmd0aCAtIHBhZGRpbmcgKyAyICogb3V0ZXJQYWRkaW5nKSk7XG4gICAgICByYW5nZSA9IHN0ZXBzKHN0YXJ0ICsgTWF0aC5yb3VuZCgoc3RvcCAtIHN0YXJ0IC0gKGRvbWFpbi5sZW5ndGggLSBwYWRkaW5nKSAqIHN0ZXApIC8gMiksIHN0ZXApO1xuICAgICAgaWYgKHJldmVyc2UpIHJhbmdlLnJldmVyc2UoKTtcbiAgICAgIHJhbmdlQmFuZCA9IE1hdGgucm91bmQoc3RlcCAqICgxIC0gcGFkZGluZykpO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlUm91bmRCYW5kc1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZUJhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5nZUJhbmQ7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZUV4dGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlRXh0ZW50KHJhbmdlci5hWzBdKTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9vcmRpbmFsKGRvbWFpbiwgcmFuZ2VyKTtcbiAgICB9O1xuICAgIHJldHVybiBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgfVxuICBkMy5zY2FsZS5jYXRlZ29yeTEwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTEwKTtcbiAgfTtcbiAgZDMuc2NhbGUuY2F0ZWdvcnkyMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkucmFuZ2UoZDNfY2F0ZWdvcnkyMCk7XG4gIH07XG4gIGQzLnNjYWxlLmNhdGVnb3J5MjBiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwYik7XG4gIH07XG4gIGQzLnNjYWxlLmNhdGVnb3J5MjBjID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwYyk7XG4gIH07XG4gIHZhciBkM19jYXRlZ29yeTEwID0gWyAyMDYyMjYwLCAxNjc0NDIwNiwgMjkyNDU4OCwgMTQwMzQ3MjgsIDk3MjU4ODUsIDkxOTcxMzEsIDE0OTA3MzMwLCA4MzU1NzExLCAxMjM2OTE4NiwgMTU1NjE3NSBdLm1hcChkM19yZ2JTdHJpbmcpO1xuICB2YXIgZDNfY2F0ZWdvcnkyMCA9IFsgMjA2MjI2MCwgMTE0NTQ0NDAsIDE2NzQ0MjA2LCAxNjc1OTY3MiwgMjkyNDU4OCwgMTAwMTg2OTgsIDE0MDM0NzI4LCAxNjc1MDc0MiwgOTcyNTg4NSwgMTI5NTU4NjEsIDkxOTcxMzEsIDEyODg1MTQwLCAxNDkwNzMzMCwgMTYyMzQxOTQsIDgzNTU3MTEsIDEzMDkyODA3LCAxMjM2OTE4NiwgMTQ0MDg1ODksIDE1NTYxNzUsIDEwNDEwNzI1IF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIHZhciBkM19jYXRlZ29yeTIwYiA9IFsgMzc1MDc3NywgNTM5NTYxOSwgNzA0MDcxOSwgMTAyNjQyODYsIDY1MTkwOTcsIDkyMTY1OTQsIDExOTE1MTE1LCAxMzU1NjYzNiwgOTIwMjk5MywgMTI0MjY4MDksIDE1MTg2NTE0LCAxNTE5MDkzMiwgODY2NjE2OSwgMTEzNTY0OTAsIDE0MDQ5NjQzLCAxNTE3NzM3MiwgODA3NzY4MywgMTA4MzQzMjQsIDEzNTI4NTA5LCAxNDU4OTY1NCBdLm1hcChkM19yZ2JTdHJpbmcpO1xuICB2YXIgZDNfY2F0ZWdvcnkyMGMgPSBbIDMyNDQ3MzMsIDcwNTcxMTAsIDEwNDA2NjI1LCAxMzAzMjQzMSwgMTUwOTUwNTMsIDE2NjE2NzY0LCAxNjYyNTI1OSwgMTY2MzQwMTgsIDMyNTMwNzYsIDc2NTI0NzAsIDEwNjA3MDAzLCAxMzEwMTUwNCwgNzY5NTI4MSwgMTAzOTQzMTIsIDEyMzY5MzcyLCAxNDM0Mjg5MSwgNjUxMzUwNywgOTg2ODk1MCwgMTI0MzQ4NzcsIDE0Mjc3MDgxIF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIGQzLnNjYWxlLnF1YW50aWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aWxlKFtdLCBbXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3F1YW50aWxlKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICB2YXIgdGhyZXNob2xkcztcbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgdmFyIGsgPSAwLCBxID0gcmFuZ2UubGVuZ3RoO1xuICAgICAgdGhyZXNob2xkcyA9IFtdO1xuICAgICAgd2hpbGUgKCsrayA8IHEpIHRocmVzaG9sZHNbayAtIDFdID0gZDMucXVhbnRpbGUoZG9tYWluLCBrIC8gcSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIHJhbmdlW2QzLmJpc2VjdCh0aHJlc2hvbGRzLCB4KV07XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IHgubWFwKGQzX251bWJlcikuZmlsdGVyKGQzX251bWVyaWMpLnNvcnQoZDNfYXNjZW5kaW5nKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRocmVzaG9sZHM7XG4gICAgfTtcbiAgICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICB5ID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiB5IDwgMCA/IFsgTmFOLCBOYU4gXSA6IFsgeSA+IDAgPyB0aHJlc2hvbGRzW3kgLSAxXSA6IGRvbWFpblswXSwgeSA8IHRocmVzaG9sZHMubGVuZ3RoID8gdGhyZXNob2xkc1t5XSA6IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0gXTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9xdWFudGlsZShkb21haW4sIHJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cbiAgZDMuc2NhbGUucXVhbnRpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpemUoMCwgMSwgWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9xdWFudGl6ZSh4MCwgeDEsIHJhbmdlKSB7XG4gICAgdmFyIGt4LCBpO1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiByYW5nZVtNYXRoLm1heCgwLCBNYXRoLm1pbihpLCBNYXRoLmZsb29yKGt4ICogKHggLSB4MCkpKSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAga3ggPSByYW5nZS5sZW5ndGggLyAoeDEgLSB4MCk7XG4gICAgICBpID0gcmFuZ2UubGVuZ3RoIC0gMTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyB4MCwgeDEgXTtcbiAgICAgIHgwID0gK3hbMF07XG4gICAgICB4MSA9ICt4W3gubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICB5ID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHkgPSB5IDwgMCA/IE5hTiA6IHkgLyBreCArIHgwO1xuICAgICAgcmV0dXJuIFsgeSwgeSArIDEgLyBreCBdO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aXplKHgwLCB4MSwgcmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfVxuICBkMy5zY2FsZS50aHJlc2hvbGQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfdGhyZXNob2xkKFsgLjUgXSwgWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV90aHJlc2hvbGQoZG9tYWluLCByYW5nZSkge1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIGlmICh4IDw9IHgpIHJldHVybiByYW5nZVtkMy5iaXNlY3QoZG9tYWluLCB4KV07XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IF87XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSBfO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgeSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgICByZXR1cm4gWyBkb21haW5beSAtIDFdLCBkb21haW5beV0gXTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV90aHJlc2hvbGQoZG9tYWluLCByYW5nZSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cbiAgZDMuc2NhbGUuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfaWRlbnRpdHkoWyAwLCAxIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9pZGVudGl0eShkb21haW4pIHtcbiAgICBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgICByZXR1cm4gK3g7XG4gICAgfVxuICAgIGlkZW50aXR5LmludmVydCA9IGlkZW50aXR5O1xuICAgIGlkZW50aXR5LmRvbWFpbiA9IGlkZW50aXR5LnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0geC5tYXAoaWRlbnRpdHkpO1xuICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgIH07XG4gICAgaWRlbnRpdHkudGlja3MgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja3MoZG9tYWluLCBtKTtcbiAgICB9O1xuICAgIGlkZW50aXR5LnRpY2tGb3JtYXQgPSBmdW5jdGlvbihtLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIGlkZW50aXR5LmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9pZGVudGl0eShkb21haW4pO1xuICAgIH07XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGQzLnN2ZyA9IHt9O1xuICBmdW5jdGlvbiBkM196ZXJvKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGQzLnN2Zy5hcmMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5uZXJSYWRpdXMgPSBkM19zdmdfYXJjSW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzID0gZDNfc3ZnX2FyY091dGVyUmFkaXVzLCBjb3JuZXJSYWRpdXMgPSBkM196ZXJvLCBwYWRSYWRpdXMgPSBkM19zdmdfYXJjQXV0bywgc3RhcnRBbmdsZSA9IGQzX3N2Z19hcmNTdGFydEFuZ2xlLCBlbmRBbmdsZSA9IGQzX3N2Z19hcmNFbmRBbmdsZSwgcGFkQW5nbGUgPSBkM19zdmdfYXJjUGFkQW5nbGU7XG4gICAgZnVuY3Rpb24gYXJjKCkge1xuICAgICAgdmFyIHIwID0gTWF0aC5tYXgoMCwgK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCByMSA9IE1hdGgubWF4KDAsICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgYTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmz4AsIGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGbPgCwgZGEgPSBNYXRoLmFicyhhMSAtIGEwKSwgY3cgPSBhMCA+IGExID8gMCA6IDE7XG4gICAgICBpZiAocjEgPCByMCkgcmMgPSByMSwgcjEgPSByMCwgcjAgPSByYztcbiAgICAgIGlmIChkYSA+PSDPhM61KSByZXR1cm4gY2lyY2xlU2VnbWVudChyMSwgY3cpICsgKHIwID8gY2lyY2xlU2VnbWVudChyMCwgMSAtIGN3KSA6IFwiXCIpICsgXCJaXCI7XG4gICAgICB2YXIgcmMsIGNyLCBycCwgYXAsIHAwID0gMCwgcDEgPSAwLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHBhdGggPSBbXTtcbiAgICAgIGlmIChhcCA9ICgrcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwKSAvIDIpIHtcbiAgICAgICAgcnAgPSBwYWRSYWRpdXMgPT09IGQzX3N2Z19hcmNBdXRvID8gTWF0aC5zcXJ0KHIwICogcjAgKyByMSAqIHIxKSA6ICtwYWRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFjdykgcDEgKj0gLTE7XG4gICAgICAgIGlmIChyMSkgcDEgPSBkM19hc2luKHJwIC8gcjEgKiBNYXRoLnNpbihhcCkpO1xuICAgICAgICBpZiAocjApIHAwID0gZDNfYXNpbihycCAvIHIwICogTWF0aC5zaW4oYXApKTtcbiAgICAgIH1cbiAgICAgIGlmIChyMSkge1xuICAgICAgICB4MCA9IHIxICogTWF0aC5jb3MoYTAgKyBwMSk7XG4gICAgICAgIHkwID0gcjEgKiBNYXRoLnNpbihhMCArIHAxKTtcbiAgICAgICAgeDEgPSByMSAqIE1hdGguY29zKGExIC0gcDEpO1xuICAgICAgICB5MSA9IHIxICogTWF0aC5zaW4oYTEgLSBwMSk7XG4gICAgICAgIHZhciBsMSA9IE1hdGguYWJzKGExIC0gYTAgLSAyICogcDEpIDw9IM+AID8gMCA6IDE7XG4gICAgICAgIGlmIChwMSAmJiBkM19zdmdfYXJjU3dlZXAoeDAsIHkwLCB4MSwgeTEpID09PSBjdyBeIGwxKSB7XG4gICAgICAgICAgdmFyIGgxID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgICB4MCA9IHIxICogTWF0aC5jb3MoaDEpO1xuICAgICAgICAgIHkwID0gcjEgKiBNYXRoLnNpbihoMSk7XG4gICAgICAgICAgeDEgPSB5MSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgwID0geTAgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHIwKSB7XG4gICAgICAgIHgyID0gcjAgKiBNYXRoLmNvcyhhMSAtIHAwKTtcbiAgICAgICAgeTIgPSByMCAqIE1hdGguc2luKGExIC0gcDApO1xuICAgICAgICB4MyA9IHIwICogTWF0aC5jb3MoYTAgKyBwMCk7XG4gICAgICAgIHkzID0gcjAgKiBNYXRoLnNpbihhMCArIHAwKTtcbiAgICAgICAgdmFyIGwwID0gTWF0aC5hYnMoYTAgLSBhMSArIDIgKiBwMCkgPD0gz4AgPyAwIDogMTtcbiAgICAgICAgaWYgKHAwICYmIGQzX3N2Z19hcmNTd2VlcCh4MiwgeTIsIHgzLCB5MykgPT09IDEgLSBjdyBeIGwwKSB7XG4gICAgICAgICAgdmFyIGgwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgICB4MiA9IHIwICogTWF0aC5jb3MoaDApO1xuICAgICAgICAgIHkyID0gcjAgKiBNYXRoLnNpbihoMCk7XG4gICAgICAgICAgeDMgPSB5MyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0geTIgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGRhID4gzrUgJiYgKHJjID0gTWF0aC5taW4oTWF0aC5hYnMocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSA+IC4wMDEpIHtcbiAgICAgICAgY3IgPSByMCA8IHIxIF4gY3cgPyAwIDogMTtcbiAgICAgICAgdmFyIHJjMSA9IHJjLCByYzAgPSByYztcbiAgICAgICAgaWYgKGRhIDwgz4ApIHtcbiAgICAgICAgICB2YXIgb2MgPSB4MyA9PSBudWxsID8gWyB4MiwgeTIgXSA6IHgxID09IG51bGwgPyBbIHgwLCB5MCBdIDogZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KFsgeDAsIHkwIF0sIFsgeDMsIHkzIF0sIFsgeDEsIHkxIF0sIFsgeDIsIHkyIF0pLCBheCA9IHgwIC0gb2NbMF0sIGF5ID0geTAgLSBvY1sxXSwgYnggPSB4MSAtIG9jWzBdLCBieSA9IHkxIC0gb2NbMV0sIGtjID0gMSAvIE1hdGguc2luKE1hdGguYWNvcygoYXggKiBieCArIGF5ICogYnkpIC8gKE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSwgbGMgPSBNYXRoLnNxcnQob2NbMF0gKiBvY1swXSArIG9jWzFdICogb2NbMV0pO1xuICAgICAgICAgIHJjMCA9IE1hdGgubWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgcmMxID0gTWF0aC5taW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0MzAgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoeDMgPT0gbnVsbCA/IFsgeDIsIHkyIF0gOiBbIHgzLCB5MyBdLCBbIHgwLCB5MCBdLCByMSwgcmMxLCBjdyksIHQxMiA9IGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhbIHgxLCB5MSBdLCBbIHgyLCB5MiBdLCByMSwgcmMxLCBjdyk7XG4gICAgICAgICAgaWYgKHJjID09PSByYzEpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIk1cIiwgdDMwWzBdLCBcIkFcIiwgcmMxLCBcIixcIiwgcmMxLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDMwWzFdLCBcIkFcIiwgcjEsIFwiLFwiLCByMSwgXCIgMCBcIiwgMSAtIGN3IF4gZDNfc3ZnX2FyY1N3ZWVwKHQzMFsxXVswXSwgdDMwWzFdWzFdLCB0MTJbMV1bMF0sIHQxMlsxXVsxXSksIFwiLFwiLCBjdywgXCIgXCIsIHQxMlsxXSwgXCJBXCIsIHJjMSwgXCIsXCIsIHJjMSwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQxMlswXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIk1cIiwgdDMwWzBdLCBcIkFcIiwgcmMxLCBcIixcIiwgcmMxLCBcIiAwIDEsXCIsIGNyLCBcIiBcIiwgdDEyWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5wdXNoKFwiTVwiLCB4MCwgXCIsXCIsIHkwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDMgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0MDMgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoWyB4MCwgeTAgXSwgWyB4MywgeTMgXSwgcjAsIC1yYzAsIGN3KSwgdDIxID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKFsgeDIsIHkyIF0sIHgxID09IG51bGwgPyBbIHgwLCB5MCBdIDogWyB4MSwgeTEgXSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgICBpZiAocmMgPT09IHJjMCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB0MjFbMF0sIFwiQVwiLCByYzAsIFwiLFwiLCByYzAsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MjFbMV0sIFwiQVwiLCByMCwgXCIsXCIsIHIwLCBcIiAwIFwiLCBjdyBeIGQzX3N2Z19hcmNTd2VlcCh0MjFbMV1bMF0sIHQyMVsxXVsxXSwgdDAzWzFdWzBdLCB0MDNbMV1bMV0pLCBcIixcIiwgMSAtIGN3LCBcIiBcIiwgdDAzWzFdLCBcIkFcIiwgcmMwLCBcIixcIiwgcmMwLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDAzWzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB0MjFbMF0sIFwiQVwiLCByYzAsIFwiLFwiLCByYzAsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MDNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goXCJMXCIsIHgyLCBcIixcIiwgeTIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHgwLCBcIixcIiwgeTApO1xuICAgICAgICBpZiAoeDEgIT0gbnVsbCkgcGF0aC5wdXNoKFwiQVwiLCByMSwgXCIsXCIsIHIxLCBcIiAwIFwiLCBsMSwgXCIsXCIsIGN3LCBcIiBcIiwgeDEsIFwiLFwiLCB5MSk7XG4gICAgICAgIHBhdGgucHVzaChcIkxcIiwgeDIsIFwiLFwiLCB5Mik7XG4gICAgICAgIGlmICh4MyAhPSBudWxsKSBwYXRoLnB1c2goXCJBXCIsIHIwLCBcIixcIiwgcjAsIFwiIDAgXCIsIGwwLCBcIixcIiwgMSAtIGN3LCBcIiBcIiwgeDMsIFwiLFwiLCB5Myk7XG4gICAgICB9XG4gICAgICBwYXRoLnB1c2goXCJaXCIpO1xuICAgICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2lyY2xlU2VnbWVudChyMSwgY3cpIHtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgcjEgKyBcIkFcIiArIHIxICsgXCIsXCIgKyByMSArIFwiIDAgMSxcIiArIGN3ICsgXCIgMCxcIiArIC1yMSArIFwiQVwiICsgcjEgKyBcIixcIiArIHIxICsgXCIgMCAxLFwiICsgY3cgKyBcIiAwLFwiICsgcjE7XG4gICAgfVxuICAgIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGlubmVyUmFkaXVzO1xuICAgICAgaW5uZXJSYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5vdXRlclJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dGVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb3JuZXJSYWRpdXM7XG4gICAgICBjb3JuZXJSYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRSYWRpdXM7XG4gICAgICBwYWRSYWRpdXMgPSB2ID09IGQzX3N2Z19hcmNBdXRvID8gZDNfc3ZnX2FyY0F1dG8gOiBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhcnRBbmdsZTtcbiAgICAgIHN0YXJ0QW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5lbmRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5wYWRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZEFuZ2xlO1xuICAgICAgcGFkQW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGFyYztcbiAgICB9O1xuICAgIGFyYy5jZW50cm9pZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLCBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIFsgTWF0aC5jb3MoYSkgKiByLCBNYXRoLnNpbihhKSAqIHIgXTtcbiAgICB9O1xuICAgIHJldHVybiBhcmM7XG4gIH07XG4gIHZhciBkM19zdmdfYXJjQXV0byA9IFwiYXV0b1wiO1xuICBmdW5jdGlvbiBkM19zdmdfYXJjSW5uZXJSYWRpdXMoZCkge1xuICAgIHJldHVybiBkLmlubmVyUmFkaXVzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNPdXRlclJhZGl1cyhkKSB7XG4gICAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY1N0YXJ0QW5nbGUoZCkge1xuICAgIHJldHVybiBkLnN0YXJ0QW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY0VuZEFuZ2xlKGQpIHtcbiAgICByZXR1cm4gZC5lbmRBbmdsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjUGFkQW5nbGUoZCkge1xuICAgIHJldHVybiBkICYmIGQucGFkQW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY1N3ZWVwKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuICh4MCAtIHgxKSAqIHkwIC0gKHkwIC0geTEpICogeDAgPiAwID8gMCA6IDE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKHAwLCBwMSwgcjEsIHJjLCBjdykge1xuICAgIHZhciB4MDEgPSBwMFswXSAtIHAxWzBdLCB5MDEgPSBwMFsxXSAtIHAxWzFdLCBsbyA9IChjdyA/IHJjIDogLXJjKSAvIE1hdGguc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLCBveCA9IGxvICogeTAxLCBveSA9IC1sbyAqIHgwMSwgeDEgPSBwMFswXSArIG94LCB5MSA9IHAwWzFdICsgb3ksIHgyID0gcDFbMF0gKyBveCwgeTIgPSBwMVsxXSArIG95LCB4MyA9ICh4MSArIHgyKSAvIDIsIHkzID0gKHkxICsgeTIpIC8gMiwgZHggPSB4MiAtIHgxLCBkeSA9IHkyIC0geTEsIGQyID0gZHggKiBkeCArIGR5ICogZHksIHIgPSByMSAtIHJjLCBEID0geDEgKiB5MiAtIHgyICogeTEsIGQgPSAoZHkgPCAwID8gLTEgOiAxKSAqIE1hdGguc3FydChNYXRoLm1heCgwLCByICogciAqIGQyIC0gRCAqIEQpKSwgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMiwgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLCBkeDAgPSBjeDAgLSB4MywgZHkwID0gY3kwIC0geTMsIGR4MSA9IGN4MSAtIHgzLCBkeTEgPSBjeTEgLSB5MztcbiAgICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSBjeDAgPSBjeDEsIGN5MCA9IGN5MTtcbiAgICByZXR1cm4gWyBbIGN4MCAtIG94LCBjeTAgLSBveSBdLCBbIGN4MCAqIHIxIC8gciwgY3kwICogcjEgLyByIF0gXTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZShwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHggPSBkM19nZW9tX3BvaW50WCwgeSA9IGQzX2dlb21fcG9pbnRZLCBkZWZpbmVkID0gZDNfdHJ1ZSwgaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUxpbmVhciwgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZS5rZXksIHRlbnNpb24gPSAuNztcbiAgICBmdW5jdGlvbiBsaW5lKGRhdGEpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdLCBwb2ludHMgPSBbXSwgaSA9IC0xLCBuID0gZGF0YS5sZW5ndGgsIGQsIGZ4ID0gZDNfZnVuY3Rvcih4KSwgZnkgPSBkM19mdW5jdG9yKHkpO1xuICAgICAgZnVuY3Rpb24gc2VnbWVudCgpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChcIk1cIiwgaW50ZXJwb2xhdGUocHJvamVjdGlvbihwb2ludHMpLCB0ZW5zaW9uKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZGVmaW5lZC5jYWxsKHRoaXMsIGQgPSBkYXRhW2ldLCBpKSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKFsgK2Z4LmNhbGwodGhpcywgZCwgaSksICtmeS5jYWxsKHRoaXMsIGQsIGkpIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWdtZW50KCk7XG4gICAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb2ludHMubGVuZ3RoKSBzZWdtZW50KCk7XG4gICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHMuam9pbihcIlwiKSA6IG51bGw7XG4gICAgfVxuICAgIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHg7XG4gICAgICB4ID0gXztcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICAgIHkgPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBsaW5lLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWZpbmVkO1xuICAgICAgZGVmaW5lZCA9IF87XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIGxpbmUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZUtleTtcbiAgICAgIGlmICh0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiKSBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlID0gXzsgZWxzZSBpbnRlcnBvbGF0ZUtleSA9IChpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lSW50ZXJwb2xhdG9ycy5nZXQoXykgfHwgZDNfc3ZnX2xpbmVMaW5lYXIpLmtleTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS50ZW5zaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGVuc2lvbjtcbiAgICAgIHRlbnNpb24gPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICByZXR1cm4gbGluZTtcbiAgfVxuICBkMy5zdmcubGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zdmdfbGluZShkM19pZGVudGl0eSk7XG4gIH07XG4gIHZhciBkM19zdmdfbGluZUludGVycG9sYXRvcnMgPSBkMy5tYXAoe1xuICAgIGxpbmVhcjogZDNfc3ZnX2xpbmVMaW5lYXIsXG4gICAgXCJsaW5lYXItY2xvc2VkXCI6IGQzX3N2Z19saW5lTGluZWFyQ2xvc2VkLFxuICAgIHN0ZXA6IGQzX3N2Z19saW5lU3RlcCxcbiAgICBcInN0ZXAtYmVmb3JlXCI6IGQzX3N2Z19saW5lU3RlcEJlZm9yZSxcbiAgICBcInN0ZXAtYWZ0ZXJcIjogZDNfc3ZnX2xpbmVTdGVwQWZ0ZXIsXG4gICAgYmFzaXM6IGQzX3N2Z19saW5lQmFzaXMsXG4gICAgXCJiYXNpcy1vcGVuXCI6IGQzX3N2Z19saW5lQmFzaXNPcGVuLFxuICAgIFwiYmFzaXMtY2xvc2VkXCI6IGQzX3N2Z19saW5lQmFzaXNDbG9zZWQsXG4gICAgYnVuZGxlOiBkM19zdmdfbGluZUJ1bmRsZSxcbiAgICBjYXJkaW5hbDogZDNfc3ZnX2xpbmVDYXJkaW5hbCxcbiAgICBcImNhcmRpbmFsLW9wZW5cIjogZDNfc3ZnX2xpbmVDYXJkaW5hbE9wZW4sXG4gICAgXCJjYXJkaW5hbC1jbG9zZWRcIjogZDNfc3ZnX2xpbmVDYXJkaW5hbENsb3NlZCxcbiAgICBtb25vdG9uZTogZDNfc3ZnX2xpbmVNb25vdG9uZVxuICB9KTtcbiAgZDNfc3ZnX2xpbmVJbnRlcnBvbGF0b3JzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhbHVlLmtleSA9IGtleTtcbiAgICB2YWx1ZS5jbG9zZWQgPSAvLWNsb3NlZCQvLnRlc3Qoa2V5KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoID4gMSA/IHBvaW50cy5qb2luKFwiTFwiKSA6IHBvaW50cyArIFwiWlwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTGluZWFyQ2xvc2VkKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMuam9pbihcIkxcIikgKyBcIlpcIjtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVN0ZXAocG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aCwgcCA9IHBvaW50c1swXSwgcGF0aCA9IFsgcFswXSwgXCIsXCIsIHBbMV0gXTtcbiAgICB3aGlsZSAoKytpIDwgbikgcGF0aC5wdXNoKFwiSFwiLCAocFswXSArIChwID0gcG9pbnRzW2ldKVswXSkgLyAyLCBcIlZcIiwgcFsxXSk7XG4gICAgaWYgKG4gPiAxKSBwYXRoLnB1c2goXCJIXCIsIHBbMF0pO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVTdGVwQmVmb3JlKHBvaW50cykge1xuICAgIHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGgsIHAgPSBwb2ludHNbMF0sIHBhdGggPSBbIHBbMF0sIFwiLFwiLCBwWzFdIF07XG4gICAgd2hpbGUgKCsraSA8IG4pIHBhdGgucHVzaChcIlZcIiwgKHAgPSBwb2ludHNbaV0pWzFdLCBcIkhcIiwgcFswXSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVN0ZXBBZnRlcihwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoLCBwID0gcG9pbnRzWzBdLCBwYXRoID0gWyBwWzBdLCBcIixcIiwgcFsxXSBdO1xuICAgIHdoaWxlICgrK2kgPCBuKSBwYXRoLnB1c2goXCJIXCIsIChwID0gcG9pbnRzW2ldKVswXSwgXCJWXCIsIHBbMV0pO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbE9wZW4ocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPCA0ID8gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKSA6IHBvaW50c1sxXSArIGQzX3N2Z19saW5lSGVybWl0ZShwb2ludHMuc2xpY2UoMSwgLTEpLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMocG9pbnRzLCB0ZW5zaW9uKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbENsb3NlZChwb2ludHMsIHRlbnNpb24pIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA8IDMgPyBkM19zdmdfbGluZUxpbmVhckNsb3NlZChwb2ludHMpIDogcG9pbnRzWzBdICsgZDNfc3ZnX2xpbmVIZXJtaXRlKChwb2ludHMucHVzaChwb2ludHNbMF0pLCBcbiAgICBwb2ludHMpLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMoWyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdIF0uY29uY2F0KHBvaW50cywgWyBwb2ludHNbMV0gXSksIHRlbnNpb24pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUNhcmRpbmFsKHBvaW50cywgdGVuc2lvbikge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMyA/IGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgOiBwb2ludHNbMF0gKyBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMocG9pbnRzLCB0ZW5zaW9uKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVIZXJtaXRlKHBvaW50cywgdGFuZ2VudHMpIHtcbiAgICBpZiAodGFuZ2VudHMubGVuZ3RoIDwgMSB8fCBwb2ludHMubGVuZ3RoICE9IHRhbmdlbnRzLmxlbmd0aCAmJiBwb2ludHMubGVuZ3RoICE9IHRhbmdlbnRzLmxlbmd0aCArIDIpIHtcbiAgICAgIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIH1cbiAgICB2YXIgcXVhZCA9IHBvaW50cy5sZW5ndGggIT0gdGFuZ2VudHMubGVuZ3RoLCBwYXRoID0gXCJcIiwgcDAgPSBwb2ludHNbMF0sIHAgPSBwb2ludHNbMV0sIHQwID0gdGFuZ2VudHNbMF0sIHQgPSB0MCwgcGkgPSAxO1xuICAgIGlmIChxdWFkKSB7XG4gICAgICBwYXRoICs9IFwiUVwiICsgKHBbMF0gLSB0MFswXSAqIDIgLyAzKSArIFwiLFwiICsgKHBbMV0gLSB0MFsxXSAqIDIgLyAzKSArIFwiLFwiICsgcFswXSArIFwiLFwiICsgcFsxXTtcbiAgICAgIHAwID0gcG9pbnRzWzFdO1xuICAgICAgcGkgPSAyO1xuICAgIH1cbiAgICBpZiAodGFuZ2VudHMubGVuZ3RoID4gMSkge1xuICAgICAgdCA9IHRhbmdlbnRzWzFdO1xuICAgICAgcCA9IHBvaW50c1twaV07XG4gICAgICBwaSsrO1xuICAgICAgcGF0aCArPSBcIkNcIiArIChwMFswXSArIHQwWzBdKSArIFwiLFwiICsgKHAwWzFdICsgdDBbMV0pICsgXCIsXCIgKyAocFswXSAtIHRbMF0pICsgXCIsXCIgKyAocFsxXSAtIHRbMV0pICsgXCIsXCIgKyBwWzBdICsgXCIsXCIgKyBwWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB0YW5nZW50cy5sZW5ndGg7IGkrKywgcGkrKykge1xuICAgICAgICBwID0gcG9pbnRzW3BpXTtcbiAgICAgICAgdCA9IHRhbmdlbnRzW2ldO1xuICAgICAgICBwYXRoICs9IFwiU1wiICsgKHBbMF0gLSB0WzBdKSArIFwiLFwiICsgKHBbMV0gLSB0WzFdKSArIFwiLFwiICsgcFswXSArIFwiLFwiICsgcFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1YWQpIHtcbiAgICAgIHZhciBscCA9IHBvaW50c1twaV07XG4gICAgICBwYXRoICs9IFwiUVwiICsgKHBbMF0gKyB0WzBdICogMiAvIDMpICsgXCIsXCIgKyAocFsxXSArIHRbMV0gKiAyIC8gMykgKyBcIixcIiArIGxwWzBdICsgXCIsXCIgKyBscFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbFRhbmdlbnRzKHBvaW50cywgdGVuc2lvbikge1xuICAgIHZhciB0YW5nZW50cyA9IFtdLCBhID0gKDEgLSB0ZW5zaW9uKSAvIDIsIHAwLCBwMSA9IHBvaW50c1swXSwgcDIgPSBwb2ludHNbMV0sIGkgPSAxLCBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcDAgPSBwMTtcbiAgICAgIHAxID0gcDI7XG4gICAgICBwMiA9IHBvaW50c1tpXTtcbiAgICAgIHRhbmdlbnRzLnB1c2goWyBhICogKHAyWzBdIC0gcDBbMF0pLCBhICogKHAyWzFdIC0gcDBbMV0pIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFuZ2VudHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpcyhwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIHZhciBpID0gMSwgbiA9IHBvaW50cy5sZW5ndGgsIHBpID0gcG9pbnRzWzBdLCB4MCA9IHBpWzBdLCB5MCA9IHBpWzFdLCBweCA9IFsgeDAsIHgwLCB4MCwgKHBpID0gcG9pbnRzWzFdKVswXSBdLCBweSA9IFsgeTAsIHkwLCB5MCwgcGlbMV0gXSwgcGF0aCA9IFsgeDAsIFwiLFwiLCB5MCwgXCJMXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweSkgXTtcbiAgICBwb2ludHMucHVzaChwb2ludHNbbiAtIDFdKTtcbiAgICB3aGlsZSAoKytpIDw9IG4pIHtcbiAgICAgIHBpID0gcG9pbnRzW2ldO1xuICAgICAgcHguc2hpZnQoKTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkuc2hpZnQoKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgICAgZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCBweCwgcHkpO1xuICAgIH1cbiAgICBwb2ludHMucG9wKCk7XG4gICAgcGF0aC5wdXNoKFwiTFwiLCBwaSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUJhc2lzT3Blbihwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDQpIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIHZhciBwYXRoID0gW10sIGkgPSAtMSwgbiA9IHBvaW50cy5sZW5ndGgsIHBpLCBweCA9IFsgMCBdLCBweSA9IFsgMCBdO1xuICAgIHdoaWxlICgrK2kgPCAzKSB7XG4gICAgICBwaSA9IHBvaW50c1tpXTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgfVxuICAgIHBhdGgucHVzaChkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB4KSArIFwiLFwiICsgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweSkpO1xuICAgIC0taTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcGkgPSBwb2ludHNbaV07XG4gICAgICBweC5zaGlmdCgpO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5zaGlmdCgpO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgICBkM19zdmdfbGluZUJhc2lzQmV6aWVyKHBhdGgsIHB4LCBweSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpc0Nsb3NlZChwb2ludHMpIHtcbiAgICB2YXIgcGF0aCwgaSA9IC0xLCBuID0gcG9pbnRzLmxlbmd0aCwgbSA9IG4gKyA0LCBwaSwgcHggPSBbXSwgcHkgPSBbXTtcbiAgICB3aGlsZSAoKytpIDwgNCkge1xuICAgICAgcGkgPSBwb2ludHNbaSAlIG5dO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICB9XG4gICAgcGF0aCA9IFsgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB5KSBdO1xuICAgIC0taTtcbiAgICB3aGlsZSAoKytpIDwgbSkge1xuICAgICAgcGkgPSBwb2ludHNbaSAlIG5dO1xuICAgICAgcHguc2hpZnQoKTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkuc2hpZnQoKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgICAgZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCBweCwgcHkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQnVuZGxlKHBvaW50cywgdGVuc2lvbikge1xuICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciB4MCA9IHBvaW50c1swXVswXSwgeTAgPSBwb2ludHNbMF1bMV0sIGR4ID0gcG9pbnRzW25dWzBdIC0geDAsIGR5ID0gcG9pbnRzW25dWzFdIC0geTAsIGkgPSAtMSwgcCwgdDtcbiAgICAgIHdoaWxlICgrK2kgPD0gbikge1xuICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICB0ID0gaSAvIG47XG4gICAgICAgIHBbMF0gPSB0ZW5zaW9uICogcFswXSArICgxIC0gdGVuc2lvbikgKiAoeDAgKyB0ICogZHgpO1xuICAgICAgICBwWzFdID0gdGVuc2lvbiAqIHBbMV0gKyAoMSAtIHRlbnNpb24pICogKHkwICsgdCAqIGR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3N2Z19saW5lQmFzaXMocG9pbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZURvdDQoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbiAgfVxuICB2YXIgZDNfc3ZnX2xpbmVCYXNpc0JlemllcjEgPSBbIDAsIDIgLyAzLCAxIC8gMywgMCBdLCBkM19zdmdfbGluZUJhc2lzQmV6aWVyMiA9IFsgMCwgMSAvIDMsIDIgLyAzLCAwIF0sIGQzX3N2Z19saW5lQmFzaXNCZXppZXIzID0gWyAwLCAxIC8gNiwgMiAvIDMsIDEgLyA2IF07XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQmFzaXNCZXppZXIocGF0aCwgeCwgeSkge1xuICAgIHBhdGgucHVzaChcIkNcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIxLCB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMSwgeSksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjIsIHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIyLCB5KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgeCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHkpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVNsb3BlKHAwLCBwMSkge1xuICAgIHJldHVybiAocDFbMV0gLSBwMFsxXSkgLyAocDFbMF0gLSBwMFswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVGaW5pdGVEaWZmZXJlbmNlcyhwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIGogPSBwb2ludHMubGVuZ3RoIC0gMSwgbSA9IFtdLCBwMCA9IHBvaW50c1swXSwgcDEgPSBwb2ludHNbMV0sIGQgPSBtWzBdID0gZDNfc3ZnX2xpbmVTbG9wZShwMCwgcDEpO1xuICAgIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgICBtW2ldID0gKGQgKyAoZCA9IGQzX3N2Z19saW5lU2xvcGUocDAgPSBwMSwgcDEgPSBwb2ludHNbaSArIDFdKSkpIC8gMjtcbiAgICB9XG4gICAgbVtpXSA9IGQ7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVNb25vdG9uZVRhbmdlbnRzKHBvaW50cykge1xuICAgIHZhciB0YW5nZW50cyA9IFtdLCBkLCBhLCBiLCBzLCBtID0gZDNfc3ZnX2xpbmVGaW5pdGVEaWZmZXJlbmNlcyhwb2ludHMpLCBpID0gLTEsIGogPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoKytpIDwgaikge1xuICAgICAgZCA9IGQzX3N2Z19saW5lU2xvcGUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgIGlmIChhYnMoZCkgPCDOtSkge1xuICAgICAgICBtW2ldID0gbVtpICsgMV0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IG1baV0gLyBkO1xuICAgICAgICBiID0gbVtpICsgMV0gLyBkO1xuICAgICAgICBzID0gYSAqIGEgKyBiICogYjtcbiAgICAgICAgaWYgKHMgPiA5KSB7XG4gICAgICAgICAgcyA9IGQgKiAzIC8gTWF0aC5zcXJ0KHMpO1xuICAgICAgICAgIG1baV0gPSBzICogYTtcbiAgICAgICAgICBtW2kgKyAxXSA9IHMgKiBiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDw9IGopIHtcbiAgICAgIHMgPSAocG9pbnRzW01hdGgubWluKGosIGkgKyAxKV1bMF0gLSBwb2ludHNbTWF0aC5tYXgoMCwgaSAtIDEpXVswXSkgLyAoNiAqICgxICsgbVtpXSAqIG1baV0pKTtcbiAgICAgIHRhbmdlbnRzLnB1c2goWyBzIHx8IDAsIG1baV0gKiBzIHx8IDAgXSk7XG4gICAgfVxuICAgIHJldHVybiB0YW5nZW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZU1vbm90b25lKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMyA/IGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgOiBwb2ludHNbMF0gKyBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLCBkM19zdmdfbGluZU1vbm90b25lVGFuZ2VudHMocG9pbnRzKSk7XG4gIH1cbiAgZDMuc3ZnLmxpbmUucmFkaWFsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpbmUgPSBkM19zdmdfbGluZShkM19zdmdfbGluZVJhZGlhbCk7XG4gICAgbGluZS5yYWRpdXMgPSBsaW5lLngsIGRlbGV0ZSBsaW5lLng7XG4gICAgbGluZS5hbmdsZSA9IGxpbmUueSwgZGVsZXRlIGxpbmUueTtcbiAgICByZXR1cm4gbGluZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVSYWRpYWwocG9pbnRzKSB7XG4gICAgdmFyIHBvaW50LCBpID0gLTEsIG4gPSBwb2ludHMubGVuZ3RoLCByLCBhO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIHIgPSBwb2ludFswXTtcbiAgICAgIGEgPSBwb2ludFsxXSAtIGhhbGbPgDtcbiAgICAgIHBvaW50WzBdID0gciAqIE1hdGguY29zKGEpO1xuICAgICAgcG9pbnRbMV0gPSByICogTWF0aC5zaW4oYSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyZWEocHJvamVjdGlvbikge1xuICAgIHZhciB4MCA9IGQzX2dlb21fcG9pbnRYLCB4MSA9IGQzX2dlb21fcG9pbnRYLCB5MCA9IDAsIHkxID0gZDNfZ2VvbV9wb2ludFksIGRlZmluZWQgPSBkM190cnVlLCBpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lTGluZWFyLCBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlLmtleSwgaW50ZXJwb2xhdGVSZXZlcnNlID0gaW50ZXJwb2xhdGUsIEwgPSBcIkxcIiwgdGVuc2lvbiA9IC43O1xuICAgIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gW10sIHBvaW50czAgPSBbXSwgcG9pbnRzMSA9IFtdLCBpID0gLTEsIG4gPSBkYXRhLmxlbmd0aCwgZCwgZngwID0gZDNfZnVuY3Rvcih4MCksIGZ5MCA9IGQzX2Z1bmN0b3IoeTApLCBmeDEgPSB4MCA9PT0geDEgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9IDogZDNfZnVuY3Rvcih4MSksIGZ5MSA9IHkwID09PSB5MSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH0gOiBkM19mdW5jdG9yKHkxKSwgeCwgeTtcbiAgICAgIGZ1bmN0aW9uIHNlZ21lbnQoKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goXCJNXCIsIGludGVycG9sYXRlKHByb2plY3Rpb24ocG9pbnRzMSksIHRlbnNpb24pLCBMLCBpbnRlcnBvbGF0ZVJldmVyc2UocHJvamVjdGlvbihwb2ludHMwLnJldmVyc2UoKSksIHRlbnNpb24pLCBcIlpcIik7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZGVmaW5lZC5jYWxsKHRoaXMsIGQgPSBkYXRhW2ldLCBpKSkge1xuICAgICAgICAgIHBvaW50czAucHVzaChbIHggPSArZngwLmNhbGwodGhpcywgZCwgaSksIHkgPSArZnkwLmNhbGwodGhpcywgZCwgaSkgXSk7XG4gICAgICAgICAgcG9pbnRzMS5wdXNoKFsgK2Z4MS5jYWxsKHRoaXMsIGQsIGkpLCArZnkxLmNhbGwodGhpcywgZCwgaSkgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzMC5sZW5ndGgpIHtcbiAgICAgICAgICBzZWdtZW50KCk7XG4gICAgICAgICAgcG9pbnRzMCA9IFtdO1xuICAgICAgICAgIHBvaW50czEgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvaW50czAubGVuZ3RoKSBzZWdtZW50KCk7XG4gICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHMuam9pbihcIlwiKSA6IG51bGw7XG4gICAgfVxuICAgIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDAgPSB4MSA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MDtcbiAgICAgIHgwID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS54MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkwID0geTEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTA7XG4gICAgICB5MCA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkxID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmaW5lZDtcbiAgICAgIGRlZmluZWQgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW50ZXJwb2xhdGVLZXk7XG4gICAgICBpZiAodHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIikgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZSA9IF87IGVsc2UgaW50ZXJwb2xhdGVLZXkgPSAoaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUludGVycG9sYXRvcnMuZ2V0KF8pIHx8IGQzX3N2Z19saW5lTGluZWFyKS5rZXk7XG4gICAgICBpbnRlcnBvbGF0ZVJldmVyc2UgPSBpbnRlcnBvbGF0ZS5yZXZlcnNlIHx8IGludGVycG9sYXRlO1xuICAgICAgTCA9IGludGVycG9sYXRlLmNsb3NlZCA/IFwiTVwiIDogXCJMXCI7XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEudGVuc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRlbnNpb247XG4gICAgICB0ZW5zaW9uID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgcmV0dXJuIGFyZWE7XG4gIH1cbiAgZDNfc3ZnX2xpbmVTdGVwQmVmb3JlLnJldmVyc2UgPSBkM19zdmdfbGluZVN0ZXBBZnRlcjtcbiAgZDNfc3ZnX2xpbmVTdGVwQWZ0ZXIucmV2ZXJzZSA9IGQzX3N2Z19saW5lU3RlcEJlZm9yZTtcbiAgZDMuc3ZnLmFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc3ZnX2FyZWEoZDNfaWRlbnRpdHkpO1xuICB9O1xuICBkMy5zdmcuYXJlYS5yYWRpYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJlYSA9IGQzX3N2Z19hcmVhKGQzX3N2Z19saW5lUmFkaWFsKTtcbiAgICBhcmVhLnJhZGl1cyA9IGFyZWEueCwgZGVsZXRlIGFyZWEueDtcbiAgICBhcmVhLmlubmVyUmFkaXVzID0gYXJlYS54MCwgZGVsZXRlIGFyZWEueDA7XG4gICAgYXJlYS5vdXRlclJhZGl1cyA9IGFyZWEueDEsIGRlbGV0ZSBhcmVhLngxO1xuICAgIGFyZWEuYW5nbGUgPSBhcmVhLnksIGRlbGV0ZSBhcmVhLnk7XG4gICAgYXJlYS5zdGFydEFuZ2xlID0gYXJlYS55MCwgZGVsZXRlIGFyZWEueTA7XG4gICAgYXJlYS5lbmRBbmdsZSA9IGFyZWEueTEsIGRlbGV0ZSBhcmVhLnkxO1xuICAgIHJldHVybiBhcmVhO1xuICB9O1xuICBkMy5zdmcuY2hvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gZDNfc291cmNlLCB0YXJnZXQgPSBkM190YXJnZXQsIHJhZGl1cyA9IGQzX3N2Z19jaG9yZFJhZGl1cywgc3RhcnRBbmdsZSA9IGQzX3N2Z19hcmNTdGFydEFuZ2xlLCBlbmRBbmdsZSA9IGQzX3N2Z19hcmNFbmRBbmdsZTtcbiAgICBmdW5jdGlvbiBjaG9yZChkLCBpKSB7XG4gICAgICB2YXIgcyA9IHN1Ymdyb3VwKHRoaXMsIHNvdXJjZSwgZCwgaSksIHQgPSBzdWJncm91cCh0aGlzLCB0YXJnZXQsIGQsIGkpO1xuICAgICAgcmV0dXJuIFwiTVwiICsgcy5wMCArIGFyYyhzLnIsIHMucDEsIHMuYTEgLSBzLmEwKSArIChlcXVhbHMocywgdCkgPyBjdXJ2ZShzLnIsIHMucDEsIHMuciwgcy5wMCkgOiBjdXJ2ZShzLnIsIHMucDEsIHQuciwgdC5wMCkgKyBhcmModC5yLCB0LnAxLCB0LmExIC0gdC5hMCkgKyBjdXJ2ZSh0LnIsIHQucDEsIHMuciwgcy5wMCkpICsgXCJaXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1Ymdyb3VwKHNlbGYsIGYsIGQsIGkpIHtcbiAgICAgIHZhciBzdWJncm91cCA9IGYuY2FsbChzZWxmLCBkLCBpKSwgciA9IHJhZGl1cy5jYWxsKHNlbGYsIHN1Ymdyb3VwLCBpKSwgYTAgPSBzdGFydEFuZ2xlLmNhbGwoc2VsZiwgc3ViZ3JvdXAsIGkpIC0gaGFsZs+ALCBhMSA9IGVuZEFuZ2xlLmNhbGwoc2VsZiwgc3ViZ3JvdXAsIGkpIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogcixcbiAgICAgICAgYTA6IGEwLFxuICAgICAgICBhMTogYTEsXG4gICAgICAgIHAwOiBbIHIgKiBNYXRoLmNvcyhhMCksIHIgKiBNYXRoLnNpbihhMCkgXSxcbiAgICAgICAgcDE6IFsgciAqIE1hdGguY29zKGExKSwgciAqIE1hdGguc2luKGExKSBdXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgcmV0dXJuIGEuYTAgPT0gYi5hMCAmJiBhLmExID09IGIuYTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyYyhyLCBwLCBhKSB7XG4gICAgICByZXR1cm4gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCBcIiArICsoYSA+IM+AKSArIFwiLDEgXCIgKyBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXJ2ZShyMCwgcDAsIHIxLCBwMSkge1xuICAgICAgcmV0dXJuIFwiUSAwLDAgXCIgKyBwMTtcbiAgICB9XG4gICAgY2hvcmQucmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFkaXVzO1xuICAgICAgcmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvdXJjZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC50YXJnZXQgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXJ0QW5nbGU7XG4gICAgICBzdGFydEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLmVuZEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICByZXR1cm4gY2hvcmQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19jaG9yZFJhZGl1cyhkKSB7XG4gICAgcmV0dXJuIGQucmFkaXVzO1xuICB9XG4gIGQzLnN2Zy5kaWFnb25hbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSBkM19zb3VyY2UsIHRhcmdldCA9IGQzX3RhcmdldCwgcHJvamVjdGlvbiA9IGQzX3N2Z19kaWFnb25hbFByb2plY3Rpb247XG4gICAgZnVuY3Rpb24gZGlhZ29uYWwoZCwgaSkge1xuICAgICAgdmFyIHAwID0gc291cmNlLmNhbGwodGhpcywgZCwgaSksIHAzID0gdGFyZ2V0LmNhbGwodGhpcywgZCwgaSksIG0gPSAocDAueSArIHAzLnkpIC8gMiwgcCA9IFsgcDAsIHtcbiAgICAgICAgeDogcDAueCxcbiAgICAgICAgeTogbVxuICAgICAgfSwge1xuICAgICAgICB4OiBwMy54LFxuICAgICAgICB5OiBtXG4gICAgICB9LCBwMyBdO1xuICAgICAgcCA9IHAubWFwKHByb2plY3Rpb24pO1xuICAgICAgcmV0dXJuIFwiTVwiICsgcFswXSArIFwiQ1wiICsgcFsxXSArIFwiIFwiICsgcFsyXSArIFwiIFwiICsgcFszXTtcbiAgICB9XG4gICAgZGlhZ29uYWwuc291cmNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc291cmNlO1xuICAgICAgc291cmNlID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICB9O1xuICAgIGRpYWdvbmFsLnRhcmdldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHRhcmdldCA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICBkaWFnb25hbC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgIHByb2plY3Rpb24gPSB4O1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgcmV0dXJuIGRpYWdvbmFsO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfZGlhZ29uYWxQcm9qZWN0aW9uKGQpIHtcbiAgICByZXR1cm4gWyBkLngsIGQueSBdO1xuICB9XG4gIGQzLnN2Zy5kaWFnb25hbC5yYWRpYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlhZ29uYWwgPSBkMy5zdmcuZGlhZ29uYWwoKSwgcHJvamVjdGlvbiA9IGQzX3N2Z19kaWFnb25hbFByb2plY3Rpb24sIHByb2plY3Rpb25fID0gZGlhZ29uYWwucHJvamVjdGlvbjtcbiAgICBkaWFnb25hbC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBwcm9qZWN0aW9uXyhkM19zdmdfZGlhZ29uYWxSYWRpYWxQcm9qZWN0aW9uKHByb2plY3Rpb24gPSB4KSkgOiBwcm9qZWN0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIGRpYWdvbmFsO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfZGlhZ29uYWxSYWRpYWxQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZCA9IHByb2plY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgciA9IGRbMF0sIGEgPSBkWzFdIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIFsgciAqIE1hdGguY29zKGEpLCByICogTWF0aC5zaW4oYSkgXTtcbiAgICB9O1xuICB9XG4gIGQzLnN2Zy5zeW1ib2wgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHlwZSA9IGQzX3N2Z19zeW1ib2xUeXBlLCBzaXplID0gZDNfc3ZnX3N5bWJvbFNpemU7XG4gICAgZnVuY3Rpb24gc3ltYm9sKGQsIGkpIHtcbiAgICAgIHJldHVybiAoZDNfc3ZnX3N5bWJvbHMuZ2V0KHR5cGUuY2FsbCh0aGlzLCBkLCBpKSkgfHwgZDNfc3ZnX3N5bWJvbENpcmNsZSkoc2l6ZS5jYWxsKHRoaXMsIGQsIGkpKTtcbiAgICB9XG4gICAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0eXBlO1xuICAgICAgdHlwZSA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX3N5bWJvbFNpemUoKSB7XG4gICAgcmV0dXJuIDY0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19zeW1ib2xUeXBlKCkge1xuICAgIHJldHVybiBcImNpcmNsZVwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19zeW1ib2xDaXJjbGUoc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyDPgCk7XG4gICAgcmV0dXJuIFwiTTAsXCIgKyByICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCAxLDEgMCxcIiArIC1yICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCAxLDEgMCxcIiArIHIgKyBcIlpcIjtcbiAgfVxuICB2YXIgZDNfc3ZnX3N5bWJvbHMgPSBkMy5tYXAoe1xuICAgIGNpcmNsZTogZDNfc3ZnX3N5bWJvbENpcmNsZSxcbiAgICBjcm9zczogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHJldHVybiBcIk1cIiArIC0zICogciArIFwiLFwiICsgLXIgKyBcIkhcIiArIC1yICsgXCJWXCIgKyAtMyAqIHIgKyBcIkhcIiArIHIgKyBcIlZcIiArIC1yICsgXCJIXCIgKyAzICogciArIFwiVlwiICsgciArIFwiSFwiICsgciArIFwiVlwiICsgMyAqIHIgKyBcIkhcIiArIC1yICsgXCJWXCIgKyByICsgXCJIXCIgKyAtMyAqIHIgKyBcIlpcIjtcbiAgICB9LFxuICAgIGRpYW1vbmQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByeSA9IE1hdGguc3FydChzaXplIC8gKDIgKiBkM19zdmdfc3ltYm9sVGFuMzApKSwgcnggPSByeSAqIGQzX3N2Z19zeW1ib2xUYW4zMDtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgLXJ5ICsgXCJMXCIgKyByeCArIFwiLDBcIiArIFwiIDAsXCIgKyByeSArIFwiIFwiICsgLXJ4ICsgXCIsMFwiICsgXCJaXCI7XG4gICAgfSxcbiAgICBzcXVhcmU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMjtcbiAgICAgIHJldHVybiBcIk1cIiArIC1yICsgXCIsXCIgKyAtciArIFwiTFwiICsgciArIFwiLFwiICsgLXIgKyBcIiBcIiArIHIgKyBcIixcIiArIHIgKyBcIiBcIiArIC1yICsgXCIsXCIgKyByICsgXCJaXCI7XG4gICAgfSxcbiAgICBcInRyaWFuZ2xlLWRvd25cIjogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBkM19zdmdfc3ltYm9sU3FydDMpLCByeSA9IHJ4ICogZDNfc3ZnX3N5bWJvbFNxcnQzIC8gMjtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgcnkgKyBcIkxcIiArIHJ4ICsgXCIsXCIgKyAtcnkgKyBcIiBcIiArIC1yeCArIFwiLFwiICsgLXJ5ICsgXCJaXCI7XG4gICAgfSxcbiAgICBcInRyaWFuZ2xlLXVwXCI6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByeCA9IE1hdGguc3FydChzaXplIC8gZDNfc3ZnX3N5bWJvbFNxcnQzKSwgcnkgPSByeCAqIGQzX3N2Z19zeW1ib2xTcXJ0MyAvIDI7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIC1yeSArIFwiTFwiICsgcnggKyBcIixcIiArIHJ5ICsgXCIgXCIgKyAtcnggKyBcIixcIiArIHJ5ICsgXCJaXCI7XG4gICAgfVxuICB9KTtcbiAgZDMuc3ZnLnN5bWJvbFR5cGVzID0gZDNfc3ZnX3N5bWJvbHMua2V5cygpO1xuICB2YXIgZDNfc3ZnX3N5bWJvbFNxcnQzID0gTWF0aC5zcXJ0KDMpLCBkM19zdmdfc3ltYm9sVGFuMzAgPSBNYXRoLnRhbigzMCAqIGQzX3JhZGlhbnMpO1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaWQgPSBkM190cmFuc2l0aW9uSW5oZXJpdElkIHx8ICsrZDNfdHJhbnNpdGlvbklkLCBucyA9IGQzX3RyYW5zaXRpb25OYW1lc3BhY2UobmFtZSksIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgbm9kZSwgdHJhbnNpdGlvbiA9IGQzX3RyYW5zaXRpb25Jbmhlcml0IHx8IHtcbiAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICBlYXNlOiBkM19lYXNlX2N1YmljSW5PdXQsXG4gICAgICBkZWxheTogMCxcbiAgICAgIGR1cmF0aW9uOiAyNTBcbiAgICB9O1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBkM190cmFuc2l0aW9uTm9kZShub2RlLCBpLCBucywgaWQsIHRyYW5zaXRpb24pO1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZCk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChuYW1lID09IG51bGwgPyBkM19zZWxlY3Rpb25faW50ZXJydXB0IDogZDNfc2VsZWN0aW9uX2ludGVycnVwdE5TKGQzX3RyYW5zaXRpb25OYW1lc3BhY2UobmFtZSkpKTtcbiAgfTtcbiAgdmFyIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQgPSBkM19zZWxlY3Rpb25faW50ZXJydXB0TlMoZDNfdHJhbnNpdGlvbk5hbWVzcGFjZSgpKTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2ludGVycnVwdE5TKG5zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxvY2ssIGFjdGl2ZUlkLCBhY3RpdmU7XG4gICAgICBpZiAoKGxvY2sgPSB0aGlzW25zXSkgJiYgKGFjdGl2ZSA9IGxvY2tbYWN0aXZlSWQgPSBsb2NrLmFjdGl2ZV0pKSB7XG4gICAgICAgIGFjdGl2ZS50aW1lci5jID0gbnVsbDtcbiAgICAgICAgYWN0aXZlLnRpbWVyLnQgPSBOYU47XG4gICAgICAgIGlmICgtLWxvY2suY291bnQpIGRlbGV0ZSBsb2NrW2FjdGl2ZUlkXTsgZWxzZSBkZWxldGUgdGhpc1tuc107XG4gICAgICAgIGxvY2suYWN0aXZlICs9IC41O1xuICAgICAgICBhY3RpdmUuZXZlbnQgJiYgYWN0aXZlLmV2ZW50LmludGVycnVwdC5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGFjdGl2ZS5pbmRleCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uKGdyb3VwcywgbnMsIGlkKSB7XG4gICAgZDNfc3ViY2xhc3MoZ3JvdXBzLCBkM190cmFuc2l0aW9uUHJvdG90eXBlKTtcbiAgICBncm91cHMubmFtZXNwYWNlID0gbnM7XG4gICAgZ3JvdXBzLmlkID0gaWQ7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuICB2YXIgZDNfdHJhbnNpdGlvblByb3RvdHlwZSA9IFtdLCBkM190cmFuc2l0aW9uSWQgPSAwLCBkM190cmFuc2l0aW9uSW5oZXJpdElkLCBkM190cmFuc2l0aW9uSW5oZXJpdDtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5jYWxsID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNhbGw7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZW1wdHkgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZW1wdHk7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUubm9kZSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5ub2RlO1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnNpemUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2l6ZTtcbiAgZDMudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgbmFtZSkge1xuICAgIHJldHVybiBzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnRyYW5zaXRpb24gPyBkM190cmFuc2l0aW9uSW5oZXJpdElkID8gc2VsZWN0aW9uLnRyYW5zaXRpb24obmFtZSkgOiBzZWxlY3Rpb24gOiBkMy5zZWxlY3Rpb24oKS50cmFuc2l0aW9uKHNlbGVjdGlvbik7XG4gIH07XG4gIGQzLnRyYW5zaXRpb24ucHJvdG90eXBlID0gZDNfdHJhbnNpdGlvblByb3RvdHlwZTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2UsIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZSwgbm9kZTtcbiAgICBzZWxlY3RvciA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpKSB7XG4gICAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgICBkM190cmFuc2l0aW9uTm9kZShzdWJub2RlLCBpLCBucywgaWQsIG5vZGVbbnNdW2lkXSk7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChzdWJub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgbnMsIGlkKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2UsIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZXMsIG5vZGUsIHN1Ym5vZGUsIHRyYW5zaXRpb247XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBub2RlW25zXVtpZF07XG4gICAgICAgICAgc3Vibm9kZXMgPSBzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopO1xuICAgICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAtMSwgbyA9IHN1Ym5vZGVzLmxlbmd0aDsgKytrIDwgbzsgKSB7XG4gICAgICAgICAgICBpZiAoc3Vibm9kZSA9IHN1Ym5vZGVzW2tdKSBkM190cmFuc2l0aW9uTm9kZShzdWJub2RlLCBrLCBucywgaWQsIHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgc3ViZ3JvdXAucHVzaChzdWJub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCBucywgaWQpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIGdyb3VwLCBub2RlO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGQzX3NlbGVjdGlvbl9maWx0ZXIoZmlsdGVyKTtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIGZpbHRlci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMubmFtZXNwYWNlLCB0aGlzLmlkKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS50d2VlbiA9IGZ1bmN0aW9uKG5hbWUsIHR3ZWVuKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLnR3ZWVuLmdldChuYW1lKTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgdHdlZW4gPT0gbnVsbCA/IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS50d2Vlbi5yZW1vdmUobmFtZSk7XG4gICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS50d2Vlbi5zZXQobmFtZSwgdHdlZW4pO1xuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uX3R3ZWVuKGdyb3VwcywgbmFtZSwgdmFsdWUsIHR3ZWVuKSB7XG4gICAgdmFyIGlkID0gZ3JvdXBzLmlkLCBucyA9IGdyb3Vwcy5uYW1lc3BhY2U7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKGdyb3VwcywgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4uc2V0KG5hbWUsIHR3ZWVuKHZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpKTtcbiAgICB9IDogKHZhbHVlID0gdHdlZW4odmFsdWUpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4uc2V0KG5hbWUsIHZhbHVlKTtcbiAgICB9KSk7XG4gIH1cbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24obmFtZU5TLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lTlMpIHRoaXMuYXR0cih2YWx1ZSwgbmFtZU5TW3ZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGludGVycG9sYXRlID0gbmFtZU5TID09IFwidHJhbnNmb3JtXCIgPyBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybSA6IGQzX2ludGVycG9sYXRlLCBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lTlMpO1xuICAgIGZ1bmN0aW9uIGF0dHJOdWxsKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJOdWxsTlMoKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyVHdlZW4oYikge1xuICAgICAgcmV0dXJuIGIgPT0gbnVsbCA/IGF0dHJOdWxsIDogKGIgKz0gXCJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSksIGk7XG4gICAgICAgIHJldHVybiBhICE9PSBiICYmIChpID0gaW50ZXJwb2xhdGUoYSwgYiksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBpKHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuTlMoYikge1xuICAgICAgcmV0dXJuIGIgPT0gbnVsbCA/IGF0dHJOdWxsTlMgOiAoYiArPSBcIlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpLCBpO1xuICAgICAgICByZXR1cm4gYSAhPT0gYiAmJiAoaSA9IGludGVycG9sYXRlKGEsIGIpLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCBpKHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb25fdHdlZW4odGhpcywgXCJhdHRyLlwiICsgbmFtZU5TLCB2YWx1ZSwgbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5hdHRyVHdlZW4gPSBmdW5jdGlvbihuYW1lTlMsIHR3ZWVuKSB7XG4gICAgdmFyIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWVOUyk7XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuKGQsIGkpIHtcbiAgICAgIHZhciBmID0gdHdlZW4uY2FsbCh0aGlzLCBkLCBpLCB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSk7XG4gICAgICByZXR1cm4gZiAmJiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGYodCkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuTlMoZCwgaSkge1xuICAgICAgdmFyIGYgPSB0d2Vlbi5jYWxsKHRoaXMsIGQsIGksIHRoaXMuZ2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCkpO1xuICAgICAgcmV0dXJuIGYgJiYgZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwsIGYodCkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHdlZW4oXCJhdHRyLlwiICsgbmFtZU5TLCBuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnN0eWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMykge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuIDwgMikgdmFsdWUgPSBcIlwiO1xuICAgICAgICBmb3IgKHByaW9yaXR5IGluIG5hbWUpIHRoaXMuc3R5bGUocHJpb3JpdHksIG5hbWVbcHJpb3JpdHldLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcHJpb3JpdHkgPSBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZU51bGwoKSB7XG4gICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHlsZVN0cmluZyhiKSB7XG4gICAgICByZXR1cm4gYiA9PSBudWxsID8gc3R5bGVOdWxsIDogKGIgKz0gXCJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gZDNfd2luZG93KHRoaXMpLmdldENvbXB1dGVkU3R5bGUodGhpcywgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSwgaTtcbiAgICAgICAgcmV0dXJuIGEgIT09IGIgJiYgKGkgPSBkM19pbnRlcnBvbGF0ZShhLCBiKSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgaSh0KSwgcHJpb3JpdHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbl90d2Vlbih0aGlzLCBcInN0eWxlLlwiICsgbmFtZSwgdmFsdWUsIHN0eWxlU3RyaW5nKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zdHlsZVR3ZWVuID0gZnVuY3Rpb24obmFtZSwgdHdlZW4sIHByaW9yaXR5KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBwcmlvcml0eSA9IFwiXCI7XG4gICAgZnVuY3Rpb24gc3R5bGVUd2VlbihkLCBpKSB7XG4gICAgICB2YXIgZiA9IHR3ZWVuLmNhbGwodGhpcywgZCwgaSwgZDNfd2luZG93KHRoaXMpLmdldENvbXB1dGVkU3R5bGUodGhpcywgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gICAgICByZXR1cm4gZiAmJiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgZih0KSwgcHJpb3JpdHkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHdlZW4oXCJzdHlsZS5cIiArIG5hbWUsIHN0eWxlVHdlZW4pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBkM190cmFuc2l0aW9uX3R3ZWVuKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSwgZDNfdHJhbnNpdGlvbl90ZXh0KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbl90ZXh0KGIpIHtcbiAgICBpZiAoYiA9PSBudWxsKSBiID0gXCJcIjtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gYjtcbiAgICB9O1xuICB9XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChcImVuZC50cmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHA7XG4gICAgICBpZiAodGhpc1tuc10uY291bnQgPCAyICYmIChwID0gdGhpcy5wYXJlbnROb2RlKSkgcC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9KTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5lYXNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXMubm9kZSgpW25zXVtpZF0uZWFzZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gZDMuZWFzZS5hcHBseShkMywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLmVhc2UgPSB2YWx1ZTtcbiAgICB9KTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLmRlbGF5O1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kZWxheSA9ICt2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopO1xuICAgIH0gOiAodmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kZWxheSA9IHZhbHVlO1xuICAgIH0pKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLmR1cmF0aW9uO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kdXJhdGlvbiA9IE1hdGgubWF4KDEsIHZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpO1xuICAgIH0gOiAodmFsdWUgPSBNYXRoLm1heCgxLCB2YWx1ZSksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5kdXJhdGlvbiA9IHZhbHVlO1xuICAgIH0pKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIGluaGVyaXQgPSBkM190cmFuc2l0aW9uSW5oZXJpdCwgaW5oZXJpdElkID0gZDNfdHJhbnNpdGlvbkluaGVyaXRJZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgPSBpZDtcbiAgICAgICAgZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0ID0gbm9kZVtuc11baWRdO1xuICAgICAgICAgIHR5cGUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdCA9IGluaGVyaXQ7XG4gICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgPSBpbmhlcml0SWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBub2RlW25zXVtpZF07XG4gICAgICAgICh0cmFuc2l0aW9uLmV2ZW50IHx8ICh0cmFuc2l0aW9uLmV2ZW50ID0gZDMuZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImludGVycnVwdFwiKSkpLm9uKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkMCA9IHRoaXMuaWQsIGlkMSA9ICsrZDNfdHJhbnNpdGlvbklkLCBucyA9IHRoaXMubmFtZXNwYWNlLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIGdyb3VwLCBub2RlLCB0cmFuc2l0aW9uO1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gdGhpcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IG5vZGVbbnNdW2lkMF07XG4gICAgICAgICAgZDNfdHJhbnNpdGlvbk5vZGUobm9kZSwgaSwgbnMsIGlkMSwge1xuICAgICAgICAgICAgdGltZTogdHJhbnNpdGlvbi50aW1lLFxuICAgICAgICAgICAgZWFzZTogdHJhbnNpdGlvbi5lYXNlLFxuICAgICAgICAgICAgZGVsYXk6IHRyYW5zaXRpb24uZGVsYXkgKyB0cmFuc2l0aW9uLmR1cmF0aW9uLFxuICAgICAgICAgICAgZHVyYXRpb246IHRyYW5zaXRpb24uZHVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZDEpO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uTmFtZXNwYWNlKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSA9PSBudWxsID8gXCJfX3RyYW5zaXRpb25fX1wiIDogXCJfX3RyYW5zaXRpb25fXCIgKyBuYW1lICsgXCJfX1wiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb25Ob2RlKG5vZGUsIGksIG5zLCBpZCwgaW5oZXJpdCkge1xuICAgIHZhciBsb2NrID0gbm9kZVtuc10gfHwgKG5vZGVbbnNdID0ge1xuICAgICAgYWN0aXZlOiAwLFxuICAgICAgY291bnQ6IDBcbiAgICB9KSwgdHJhbnNpdGlvbiA9IGxvY2tbaWRdLCB0aW1lLCB0aW1lciwgZHVyYXRpb24sIGVhc2UsIHR3ZWVucztcbiAgICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgICB2YXIgZGVsYXkgPSB0cmFuc2l0aW9uLmRlbGF5O1xuICAgICAgdGltZXIudCA9IGRlbGF5ICsgdGltZTtcbiAgICAgIGlmIChkZWxheSA8PSBlbGFwc2VkKSByZXR1cm4gc3RhcnQoZWxhcHNlZCAtIGRlbGF5KTtcbiAgICAgIHRpbWVyLmMgPSBzdGFydDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnQoZWxhcHNlZCkge1xuICAgICAgdmFyIGFjdGl2ZUlkID0gbG9jay5hY3RpdmUsIGFjdGl2ZSA9IGxvY2tbYWN0aXZlSWRdO1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBhY3RpdmUudGltZXIuYyA9IG51bGw7XG4gICAgICAgIGFjdGl2ZS50aW1lci50ID0gTmFOO1xuICAgICAgICAtLWxvY2suY291bnQ7XG4gICAgICAgIGRlbGV0ZSBsb2NrW2FjdGl2ZUlkXTtcbiAgICAgICAgYWN0aXZlLmV2ZW50ICYmIGFjdGl2ZS5ldmVudC5pbnRlcnJ1cHQuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBhY3RpdmUuaW5kZXgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgY2FuY2VsSWQgaW4gbG9jaykge1xuICAgICAgICBpZiAoK2NhbmNlbElkIDwgaWQpIHtcbiAgICAgICAgICB2YXIgY2FuY2VsID0gbG9ja1tjYW5jZWxJZF07XG4gICAgICAgICAgY2FuY2VsLnRpbWVyLmMgPSBudWxsO1xuICAgICAgICAgIGNhbmNlbC50aW1lci50ID0gTmFOO1xuICAgICAgICAgIC0tbG9jay5jb3VudDtcbiAgICAgICAgICBkZWxldGUgbG9ja1tjYW5jZWxJZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRpbWVyLmMgPSB0aWNrO1xuICAgICAgZDNfdGltZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aW1lci5jICYmIHRpY2soZWxhcHNlZCB8fCAxKSkge1xuICAgICAgICAgIHRpbWVyLmMgPSBudWxsO1xuICAgICAgICAgIHRpbWVyLnQgPSBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9LCAwLCB0aW1lKTtcbiAgICAgIGxvY2suYWN0aXZlID0gaWQ7XG4gICAgICB0cmFuc2l0aW9uLmV2ZW50ICYmIHRyYW5zaXRpb24uZXZlbnQuc3RhcnQuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKTtcbiAgICAgIHR3ZWVucyA9IFtdO1xuICAgICAgdHJhbnNpdGlvbi50d2Vlbi5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID0gdmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKSkge1xuICAgICAgICAgIHR3ZWVucy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlYXNlID0gdHJhbnNpdGlvbi5lYXNlO1xuICAgICAgZHVyYXRpb24gPSB0cmFuc2l0aW9uLmR1cmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICAgIHZhciB0ID0gZWxhcHNlZCAvIGR1cmF0aW9uLCBlID0gZWFzZSh0KSwgbiA9IHR3ZWVucy5sZW5ndGg7XG4gICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgdHdlZW5zWy0tbl0uY2FsbChub2RlLCBlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5ldmVudCAmJiB0cmFuc2l0aW9uLmV2ZW50LmVuZC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpO1xuICAgICAgICBpZiAoLS1sb2NrLmNvdW50KSBkZWxldGUgbG9ja1tpZF07IGVsc2UgZGVsZXRlIG5vZGVbbnNdO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0cmFuc2l0aW9uKSB7XG4gICAgICB0aW1lID0gaW5oZXJpdC50aW1lO1xuICAgICAgdGltZXIgPSBkM190aW1lcihzY2hlZHVsZSwgMCwgdGltZSk7XG4gICAgICB0cmFuc2l0aW9uID0gbG9ja1tpZF0gPSB7XG4gICAgICAgIHR3ZWVuOiBuZXcgZDNfTWFwKCksXG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIHRpbWVyOiB0aW1lcixcbiAgICAgICAgZGVsYXk6IGluaGVyaXQuZGVsYXksXG4gICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICBlYXNlOiBpbmhlcml0LmVhc2UsXG4gICAgICAgIGluZGV4OiBpXG4gICAgICB9O1xuICAgICAgaW5oZXJpdCA9IG51bGw7XG4gICAgICArK2xvY2suY291bnQ7XG4gICAgfVxuICB9XG4gIGQzLnN2Zy5heGlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjYWxlID0gZDMuc2NhbGUubGluZWFyKCksIG9yaWVudCA9IGQzX3N2Z19heGlzRGVmYXVsdE9yaWVudCwgaW5uZXJUaWNrU2l6ZSA9IDYsIG91dGVyVGlja1NpemUgPSA2LCB0aWNrUGFkZGluZyA9IDMsIHRpY2tBcmd1bWVudHNfID0gWyAxMCBdLCB0aWNrVmFsdWVzID0gbnVsbCwgdGlja0Zvcm1hdF87XG4gICAgZnVuY3Rpb24gYXhpcyhnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2NhbGUwID0gdGhpcy5fX2NoYXJ0X18gfHwgc2NhbGUsIHNjYWxlMSA9IHRoaXMuX19jaGFydF9fID0gc2NhbGUuY29weSgpO1xuICAgICAgICB2YXIgdGlja3MgPSB0aWNrVmFsdWVzID09IG51bGwgPyBzY2FsZTEudGlja3MgPyBzY2FsZTEudGlja3MuYXBwbHkoc2NhbGUxLCB0aWNrQXJndW1lbnRzXykgOiBzY2FsZTEuZG9tYWluKCkgOiB0aWNrVmFsdWVzLCB0aWNrRm9ybWF0ID0gdGlja0Zvcm1hdF8gPT0gbnVsbCA/IHNjYWxlMS50aWNrRm9ybWF0ID8gc2NhbGUxLnRpY2tGb3JtYXQuYXBwbHkoc2NhbGUxLCB0aWNrQXJndW1lbnRzXykgOiBkM19pZGVudGl0eSA6IHRpY2tGb3JtYXRfLCB0aWNrID0gZy5zZWxlY3RBbGwoXCIudGlja1wiKS5kYXRhKHRpY2tzLCBzY2FsZTEpLCB0aWNrRW50ZXIgPSB0aWNrLmVudGVyKCkuaW5zZXJ0KFwiZ1wiLCBcIi5kb21haW5cIikuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKS5zdHlsZShcIm9wYWNpdHlcIiwgzrUpLCB0aWNrRXhpdCA9IGQzLnRyYW5zaXRpb24odGljay5leGl0KCkpLnN0eWxlKFwib3BhY2l0eVwiLCDOtSkucmVtb3ZlKCksIHRpY2tVcGRhdGUgPSBkMy50cmFuc2l0aW9uKHRpY2sub3JkZXIoKSkuc3R5bGUoXCJvcGFjaXR5XCIsIDEpLCB0aWNrU3BhY2luZyA9IE1hdGgubWF4KGlubmVyVGlja1NpemUsIDApICsgdGlja1BhZGRpbmcsIHRpY2tUcmFuc2Zvcm07XG4gICAgICAgIHZhciByYW5nZSA9IGQzX3NjYWxlUmFuZ2Uoc2NhbGUxKSwgcGF0aCA9IGcuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFsgMCBdKSwgcGF0aFVwZGF0ZSA9IChwYXRoLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIiksIFxuICAgICAgICBkMy50cmFuc2l0aW9uKHBhdGgpKTtcbiAgICAgICAgdGlja0VudGVyLmFwcGVuZChcImxpbmVcIik7XG4gICAgICAgIHRpY2tFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xuICAgICAgICB2YXIgbGluZUVudGVyID0gdGlja0VudGVyLnNlbGVjdChcImxpbmVcIiksIGxpbmVVcGRhdGUgPSB0aWNrVXBkYXRlLnNlbGVjdChcImxpbmVcIiksIHRleHQgPSB0aWNrLnNlbGVjdChcInRleHRcIikudGV4dCh0aWNrRm9ybWF0KSwgdGV4dEVudGVyID0gdGlja0VudGVyLnNlbGVjdChcInRleHRcIiksIHRleHRVcGRhdGUgPSB0aWNrVXBkYXRlLnNlbGVjdChcInRleHRcIiksIHNpZ24gPSBvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIiA/IC0xIDogMSwgeDEsIHgyLCB5MSwgeTI7XG4gICAgICAgIGlmIChvcmllbnQgPT09IFwiYm90dG9tXCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgdGlja1RyYW5zZm9ybSA9IGQzX3N2Z19heGlzWCwgeDEgPSBcInhcIiwgeTEgPSBcInlcIiwgeDIgPSBcIngyXCIsIHkyID0gXCJ5MlwiO1xuICAgICAgICAgIHRleHQuYXR0cihcImR5XCIsIHNpZ24gPCAwID8gXCIwZW1cIiA6IFwiLjcxZW1cIikuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcbiAgICAgICAgICBwYXRoVXBkYXRlLmF0dHIoXCJkXCIsIFwiTVwiICsgcmFuZ2VbMF0gKyBcIixcIiArIHNpZ24gKiBvdXRlclRpY2tTaXplICsgXCJWMEhcIiArIHJhbmdlWzFdICsgXCJWXCIgKyBzaWduICogb3V0ZXJUaWNrU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja1RyYW5zZm9ybSA9IGQzX3N2Z19heGlzWSwgeDEgPSBcInlcIiwgeTEgPSBcInhcIiwgeDIgPSBcInkyXCIsIHkyID0gXCJ4MlwiO1xuICAgICAgICAgIHRleHQuYXR0cihcImR5XCIsIFwiLjMyZW1cIikuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBzaWduIDwgMCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIpO1xuICAgICAgICAgIHBhdGhVcGRhdGUuYXR0cihcImRcIiwgXCJNXCIgKyBzaWduICogb3V0ZXJUaWNrU2l6ZSArIFwiLFwiICsgcmFuZ2VbMF0gKyBcIkgwVlwiICsgcmFuZ2VbMV0gKyBcIkhcIiArIHNpZ24gKiBvdXRlclRpY2tTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lRW50ZXIuYXR0cih5Miwgc2lnbiAqIGlubmVyVGlja1NpemUpO1xuICAgICAgICB0ZXh0RW50ZXIuYXR0cih5MSwgc2lnbiAqIHRpY2tTcGFjaW5nKTtcbiAgICAgICAgbGluZVVwZGF0ZS5hdHRyKHgyLCAwKS5hdHRyKHkyLCBzaWduICogaW5uZXJUaWNrU2l6ZSk7XG4gICAgICAgIHRleHRVcGRhdGUuYXR0cih4MSwgMCkuYXR0cih5MSwgc2lnbiAqIHRpY2tTcGFjaW5nKTtcbiAgICAgICAgaWYgKHNjYWxlMS5yYW5nZUJhbmQpIHtcbiAgICAgICAgICB2YXIgeCA9IHNjYWxlMSwgZHggPSB4LnJhbmdlQmFuZCgpIC8gMjtcbiAgICAgICAgICBzY2FsZTAgPSBzY2FsZTEgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4geChkKSArIGR4O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2NhbGUwLnJhbmdlQmFuZCkge1xuICAgICAgICAgIHNjYWxlMCA9IHNjYWxlMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWNrRXhpdC5jYWxsKHRpY2tUcmFuc2Zvcm0sIHNjYWxlMSwgc2NhbGUwKTtcbiAgICAgICAgfVxuICAgICAgICB0aWNrRW50ZXIuY2FsbCh0aWNrVHJhbnNmb3JtLCBzY2FsZTAsIHNjYWxlMSk7XG4gICAgICAgIHRpY2tVcGRhdGUuY2FsbCh0aWNrVHJhbnNmb3JtLCBzY2FsZTEsIHNjYWxlMSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYXhpcy5zY2FsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlO1xuICAgICAgc2NhbGUgPSB4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLm9yaWVudCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICAgIG9yaWVudCA9IHggaW4gZDNfc3ZnX2F4aXNPcmllbnRzID8geCArIFwiXCIgOiBkM19zdmdfYXhpc0RlZmF1bHRPcmllbnQ7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tBcmd1bWVudHNfO1xuICAgICAgdGlja0FyZ3VtZW50c18gPSBkM19hcnJheShhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tWYWx1ZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrVmFsdWVzO1xuICAgICAgdGlja1ZhbHVlcyA9IHg7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tGb3JtYXRfO1xuICAgICAgdGlja0Zvcm1hdF8gPSB4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFuKSByZXR1cm4gaW5uZXJUaWNrU2l6ZTtcbiAgICAgIGlubmVyVGlja1NpemUgPSAreDtcbiAgICAgIG91dGVyVGlja1NpemUgPSArYXJndW1lbnRzW24gLSAxXTtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy5pbm5lclRpY2tTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW5uZXJUaWNrU2l6ZTtcbiAgICAgIGlubmVyVGlja1NpemUgPSAreDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy5vdXRlclRpY2tTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0ZXJUaWNrU2l6ZTtcbiAgICAgIG91dGVyVGlja1NpemUgPSAreDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrUGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tQYWRkaW5nO1xuICAgICAgdGlja1BhZGRpbmcgPSAreDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrU3ViZGl2aWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCAmJiBheGlzO1xuICAgIH07XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG4gIHZhciBkM19zdmdfYXhpc0RlZmF1bHRPcmllbnQgPSBcImJvdHRvbVwiLCBkM19zdmdfYXhpc09yaWVudHMgPSB7XG4gICAgdG9wOiAxLFxuICAgIHJpZ2h0OiAxLFxuICAgIGJvdHRvbTogMSxcbiAgICBsZWZ0OiAxXG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19heGlzWChzZWxlY3Rpb24sIHgwLCB4MSkge1xuICAgIHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciB2MCA9IHgwKGQpO1xuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgKGlzRmluaXRlKHYwKSA/IHYwIDogeDEoZCkpICsgXCIsMClcIjtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXhpc1koc2VsZWN0aW9uLCB5MCwgeTEpIHtcbiAgICBzZWxlY3Rpb24uYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgdjAgPSB5MChkKTtcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgKGlzRmluaXRlKHYwKSA/IHYwIDogeTEoZCkpICsgXCIpXCI7XG4gICAgfSk7XG4gIH1cbiAgZDMuc3ZnLmJydXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV2ZW50ID0gZDNfZXZlbnREaXNwYXRjaChicnVzaCwgXCJicnVzaHN0YXJ0XCIsIFwiYnJ1c2hcIiwgXCJicnVzaGVuZFwiKSwgeCA9IG51bGwsIHkgPSBudWxsLCB4RXh0ZW50ID0gWyAwLCAwIF0sIHlFeHRlbnQgPSBbIDAsIDAgXSwgeEV4dGVudERvbWFpbiwgeUV4dGVudERvbWFpbiwgeENsYW1wID0gdHJ1ZSwgeUNsYW1wID0gdHJ1ZSwgcmVzaXplcyA9IGQzX3N2Z19icnVzaFJlc2l6ZXNbMF07XG4gICAgZnVuY3Rpb24gYnJ1c2goZykge1xuICAgICAgZy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZyA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKS5vbihcIm1vdXNlZG93bi5icnVzaFwiLCBicnVzaHN0YXJ0KS5vbihcInRvdWNoc3RhcnQuYnJ1c2hcIiwgYnJ1c2hzdGFydCk7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kID0gZy5zZWxlY3RBbGwoXCIuYmFja2dyb3VuZFwiKS5kYXRhKFsgMCBdKTtcbiAgICAgICAgYmFja2dyb3VuZC5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIFwiYmFja2dyb3VuZFwiKS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikuc3R5bGUoXCJjdXJzb3JcIiwgXCJjcm9zc2hhaXJcIik7XG4gICAgICAgIGcuc2VsZWN0QWxsKFwiLmV4dGVudFwiKS5kYXRhKFsgMCBdKS5lbnRlcigpLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIFwiZXh0ZW50XCIpLnN0eWxlKFwiY3Vyc29yXCIsIFwibW92ZVwiKTtcbiAgICAgICAgdmFyIHJlc2l6ZSA9IGcuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5kYXRhKHJlc2l6ZXMsIGQzX2lkZW50aXR5KTtcbiAgICAgICAgcmVzaXplLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgcmVzaXplLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBcInJlc2l6ZSBcIiArIGQ7XG4gICAgICAgIH0pLnN0eWxlKFwiY3Vyc29yXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gZDNfc3ZnX2JydXNoQ3Vyc29yW2RdO1xuICAgICAgICB9KS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gL1tld10kLy50ZXN0KGQpID8gLTMgOiBudWxsO1xuICAgICAgICB9KS5hdHRyKFwieVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIC9eW25zXS8udGVzdChkKSA/IC0zIDogbnVsbDtcbiAgICAgICAgfSkuYXR0cihcIndpZHRoXCIsIDYpLmF0dHIoXCJoZWlnaHRcIiwgNikuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICByZXNpemUuc3R5bGUoXCJkaXNwbGF5XCIsIGJydXNoLmVtcHR5KCkgPyBcIm5vbmVcIiA6IG51bGwpO1xuICAgICAgICB2YXIgZ1VwZGF0ZSA9IGQzLnRyYW5zaXRpb24oZyksIGJhY2tncm91bmRVcGRhdGUgPSBkMy50cmFuc2l0aW9uKGJhY2tncm91bmQpLCByYW5nZTtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICByYW5nZSA9IGQzX3NjYWxlUmFuZ2UoeCk7XG4gICAgICAgICAgYmFja2dyb3VuZFVwZGF0ZS5hdHRyKFwieFwiLCByYW5nZVswXSkuYXR0cihcIndpZHRoXCIsIHJhbmdlWzFdIC0gcmFuZ2VbMF0pO1xuICAgICAgICAgIHJlZHJhd1goZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICByYW5nZSA9IGQzX3NjYWxlUmFuZ2UoeSk7XG4gICAgICAgICAgYmFja2dyb3VuZFVwZGF0ZS5hdHRyKFwieVwiLCByYW5nZVswXSkuYXR0cihcImhlaWdodFwiLCByYW5nZVsxXSAtIHJhbmdlWzBdKTtcbiAgICAgICAgICByZWRyYXdZKGdVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJlZHJhdyhnVXBkYXRlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBicnVzaC5ldmVudCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGV2ZW50XyA9IGV2ZW50Lm9mKHRoaXMsIGFyZ3VtZW50cyksIGV4dGVudDEgPSB7XG4gICAgICAgICAgeDogeEV4dGVudCxcbiAgICAgICAgICB5OiB5RXh0ZW50LFxuICAgICAgICAgIGk6IHhFeHRlbnREb21haW4sXG4gICAgICAgICAgajogeUV4dGVudERvbWFpblxuICAgICAgICB9LCBleHRlbnQwID0gdGhpcy5fX2NoYXJ0X18gfHwgZXh0ZW50MTtcbiAgICAgICAgdGhpcy5fX2NoYXJ0X18gPSBleHRlbnQxO1xuICAgICAgICBpZiAoZDNfdHJhbnNpdGlvbkluaGVyaXRJZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZWFjaChcInN0YXJ0LmJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgeEV4dGVudERvbWFpbiA9IGV4dGVudDAuaTtcbiAgICAgICAgICAgIHlFeHRlbnREb21haW4gPSBleHRlbnQwLmo7XG4gICAgICAgICAgICB4RXh0ZW50ID0gZXh0ZW50MC54O1xuICAgICAgICAgICAgeUV4dGVudCA9IGV4dGVudDAueTtcbiAgICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hzdGFydFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS50d2VlbihcImJydXNoOmJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHhpID0gZDNfaW50ZXJwb2xhdGVBcnJheSh4RXh0ZW50LCBleHRlbnQxLngpLCB5aSA9IGQzX2ludGVycG9sYXRlQXJyYXkoeUV4dGVudCwgZXh0ZW50MS55KTtcbiAgICAgICAgICAgIHhFeHRlbnREb21haW4gPSB5RXh0ZW50RG9tYWluID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgIHhFeHRlbnQgPSBleHRlbnQxLnggPSB4aSh0KTtcbiAgICAgICAgICAgICAgeUV4dGVudCA9IGV4dGVudDEueSA9IHlpKHQpO1xuICAgICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgICAgICBtb2RlOiBcInJlc2l6ZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KS5lYWNoKFwiZW5kLmJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgeEV4dGVudERvbWFpbiA9IGV4dGVudDEuaTtcbiAgICAgICAgICAgIHlFeHRlbnREb21haW4gPSBleHRlbnQxLmo7XG4gICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICB0eXBlOiBcImJydXNoXCIsXG4gICAgICAgICAgICAgIG1vZGU6IFwicmVzaXplXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJicnVzaGVuZFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaHN0YXJ0XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgbW9kZTogXCJyZXNpemVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICB0eXBlOiBcImJydXNoZW5kXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZWRyYXcoZykge1xuICAgICAgZy5zZWxlY3RBbGwoXCIucmVzaXplXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4RXh0ZW50WysvZSQvLnRlc3QoZCldICsgXCIsXCIgKyB5RXh0ZW50WysvXnMvLnRlc3QoZCldICsgXCIpXCI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkcmF3WChnKSB7XG4gICAgICBnLnNlbGVjdChcIi5leHRlbnRcIikuYXR0cihcInhcIiwgeEV4dGVudFswXSk7XG4gICAgICBnLnNlbGVjdEFsbChcIi5leHRlbnQsLm4+cmVjdCwucz5yZWN0XCIpLmF0dHIoXCJ3aWR0aFwiLCB4RXh0ZW50WzFdIC0geEV4dGVudFswXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZHJhd1koZykge1xuICAgICAgZy5zZWxlY3QoXCIuZXh0ZW50XCIpLmF0dHIoXCJ5XCIsIHlFeHRlbnRbMF0pO1xuICAgICAgZy5zZWxlY3RBbGwoXCIuZXh0ZW50LC5lPnJlY3QsLnc+cmVjdFwiKS5hdHRyKFwiaGVpZ2h0XCIsIHlFeHRlbnRbMV0gLSB5RXh0ZW50WzBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnJ1c2hzdGFydCgpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCBldmVudFRhcmdldCA9IGQzLnNlbGVjdChkMy5ldmVudC50YXJnZXQpLCBldmVudF8gPSBldmVudC5vZih0YXJnZXQsIGFyZ3VtZW50cyksIGcgPSBkMy5zZWxlY3QodGFyZ2V0KSwgcmVzaXppbmcgPSBldmVudFRhcmdldC5kYXR1bSgpLCByZXNpemluZ1ggPSAhL14obnxzKSQvLnRlc3QocmVzaXppbmcpICYmIHgsIHJlc2l6aW5nWSA9ICEvXihlfHcpJC8udGVzdChyZXNpemluZykgJiYgeSwgZHJhZ2dpbmcgPSBldmVudFRhcmdldC5jbGFzc2VkKFwiZXh0ZW50XCIpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcyh0YXJnZXQpLCBjZW50ZXIsIG9yaWdpbiA9IGQzLm1vdXNlKHRhcmdldCksIG9mZnNldDtcbiAgICAgIHZhciB3ID0gZDMuc2VsZWN0KGQzX3dpbmRvdyh0YXJnZXQpKS5vbihcImtleWRvd24uYnJ1c2hcIiwga2V5ZG93bikub24oXCJrZXl1cC5icnVzaFwiLCBrZXl1cCk7XG4gICAgICBpZiAoZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgdy5vbihcInRvdWNobW92ZS5icnVzaFwiLCBicnVzaG1vdmUpLm9uKFwidG91Y2hlbmQuYnJ1c2hcIiwgYnJ1c2hlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5vbihcIm1vdXNlbW92ZS5icnVzaFwiLCBicnVzaG1vdmUpLm9uKFwibW91c2V1cC5icnVzaFwiLCBicnVzaGVuZCk7XG4gICAgICB9XG4gICAgICBnLmludGVycnVwdCgpLnNlbGVjdEFsbChcIipcIikuaW50ZXJydXB0KCk7XG4gICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgb3JpZ2luWzBdID0geEV4dGVudFswXSAtIG9yaWdpblswXTtcbiAgICAgICAgb3JpZ2luWzFdID0geUV4dGVudFswXSAtIG9yaWdpblsxXTtcbiAgICAgIH0gZWxzZSBpZiAocmVzaXppbmcpIHtcbiAgICAgICAgdmFyIGV4ID0gKy93JC8udGVzdChyZXNpemluZyksIGV5ID0gKy9ebi8udGVzdChyZXNpemluZyk7XG4gICAgICAgIG9mZnNldCA9IFsgeEV4dGVudFsxIC0gZXhdIC0gb3JpZ2luWzBdLCB5RXh0ZW50WzEgLSBleV0gLSBvcmlnaW5bMV0gXTtcbiAgICAgICAgb3JpZ2luWzBdID0geEV4dGVudFtleF07XG4gICAgICAgIG9yaWdpblsxXSA9IHlFeHRlbnRbZXldO1xuICAgICAgfSBlbHNlIGlmIChkMy5ldmVudC5hbHRLZXkpIGNlbnRlciA9IG9yaWdpbi5zbGljZSgpO1xuICAgICAgZy5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKS5zZWxlY3RBbGwoXCIucmVzaXplXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKTtcbiAgICAgIGQzLnNlbGVjdChcImJvZHlcIikuc3R5bGUoXCJjdXJzb3JcIiwgZXZlbnRUYXJnZXQuc3R5bGUoXCJjdXJzb3JcIikpO1xuICAgICAgZXZlbnRfKHtcbiAgICAgICAgdHlwZTogXCJicnVzaHN0YXJ0XCJcbiAgICAgIH0pO1xuICAgICAgYnJ1c2htb3ZlKCk7XG4gICAgICBmdW5jdGlvbiBrZXlkb3duKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQua2V5Q29kZSA9PSAzMikge1xuICAgICAgICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGNlbnRlciA9IG51bGw7XG4gICAgICAgICAgICBvcmlnaW5bMF0gLT0geEV4dGVudFsxXTtcbiAgICAgICAgICAgIG9yaWdpblsxXSAtPSB5RXh0ZW50WzFdO1xuICAgICAgICAgICAgZHJhZ2dpbmcgPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGtleXVwKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQua2V5Q29kZSA9PSAzMiAmJiBkcmFnZ2luZyA9PSAyKSB7XG4gICAgICAgICAgb3JpZ2luWzBdICs9IHhFeHRlbnRbMV07XG4gICAgICAgICAgb3JpZ2luWzFdICs9IHlFeHRlbnRbMV07XG4gICAgICAgICAgZHJhZ2dpbmcgPSAwO1xuICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYnJ1c2htb3ZlKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBkMy5tb3VzZSh0YXJnZXQpLCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgcG9pbnRbMF0gKz0gb2Zmc2V0WzBdO1xuICAgICAgICAgIHBvaW50WzFdICs9IG9mZnNldFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgaWYgKGQzLmV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgaWYgKCFjZW50ZXIpIGNlbnRlciA9IFsgKHhFeHRlbnRbMF0gKyB4RXh0ZW50WzFdKSAvIDIsICh5RXh0ZW50WzBdICsgeUV4dGVudFsxXSkgLyAyIF07XG4gICAgICAgICAgICBvcmlnaW5bMF0gPSB4RXh0ZW50WysocG9pbnRbMF0gPCBjZW50ZXJbMF0pXTtcbiAgICAgICAgICAgIG9yaWdpblsxXSA9IHlFeHRlbnRbKyhwb2ludFsxXSA8IGNlbnRlclsxXSldO1xuICAgICAgICAgIH0gZWxzZSBjZW50ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNpemluZ1ggJiYgbW92ZTEocG9pbnQsIHgsIDApKSB7XG4gICAgICAgICAgcmVkcmF3WChnKTtcbiAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2l6aW5nWSAmJiBtb3ZlMShwb2ludCwgeSwgMSkpIHtcbiAgICAgICAgICByZWRyYXdZKGcpO1xuICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZWQpIHtcbiAgICAgICAgICByZWRyYXcoZyk7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgIG1vZGU6IGRyYWdnaW5nID8gXCJtb3ZlXCIgOiBcInJlc2l6ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1vdmUxKHBvaW50LCBzY2FsZSwgaSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHNjYWxlKSwgcjAgPSByYW5nZVswXSwgcjEgPSByYW5nZVsxXSwgcG9zaXRpb24gPSBvcmlnaW5baV0sIGV4dGVudCA9IGkgPyB5RXh0ZW50IDogeEV4dGVudCwgc2l6ZSA9IGV4dGVudFsxXSAtIGV4dGVudFswXSwgbWluLCBtYXg7XG4gICAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICAgIHIwIC09IHBvc2l0aW9uO1xuICAgICAgICAgIHIxIC09IHNpemUgKyBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBtaW4gPSAoaSA/IHlDbGFtcCA6IHhDbGFtcCkgPyBNYXRoLm1heChyMCwgTWF0aC5taW4ocjEsIHBvaW50W2ldKSkgOiBwb2ludFtpXTtcbiAgICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgICAgbWF4ID0gKG1pbiArPSBwb3NpdGlvbikgKyBzaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjZW50ZXIpIHBvc2l0aW9uID0gTWF0aC5tYXgocjAsIE1hdGgubWluKHIxLCAyICogY2VudGVyW2ldIC0gbWluKSk7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uIDwgbWluKSB7XG4gICAgICAgICAgICBtYXggPSBtaW47XG4gICAgICAgICAgICBtaW4gPSBwb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF4ID0gcG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRlbnRbMF0gIT0gbWluIHx8IGV4dGVudFsxXSAhPSBtYXgpIHtcbiAgICAgICAgICBpZiAoaSkgeUV4dGVudERvbWFpbiA9IG51bGw7IGVsc2UgeEV4dGVudERvbWFpbiA9IG51bGw7XG4gICAgICAgICAgZXh0ZW50WzBdID0gbWluO1xuICAgICAgICAgIGV4dGVudFsxXSA9IG1heDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYnJ1c2hlbmQoKSB7XG4gICAgICAgIGJydXNobW92ZSgpO1xuICAgICAgICBnLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIikuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5zdHlsZShcImRpc3BsYXlcIiwgYnJ1c2guZW1wdHkoKSA/IFwibm9uZVwiIDogbnVsbCk7XG4gICAgICAgIGQzLnNlbGVjdChcImJvZHlcIikuc3R5bGUoXCJjdXJzb3JcIiwgbnVsbCk7XG4gICAgICAgIHcub24oXCJtb3VzZW1vdmUuYnJ1c2hcIiwgbnVsbCkub24oXCJtb3VzZXVwLmJydXNoXCIsIG51bGwpLm9uKFwidG91Y2htb3ZlLmJydXNoXCIsIG51bGwpLm9uKFwidG91Y2hlbmQuYnJ1c2hcIiwgbnVsbCkub24oXCJrZXlkb3duLmJydXNoXCIsIG51bGwpLm9uKFwia2V5dXAuYnJ1c2hcIiwgbnVsbCk7XG4gICAgICAgIGRyYWdSZXN0b3JlKCk7XG4gICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgdHlwZTogXCJicnVzaGVuZFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBicnVzaC54ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDtcbiAgICAgIHggPSB6O1xuICAgICAgcmVzaXplcyA9IGQzX3N2Z19icnVzaFJlc2l6ZXNbIXggPDwgMSB8ICF5XTtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLnkgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5O1xuICAgICAgeSA9IHo7XG4gICAgICByZXNpemVzID0gZDNfc3ZnX2JydXNoUmVzaXplc1sheCA8PCAxIHwgIXldO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guY2xhbXAgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4ICYmIHkgPyBbIHhDbGFtcCwgeUNsYW1wIF0gOiB4ID8geENsYW1wIDogeSA/IHlDbGFtcCA6IG51bGw7XG4gICAgICBpZiAoeCAmJiB5KSB4Q2xhbXAgPSAhIXpbMF0sIHlDbGFtcCA9ICEhelsxXTsgZWxzZSBpZiAoeCkgeENsYW1wID0gISF6OyBlbHNlIGlmICh5KSB5Q2xhbXAgPSAhIXo7XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC5leHRlbnQgPSBmdW5jdGlvbih6KSB7XG4gICAgICB2YXIgeDAsIHgxLCB5MCwgeTEsIHQ7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICBpZiAoeEV4dGVudERvbWFpbikge1xuICAgICAgICAgICAgeDAgPSB4RXh0ZW50RG9tYWluWzBdLCB4MSA9IHhFeHRlbnREb21haW5bMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgwID0geEV4dGVudFswXSwgeDEgPSB4RXh0ZW50WzFdO1xuICAgICAgICAgICAgaWYgKHguaW52ZXJ0KSB4MCA9IHguaW52ZXJ0KHgwKSwgeDEgPSB4LmludmVydCh4MSk7XG4gICAgICAgICAgICBpZiAoeDEgPCB4MCkgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgaWYgKHlFeHRlbnREb21haW4pIHtcbiAgICAgICAgICAgIHkwID0geUV4dGVudERvbWFpblswXSwgeTEgPSB5RXh0ZW50RG9tYWluWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5MCA9IHlFeHRlbnRbMF0sIHkxID0geUV4dGVudFsxXTtcbiAgICAgICAgICAgIGlmICh5LmludmVydCkgeTAgPSB5LmludmVydCh5MCksIHkxID0geS5pbnZlcnQoeTEpO1xuICAgICAgICAgICAgaWYgKHkxIDwgeTApIHQgPSB5MCwgeTAgPSB5MSwgeTEgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCAmJiB5ID8gWyBbIHgwLCB5MCBdLCBbIHgxLCB5MSBdIF0gOiB4ID8gWyB4MCwgeDEgXSA6IHkgJiYgWyB5MCwgeTEgXTtcbiAgICAgIH1cbiAgICAgIGlmICh4KSB7XG4gICAgICAgIHgwID0gelswXSwgeDEgPSB6WzFdO1xuICAgICAgICBpZiAoeSkgeDAgPSB4MFswXSwgeDEgPSB4MVswXTtcbiAgICAgICAgeEV4dGVudERvbWFpbiA9IFsgeDAsIHgxIF07XG4gICAgICAgIGlmICh4LmludmVydCkgeDAgPSB4KHgwKSwgeDEgPSB4KHgxKTtcbiAgICAgICAgaWYgKHgxIDwgeDApIHQgPSB4MCwgeDAgPSB4MSwgeDEgPSB0O1xuICAgICAgICBpZiAoeDAgIT0geEV4dGVudFswXSB8fCB4MSAhPSB4RXh0ZW50WzFdKSB4RXh0ZW50ID0gWyB4MCwgeDEgXTtcbiAgICAgIH1cbiAgICAgIGlmICh5KSB7XG4gICAgICAgIHkwID0gelswXSwgeTEgPSB6WzFdO1xuICAgICAgICBpZiAoeCkgeTAgPSB5MFsxXSwgeTEgPSB5MVsxXTtcbiAgICAgICAgeUV4dGVudERvbWFpbiA9IFsgeTAsIHkxIF07XG4gICAgICAgIGlmICh5LmludmVydCkgeTAgPSB5KHkwKSwgeTEgPSB5KHkxKTtcbiAgICAgICAgaWYgKHkxIDwgeTApIHQgPSB5MCwgeTAgPSB5MSwgeTEgPSB0O1xuICAgICAgICBpZiAoeTAgIT0geUV4dGVudFswXSB8fCB5MSAhPSB5RXh0ZW50WzFdKSB5RXh0ZW50ID0gWyB5MCwgeTEgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgeEV4dGVudCA9IFsgMCwgMCBdLCB5RXh0ZW50ID0gWyAwLCAwIF07XG4gICAgICAgIHhFeHRlbnREb21haW4gPSB5RXh0ZW50RG9tYWluID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISF4ICYmIHhFeHRlbnRbMF0gPT0geEV4dGVudFsxXSB8fCAhIXkgJiYgeUV4dGVudFswXSA9PSB5RXh0ZW50WzFdO1xuICAgIH07XG4gICAgcmV0dXJuIGQzLnJlYmluZChicnVzaCwgZXZlbnQsIFwib25cIik7XG4gIH07XG4gIHZhciBkM19zdmdfYnJ1c2hDdXJzb3IgPSB7XG4gICAgbjogXCJucy1yZXNpemVcIixcbiAgICBlOiBcImV3LXJlc2l6ZVwiLFxuICAgIHM6IFwibnMtcmVzaXplXCIsXG4gICAgdzogXCJldy1yZXNpemVcIixcbiAgICBudzogXCJud3NlLXJlc2l6ZVwiLFxuICAgIG5lOiBcIm5lc3ctcmVzaXplXCIsXG4gICAgc2U6IFwibndzZS1yZXNpemVcIixcbiAgICBzdzogXCJuZXN3LXJlc2l6ZVwiXG4gIH07XG4gIHZhciBkM19zdmdfYnJ1c2hSZXNpemVzID0gWyBbIFwiblwiLCBcImVcIiwgXCJzXCIsIFwid1wiLCBcIm53XCIsIFwibmVcIiwgXCJzZVwiLCBcInN3XCIgXSwgWyBcImVcIiwgXCJ3XCIgXSwgWyBcIm5cIiwgXCJzXCIgXSwgW10gXTtcbiAgdmFyIGQzX3RpbWVfZm9ybWF0ID0gZDNfdGltZS5mb3JtYXQgPSBkM19sb2NhbGVfZW5VUy50aW1lRm9ybWF0O1xuICB2YXIgZDNfdGltZV9mb3JtYXRVdGMgPSBkM190aW1lX2Zvcm1hdC51dGM7XG4gIHZhciBkM190aW1lX2Zvcm1hdElzbyA9IGQzX3RpbWVfZm9ybWF0VXRjKFwiJVktJW0tJWRUJUg6JU06JVMuJUxaXCIpO1xuICBkM190aW1lX2Zvcm1hdC5pc28gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiArbmV3IERhdGUoXCIyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIikgPyBkM190aW1lX2Zvcm1hdElzb05hdGl2ZSA6IGQzX3RpbWVfZm9ybWF0SXNvO1xuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdElzb05hdGl2ZShkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbiAgfVxuICBkM190aW1lX2Zvcm1hdElzb05hdGl2ZS5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoc3RyaW5nKTtcbiAgICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBudWxsIDogZGF0ZTtcbiAgfTtcbiAgZDNfdGltZV9mb3JtYXRJc29OYXRpdmUudG9TdHJpbmcgPSBkM190aW1lX2Zvcm1hdElzby50b1N0cmluZztcbiAgZDNfdGltZS5zZWNvbmQgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gbmV3IGQzX2RhdGUoTWF0aC5mbG9vcihkYXRlIC8gMWUzKSAqIDFlMyk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDFlMyk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gIH0pO1xuICBkM190aW1lLnNlY29uZHMgPSBkM190aW1lLnNlY29uZC5yYW5nZTtcbiAgZDNfdGltZS5zZWNvbmRzLnV0YyA9IGQzX3RpbWUuc2Vjb25kLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5taW51dGUgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gbmV3IGQzX2RhdGUoTWF0aC5mbG9vcihkYXRlIC8gNmU0KSAqIDZlNCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDZlNCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNaW51dGVzKCk7XG4gIH0pO1xuICBkM190aW1lLm1pbnV0ZXMgPSBkM190aW1lLm1pbnV0ZS5yYW5nZTtcbiAgZDNfdGltZS5taW51dGVzLnV0YyA9IGQzX3RpbWUubWludXRlLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5ob3VyID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIHRpbWV6b25lID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC8gNjA7XG4gICAgcmV0dXJuIG5ldyBkM19kYXRlKChNYXRoLmZsb29yKGRhdGUgLyAzNmU1IC0gdGltZXpvbmUpICsgdGltZXpvbmUpICogMzZlNSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKTtcbiAgfSk7XG4gIGQzX3RpbWUuaG91cnMgPSBkM190aW1lLmhvdXIucmFuZ2U7XG4gIGQzX3RpbWUuaG91cnMudXRjID0gZDNfdGltZS5ob3VyLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5tb250aCA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUgPSBkM190aW1lLmRheShkYXRlKTtcbiAgICBkYXRlLnNldERhdGUoMSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgb2Zmc2V0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XG4gIH0pO1xuICBkM190aW1lLm1vbnRocyA9IGQzX3RpbWUubW9udGgucmFuZ2U7XG4gIGQzX3RpbWUubW9udGhzLnV0YyA9IGQzX3RpbWUubW9udGgudXRjLnJhbmdlO1xuICBmdW5jdGlvbiBkM190aW1lX3NjYWxlKGxpbmVhciwgbWV0aG9kcywgZm9ybWF0KSB7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIGxpbmVhcih4KTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfc2NhbGVEYXRlKGxpbmVhci5pbnZlcnQoeCkpO1xuICAgIH07XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGluZWFyLmRvbWFpbigpLm1hcChkM190aW1lX3NjYWxlRGF0ZSk7XG4gICAgICBsaW5lYXIuZG9tYWluKHgpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdGlja01ldGhvZChleHRlbnQsIGNvdW50KSB7XG4gICAgICB2YXIgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXSwgdGFyZ2V0ID0gc3BhbiAvIGNvdW50LCBpID0gZDMuYmlzZWN0KGQzX3RpbWVfc2NhbGVTdGVwcywgdGFyZ2V0KTtcbiAgICAgIHJldHVybiBpID09IGQzX3RpbWVfc2NhbGVTdGVwcy5sZW5ndGggPyBbIG1ldGhvZHMueWVhciwgZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGV4dGVudC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCAvIDMxNTM2ZTY7XG4gICAgICB9KSwgY291bnQpWzJdIF0gOiAhaSA/IFsgZDNfdGltZV9zY2FsZU1pbGxpc2Vjb25kcywgZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGV4dGVudCwgY291bnQpWzJdIF0gOiBtZXRob2RzW3RhcmdldCAvIGQzX3RpbWVfc2NhbGVTdGVwc1tpIC0gMV0gPCBkM190aW1lX3NjYWxlU3RlcHNbaV0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgIH1cbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHNraXApIHtcbiAgICAgIHZhciBkb21haW4gPSBzY2FsZS5kb21haW4oKSwgZXh0ZW50ID0gZDNfc2NhbGVFeHRlbnQoZG9tYWluKSwgbWV0aG9kID0gaW50ZXJ2YWwgPT0gbnVsbCA/IHRpY2tNZXRob2QoZXh0ZW50LCAxMCkgOiB0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIgJiYgdGlja01ldGhvZChleHRlbnQsIGludGVydmFsKTtcbiAgICAgIGlmIChtZXRob2QpIGludGVydmFsID0gbWV0aG9kWzBdLCBza2lwID0gbWV0aG9kWzFdO1xuICAgICAgZnVuY3Rpb24gc2tpcHBlZChkYXRlKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4oZGF0ZSkgJiYgIWludGVydmFsLnJhbmdlKGRhdGUsIGQzX3RpbWVfc2NhbGVEYXRlKCtkYXRlICsgMSksIHNraXApLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FsZS5kb21haW4oZDNfc2NhbGVfbmljZShkb21haW4sIHNraXAgPiAxID8ge1xuICAgICAgICBmbG9vcjogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgIHdoaWxlIChza2lwcGVkKGRhdGUgPSBpbnRlcnZhbC5mbG9vcihkYXRlKSkpIGRhdGUgPSBkM190aW1lX3NjYWxlRGF0ZShkYXRlIC0gMSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNlaWw6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICB3aGlsZSAoc2tpcHBlZChkYXRlID0gaW50ZXJ2YWwuY2VpbChkYXRlKSkpIGRhdGUgPSBkM190aW1lX3NjYWxlRGF0ZSgrZGF0ZSArIDEpO1xuICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgICB9IDogaW50ZXJ2YWwpKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHNraXApIHtcbiAgICAgIHZhciBleHRlbnQgPSBkM19zY2FsZUV4dGVudChzY2FsZS5kb21haW4oKSksIG1ldGhvZCA9IGludGVydmFsID09IG51bGwgPyB0aWNrTWV0aG9kKGV4dGVudCwgMTApIDogdHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiID8gdGlja01ldGhvZChleHRlbnQsIGludGVydmFsKSA6ICFpbnRlcnZhbC5yYW5nZSAmJiBbIHtcbiAgICAgICAgcmFuZ2U6IGludGVydmFsXG4gICAgICB9LCBza2lwIF07XG4gICAgICBpZiAobWV0aG9kKSBpbnRlcnZhbCA9IG1ldGhvZFswXSwgc2tpcCA9IG1ldGhvZFsxXTtcbiAgICAgIHJldHVybiBpbnRlcnZhbC5yYW5nZShleHRlbnRbMF0sIGQzX3RpbWVfc2NhbGVEYXRlKCtleHRlbnRbMV0gKyAxKSwgc2tpcCA8IDEgPyAxIDogc2tpcCk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfc2NhbGUobGluZWFyLmNvcHkoKSwgbWV0aG9kcywgZm9ybWF0KTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9zY2FsZURhdGUodCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0KTtcbiAgfVxuICB2YXIgZDNfdGltZV9zY2FsZVN0ZXBzID0gWyAxZTMsIDVlMywgMTVlMywgM2U0LCA2ZTQsIDNlNSwgOWU1LCAxOGU1LCAzNmU1LCAxMDhlNSwgMjE2ZTUsIDQzMmU1LCA4NjRlNSwgMTcyOGU1LCA2MDQ4ZTUsIDI1OTJlNiwgNzc3NmU2LCAzMTUzNmU2IF07XG4gIHZhciBkM190aW1lX3NjYWxlTG9jYWxNZXRob2RzID0gWyBbIGQzX3RpbWUuc2Vjb25kLCAxIF0sIFsgZDNfdGltZS5zZWNvbmQsIDUgXSwgWyBkM190aW1lLnNlY29uZCwgMTUgXSwgWyBkM190aW1lLnNlY29uZCwgMzAgXSwgWyBkM190aW1lLm1pbnV0ZSwgMSBdLCBbIGQzX3RpbWUubWludXRlLCA1IF0sIFsgZDNfdGltZS5taW51dGUsIDE1IF0sIFsgZDNfdGltZS5taW51dGUsIDMwIF0sIFsgZDNfdGltZS5ob3VyLCAxIF0sIFsgZDNfdGltZS5ob3VyLCAzIF0sIFsgZDNfdGltZS5ob3VyLCA2IF0sIFsgZDNfdGltZS5ob3VyLCAxMiBdLCBbIGQzX3RpbWUuZGF5LCAxIF0sIFsgZDNfdGltZS5kYXksIDIgXSwgWyBkM190aW1lLndlZWssIDEgXSwgWyBkM190aW1lLm1vbnRoLCAxIF0sIFsgZDNfdGltZS5tb250aCwgMyBdLCBbIGQzX3RpbWUueWVhciwgMSBdIF07XG4gIHZhciBkM190aW1lX3NjYWxlTG9jYWxGb3JtYXQgPSBkM190aW1lX2Zvcm1hdC5tdWx0aShbIFsgXCIuJUxcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldE1pbGxpc2Vjb25kcygpO1xuICB9IF0sIFsgXCI6JVNcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFNlY29uZHMoKTtcbiAgfSBdLCBbIFwiJUk6JU1cIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldE1pbnV0ZXMoKTtcbiAgfSBdLCBbIFwiJUkgJXBcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldEhvdXJzKCk7XG4gIH0gXSwgWyBcIiVhICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXREYXkoKSAmJiBkLmdldERhdGUoKSAhPSAxO1xuICB9IF0sIFsgXCIlYiAlZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0RGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiVCXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRNb250aCgpO1xuICB9IF0sIFsgXCIlWVwiLCBkM190cnVlIF0gXSk7XG4gIHZhciBkM190aW1lX3NjYWxlTWlsbGlzZWNvbmRzID0ge1xuICAgIHJhbmdlOiBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKE1hdGguY2VpbChzdGFydCAvIHN0ZXApICogc3RlcCwgK3N0b3AsIHN0ZXApLm1hcChkM190aW1lX3NjYWxlRGF0ZSk7XG4gICAgfSxcbiAgICBmbG9vcjogZDNfaWRlbnRpdHksXG4gICAgY2VpbDogZDNfaWRlbnRpdHlcbiAgfTtcbiAgZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcy55ZWFyID0gZDNfdGltZS55ZWFyO1xuICBkM190aW1lLnNjYWxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3RpbWVfc2NhbGUoZDMuc2NhbGUubGluZWFyKCksIGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMsIGQzX3RpbWVfc2NhbGVMb2NhbEZvcm1hdCk7XG4gIH07XG4gIHZhciBkM190aW1lX3NjYWxlVXRjTWV0aG9kcyA9IGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gWyBtWzBdLnV0YywgbVsxXSBdO1xuICB9KTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVVdGNGb3JtYXQgPSBkM190aW1lX2Zvcm1hdFV0Yy5tdWx0aShbIFsgXCIuJUxcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICB9IF0sIFsgXCI6JVNcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ1NlY29uZHMoKTtcbiAgfSBdLCBbIFwiJUk6JU1cIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ01pbnV0ZXMoKTtcbiAgfSBdLCBbIFwiJUkgJXBcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0hvdXJzKCk7XG4gIH0gXSwgWyBcIiVhICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENEYXkoKSAmJiBkLmdldFVUQ0RhdGUoKSAhPSAxO1xuICB9IF0sIFsgXCIlYiAlZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiVCXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xuICB9IF0sIFsgXCIlWVwiLCBkM190cnVlIF0gXSk7XG4gIGQzX3RpbWVfc2NhbGVVdGNNZXRob2RzLnllYXIgPSBkM190aW1lLnllYXIudXRjO1xuICBkM190aW1lLnNjYWxlLnV0YyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM190aW1lX3NjYWxlKGQzLnNjYWxlLmxpbmVhcigpLCBkM190aW1lX3NjYWxlVXRjTWV0aG9kcywgZDNfdGltZV9zY2FsZVV0Y0Zvcm1hdCk7XG4gIH07XG4gIGQzLnRleHQgPSBkM194aHJUeXBlKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gIH0pO1xuICBkMy5qc29uID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBkM194aHIodXJsLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgZDNfanNvbiwgY2FsbGJhY2spO1xuICB9O1xuICBmdW5jdGlvbiBkM19qc29uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gIH1cbiAgZDMuaHRtbCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZDNfeGhyKHVybCwgXCJ0ZXh0L2h0bWxcIiwgZDNfaHRtbCwgY2FsbGJhY2spO1xuICB9O1xuICBmdW5jdGlvbiBkM19odG1sKHJlcXVlc3QpIHtcbiAgICB2YXIgcmFuZ2UgPSBkM19kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNlbGVjdE5vZGUoZDNfZG9jdW1lbnQuYm9keSk7XG4gICAgcmV0dXJuIHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gIH1cbiAgZDMueG1sID0gZDNfeGhyVHlwZShmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VYTUw7XG4gIH0pO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHRoaXMuZDMgPSBkMywgZGVmaW5lKGQzKTsgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkMzsgZWxzZSB0aGlzLmQzID0gZDM7XG59KCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX0FDQ09SRElPTl9PUFRJT05TLFxuICAgIF9BRERfQUNDT1JESU9OX09QVElPTlMsXG4gICAgX0FDQ09SRElPTl9DTE9TRUQsXG4gICAgX0FDQ09SRElPTl9UT0dHTEUsXG4gICAgX0FDQ09SRElPTl9DT05URU5UO1xuXG5cbl9BQ0NPUkRJT05fT1BUSU9OUyA9IHtcbiAgYWNjb3JkaW9uczogbnVsbCxcbiAgZWw6IG51bGxcbn07XG5cbl9BRERfQUNDT1JESU9OX09QVElPTlMgPSB7XG4gIHRvZ2dsZVRleHQ6ICdEZXRhaWxzJyxcbiAgdG9nZ2xlRWxlbWVudDogJ3NwYW4nLFxuICBjb250ZW50OiAnQ29udGVudHMnLFxuICBjbGFzc2VzOiAnYWNjb3JkaW9uLXN0YW5kYXJkJ1xufTtcblxuX0FDQ09SRElPTl9DTE9TRUQgPSAnYWNjb3JkaW9uLWNsb3NlZCc7XG5fQUNDT1JESU9OX1RPR0dMRSA9ICdhY2NvcmRpb24tdG9nZ2xlJztcbl9BQ0NPUkRJT05fQ09OVEVOVCA9ICdhY2NvcmRpb24tY29udGVudCc7XG5cblxuLyoqXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBvbmUgb3IgbW9yZSBvYmplY3RzIG9udG8gYW5vdGhlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIGRzdCB7T2JqZWN0fVxuICogICAgICAgIERlc3RpbmF0aW9uIG9iamVjdCB3aGVyZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB2YXJhcmdzIHtPYmplY3QuLi59XG4gKiAgICAgICAgVmFyaWFibGUgbnVtYmVyIG9mIG9iamVjdHMgd2hlcmUgcHJvcGVydGllcyBhcmUgY29waWVkIGZyb20uXG4gKiAgICAgICAgT2JqZWN0cyBlYXJsaWVyIGluIHRoZSBhcmd1bWVudHMgbGlzdCBoYXZlIHRoZWlyIHByb3BlcnRpZXNcbiAqICAgICAgICBvdmVycmlkZGVuIGJ5IG9iamVjdHMgbGF0ZXIgaW4gdGhlIGFyZ3VtZW50cyBsaXN0LlxuICogQHJldHVybiBkc3QuXG4gKi9cbnZhciBfZXh0ZW5kID0gZnVuY3Rpb24gKGRzdCkge1xuICBmb3IgKHZhciBpPTEsIGxlbj1hcmd1bWVudHMubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgdmFyIG8gPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvKSB7XG4gICAgICBkc3RbcHJvcF0gPSBvW3Byb3BdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHN0O1xufTtcblxudmFyIF9vbkNsaWNrID0gZnVuY3Rpb24gKGV2dCkge1xuICB2YXIgdGFyZ2V0ID0gZXZ0LnRhcmdldDtcblxuICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhfQUNDT1JESU9OX1RPR0dMRSkpIHtcbiAgICB0YXJnZXQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKF9BQ0NPUkRJT05fQ0xPU0VEKTtcbiAgfVxufTtcblxuXG52YXIgQWNjb3JkaW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9lbCxcbiAgICAgIF9vcHRpb25zO1xuXG5cbiAgX3RoaXMgPSB7XG4gICAgYWRkQWNjb3JkaW9uOiBudWxsLFxuICAgIGRlc3Ryb3k6IG51bGxcbiAgfTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGxlbjtcblxuICAgIF9vcHRpb25zID0gX2V4dGVuZCh7fSwgX0FDQ09SRElPTl9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBfZWwgPSBfb3B0aW9ucy5lbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX29uQ2xpY2spO1xuXG4gICAgaWYgKG9wdGlvbnMuYWNjb3JkaW9ucykge1xuICAgICAgbGVuID0gb3B0aW9ucy5hY2NvcmRpb25zLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBfdGhpcy5hZGRBY2NvcmRpb24ob3B0aW9ucy5hY2NvcmRpb25zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICAvKlxuICAgKiB0aGlzIHdpbGwgYnVpbGQgdGhlIG1hcmt1cCBmb3IgYW4gYWNjb3JkaW9uIGVsZW1lbnRcbiAgICovXG4gIF90aGlzLmFkZEFjY29yZGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGFjY29yZGlvbixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbnRlbnQ7XG5cbiAgICBvcHRpb25zID0gX2V4dGVuZCh7fSwgX0FERF9BQ0NPUkRJT05fT1BUSU9OUywgb3B0aW9ucyk7XG5cbiAgICBhY2NvcmRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgYWNjb3JkaW9uLmNsYXNzTmFtZSA9ICdhY2NvcmRpb24gJyArIG9wdGlvbnMuY2xhc3NlcztcblxuICAgIHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChvcHRpb25zLnRvZ2dsZUVsZW1lbnQpO1xuICAgIHRpdGxlLmNsYXNzTmFtZSA9IF9BQ0NPUkRJT05fVE9HR0xFO1xuICAgIHRpdGxlLmlubmVySFRNTCA9IG9wdGlvbnMudG9nZ2xlVGV4dDtcbiAgICBhY2NvcmRpb24uYXBwZW5kQ2hpbGQodGl0bGUpO1xuXG4gICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRlbnQuY2xhc3NOYW1lID0gX0FDQ09SRElPTl9DT05URU5UO1xuXG4gICAgLy8gU3VwcG9ydCBsZWdhY3kgXCJjb250ZW50VGV4dFwiIGlmIHN0aWxsIHByZXNlbnQsIGJ1dCBwcmVmZXJ0IFwiY29udGVudFwiXG4gICAgaWYgKG9wdGlvbnMuY29udGVudFRleHQpIHtcbiAgICAgIGNvbnRlbnQuaW5uZXJIVE1MID0gb3B0aW9ucy5jb250ZW50VGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hlY2sgaWYgc3RyaW5nIGNvbnRlbnQgb3IgRE9NIGNvbnRlbnRcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb250ZW50LmlubmVySFRNTCA9IG9wdGlvbnMuY29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQob3B0aW9ucy5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhY2NvcmRpb24uYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICBfZWwuYXBwZW5kQ2hpbGQoYWNjb3JkaW9uKTtcbiAgfTtcblxuICBfdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIF9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF9vbkNsaWNrKTtcblxuICAgIF9lbCA9IG51bGw7XG4gICAgX29wdGlvbnMgPSBudWxsO1xuXG4gICAgX3RoaXMgPSBudWxsO1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjY29yZGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5cbi8qKlxuICogU2ltdWxhdGVzIGEgY2xhc3MgbGlzdC5cbiAqXG4gKiBJZiBjaGFuZ2VzIGFyZSBtYWRlIG91dHNpZGUgdGhpcyBvYmplY3QsIHJlc3luYyB1c2luZyBzeW5jaHJvbml6ZSgpLlxuICovXG52YXIgQ2xhc3NMaXN0ID0gZnVuY3Rpb24gKGVsKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuICAgICAgLy8gdmFyaWFibGVzXG4gICAgICBfY2xhc3NMaXN0LFxuICAgICAgX3N5bmNWYWx1ZSxcbiAgICAgIC8vIG1ldGhvZHNcbiAgICAgIF9zeW5jO1xuXG5cbiAgX3RoaXMgPSB7fTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBDbGFzc0xpc3QuXG4gICAqL1xuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfc3luY1ZhbHVlID0gbnVsbDtcbiAgICBfY2xhc3NMaXN0ID0gW107XG4gICAgX3RoaXMubGVuZ3RoID0gMDtcblxuICAgIF9zeW5jKHRydWUpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplIHdpdGggZWxlbWVudCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIGxvYWQge0Jvb2xlYW59XG4gICAqICAgICAgICB3aGVuIHRydWUsIHJlYWQgc3RhdGUgZnJvbSBlbGVtZW50LlxuICAgKiAgICAgICAgb3RoZXJ3aXNlLCBzZXQgZWxlbWVudCBzdGF0ZS5cbiAgICovXG4gIF9zeW5jID0gZnVuY3Rpb24gKGxvYWQpIHtcbiAgICB2YXIgdmFsdWU7XG5cbiAgICBpZiAobG9hZCkge1xuICAgICAgLy8gcmVhZCBmcm9tIGVsZW1lbnRcbiAgICAgIHZhbHVlID0gZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIF9jbGFzc0xpc3QgPSBbXTtcbiAgICAgICAgX3RoaXMubGVuZ3RoID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgX2NsYXNzTGlzdCA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICAgIF90aGlzLmxlbmd0aCA9IF9jbGFzc0xpc3QubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgZWxlbWVudFxuICAgICAgdmFsdWUgPSBfY2xhc3NMaXN0LmpvaW4oJyAnKTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XG4gICAgfVxuICAgIF9zeW5jVmFsdWUgPSB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSBjbGFzc05hbWUge1N0cmluZ31cbiAgICogICAgICAgIGNsYXNzIHRvIGFkZC5cbiAgICovXG4gIF90aGlzLmFkZCA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICB2YXIgcG9zO1xuICAgIC8vIGxvYWQgZnJvbSBlbGVtZW50XG4gICAgX3N5bmModHJ1ZSk7XG4gICAgcG9zID0gX2NsYXNzTGlzdC5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIF9jbGFzc0xpc3QucHVzaChjbGFzc05hbWUpO1xuICAgICAgX3RoaXMubGVuZ3RoKys7XG4gICAgICAvLyB1cGRhdGUgZWxlbWVudFxuICAgICAgX3N5bmMoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgZWxlbWVudCBoYXMgYSBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIGNsYXNzTmFtZSB7U3RyaW5nfVxuICAgKiAgICAgICAgY2xhc3MgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiAgICAgICAgIHRydWUgaWYgZWxlbWVudCBsaXN0IGluY2x1ZGVzIGNsYXNzLlxuICAgKi9cbiAgX3RoaXMuY29udGFpbnMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgdmFyIHBvcztcbiAgICAvLyBsb2FkIGZyb20gZWxlbWVudFxuICAgIF9zeW5jKHRydWUpO1xuICAgIHBvcyA9IF9jbGFzc0xpc3QuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgIHJldHVybiAocG9zICE9PSAtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFjY2VzcyBhIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gcG9zIHtTdHJpbmd9XG4gICAqICAgICAgICBpbmRleCBpbiBsaXN0IFswLENsYXNzTGlzdC5sZW5ndGgtMV0uXG4gICAqIEByZXR1cm4gY2xhc3NOYW1lIGluIGxpc3QsIG9yIG51bGwgaWYgb3V0IG9mIHJhbmdlLlxuICAgKi9cbiAgX3RoaXMuaXRlbSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAvLyBsb2FkIGZyb20gZWxlbWVudFxuICAgIF9zeW5jKHRydWUpO1xuICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+PSBfY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfY2xhc3NMaXN0W3Bvc107XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gY2xhc3NOYW1lIHtTdHJpbmd9XG4gICAqICAgICAgICBjbGFzcyB0byByZW1vdmUuXG4gICAqL1xuICBfdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgdmFyIHBvcztcbiAgICAvLyBsb2FkIGZyb20gZWxlbWVudFxuICAgIF9zeW5jKHRydWUpO1xuICAgIHBvcyA9IF9jbGFzc0xpc3QuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICBfY2xhc3NMaXN0LnNwbGljZShwb3MsIDEpO1xuICAgICAgX3RoaXMubGVuZ3RoLS07XG4gICAgICAvLyB1cGRhdGUgZWxlbWVudFxuICAgICAgX3N5bmMoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVG9nZ2xlIGEgY2xhc3MuXG4gICAqXG4gICAqIEFkZCBpcyBub3QgaW4gbGlzdCwgb3RoZXJ3aXNlIHJlbW92ZS5cbiAgICpcbiAgICogQHBhcmFtIGNsYXNzTmFtZSB7U3RyaW5nfVxuICAgKiAgICAgICAgY2xhc3MgdG8gYWRkLlxuICAgKi9cbiAgX3RoaXMudG9nZ2xlID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIGlmIChfdGhpcy5oYXMoY2xhc3NOYW1lKSkge1xuICAgICAgX3RoaXMucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmFkZChjbGFzc05hbWUpO1xuICAgIH1cbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKCk7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuLyoqXG4gKiBBZGQgY2xhc3NMaXN0IGlmIGVsZW1lbnQgZG9lc24ndCBuYXRpdmVseSBzdXBwb3J0IGNsYXNzTGlzdC5cbiAqXG4gKiBTb21lIFNWRyBpbXBsZW1lbnRhdGlvbnMgZG8gbm90IHN1cHBvcnQgY2xhc3NMaXN0LlxuICpcbiAqIEBwYXJhbSBlbCB7RWxlbWVudH1cbiAqICAgICAgICBlbGVtZW50IHRvIHBvbHlmaWxsLlxuICovXG5DbGFzc0xpc3QucG9seWZpbGwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgaWYgKCFlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QgPSBDbGFzc0xpc3QoZWwpO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ2xhc3NMaXN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpLFxuICAgIENsYXNzTGlzdCA9IHJlcXVpcmUoJy4vQ2xhc3NMaXN0JyksXG4gICAgRDNTdWJWaWV3ID0gcmVxdWlyZSgnZDMvRDNTdWJWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbi8qKlxuICogTGluZSB2aWV3IGZvciBhIEQzIHBsb3QuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICAgICBvcHRpb25zIGFyZSBwYXNzZWQgdG8gRDNTdWJWaWV3LlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSB7QXJyYXk8QXJyYXk8TnVtYmVyPj59XG4gKiAgICAgICAgZGVmYXVsdCBbXS5cbiAqICAgICAgICBhcnJheSBvZiBhcnJheXMgb2YgeCwgeSBjb29yZGluYXRlczpcbiAqICAgICAgICBbIFt4MCwgeTBdLCBbeDEsIHkxXSwgLi4uIF1cbiAqIEBwYXJhbSBsaW5lRm9ybWF0IHtEMyBMaW5lfVxuICogICAgICAgIGRlZmF1bHQgZDMuc3ZnLmxpbmUoKS5cbiAqIEBwYXJhbSBwb2ludFJhZGl1cyB7TnVtYmVyfVxuICogICAgICAgIGRlZmF1bHQgNS5cbiAqICAgICAgICByYWRpdXMgZm9yIHBvaW50cy5cbiAqIEBwYXJhbSBzaG93TGluZSB7Qm9vbGVhbn1cbiAqICAgICAgICBkZWZhdWx0IHRydWUuXG4gKiAgICAgICAgd2hldGhlciB0byBwbG90IGxpbmUuXG4gKiBAcGFyYW0gc2hvd1BvaW50cyB7Qm9vbGVhbn1cbiAqICAgICAgICBkZWZhdWx0IHRydWUuXG4gKiAgICAgICAgd2hldGhlciB0byBwbG90IHBvaW50cy5cbiAqL1xudmFyIEQzTGluZVZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcbiAgICAgIC8vIHZhcmlhYmxlc1xuICAgICAgX2VsLFxuICAgICAgX2xlZ2VuZCxcbiAgICAgIF9sZWdlbmRMaW5lLFxuICAgICAgX2xlZ2VuZFBvaW50LFxuICAgICAgX2xlZ2VuZFRleHQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lRm9ybWF0LFxuICAgICAgX3gsXG4gICAgICBfeSxcbiAgICAgIC8vIG1ldGhvZHNcbiAgICAgIF9nZXRYLFxuICAgICAgX2dldFk7XG5cblxuICBfdGhpcyA9IEQzU3ViVmlldyhvcHRpb25zKTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB2aWV3LlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF90aGlzLm1vZGVsLnNldChVdGlsLmV4dGVuZCh7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIHBvaW50UmFkaXVzOiA1LFxuICAgICAgc2hvd0xpbmU6IHRydWUsXG4gICAgICBzaG93UG9pbnRzOiB0cnVlLFxuICAgICAgc2hvd0xlZ2VuZFBvaW50OiB0cnVlLFxuICAgIH0sIG9wdGlvbnMsIF90aGlzLm1vZGVsLmdldCgpKSwge3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgQ2xhc3NMaXN0LnBvbHlmaWxsKF90aGlzLmVsKTtcbiAgICBfdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdEM0xpbmVWaWV3Jyk7XG4gICAgX2VsID0gZDMuc2VsZWN0KF90aGlzLmVsKTtcblxuICAgIGlmIChfdGhpcy5sZWdlbmQpIHtcbiAgICAgIENsYXNzTGlzdC5wb2x5ZmlsbChfdGhpcy5sZWdlbmQpO1xuICAgICAgX3RoaXMubGVnZW5kLmNsYXNzTGlzdC5hZGQoJ0QzTGluZVZpZXcnKTtcbiAgICAgIF9sZWdlbmQgPSBkMy5zZWxlY3QoX3RoaXMubGVnZW5kKTtcbiAgICAgIF9sZWdlbmRMaW5lID0gX2xlZ2VuZC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lJyk7XG4gICAgICBfbGVnZW5kVGV4dCA9IF9sZWdlbmQuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCAndGV4dCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfbGVnZW5kID0gbnVsbDtcbiAgICAgIF9sZWdlbmRMaW5lID0gbnVsbDtcbiAgICAgIF9sZWdlbmRUZXh0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBfbGluZSA9IF9lbC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZScpXG4gICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKCNwbG90QXJlYUNsaXApJyk7XG5cbiAgICBfbGluZUZvcm1hdCA9IG9wdGlvbnMubGluZUZvcm1hdCB8fCBkMy5zdmcubGluZSgpO1xuICAgIF9saW5lRm9ybWF0LngoX3RoaXMuZ2V0U2NhbGVYKTtcbiAgICBfbGluZUZvcm1hdC55KF90aGlzLmdldFNjYWxlWSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBkYXRhIGNvb3JkaW5hdGUgdG8gYSBwbG90IGNvb3JkaW5hdGUuXG4gICAqXG4gICAqIEBwYXJhbSBkIHtBcnJheTxOdW1iZXI+fVxuICAgKiAgICAgICAgZGF0YSBwb2ludC5cbiAgICogQHJldHVybiB7TnVtYmVyfSB4IHBsb3QgY29vcmRpbmF0ZS5cbiAgICovXG4gIF90aGlzLmdldFNjYWxlWCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIF94KGRbMF0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgZGF0YSBjb29yZGluYXRlIHRvIGEgcGxvdCBjb29yZGluYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gZCB7QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgIGRhdGEgcG9pbnQuXG4gICAqIEByZXR1cm4ge051bWJlcn0geSBwbG90IGNvb3JkaW5hdGUuXG4gICAqL1xuICBfdGhpcy5nZXRTY2FsZVkgPSBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBfeShkWzFdKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhbiB4IGRhdGEgY29vcmRpbmF0ZSBmcm9tIGEgZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBkIHtBcnJheTxOdW1iZXI+fVxuICAgKiAgICAgICAgZGF0YSBwb2ludC5cbiAgICogQHJldHVybiB7TnVtYmVyfSB4IHBsb3QgY29vcmRpbmF0ZS5cbiAgICovXG4gIF9nZXRYID0gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgeSBkYXRhIGNvb3JkaW5hdGUgZnJvbSBhIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gZCB7QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgIGRhdGEgcG9pbnQuXG4gICAqIEByZXR1cm4ge051bWJlcn0geSBwbG90IGNvb3JkaW5hdGUuXG4gICAqL1xuICBfZ2V0WSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGRbMV07XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdmlldy5cbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb2ludHM7XG5cbiAgICBpZiAoX2VsKSB7XG4gICAgICAvLyByZW1vdmUgcG9pbnQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBwb2ludHMgPSBfZWwuc2VsZWN0QWxsKCcucG9pbnQnKVxuICAgICAgICAgIC5vbignbW91c2VvdXQnLCBudWxsKVxuICAgICAgICAgIC5vbignbW91c2VvdmVyJywgbnVsbCk7XG4gICAgICBfZWwgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChfbGVnZW5kKSB7XG4gICAgICBfbGVnZW5kTGluZSA9IG51bGw7XG4gICAgICBfbGVnZW5kVGV4dCA9IG51bGw7XG4gICAgfVxuXG4gICAgX2xpbmUgPSBudWxsO1xuICAgIF9saW5lRm9ybWF0ID0gbnVsbDtcblxuICAgIF94ID0gbnVsbDtcbiAgICBfeSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogRm9ybWF0IHggdmFsdWUgZm9yIHRvb2x0aXAuXG4gICAqXG4gICAqIEBwYXJhbSB4IHtOdW1iZXJ9XG4gICAqICAgICAgICB2YWx1ZSB0byBmb3JtYXQuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgICAgICBmb3JtYXR0ZWQgbnVtYmVyLlxuICAgKi9cbiAgX3RoaXMuZm9ybWF0WCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCB5IHZhbHVlIGZvciB0b29sdGlwLlxuICAgKlxuICAgKiBAcGFyYW0geSB7TnVtYmVyfVxuICAgKiAgICAgICAgdmFsdWUgdG8gZm9ybWF0LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICAgICAgZm9ybWF0dGVkIG51bWJlci5cbiAgICovXG4gIF90aGlzLmZvcm1hdFkgPSBmdW5jdGlvbiAoeSkge1xuICAgIHJldHVybiB5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBYIGV4dGVudCBmb3Igdmlldy5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgICB4IGV4dGVudCBmb3Igdmlldy5cbiAgICovXG4gIF90aGlzLmdldFhFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGQzLmV4dGVudChfdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKSwgX2dldFgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBZIGV4dGVudCBmb3Igdmlldy5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgICB5IGV4dGVudCBmb3Igdmlldy5cbiAgICovXG4gIF90aGlzLmdldFlFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGQzLmV4dGVudChfdGhpcy5tb2RlbC5nZXQoJ2RhdGEnKSwgX2dldFkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQb2ludCBtb3VzZW91dCBldmVudCBoYW5kbGVyLlxuICAgKi9cbiAgX3RoaXMub25Qb2ludE91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9pbnQ7XG5cbiAgICBwb2ludCA9IGQzLmV2ZW50LnRhcmdldDtcbiAgICBDbGFzc0xpc3QucG9seWZpbGwocG9pbnQpO1xuICAgIHBvaW50LmNsYXNzTGlzdC5yZW1vdmUoJ21vdXNlb3ZlcicpO1xuXG4gICAgLy8gY2xlYXIgcHJldmlvdXMgdG9vbHRpcFxuICAgIF90aGlzLnZpZXcuc2hvd1Rvb2x0aXAobnVsbCwgbnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBvaW50IG1vdXNlb3ZlciBldmVudCBoYW5kbGVyLlxuICAgKlxuICAgKiBAcGFyYW0gY29vcmRzIHtBcnJheTxOdW1iZXI+fVxuICAgKiAgICAgICAgeCwgeSBjb29yZGluYXRlIG9mIHBvaW50LlxuICAgKi9cbiAgX3RoaXMub25Qb2ludE92ZXIgPSBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgdmFyIHBvaW50O1xuXG4gICAgcG9pbnQgPSBkMy5ldmVudC50YXJnZXQ7XG4gICAgQ2xhc3NMaXN0LnBvbHlmaWxsKHBvaW50KTtcbiAgICBwb2ludC5jbGFzc0xpc3QuYWRkKCdtb3VzZW92ZXInKTtcblxuICAgIF90aGlzLnZpZXcuc2hvd1Rvb2x0aXAoY29vcmRzLCBbXG4gICAgICB7dGV4dDogX3RoaXMubW9kZWwuZ2V0KCdsYWJlbCcpfSxcbiAgICAgIFtcbiAgICAgICAge2NsYXNzOiAnbGFiZWwnLCB0ZXh0OiBfdGhpcy52aWV3Lm1vZGVsLmdldCgneExhYmVsJykgKyAnOiAnfSxcbiAgICAgICAge2NsYXNzOiAndmFsdWUnLCB0ZXh0OiBfdGhpcy5mb3JtYXRYKF9nZXRYKGNvb3JkcykpfVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAge2NsYXNzOiAnbGFiZWwnLCB0ZXh0OiBfdGhpcy52aWV3Lm1vZGVsLmdldCgneUxhYmVsJykgKyAnOiAnfSxcbiAgICAgICAge2NsYXNzOiAndmFsdWUnLCB0ZXh0OiBfdGhpcy5mb3JtYXRZKF9nZXRZKGNvb3JkcykpfVxuICAgICAgXVxuICAgIF0pO1xuICB9O1xuXG4gIF90aGlzLnBsb3RQb2ludHMgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgcG9pbnRzLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgnc3ZnOmNpcmNsZScpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdwb2ludCcpXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBfdGhpcy5vblBvaW50T3V0KVxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIF90aGlzLm9uUG9pbnRPdmVyKTtcblxuICAgIHBvaW50cy5hdHRyKCdyJywgX3RoaXMubW9kZWwuZ2V0KCdwb2ludFJhZGl1cycpKVxuICAgICAgICAuYXR0cignY3gnLCBfdGhpcy5nZXRTY2FsZVgpXG4gICAgICAgIC5hdHRyKCdjeScsIF90aGlzLmdldFNjYWxlWSk7XG5cbiAgICBwb2ludHMuZXhpdCgpXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBudWxsKVxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIG51bGwpXG4gICAgICAgIC5yZW1vdmUoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHN1YiB2aWV3LlxuICAgKiBFbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gYXR0YWNoZWQgdG8gdmlldy5cbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSxcbiAgICAgICAgcG9pbnRzO1xuXG4gICAgZGF0YSA9IF90aGlzLm1vZGVsLmdldCgnZGF0YScpO1xuICAgIF94ID0gX3RoaXMudmlldy5tb2RlbC5nZXQoJ3hBeGlzU2NhbGUnKTtcbiAgICBfeSA9IF90aGlzLnZpZXcubW9kZWwuZ2V0KCd5QXhpc1NjYWxlJyk7XG5cbiAgICAvLyB1cGRhdGUgbGVnZW5kXG4gICAgaWYgKF90aGlzLmxlZ2VuZCkge1xuICAgICAgX2xlZ2VuZExpbmUuYXR0cignZCcsICdNMCwtM0wyNSwtMycpO1xuXG4gICAgICBfbGVnZW5kUG9pbnQgPSBfbGVnZW5kLnNlbGVjdEFsbCgnLnBvaW50Jyk7XG4gICAgICBpZiAoIV90aGlzLm1vZGVsLmdldCgnc2hvd0xlZ2VuZFBvaW50JykpIHtcbiAgICAgICAgX2xlZ2VuZFBvaW50LnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF9sZWdlbmRQb2ludC5lbXB0eSgpKSB7XG4gICAgICAgICAgX2xlZ2VuZFBvaW50ID0gX2xlZ2VuZC5hcHBlbmQoJ3N2ZzpjaXJjbGUnKVxuICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncG9pbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9sZWdlbmRQb2ludFxuICAgICAgICAgICAgLmF0dHIoJ3InLCBfdGhpcy5tb2RlbC5nZXQoJ3BvaW50UmFkaXVzJykpXG4gICAgICAgICAgICAuYXR0cignY3gnLCAxMi41KVxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgLTMpO1xuICAgICAgfVxuXG4gICAgICBfbGVnZW5kVGV4dFxuICAgICAgICAgIC50ZXh0KF90aGlzLm1vZGVsLmdldCgnbGFiZWwnKSlcbiAgICAgICAgICAuYXR0cignZHgnLCAzMCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGxpbmVcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDAgfHwgIV90aGlzLm1vZGVsLmdldCgnc2hvd0xpbmUnKSkge1xuICAgICAgX2xpbmUuYXR0cignZCcsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfbGluZS5hdHRyKCdkJywgX2xpbmVGb3JtYXQoZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBwb2ludHNcbiAgICBwb2ludHMgPSBfZWwuc2VsZWN0QWxsKCcucG9pbnQnKVxuICAgICAgICAuZGF0YShkYXRhKTtcbiAgICBpZiAoIV90aGlzLm1vZGVsLmdldCgnc2hvd1BvaW50cycpKSB7XG4gICAgICBwb2ludHMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLnBsb3RQb2ludHMocG9pbnRzKTtcbiAgICB9XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEM0xpbmVWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZDMgPSByZXF1aXJlKCdkMycpLFxuICAgIENsYXNzTGlzdCA9IHJlcXVpcmUoJy4vQ2xhc3NMaXN0JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIFZpZXcgPSByZXF1aXJlKCdtdmMvVmlldycpO1xuXG5cbnZhciBJRF9TRVFVRU5DRSA9IDA7XG5cblxuLyoqXG4gKiBTdWIgdmlldyBmb3IgYSBEMyBwbG90LlxuICpcbiAqIE1hbmFnZXMgbW91c2VvdmVyLCBtb3VzZW91dCwgY2xpY2sgZXZlbnRzIGZvciB2aWV3LlxuICogbW91c2VvdmVyIGFuZCBtb3VzZW91dCB0b2dnbGUgYSBcIm1vdXNlb3ZlclwiIGNsYXNzIG9uIHZpZXcuXG4gKiBjbGljayB0cmlnZ2VycyBcImNsaWNrXCIgZXZlbnQuXG4gKlxuICogV2hlbiBhZGRlZCB0byBhIEQzVmlldywgXCJjbGlja1wiIGV2ZW50IHRyaWdnZXJzIFwic2VsZWN0XCIgaW4gY29sbGVjdGlvbi5cbiAqIEQzVmlldyBjYWxscyBvblNlbGVjdCwgb25EZXNlbGVjdCBtZXRob2RzIHdoZW4gY29sbGVjdGlvbiBzZWxlY3Rpb24gY2hhbmdlcy5cbiAqXG4gKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSBhdCBsZWFzdCBnZXRYRXh0ZW50KCksIGdldFlFeHRlbnQoKSwgcmVuZGVyKHZpZXcpLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gKiAgICAgICAgYWxsIG9wdGlvbnMgYXJlIHBhc3NlZCB0byBWaWV3LlxuICogQHBhcmFtIG9wdGlvbnMuZWwge1NWR0VsZW1lbnR9XG4gKiAgICAgICAgZGVmYXVsdCBzdmc6Zy5cbiAqIEBwYXJhbSBvcHRpb25zLmxlZ2VuZCB7U1ZHRWxlbWVudH1cbiAqICAgICAgICBkZWZhdWx0IHN2ZzpnLlxuICogICAgICAgIHNldCB0byBudWxsIGZvciBubyBsZWdlbmQuXG4gKiBAcGFyYW0gb3B0aW9ucy5jbGFzc05hbWUge1N0cmluZ31cbiAqICAgICAgICBkZWZhdWx0IG51bGwuXG4gKiAgICAgICAgY2xhc3MgYWRkZWQgdG8gZWwgYW5kIGxlZ2VuZC5cbiAqL1xudmFyIEQzU3ViVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuICAgICAgLy8gdmFyaWFibGVzXG4gICAgICBfZWwsXG4gICAgICBfbGVnZW5kO1xuXG5cbiAgX3RoaXMgPSBWaWV3KFV0aWwuZXh0ZW5kKHtcbiAgICBlbDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdnJyksXG4gIH0sIG9wdGlvbnMpKTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB2aWV3LlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XG4gICAgICBjbGFzc05hbWU6IG51bGwsXG4gICAgICBsZWdlbmQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnZycpXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBlbnN1cmUgdmlld3MgaGF2ZSBhIHVuaXF1ZSBpZFxuICAgIF90aGlzLmlkID0gb3B0aW9ucy5pZCB8fCAoSURfU0VRVUVOQ0UrKyk7XG4gICAgX3RoaXMudmlldyA9IG9wdGlvbnMudmlldztcblxuICAgIC8vIHJlZmVyZW5jZSB0byB2aWV3IGZyb20gZWxlbWVudFxuICAgIF90aGlzLmVsLnZpZXcgPSBfdGhpcztcblxuICAgIENsYXNzTGlzdC5wb2x5ZmlsbChfdGhpcy5lbCk7XG4gICAgX2VsID0gZDMuc2VsZWN0KF90aGlzLmVsKTtcbiAgICBfZWwub24oJ2NsaWNrJywgX3RoaXMub25DbGljayk7XG4gICAgX2VsLm9uKCdtb3VzZW91dCcsIF90aGlzLm9uTW91c2VPdXQpO1xuICAgIF9lbC5vbignbW91c2VvdmVyJywgX3RoaXMub25Nb3VzZU92ZXIpO1xuXG4gICAgX3RoaXMubGVnZW5kID0gb3B0aW9ucy5sZWdlbmQ7XG4gICAgaWYgKF90aGlzLmxlZ2VuZCkge1xuICAgICAgQ2xhc3NMaXN0LnBvbHlmaWxsKF90aGlzLmxlZ2VuZCk7XG4gICAgICBfbGVnZW5kID0gZDMuc2VsZWN0KF90aGlzLmxlZ2VuZCk7XG4gICAgICBfbGVnZW5kLm9uKCdjbGljaycsIF90aGlzLm9uQ2xpY2spO1xuICAgICAgX2xlZ2VuZC5vbignbW91c2VvdXQnLCBfdGhpcy5vbk1vdXNlT3V0KTtcbiAgICAgIF9sZWdlbmQub24oJ21vdXNlb3ZlcicsIF90aGlzLm9uTW91c2VPdmVyKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQob3B0aW9ucy5jbGFzc05hbWUpO1xuICAgICAgaWYgKF90aGlzLmxlZ2VuZCkge1xuICAgICAgICBfdGhpcy5sZWdlbmQuY2xhc3NMaXN0LmFkZChvcHRpb25zLmNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHZpZXcuXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3RoaXMgPT09IG51bGwpIHtcbiAgICAgIC8vIGFscmVhZHkgZGVzdHJveWVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKF9lbCkge1xuICAgICAgX2VsLm9uKCdjbGljaycsIG51bGwpO1xuICAgICAgX2VsLm9uKCdtb3VzZW91dCcsIG51bGwpO1xuICAgICAgX2VsLm9uKCdtb3VzZW92ZXInLCBudWxsKTtcbiAgICAgIF9lbCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChfdGhpcy5sZWdlbmQpIHtcbiAgICAgIF9sZWdlbmQub24oJ2NsaWNrJywgbnVsbCk7XG4gICAgICBfbGVnZW5kLm9uKCdtb3VzZW91dCcsIG51bGwpO1xuICAgICAgX2xlZ2VuZC5vbignbW91c2VvdmVyJywgbnVsbCk7XG4gICAgICBfbGVnZW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICBfdGhpcy5lbC52aWV3ID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBYIGV4dGVudCBmb3Igdmlldy5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgICB4IGV4dGVudCBmb3Igdmlldy5cbiAgICovXG4gIF90aGlzLmdldFhFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBZIGV4dGVudCBmb3Igdmlldy5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgICB5IGV4dGVudCBmb3Igdmlldy5cbiAgICovXG4gIF90aGlzLmdldFlFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGljayBldmVudCBoYW5kbGVyLlxuICAgKi9cbiAgX3RoaXMub25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy50cmlnZ2VyKCdjbGljaycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXNlbGVjdCBldmVudCBoYW5kbGVyLlxuICAgKi9cbiAgX3RoaXMub25EZXNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgIGlmIChfdGhpcy5sZWdlbmQpIHtcbiAgICAgIF90aGlzLmxlZ2VuZC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTW91c2VvdXQgZXZlbnQgaGFuZGxlci5cbiAgICovXG4gIF90aGlzLm9uTW91c2VPdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnbW91c2VvdmVyJyk7XG4gICAgaWYgKF90aGlzLmxlZ2VuZCkge1xuICAgICAgX3RoaXMubGVnZW5kLmNsYXNzTGlzdC5yZW1vdmUoJ21vdXNlb3ZlcicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTW91c2VvdmVyIGV2ZW50IGhhbmRsZXIuXG4gICAqL1xuICBfdGhpcy5vbk1vdXNlT3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdtb3VzZW92ZXInKTtcbiAgICBpZiAoX3RoaXMubGVnZW5kKSB7XG4gICAgICBfdGhpcy5sZWdlbmQuY2xhc3NMaXN0LmFkZCgnbW91c2VvdmVyJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZWxlY3QgZXZlbnQgaGFuZGxlci5cbiAgICovXG4gIF90aGlzLm9uU2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgaWYgKF90aGlzLmxlZ2VuZCkge1xuICAgICAgX3RoaXMubGVnZW5kLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgc3ViIHZpZXcuXG4gICAqIEVsZW1lbnQgaGFzIGFscmVhZHkgYmVlbiBhdHRhY2hlZCB0byB2aWV3LlxuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRDNTdWJWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8qKlxuICogRm9ybWF0IHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gZWwge0QzRWxlbWVudH1cbiAqICAgICAgICB0b29sdGlwIGNvbnRhaW5lciBlbGVtZW50LlxuICogQHBhcmFtIGRhdGEge0FycmF5PE9iamVjdHxBcnJheT59XG4gKiAgICAgICAgZGF0YSBwYXNzZWQgdG8gc2hvd1Rvb2x0aXAuXG4gKiAgICAgICAgdGhpcyBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIG9iamVjdHMgKG9yIGFycmF5cyBvZiBvYmplY3RzKTpcbiAqICAgICAgICBvYmouY2xhc3Mge1N0cmluZ30gY2xhc3MgYXR0cmlidXRlIGZvciB0ZXh0fHRzcGFuLlxuICogICAgICAgIG9iai50ZXh0IHtTdHJpbmd9IGNvbnRlbnQgZm9yIHRleHR8dHNwYW4uXG4gKi9cbnZhciBfZm9ybWF0VGV4dCA9IGZ1bmN0aW9uIChlbCwgZGF0YSkge1xuICB2YXIgeTtcblxuICAvLyBhZGQgY29udGVudCB0byB0b29sdGlwXG4gIGRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgIHZhciB0ZXh0ID0gZWwuYXBwZW5kKCd0ZXh0Jyk7XG4gICAgaWYgKHR5cGVvZiBsaW5lLmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGFycmF5IG9mIGNvbXBvbmVudHM6XG4gICAgICBsaW5lLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdGV4dC5hcHBlbmQoJ3RzcGFuJykuYXR0cignY2xhc3MnLCBsLmNsYXNzIHx8ICcnKS50ZXh0KGwudGV4dCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dC5hdHRyKCdjbGFzcycsIGxpbmUuY2xhc3MgfHwgJycpLnRleHQobGluZS50ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH0pO1xuICAvLyBwb3NpdGlvbiBsaW5lcyBpbiB0b29sdGlwXG4gIHkgPSAwO1xuICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICB2YXIgYmJveCA9IGxpbmUubm9kZSgpLmdldEJCb3goKTtcbiAgICB5ICs9IGJib3guaGVpZ2h0O1xuICAgIGxpbmUuYXR0cigneScsIHkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUGVyc2lzdGVudGx5IHRyaWVzIHRvIGdldCB0aGUgYm91bmRpbmcgYm94IGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gZWxlbWVudCB7U1ZHVGV4dH1cbiAqICAgICAgVGhlIGVsZW1lbnQgZm9yIHdoaWNoIHRvIGdldCB0aGUgYm91bmRpbmcgYm94LlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICBBIGJvdW5kaW5nIGJveCBvYmplY3Qgd2l0aCB4LCB5LCB3aWR0aCwgaGVpZ2h0IGF0dHJpYnV0ZXNcbiAqL1xudmFyIF9nZXRCQm94ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGJib3g7XG5cbiAgdHJ5IHtcbiAgICBiYm94ID0gZWxlbWVudC5nZXRCQm94KCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmVcbiAgfVxuXG4gIGlmICghYmJveCkge1xuICAgIHRyeSB7XG4gICAgICBiYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZ25vcmVcbiAgICB9XG4gIH1cblxuICBpZiAoIWJib3gpIHtcbiAgICBiYm94ID0ge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuICB9XG5cbiAgcmV0dXJuIGJib3g7XG59O1xuXG4vKipcbiAqIFBhZCBhbiBleHRlbnQuXG4gKlxuICogQHBhcmFtIGV4dGVudCB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICBmaXJzdCBlbnRyeSBzaG91bGQgYmUgbWluaW11bS5cbiAqICAgICAgICBsYXN0IGVudHJ5IHNob3VsZCBiZSBtYXhpbXVtLlxuICogQHBhcmFtIGFtb3VudCB7TnVtYmVyfVxuICogICAgICAgIHBlcmNlbnRhZ2Ugb2YgcmFuZ2UgdG8gcGFkLlxuICogICAgICAgIEZvciBleGFtcGxlOiAwLjA1ID0gKy8tIDUlIG9mIHJhbmdlLlxuICogQHJldHVybiB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICAgcGFkZGVkIGV4dGVudC5cbiAqL1xudmFyIF9wYWRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBhbW91bnQpIHtcbiAgdmFyIHN0YXJ0ID0gZXh0ZW50WzBdLFxuICAgICAgZW5kID0gZXh0ZW50W2V4dGVudC5sZW5ndGggLSAxXSxcbiAgICAgIHJhbmdlID0gZW5kIC0gc3RhcnQsXG4gICAgICBwYWQgPSByYW5nZSAqIGFtb3VudDtcbiAgcmV0dXJuIFtzdGFydCAtIHBhZCwgZW5kICsgcGFkXTtcbn07XG5cbi8qKlxuICogUGFkIGEgbG9nIGJhc2VkIGV4dGVudC5cbiAqXG4gKiBTaW1pbGFyIHRvIF9wYWRFeHRlbnQoKSwgYnV0IHBhZGRpbmcgb2NjdXJzIGluIGxvZyBzcGFjZS5cbiAqXG4gKiBAcGFyYW0gZXh0ZW50IHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIGZpcnN0IGVudHJ5IHNob3VsZCBiZSBtaW5pbXVtLlxuICogICAgICAgIGxhc3QgZW50cnkgc2hvdWxkIGJlIG1heGltdW0uXG4gKiBAcGFyYW0gYW1vdW50IHtOdW1iZXJ9XG4gKiAgICAgICAgcGVyY2VudGFnZSBvZiByYW5nZSB0byBwYWQuXG4gKiAgICAgICAgRm9yIGV4YW1wbGU6IDAuMDUgPSArLy0gNSUgb2YgcmFuZ2UuXG4gKiBAcmV0dXJuIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgICBwYWRkZWQgZXh0ZW50LlxuICovXG52YXIgX3BhZExvZ0V4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIGFtb3VudCkge1xuICB2YXIgYmFzZSxcbiAgICAgIGJhc2VMb2csXG4gICAgICBlbmQsXG4gICAgICBzdGFydDtcblxuICAvLyBjb252ZXJ0IG1pbi9tYXggdG8gYmFzZSAxMFxuICBiYXNlID0gMTA7XG4gIGJhc2VMb2cgPSBNYXRoLmxvZyhiYXNlKTtcbiAgc3RhcnQgPSBNYXRoLmxvZyhleHRlbnRbMF0pIC8gYmFzZUxvZztcbiAgZW5kID0gTWF0aC5sb2coZXh0ZW50W2V4dGVudC5sZW5ndGggLSAxXSkgLyBiYXNlTG9nO1xuICBleHRlbnQgPSBfcGFkRXh0ZW50KFtzdGFydCwgZW5kXSwgYW1vdW50KTtcbiAgcmV0dXJuIFtNYXRoLnBvdyhiYXNlLCBleHRlbnRbMF0pLCBNYXRoLnBvdyhiYXNlLCBleHRlbnRbZXh0ZW50Lmxlbmd0aCAtIDFdKV07XG59O1xuXG5cbnZhciBEM1V0aWwgPSB7XG4gIGZvcm1hdFRleHQ6IF9mb3JtYXRUZXh0LFxuICBnZXRCQm94OiBfZ2V0QkJveCxcbiAgcGFkRXh0ZW50OiBfcGFkRXh0ZW50LFxuICBwYWRMb2dFeHRlbnQ6IF9wYWRMb2dFeHRlbnRcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEM1V0aWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkMyA9IHJlcXVpcmUoJ2QzJyksXG4gICAgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ212Yy9Db2xsZWN0aW9uJyksXG4gICAgRDNVdGlsID0gcmVxdWlyZSgnLi9EM1V0aWwnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyksXG4gICAgVmlldyA9IHJlcXVpcmUoJ212Yy9WaWV3Jyk7XG5cblxuLyoqXG4gKiBWaWV3IGZvciBhIEQzIHBsb3QuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICAgICBvcHRpb25zIGFyZSBwYXNzZWQgdG8gVmlldy5cbiAqIEBwYXJhbSBvcHRpb25zLmNsaWNrVG9TZWxlY3Qge0Jvb2xlYW59XG4gKiAgICAgICAgZGVmYXVsdCB0cnVlLlxuICogICAgICAgIHdoZW4gdHJ1ZSwgY2xpY2tpbmcgYSB2aWV3IGNhdXNlcyBpdCB0byBiZSBzZWxlY3RlZCBpbiB0aGVcbiAqICAgICAgICB2aWV3cyBjb2xsZWN0aW9uLlxuICogQHBhcmFtIG9wdGlvbnMuaGVpZ2h0IHtOdW1iZXJ9XG4gKiAgICAgICAgZGVmYXVsdCA0ODAuXG4gKiAgICAgICAgb3ZlcmFsbCAodmlld2JveCkgaGVpZ2h0IG9mIHN2ZyBlbGVtZW50LlxuICogQHBhcmFtIG9wdGlvbnMubGVnZW5kUG9zaXRpb24ge1N0cmluZ31cbiAqICAgICAgICBkZWZhdWx0ICd0b3BsZWZ0Jy5cbiAqICAgICAgICBvbmUgb2YgKHRvcHJpZ2h0fHRvcGxlZnR8Ym90dG9tcmlnaHR8Ym90dG9tbGVmdCkuXG4gKiAgICAgICAgcG9zaXRpb24gb2YgbGVnZW5kIGVsZW1lbnQuXG4gKiBAcGFyYW0gb3B0aW9ucy5tYXJnaW5Cb3R0b20ge051bWJlcn1cbiAqICAgICAgICBkZWZhdWx0IDAuXG4gKiBAcGFyYW0gb3B0aW9ucy5tYXJnaW5MZWZ0IHtOdW1iZXJ9XG4gKiAgICAgICAgZGVmYXVsdCAwLlxuICogQHBhcmFtIG9wdGlvbnMubWFyZ2luUmlnaHQge051bWJlcn1cbiAqICAgICAgICBkZWZhdWx0IDAuXG4gKiBAcGFyYW0gb3B0aW9ucy5tYXJnaW5Ub3Age051bWJlcn1cbiAqICAgICAgICBkZWZhdWx0IDAuXG4gKiBAcGFyYW0gb3B0aW9ucy5wYWRkaW5nQm90dG9tIHtOdW1iZXJ9XG4gKiAgICAgICAgZGVmYXVsdCA4MC5cbiAqIEBwYXJhbSBvcHRpb25zLnBhZGRpbmdMZWZ0IHtOdW1iZXJ9XG4gKiAgICAgICAgZGVmYXVsdCA4MC5cbiAqIEBwYXJhbSBvcHRpb25zLnBhZGRpbmdSaWdodCB7TnVtYmVyfVxuICogICAgICAgIGRlZmF1bHQgMjAuXG4gKiBAcGFyYW0gb3B0aW9ucy5wYWRkaW5nVG9wIHtOdW1iZXJ9XG4gKiAgICAgICAgZGVmYXVsdCA1MC5cbiAqIEBwYXJhbSBvcHRpb25zLnRpdGxlIHtTdHJpbmd9XG4gKiAgICAgICAgdGl0bGUgZm9yIHBsb3QuXG4gKiBAcGFyYW0gb3B0aW9ucy50b29sdGlwT2Zmc2V0IHtOdW1iZXJ9XG4gKiAgICAgICAgZGVmYXVsdCAxMC5cbiAqICAgICAgICB4L3kgZGlzdGFuY2UgZnJvbSB0b29sdGlwIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0gb3B0aW9ucy50b29sdGlwUGFkZGluZyB7TnVtYmVyfVxuICogICAgICAgIGRlZmF1bHQgNS5cbiAqICAgICAgICBwYWRkaW5nIGFyb3VuZCB0b29sdGlwIGNvbnRlbnQuXG4gKiBAcGFyYW0gb3B0aW9ucy53aWR0aCB7TnVtYmVyfVxuICogICAgICAgIGRlZmF1bHQgNjQwLlxuICogICAgICAgIHdpZHRoIG9mIHN2ZyB2aWV3Qm94LlxuICogQHBhcmFtIG9wdGlvbnMueEF4aXNGb3JtYXQge0Z1bmN0aW9ufFN0cmluZ31cbiAqICAgICAgICBkZWZhdWx0IG51bGwuXG4gKiAgICAgICAgeCBheGlzIHRpY2tGb3JtYXQuXG4gKiBAcGFyYW0gb3B0aW9ucy54QXhpc1BhZGRpbmcge051bWJlcn1cbiAqICAgICAgICBkZWZhdWx0IDAuMDUuXG4gKiAgICAgICAgcGFkIGV4dGVudHMgYnkgdGhpcyByYXRpby5cbiAqICAgICAgICBGb3IgZXhhbXBsZTogIDAuMDUgcGFkcyB0aGUgeCBheGlzIGV4dGVudCBieSA1JSBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0gb3B0aW9ucy54QXhpc1NjYWxlIHtkMy5zY2FsZX1cbiAqICAgICAgICBkZWZhdWx0IGQzLnNjYWxlLmxpbmVhcigpLlxuICogQHBhcmFtIG9wdGlvbnMueEF4aXNUaWNrcyB7RnVuY3Rpb24oZXh0ZW50KXxBcnJheTxOdW1iZXI+fVxuICogICAgICAgIGRlZmF1bHQgbnVsbC5cbiAqICAgICAgICB4IGF4aXMgdGljayB2YWx1ZXMuXG4gKiBAcGFyYW0gb3B0b2lucy54RXh0ZW50IHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIGRlZmF1bHQgbnVsbC5cbiAqICAgICAgICBleHBsaWNpdCB4IGV4dGVudCBmb3IgZ3JhcGgsIGRlZmF1bHQgaXMgYXV0by5cbiAqIEBwYXJhbSBvcHRpb25zLnhMYWJlbCB7U3RyaW5nfVxuICogICAgICAgIGxhYmVsIGZvciB4IGF4aXMuXG4gKiBAcGFyYW0gb3B0aW9ucy55QXhpc0Zvcm1hdCB7RnVuY3Rpb258U3RyaW5nfVxuICogICAgICAgIGRlZmF1bHQgbnVsbC5cbiAqICAgICAgICB5IGF4aXMgdGlja0Zvcm1hdC5cbiAqIEBwYXJhbSBvcHRpb25zLnlBeGlzUGFkZGluZyB7TnVtYmVyfVxuICogICAgICAgIGRlZmF1bHQgMC4wNS5cbiAqICAgICAgICBwYWQgZXh0ZW50cyBieSB0aGlzIHJhdGlvLlxuICogICAgICAgIEZvciBleGFtcGxlOiAgMC4wNSBwYWRzIHRoZSB5IGF4aXMgZXh0ZW50IGJ5IDUlIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSBvcHRpb25zLnlBeGlzU2NhbGUge2QzLnNjYWxlfVxuICogICAgICAgIGRlZmF1bHQgZDMuc2NhbGUubGluZWFyKCkuXG4gKiBAcGFyYW0gb3B0aW9ucy55QXhpc1RpY2tzIHtGdW5jdGlvbihleHRlbnQpfEFycmF5PE51bWJlcj59XG4gKiAgICAgICAgZGVmYXVsdCBudWxsLlxuICogICAgICAgIHkgYXhpcyB0aWNrIHZhbHVlcy5cbiAqIEBwYXJhbSBvcHRvaW5zLnlFeHRlbnQge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgZGVmYXVsdCBudWxsLlxuICogICAgICAgIGV4cGxpY2l0IHkgZXh0ZW50IGZvciBncmFwaCwgZGVmYXVsdCBpcyBhdXRvLlxuICogQHBhcmFtIG9wdGlvbnMueUxhYmVsIHtTdHJpbmd9XG4gKiAgICAgICAgbGFiZWwgZm9yIHkgYXhpcy5cbiAqL1xudmFyIEQzVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuICAgICAgLy8gdmFyaWFibGVzXG4gICAgICBfZmlyc3RSZW5kZXIsXG4gICAgICBfaW5uZXJGcmFtZSxcbiAgICAgIF9sZWdlbmQsXG4gICAgICBfbWFyZ2luLFxuICAgICAgX291dGVyRnJhbWUsXG4gICAgICBfcGFkZGluZyxcbiAgICAgIF9wbG90QXJlYSxcbiAgICAgIF9wbG90QXJlYUNsaXAsXG4gICAgICBfcGxvdFRpdGxlLFxuICAgICAgX3N2ZyxcbiAgICAgIF90b29sdGlwLFxuICAgICAgX3hBeGlzLFxuICAgICAgX3hBeGlzRWwsXG4gICAgICBfeEF4aXNMYWJlbCxcbiAgICAgIF94RWwsXG4gICAgICBfeUF4aXMsXG4gICAgICBfeUF4aXNFbCxcbiAgICAgIF95QXhpc0xhYmVsLFxuICAgICAgX3lFbDtcblxuXG4gIF90aGlzID0gVmlldyhvcHRpb25zKTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB2aWV3LlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBlbDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF9maXJzdFJlbmRlciA9IHRydWU7XG5cbiAgICBfdGhpcy5tb2RlbC5zZXQoVXRpbC5leHRlbmQoe1xuICAgICAgY2xpY2tUb1NlbGVjdDogdHJ1ZSxcbiAgICAgIGhlaWdodDogNDgwLFxuICAgICAgbGVnZW5kUG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICBsZWdlbmRPZmZzZXQ6IDIwLFxuICAgICAgbWFyZ2luQm90dG9tOiAwLFxuICAgICAgbWFyZ2luTGVmdDogMCxcbiAgICAgIG1hcmdpblJpZ2h0OiAwLFxuICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgcGFkZGluZ0JvdHRvbTogODAsXG4gICAgICBwYWRkaW5nTGVmdDogODAsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDIwLFxuICAgICAgcGFkZGluZ1RvcDogNTAsXG4gICAgICBwb2ludFJhZGl1czogMyxcbiAgICAgIHRpdGxlOiAnJyxcbiAgICAgIHRvb2x0aXBPZmZzZXQ6IDEwLFxuICAgICAgdG9vbHRpcFBhZGRpbmc6IDUsXG4gICAgICB3aWR0aDogNjQwLFxuICAgICAgeEF4aXNGb3JtYXQ6IG51bGwsXG4gICAgICB4QXhpc1BhZGRpbmc6IDAuMDUsXG4gICAgICB4QXhpc1NjYWxlOiBkMy5zY2FsZS5saW5lYXIoKSxcbiAgICAgIHhBeGlzVGlja3M6IG51bGwsXG4gICAgICB4RXh0ZW50OiBudWxsLFxuICAgICAgeExhYmVsOiAnJyxcbiAgICAgIHlBeGlzRm9ybWF0OiBudWxsLFxuICAgICAgeUF4aXNQYWRkaW5nOiAwLjA1LFxuICAgICAgeUF4aXNTY2FsZTogZDMuc2NhbGUubGluZWFyKCksXG4gICAgICB5QXhpc1RpY2tzOiBudWxsLFxuICAgICAgeUV4dGVudDogbnVsbCxcbiAgICAgIHlMYWJlbDogJydcbiAgICB9LCBvcHRpb25zKSwge3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgZWwgPSBfdGhpcy5lbDtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKCdEM1ZpZXcnKTtcbiAgICBlbC5pbm5lckhUTUwgPVxuICAgICAgICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nICtcbiAgICAgICAgICAgICc8ZGVmcz4nICtcbiAgICAgICAgICAgICAgJzxjbGlwUGF0aCBpZD1cInBsb3RBcmVhQ2xpcFwiPicgK1xuICAgICAgICAgICAgICAgICc8cmVjdCB4PVwiMFwiIHk9XCIwXCI+PC9yZWN0PicgK1xuICAgICAgICAgICAgICAnPC9jbGlwUGF0aD4nICtcbiAgICAgICAgICAgICc8L2RlZnM+JyArXG4gICAgICAgICAgICAnPGcgY2xhc3M9XCJtYXJnaW5cIj4nICtcbiAgICAgICAgICAgICAgJzxyZWN0IGNsYXNzPVwib3V0ZXItZnJhbWVcIj48L3JlY3Q+JyArXG4gICAgICAgICAgICAgICc8dGV4dCBjbGFzcz1cInBsb3QtdGl0bGVcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjwvdGV4dD4nICtcbiAgICAgICAgICAgICAgJzxnIGNsYXNzPVwicGFkZGluZ1wiPicgK1xuICAgICAgICAgICAgICAgICc8cmVjdCBjbGFzcz1cImlubmVyLWZyYW1lXCI+PC9yZWN0PicgK1xuICAgICAgICAgICAgICAgICc8ZyBjbGFzcz1cImxlZ2VuZFwiPjwvZz4nICtcbiAgICAgICAgICAgICAgICAnPGcgY2xhc3M9XCJ4XCI+JyArXG4gICAgICAgICAgICAgICAgICAnPGcgY2xhc3M9XCJheGlzXCI+PC9nPicgK1xuICAgICAgICAgICAgICAgICAgJzx0ZXh0IGNsYXNzPVwibGFiZWxcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjwvdGV4dD4nICtcbiAgICAgICAgICAgICAgICAnPC9nPicgK1xuICAgICAgICAgICAgICAgICc8ZyBjbGFzcz1cInlcIj4nICtcbiAgICAgICAgICAgICAgICAgICc8ZyBjbGFzcz1cImF4aXNcIj48L2c+JyArXG4gICAgICAgICAgICAgICAgICAnPHRleHQgY2xhc3M9XCJsYWJlbFwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAnIHRyYW5zZm9ybT1cInJvdGF0ZSgtOTApXCI+PC90ZXh0PicgK1xuICAgICAgICAgICAgICAgICc8L2c+JyArXG4gICAgICAgICAgICAgICAgJzxnIGNsYXNzPVwicGxvdFwiPjwvZz4nICtcbiAgICAgICAgICAgICAgICAnPGcgY2xhc3M9XCJ0b29sdGlwXCI+PC9nPicgK1xuICAgICAgICAgICAgICAnPC9nPicgK1xuICAgICAgICAgICAgJzwvZz4nICtcbiAgICAgICAgICAnPC9zdmc+JztcblxuICAgIF9zdmcgPSBlbC5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcbiAgICBfcGxvdEFyZWFDbGlwID0gX3N2Zy5xdWVyeVNlbGVjdG9yKCcjcGxvdEFyZWFDbGlwID4gcmVjdCcpO1xuICAgIF9vdXRlckZyYW1lID0gX3N2Zy5xdWVyeVNlbGVjdG9yKCcub3V0ZXItZnJhbWUnKTtcbiAgICBfaW5uZXJGcmFtZSA9IF9zdmcucXVlcnlTZWxlY3RvcignLmlubmVyLWZyYW1lJyk7XG4gICAgX21hcmdpbiA9IF9zdmcucXVlcnlTZWxlY3RvcignLm1hcmdpbicpO1xuICAgIF9wbG90VGl0bGUgPSBfbWFyZ2luLnF1ZXJ5U2VsZWN0b3IoJy5wbG90LXRpdGxlJyk7XG4gICAgX3BhZGRpbmcgPSBfbWFyZ2luLnF1ZXJ5U2VsZWN0b3IoJy5wYWRkaW5nJyk7XG4gICAgX2xlZ2VuZCA9IF9wYWRkaW5nLnF1ZXJ5U2VsZWN0b3IoJy5sZWdlbmQnKTtcbiAgICBfeEVsID0gX3BhZGRpbmcucXVlcnlTZWxlY3RvcignLngnKTtcbiAgICBfeEF4aXNFbCA9IF94RWwucXVlcnlTZWxlY3RvcignLmF4aXMnKTtcbiAgICBfeEF4aXNMYWJlbCA9IF94RWwucXVlcnlTZWxlY3RvcignLmxhYmVsJyk7XG4gICAgX3lFbCA9IF9wYWRkaW5nLnF1ZXJ5U2VsZWN0b3IoJy55Jyk7XG4gICAgX3lBeGlzRWwgPSBfeUVsLnF1ZXJ5U2VsZWN0b3IoJy5heGlzJyk7XG4gICAgX3lBeGlzTGFiZWwgPSBfeUVsLnF1ZXJ5U2VsZWN0b3IoJy5sYWJlbCcpO1xuICAgIF9wbG90QXJlYSA9IF9wYWRkaW5nLnF1ZXJ5U2VsZWN0b3IoJy5wbG90Jyk7XG4gICAgX3Rvb2x0aXAgPSBfcGFkZGluZy5xdWVyeVNlbGVjdG9yKCcudG9vbHRpcCcpO1xuXG4gICAgX3RoaXMudmlld3MgPSBDb2xsZWN0aW9uKFtdKTtcbiAgICBfdGhpcy52aWV3cy5vbignYWRkJywgX3RoaXMub25BZGQpO1xuICAgIF90aGlzLnZpZXdzLm9uKCdkZXNlbGVjdCcsIF90aGlzLm9uRGVzZWxlY3QpO1xuICAgIF90aGlzLnZpZXdzLm9uKCdyZW1vdmUnLCBfdGhpcy5vblJlbW92ZSk7XG4gICAgX3RoaXMudmlld3Mub24oJ3Jlc2V0JywgX3RoaXMub25SZXNldCk7XG4gICAgX3RoaXMudmlld3Mub24oJ3NlbGVjdCcsIF90aGlzLm9uU2VsZWN0KTtcblxuICAgIF94QXhpcyA9IGQzLnN2Zy5heGlzKCkub3JpZW50KCdib3R0b20nKS5vdXRlclRpY2tTaXplKDApO1xuICAgIF95QXhpcyA9IGQzLnN2Zy5heGlzKCkub3JpZW50KCdsZWZ0Jykub3V0ZXJUaWNrU2l6ZSgwKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHZpZXcuXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3RoaXMgPT09IG51bGwpIHtcbiAgICAgIC8vIGFscmVhZHkgZGVzdHJveWVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3RoaXMudmlld3Mub2ZmKCk7XG4gICAgX3RoaXMudmlld3MuZGVzdHJveSgpO1xuXG4gICAgX3RoaXMudmlld3MgPSBudWxsO1xuICAgIF9pbm5lckZyYW1lID0gbnVsbDtcbiAgICBfbGVnZW5kID0gbnVsbDtcbiAgICBfbWFyZ2luID0gbnVsbDtcbiAgICBfb3V0ZXJGcmFtZSA9IG51bGw7XG4gICAgX3BhZGRpbmcgPSBudWxsO1xuICAgIF9wbG90QXJlYSA9IG51bGw7XG4gICAgX3Bsb3RBcmVhQ2xpcCA9IG51bGw7XG4gICAgX3Bsb3RUaXRsZSA9IG51bGw7XG4gICAgX3N2ZyA9IG51bGw7XG4gICAgX3Rvb2x0aXAgPSBudWxsO1xuICAgIF94QXhpcyA9IG51bGw7XG4gICAgX3hBeGlzRWwgPSBudWxsO1xuICAgIF94QXhpc0xhYmVsID0gbnVsbDtcbiAgICBfeEVsID0gbnVsbDtcbiAgICBfeUF4aXMgPSBudWxsO1xuICAgIF95QXhpc0VsID0gbnVsbDtcbiAgICBfeUF4aXNMYWJlbCA9IG51bGw7XG4gICAgX3lFbCA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICBfdGhpcy5nZXRMZWdlbmRDbGFzcyA9IGZ1bmN0aW9uICgvKmRhdGEsIGluZGV4LCBzY29wZSovKSB7XG4gICAgcmV0dXJuICdsZWdlbmQtY29udGVudCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZpZXdzIGNvbGxlY3Rpb24gYWRkIGhhbmRsZXIuXG4gICAqXG4gICAqIEBwYXJhbSB2aWV3cyB7QXJyYXk8RDNTdWJWaWV3Pn1cbiAgICogICAgICAgIHZpZXdzIHRoYXQgd2VyZSBhZGRlZC5cbiAgICovXG4gIF90aGlzLm9uQWRkID0gZnVuY3Rpb24gKHZpZXdzLCBkb250cmVuZGVyKSB7XG4gICAgdmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgdmlldy5fZDN2aWV3X29uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLm9uQ2xpY2sodmlldyk7XG4gICAgICB9O1xuICAgICAgdmlldy5vbignY2xpY2snLCB2aWV3Ll9kM3ZpZXdfb25jbGljayk7XG4gICAgfSk7XG4gICAgaWYgKCFkb250cmVuZGVyKSB7XG4gICAgICBfdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgdmlldyBpcyBjbGlja2VkLlxuICAgKlxuICAgKiBAcGFyYW0gdmlldyB7RDNTdWJWaWV3fVxuICAgKiAgICAgICAgdmlldyB0aGF0IHdhcyBjbGlja2VkLlxuICAgKi9cbiAgX3RoaXMub25DbGljayA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgaWYgKF90aGlzLm1vZGVsLmdldCgnY2xpY2tUb1NlbGVjdCcpKSB7XG4gICAgICBfdGhpcy52aWV3cy5zZWxlY3Qodmlldyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBWaWV3cyBjb2xsZWN0aW9uIHNlbGVjdCBoYW5kbGVyLlxuICAgKlxuICAgKiBAcGFyYW0gdmlldyB7RDNTdWJWaWV3fVxuICAgKiAgICAgICAgdmlldyB0aGF0IHdhcyBzZWxlY3RlZC5cbiAgICovXG4gIF90aGlzLm9uRGVzZWxlY3QgPSBmdW5jdGlvbiAodmlldykge1xuICAgIHZpZXcub25EZXNlbGVjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWaWV3cyBjb2xsZWN0aW9uIHJlbW92ZSBoYW5kbGVyLlxuICAgKlxuICAgKiBAcGFyYW0gdmlld3Mge0FycmF5PEQzU3ViVmlldz59XG4gICAqICAgICAgICB2aWV3cyB0aGF0IHdlcmUgcmVtb3ZlZC5cbiAgICovXG4gIF90aGlzLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZpZXdzLCBkb250cmVuZGVyKSB7XG4gICAgdmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgdmlldy5vZmYoJ2NsaWNrJywgdmlldy5fZDN2aWV3X29uY2xpY2spO1xuICAgICAgdmlldy5fZDN2aWV3X29uY2xpY2sgPSBudWxsO1xuICAgIH0pO1xuICAgIGlmICghZG9udHJlbmRlcikge1xuICAgICAgX3RoaXMucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBWaWV3cyBjb2xsZWN0aW9uIHJlc2V0IGhhbmRsZXIuXG4gICAqL1xuICBfdGhpcy5vblJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCxcbiAgICAgICAgdG9SZW1vdmUgPSBbXTtcbiAgICAvLyBjYWxsIG9uUmVtb3ZlIGZvciBhbGwgZXhpc3Rpbmcgdmlld3MuXG4gICAgd2hpbGUgKF9wbG90QXJlYS5maXJzdENoaWxkKSB7XG4gICAgICAvLyBkZXRhY2ggdmlld1xuICAgICAgZWwgPSBfcGxvdEFyZWEuZmlyc3RDaGlsZDtcbiAgICAgIF9wbG90QXJlYS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAvLyBjYWxsIHJlbW92ZSB0byBjbGVhbiB1cFxuICAgICAgdG9SZW1vdmUucHVzaChlbC52aWV3KTtcbiAgICB9XG4gICAgX3RoaXMub25SZW1vdmUodG9SZW1vdmUpO1xuICAgIC8vIGNhbGwgb25BZGQgZm9yIGFsbCB2aWV3c1xuICAgIF90aGlzLm9uQWRkKF90aGlzLnZpZXdzLmRhdGEoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZpZXdzIGNvbGxlY3Rpb24gc2VsZWN0IGhhbmRsZXIuXG4gICAqXG4gICAqIEBwYXJhbSB2aWV3IHtEM1N1YlZpZXd9XG4gICAqICAgICAgICB2aWV3IHRoYXQgd2FzIHNlbGVjdGVkLlxuICAgKi9cbiAgX3RoaXMub25TZWxlY3QgPSBmdW5jdGlvbiAodmlldykge1xuICAgIHZpZXcub25TZWxlY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSBjaGFuZ2VkIHtPYmplY3R9XG4gICAqICAgICAgICBkZWZhdWx0IGlzIF90aGlzLm1vZGVsLmdldC5cbiAgICogICAgICAgIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGhhdmUgY2hhbmdlZC5cbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uIChjaGFuZ2VkKSB7XG4gICAgdmFyIGhlaWdodCxcbiAgICAgICAgaW5uZXJXaWR0aCxcbiAgICAgICAgaW5uZXJIZWlnaHQsXG4gICAgICAgIGxlZ2VuZFBvc2l0aW9uLFxuICAgICAgICBsZWdlbmRYLFxuICAgICAgICBsZWdlbmRZLFxuICAgICAgICBtYXJnaW5Cb3R0b20sXG4gICAgICAgIG1hcmdpbkxlZnQsXG4gICAgICAgIG1hcmdpblJpZ2h0LFxuICAgICAgICBtYXJnaW5Ub3AsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG91dGVySGVpZ2h0LFxuICAgICAgICBvdXRlcldpZHRoLFxuICAgICAgICBwYWRkaW5nQm90dG9tLFxuICAgICAgICBwYWRkaW5nTGVmdCxcbiAgICAgICAgcGFkZGluZ1JpZ2h0LFxuICAgICAgICBwYWRkaW5nVG9wLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgeEF4aXNTY2FsZSxcbiAgICAgICAgeEF4aXNUaWNrcyxcbiAgICAgICAgeEV4dGVudCxcbiAgICAgICAgeUF4aXNTY2FsZSxcbiAgICAgICAgeUF4aXNUaWNrcyxcbiAgICAgICAgeUV4dGVudDtcblxuXG4gICAgb3B0aW9ucyA9IF90aGlzLm1vZGVsLmdldCgpO1xuICAgIGlmIChfZmlyc3RSZW5kZXIgfHwgIWNoYW5nZWQpIHtcbiAgICAgIGNoYW5nZWQgPSBvcHRpb25zO1xuICAgICAgX2ZpcnN0UmVuZGVyID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYWxsIG9wdGlvbnNcbiAgICB4QXhpc1NjYWxlID0gb3B0aW9ucy54QXhpc1NjYWxlO1xuICAgIHlBeGlzU2NhbGUgPSBvcHRpb25zLnlBeGlzU2NhbGU7XG4gICAgLy8gdGhlc2UgYXJlIHVzZWQgZm9yIGxhYmVsIHBvc2l0aW9uaW5nXG4gICAgcGFkZGluZ0JvdHRvbSA9IG9wdGlvbnMucGFkZGluZ0JvdHRvbTtcbiAgICBwYWRkaW5nTGVmdCA9IG9wdGlvbnMucGFkZGluZ0xlZnQ7XG5cbiAgICBpZiAoY2hhbmdlZC5oYXNPd25Qcm9wZXJ0eSgndGl0bGUnKSkge1xuICAgICAgX3Bsb3RUaXRsZS50ZXh0Q29udGVudCA9IG9wdGlvbnMudGl0bGU7XG4gICAgICBfcGxvdFRpdGxlLnNldEF0dHJpYnV0ZSgneScsIEQzVXRpbC5nZXRCQm94KF9wbG90VGl0bGUpLmhlaWdodCk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkLmhhc093blByb3BlcnR5KCd4TGFiZWwnKSkge1xuICAgICAgX3hBeGlzTGFiZWwudGV4dENvbnRlbnQgPSBvcHRpb25zLnhMYWJlbDtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWQuaGFzT3duUHJvcGVydHkoJ3lMYWJlbCcpKSB7XG4gICAgICBfeUF4aXNMYWJlbC50ZXh0Q29udGVudCA9IG9wdGlvbnMueUxhYmVsO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkLmhhc093blByb3BlcnR5KCd3aWR0aCcpIHx8XG4gICAgICAgIGNoYW5nZWQuaGFzT3duUHJvcGVydHkoJ2hlaWdodCcpIHx8XG4gICAgICAgIGNoYW5nZWQuaGFzT3duUHJvcGVydHkoJ2xlZ2VuZFBvc2l0aW9uJykgfHxcbiAgICAgICAgY2hhbmdlZC5oYXNPd25Qcm9wZXJ0eSgnbWFyZ2luQm90dG9tJykgfHxcbiAgICAgICAgY2hhbmdlZC5oYXNPd25Qcm9wZXJ0eSgnbWFyZ2luTGVmdCcpIHx8XG4gICAgICAgIGNoYW5nZWQuaGFzT3duUHJvcGVydHkoJ21hcmdpblJpZ2h0JykgfHxcbiAgICAgICAgY2hhbmdlZC5oYXNPd25Qcm9wZXJ0eSgnbWFyZ2luVG9wJykgfHxcbiAgICAgICAgY2hhbmdlZC5oYXNPd25Qcm9wZXJ0eSgncGFkZGluZ0JvdHRvbScpIHx8XG4gICAgICAgIGNoYW5nZWQuaGFzT3duUHJvcGVydHkoJ3BhZGRpbmdMZWZ0JykgfHxcbiAgICAgICAgY2hhbmdlZC5oYXNPd25Qcm9wZXJ0eSgncGFkZGluZ1JpZ2h0JykgfHxcbiAgICAgICAgY2hhbmdlZC5oYXNPd25Qcm9wZXJ0eSgncGFkZGluZ1RvcCcpKSB7XG4gICAgICB3aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgIG1hcmdpbkJvdHRvbSA9IG9wdGlvbnMubWFyZ2luQm90dG9tO1xuICAgICAgbWFyZ2luTGVmdCA9IG9wdGlvbnMubWFyZ2luTGVmdDtcbiAgICAgIG1hcmdpblJpZ2h0ID0gb3B0aW9ucy5tYXJnaW5SaWdodDtcbiAgICAgIG1hcmdpblRvcCA9IG9wdGlvbnMubWFyZ2luVG9wO1xuICAgICAgcGFkZGluZ1JpZ2h0ID0gb3B0aW9ucy5wYWRkaW5nUmlnaHQ7XG4gICAgICBwYWRkaW5nVG9wID0gb3B0aW9ucy5wYWRkaW5nVG9wO1xuICAgICAgLy8gYWRqdXN0IGJhc2VkIG9uIG1hcmdpbi9wYWRkaW5nXG4gICAgICBvdXRlcldpZHRoID0gd2lkdGggLSBtYXJnaW5MZWZ0IC0gbWFyZ2luUmlnaHQ7XG4gICAgICBvdXRlckhlaWdodCA9IGhlaWdodCAtIG1hcmdpblRvcCAtIG1hcmdpbkJvdHRvbTtcbiAgICAgIGlubmVyV2lkdGggPSBvdXRlcldpZHRoIC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XG4gICAgICBpbm5lckhlaWdodCA9IG91dGVySGVpZ2h0IC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG4gICAgICAvLyB1cGRhdGUgZWxlbWVudHNcbiAgICAgIF90aGlzLmVsLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAoMTAwICogaGVpZ2h0IC8gd2lkdGgpICsgJyUnO1xuICAgICAgX3N2Zy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAnMCAwICcgKyB3aWR0aCArICcgJyArIGhlaWdodCk7XG4gICAgICBfc3ZnLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWluWU1pbiBtZWV0Jyk7XG4gICAgICBfcGxvdEFyZWFDbGlwLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBpbm5lcldpZHRoKTtcbiAgICAgIF9wbG90QXJlYUNsaXAuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBpbm5lckhlaWdodCk7XG4gICAgICBfbWFyZ2luLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxcbiAgICAgICAgICAndHJhbnNsYXRlKCcgKyBtYXJnaW5MZWZ0ICsgJywnICsgbWFyZ2luVG9wICsgJyknKTtcbiAgICAgIF9vdXRlckZyYW1lLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgb3V0ZXJIZWlnaHQpO1xuICAgICAgX291dGVyRnJhbWUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIG91dGVyV2lkdGgpO1xuICAgICAgX3Bsb3RUaXRsZS5zZXRBdHRyaWJ1dGUoJ3gnLCBvdXRlcldpZHRoIC8gMik7XG4gICAgICBfcGFkZGluZy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsXG4gICAgICAgICAgJ3RyYW5zbGF0ZSgnICsgcGFkZGluZ0xlZnQgKyAnLCcgKyBwYWRkaW5nVG9wICsgJyknKTtcbiAgICAgIF9pbm5lckZyYW1lLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBpbm5lcldpZHRoKTtcbiAgICAgIF9pbm5lckZyYW1lLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaW5uZXJIZWlnaHQpO1xuICAgICAgX3hFbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsXG4gICAgICAgICAgJ3RyYW5zbGF0ZSgwLCcgKyBpbm5lckhlaWdodCArICcpJyk7XG4gICAgICAvLyB1cGRhdGUgYXhlcyByYW5nZSBhbmQgcG9zaXRpb25cbiAgICAgIHhBeGlzU2NhbGUucmFuZ2UoWzAsIGlubmVyV2lkdGhdKTtcbiAgICAgIHlBeGlzU2NhbGUucmFuZ2UoW2lubmVySGVpZ2h0LCAwXSk7XG4gICAgICBfeEF4aXNMYWJlbC5zZXRBdHRyaWJ1dGUoJ3gnLCBpbm5lcldpZHRoIC8gMik7XG4gICAgICBfeUF4aXNMYWJlbC5zZXRBdHRyaWJ1dGUoJ3gnLCAtaW5uZXJIZWlnaHQgLyAyKTtcblxuICAgICAgbGVnZW5kUG9zaXRpb24gPSBvcHRpb25zLmxlZ2VuZFBvc2l0aW9uO1xuICAgICAgbGVnZW5kWCA9IDA7XG4gICAgICBsZWdlbmRZID0gMDtcbiAgICAgIGlmIChsZWdlbmRQb3NpdGlvbiA9PT0gJ3RvcHJpZ2h0Jykge1xuICAgICAgICBsZWdlbmRYID0gaW5uZXJXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAobGVnZW5kUG9zaXRpb24gPT09ICdib3R0b21sZWZ0Jykge1xuICAgICAgICBsZWdlbmRZID0gaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGxlZ2VuZFBvc2l0aW9uID09PSAnYm90dG9tcmlnaHQnKSB7XG4gICAgICAgIGxlZ2VuZFggPSBpbm5lcldpZHRoO1xuICAgICAgICBsZWdlbmRZID0gaW5uZXJIZWlnaHQ7XG4gICAgICB9IC8vIGVsc2UgJ3RvcGxlZnQnXG4gICAgICBfbGVnZW5kLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxcbiAgICAgICAgICAndHJhbnNsYXRlKCcgKyBsZWdlbmRYICsgJywnICsgbGVnZW5kWSArICcpJyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGF4ZXMgZXh0ZW50XG4gICAgeEV4dGVudCA9IF90aGlzLmdldFBsb3RYRXh0ZW50KCk7XG4gICAgeEF4aXNTY2FsZS5kb21haW4oeEV4dGVudCk7XG4gICAgeUV4dGVudCA9IF90aGlzLmdldFBsb3RZRXh0ZW50KHhFeHRlbnQpO1xuICAgIHlBeGlzU2NhbGUuZG9tYWluKHlFeHRlbnQpO1xuXG4gICAgLy8gcmVkcmF3IGF4ZXNcbiAgICBfeEF4aXMuc2NhbGUoeEF4aXNTY2FsZSk7XG4gICAgX3hBeGlzLnRpY2tGb3JtYXQob3B0aW9ucy54QXhpc0Zvcm1hdCk7XG4gICAgeEF4aXNUaWNrcyA9IG9wdGlvbnMueEF4aXNUaWNrcztcbiAgICBpZiAodHlwZW9mIHhBeGlzVGlja3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHhBeGlzVGlja3MgPSB4QXhpc1RpY2tzKHhFeHRlbnQpO1xuICAgIH1cbiAgICBfeEF4aXMudGlja1ZhbHVlcyh4QXhpc1RpY2tzKTtcblxuICAgIF95QXhpcy5zY2FsZSh5QXhpc1NjYWxlKTtcbiAgICBfeUF4aXMudGlja0Zvcm1hdChvcHRpb25zLnlBeGlzRm9ybWF0KTtcbiAgICB5QXhpc1RpY2tzID0gb3B0aW9ucy55QXhpc1RpY2tzO1xuICAgIGlmICh0eXBlb2YgeUF4aXNUaWNrcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgeUF4aXNUaWNrcyA9IHlBeGlzVGlja3MoeUV4dGVudCk7XG4gICAgfVxuICAgIF95QXhpcy50aWNrVmFsdWVzKHlBeGlzVGlja3MpO1xuXG4gICAgZDMuc2VsZWN0KF94QXhpc0VsKS5jYWxsKF94QXhpcyk7XG4gICAgZDMuc2VsZWN0KF95QXhpc0VsKS5jYWxsKF95QXhpcyk7XG5cbiAgICAvLyB1cGRhdGUgbGFiZWwgcG9zaXRpb25zIGJhc2VkIG9uIGF4ZXMgc2l6ZVxuICAgIF94QXhpc0xhYmVsLnNldEF0dHJpYnV0ZSgneScsXG4gICAgICAgIHBhZGRpbmdCb3R0b20gLSBEM1V0aWwuZ2V0QkJveChfeEF4aXNMYWJlbCkuaGVpZ2h0KTtcbiAgICBfeUF4aXNMYWJlbC5zZXRBdHRyaWJ1dGUoJ3knLFxuICAgICAgICBEM1V0aWwuZ2V0QkJveChfeUF4aXNMYWJlbCkuaGVpZ2h0IC0gcGFkZGluZ0xlZnQpO1xuXG4gICAgLy8gbm93IHJlbmRlciB2aWV3c1xuICAgIF90aGlzLnJlbmRlclZpZXdzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlLXJlbmRlciBzdWItdmlld3MuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmJveCxcbiAgICAgICAgbGVnZW5kQ29udGVudCxcbiAgICAgICAgbGVnZW5kT2Zmc2V0LFxuICAgICAgICBsZWdlbmRQb3NpdGlvbixcbiAgICAgICAgbGVnZW5kWCxcbiAgICAgICAgbGVnZW5kWTtcblxuICAgIC8vIGNsZWFyIHBsb3QgYXJlYVxuICAgIFV0aWwuZW1wdHkoX3Bsb3RBcmVhKTtcbiAgICBVdGlsLmVtcHR5KF9sZWdlbmQpO1xuICAgIGxlZ2VuZENvbnRlbnQgPSBkMy5zZWxlY3QoX2xlZ2VuZClcbiAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIF90aGlzLmdldExlZ2VuZENsYXNzKS5ub2RlKCk7XG5cbiAgICAvLyBhZGQgdmlld3MgdG8gcGxvdCBhcmVhXG4gICAgbGVnZW5kWSA9IDA7XG4gICAgX3RoaXMudmlld3MuZGF0YSgpLmZvckVhY2goZnVuY3Rpb24gKHZpZXcsIGluZGV4KSB7XG4gICAgICAvLyBhZGQgZWxlbWVudHNcbiAgICAgIF9wbG90QXJlYS5hcHBlbmRDaGlsZCh2aWV3LmVsKTtcbiAgICAgIHZpZXcuZWwuc2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JywgaW5kZXgpO1xuICAgICAgaWYgKHZpZXcubGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZENvbnRlbnQuYXBwZW5kQ2hpbGQodmlldy5sZWdlbmQpO1xuICAgICAgICB2aWV3LmxlZ2VuZC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBpbmRleCk7XG4gICAgICB9XG4gICAgICAvLyByZW5kZXIgZWxlbWVudHNcbiAgICAgIHZpZXcucmVuZGVyKF90aGlzKTtcbiAgICAgIC8vIHBvc2l0aW9uIGxlZ2VuZFxuICAgICAgaWYgKHZpZXcubGVnZW5kKSB7XG4gICAgICAgIGJib3ggPSBEM1V0aWwuZ2V0QkJveCh2aWV3LmxlZ2VuZCk7XG4gICAgICAgIGxlZ2VuZFkgKz0gYmJveC5oZWlnaHQ7XG4gICAgICAgIHZpZXcubGVnZW5kLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxcbiAgICAgICAgICAgICd0cmFuc2xhdGUoMCwnICsgbGVnZW5kWSAgKyAnKScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcG9zaXRpb24gbGVnZW5kIGNvbnRlbnQuXG4gICAgYmJveCA9IEQzVXRpbC5nZXRCQm94KGxlZ2VuZENvbnRlbnQpO1xuICAgIGxlZ2VuZE9mZnNldCA9IF90aGlzLm1vZGVsLmdldCgnbGVnZW5kT2Zmc2V0Jyk7XG4gICAgbGVnZW5kUG9zaXRpb24gPSBfdGhpcy5tb2RlbC5nZXQoJ2xlZ2VuZFBvc2l0aW9uJyk7XG4gICAgbGVnZW5kWCA9IGxlZ2VuZE9mZnNldDtcbiAgICBsZWdlbmRZID0gbGVnZW5kT2Zmc2V0O1xuICAgIGlmIChsZWdlbmRQb3NpdGlvbiA9PT0gJ3RvcHJpZ2h0Jykge1xuICAgICAgbGVnZW5kWCA9IC0obGVnZW5kT2Zmc2V0ICsgYmJveC53aWR0aCk7XG4gICAgfSBlbHNlIGlmIChsZWdlbmRQb3NpdGlvbiA9PT0gJ2JvdHRvbWxlZnQnKSB7XG4gICAgICBsZWdlbmRZID0gLShsZWdlbmRPZmZzZXQgKyBiYm94LmhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChsZWdlbmRQb3NpdGlvbiA9PT0gJ2JvdHRvbXJpZ2h0Jykge1xuICAgICAgbGVnZW5kWCA9IC0obGVnZW5kT2Zmc2V0ICsgYmJveC53aWR0aCk7XG4gICAgICBsZWdlbmRZID0gLShsZWdlbmRPZmZzZXQgKyBiYm94LmhlaWdodCk7XG4gICAgfSAvLyBlbHNlICd0b3BsZWZ0J1xuICAgIGxlZ2VuZENvbnRlbnQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLFxuICAgICAgICAndHJhbnNsYXRlKCcgKyBsZWdlbmRYICsgJywnICsgbGVnZW5kWSArICcpJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGxvdCB4IGV4dGVudCwgaW5jbHVkaW5nIHBhZGRpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PE51bWJlcj59IHggZXh0ZW50cy5cbiAgICovXG4gIF90aGlzLmdldFBsb3RYRXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB4QXhpc1BhZGRpbmcsXG4gICAgICAgIHhBeGlzU2NhbGUsXG4gICAgICAgIHhFeHRlbnQ7XG5cbiAgICB4RXh0ZW50ID0gX3RoaXMuZ2V0WEV4dGVudCgpO1xuICAgIHhBeGlzUGFkZGluZyA9IF90aGlzLm1vZGVsLmdldCgneEF4aXNQYWRkaW5nJyk7XG4gICAgaWYgKHhBeGlzUGFkZGluZykge1xuICAgICAgeEF4aXNTY2FsZSA9IF90aGlzLm1vZGVsLmdldCgneEF4aXNTY2FsZScpO1xuICAgICAgeEV4dGVudCA9ICh0eXBlb2YgeEF4aXNTY2FsZS5iYXNlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIEQzVXRpbC5wYWRMb2dFeHRlbnQgOiBEM1V0aWwucGFkRXh0ZW50KSh4RXh0ZW50LCB4QXhpc1BhZGRpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiB4RXh0ZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBsb3QgeSBleHRlbnQsIGluY2x1ZGluZyBwYWRkaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geEV4dGVudCB7QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgIHhFeHRlbnQgaXMgcGFzc2VkIHRvIF90aGlzLmdldFlFeHRlbnQoKS5cbiAgICogQHJldHVybiB7QXJyYXk8TnVtYmVyPn0geSBleHRlbnRzLlxuICAgKi9cbiAgX3RoaXMuZ2V0UGxvdFlFeHRlbnQgPSBmdW5jdGlvbiAoeEV4dGVudCkge1xuICAgIHZhciB5QXhpc1BhZGRpbmcsXG4gICAgICAgIHlBeGlzU2NhbGUsXG4gICAgICAgIHlFeHRlbnQ7XG5cbiAgICB5RXh0ZW50ID0gX3RoaXMuZ2V0WUV4dGVudCh4RXh0ZW50KTtcbiAgICB5QXhpc1BhZGRpbmcgPSBfdGhpcy5tb2RlbC5nZXQoJ3lBeGlzUGFkZGluZycpO1xuICAgIGlmICh5QXhpc1BhZGRpbmcpIHtcbiAgICAgIHlBeGlzU2NhbGUgPSBfdGhpcy5tb2RlbC5nZXQoJ3lBeGlzU2NhbGUnKTtcbiAgICAgIHlFeHRlbnQgPSAodHlwZW9mIHlBeGlzU2NhbGUuYmFzZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBEM1V0aWwucGFkTG9nRXh0ZW50IDogRDNVdGlsLnBhZEV4dGVudCkoeUV4dGVudCwgeUF4aXNQYWRkaW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geUV4dGVudDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIHggZXh0ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxOdW1iZXI+fSB4IGV4dGVudHMuXG4gICAqL1xuICBfdGhpcy5nZXRYRXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB4RXh0ZW50O1xuXG4gICAgeEV4dGVudCA9IF90aGlzLm1vZGVsLmdldCgneEV4dGVudCcpO1xuICAgIGlmICh4RXh0ZW50ID09PSBudWxsKSB7XG4gICAgICB4RXh0ZW50ID0gW107XG4gICAgICBfdGhpcy52aWV3cy5kYXRhKCkuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICB4RXh0ZW50ID0geEV4dGVudC5jb25jYXQodmlldy5nZXRYRXh0ZW50KCkpO1xuICAgICAgfSk7XG4gICAgICB4RXh0ZW50ID0gZDMuZXh0ZW50KHhFeHRlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB4RXh0ZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGEgeSBleHRlbnQsIGluY2x1ZGluZyBwYWRkaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geEV4dGVudCB7QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgIHggZXh0ZW50LCBpbiBjYXNlIHkgZXh0ZW50IGlzIGZpbHRlcmVkIGJhc2VkIG9uIHggZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtBcnJheTxOdW1iZXI+fSB4IGV4dGVudHMuXG4gICAqL1xuICBfdGhpcy5nZXRZRXh0ZW50ID0gZnVuY3Rpb24gKC8qIHhFeHRlbnQgKi8pIHtcbiAgICB2YXIgeUV4dGVudDtcblxuICAgIHlFeHRlbnQgPSBfdGhpcy5tb2RlbC5nZXQoJ3lFeHRlbnQnKTtcbiAgICBpZiAoeUV4dGVudCA9PT0gbnVsbCkge1xuICAgICAgeUV4dGVudCA9IFtdO1xuICAgICAgX3RoaXMudmlld3MuZGF0YSgpLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgeUV4dGVudCA9IHlFeHRlbnQuY29uY2F0KHZpZXcuZ2V0WUV4dGVudCgpKTtcbiAgICAgIH0pO1xuICAgICAgeUV4dGVudCA9IGQzLmV4dGVudCh5RXh0ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4geUV4dGVudDtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyBhIHRvb2x0aXAgb24gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gY29vcmRzIHtBcnJheTx4LCB5Pn1cbiAgICogICAgICAgIGNvb3JkaW5hdGUgZm9yIG9yaWdpbiBvZiB0b29sdGlwLlxuICAgKiBAcGFyYW0gZGF0YSB7QXJyYXk8T2JqZWN0fEFycmF5Pn1cbiAgICogICAgICAgIHRvb2x0aXAgY29udGVudCwgcGFzc2VkIHRvIGZvcm1hdFRvb2x0aXAuXG4gICAqL1xuICBfdGhpcy5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uIChjb29yZHMsIGRhdGEpIHtcbiAgICB2YXIgYmJveCxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBvdXRsaW5lLFxuICAgICAgICBwYWRkaW5nLFxuICAgICAgICB0b29sdGlwLFxuICAgICAgICB0b29sdGlwQmJveCxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIHRvb2x0aXAgPSBkMy5zZWxlY3QoX3Rvb2x0aXApO1xuICAgIC8vIGNsZWFyIHRvb2x0aXBcbiAgICB0b29sdGlwLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICAgIGlmICghY29vcmRzIHx8ICFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IF90aGlzLm1vZGVsLmdldCgpO1xuICAgIG9mZnNldCA9IG9wdGlvbnMudG9vbHRpcE9mZnNldDtcbiAgICBwYWRkaW5nID0gb3B0aW9ucy50b29sdGlwUGFkZGluZztcbiAgICAvLyBjcmVhdGUgdG9vbHRpcCBjb250ZW50XG4gICAgb3V0bGluZSA9IHRvb2x0aXAuYXBwZW5kKCdyZWN0JykuYXR0cignY2xhc3MnLCAndG9vbHRpcC1vdXRsaW5lJyk7XG4gICAgY29udGVudCA9IHRvb2x0aXAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAndG9vbHRpcC1jb250ZW50Jyk7XG4gICAgRDNVdGlsLmZvcm1hdFRleHQoY29udGVudCwgZGF0YSk7XG4gICAgLy8gcG9zaXRpb24gdG9vbHRpcCBvdXRsaW5lXG4gICAgYmJveCA9IEQzVXRpbC5nZXRCQm94KHRvb2x0aXAubm9kZSgpKTtcbiAgICBvdXRsaW5lLmF0dHIoJ3dpZHRoJywgYmJveC53aWR0aCArIDIgKiBwYWRkaW5nKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgYmJveC5oZWlnaHQgKyAyICogcGFkZGluZyk7XG4gICAgY29udGVudC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBwYWRkaW5nICsgJywwKScpO1xuXG4gICAgLy8gcG9zaXRpb24gdG9vbHRpcCBvbiBncmFwaFxuICAgIC8vIGNlbnRlciBvZiBwb2ludFxuICAgIHggPSBvcHRpb25zLnhBeGlzU2NhbGUoY29vcmRzWzBdKTtcbiAgICB5ID0gb3B0aW9ucy55QXhpc1NjYWxlKGNvb3Jkc1sxXSk7XG4gICAgLy8gYm94IHJlbmRlcmluZyBpbnNpZGVcbiAgICBiYm94ID0gRDNVdGlsLmdldEJCb3goX2lubmVyRnJhbWUpO1xuICAgIC8vIGJveCBiZWluZyByZW5kZXJlZFxuICAgIHRvb2x0aXBCYm94ID0gRDNVdGlsLmdldEJCb3goX3Rvb2x0aXApO1xuICAgIC8vIGtlZXAgdG9vbHRpcCBpbiBncmFwaCBhcmVhXG4gICAgaWYgKHggKyB0b29sdGlwQmJveC53aWR0aCA+IGJib3gud2lkdGgpIHtcbiAgICAgIHggPSB4IC0gdG9vbHRpcEJib3gud2lkdGggLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4ICsgb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoeSArIHRvb2x0aXBCYm94LmhlaWdodCA+IGJib3guaGVpZ2h0KSB7XG4gICAgICB5ID0geSAtIHRvb2x0aXBCYm94LmhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgeSA9IHkgKyBvZmZzZXQ7XG4gICAgfVxuICAgIC8vIHNldCBwb3NpdGlvblxuICAgIF90b29sdGlwLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxcbiAgICAgICAgJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHkgKyAnKScpO1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRDNWaWV3O1xuIiwiLyogZ2xvYmFsIEwgKi9cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEyLCBTbWFydHJhaywgRGF2aWQgTGVhdmVyXG4gKiBMZWFmbGV0LnV0ZmdyaWQgaXMgYW4gb3Blbi1zb3VyY2UgSmF2YVNjcmlwdCBsaWJyYXJ5IHRoYXQgcHJvdmlkZXMgdXRmZ3JpZFxuICogaW50ZXJhY3Rpb24gb24gbGVhZmxldCBwb3dlcmVkIG1hcHMuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2RhbnplbC9MZWFmbGV0LnV0ZmdyaWRcbiAqL1xuXG4vLyAwNC8xMS8xMyAtLSBFTU06IFRoaXMgaXMgYW4gQU1EJ2QgKHJlcXVpcmUuanMpIHZlcnNpb24gb2YgdGhlIG9yaWdpbmFsXG4vLyAgICAgICAgICAgICAgICAgIHNvdXJjZS5cbid1c2Ugc3RyaWN0JztcblxuXG5MLlV0aWwuYWpheCA9IGZ1bmN0aW9uICh1cmwsIGNiKSB7XG4gIC8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBKYXZhU2NyaXB0OiBUaGUgRGVmaW5pdGl2ZSBHdWlkZVxuICAvLyBhbmQgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vWE1MSHR0cFJlcXVlc3QvVXNpbmdfWE1MSHR0cFJlcXVlc3RfaW5fSUU2XG4gIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qZ2xvYmFsIEFjdGl2ZVhPYmplY3Q6dHJ1ZSAqL1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWE1MSHR0cFJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdmFyIHJlc3BvbnNlLCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHJlcXVlc3Qub3BlbignR0VUJywgdXJsKTtcbiAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLypqc2hpbnQgZXZpbDogdHJ1ZSAqL1xuICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQgJiYgcmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgaWYgKHdpbmRvdy5KU09OKSB7XG4gICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZSA9IGV2YWwoJygnICsgcmVxdWVzdC5yZXNwb25zZVRleHQgKyAnKScpO1xuICAgICAgfVxuICAgICAgY2IocmVzcG9uc2UpO1xuICAgIH1cbiAgfTtcbiAgcmVxdWVzdC5zZW5kKCk7XG59O1xuXG5MLlV0ZkdyaWQgPSBMLkNsYXNzLmV4dGVuZCh7XG4gIGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcbiAgb3B0aW9uczoge1xuICAgIHN1YmRvbWFpbnM6ICdhYmMnLFxuXG4gICAgbWluWm9vbTogMCxcbiAgICBtYXhab29tOiAxOCxcbiAgICB0aWxlU2l6ZTogMjU2LFxuXG4gICAgcmVzb2x1dGlvbjogNCxcblxuICAgIHVzZUpzb25QOiB0cnVlLFxuICAgIHBvaW50ZXJDdXJzb3I6IHRydWVcbiAgfSxcblxuICAvL1RoZSB0aGluZyB0aGUgbW91c2UgaXMgY3VycmVudGx5IG9uXG4gIF9tb3VzZU9uOiBudWxsLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuXG4gICAgLy9GaW5kIGEgdW5pcXVlIGlkIGluIHdpbmRvdyB3ZSBjYW4gdXNlIGZvciBvdXIgY2FsbGJhY2tzXG4gICAgLy9SZXF1aXJlZCBmb3IganNvblBcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHdpbmRvd1snbHUnICsgaV0pIHtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgdGhpcy5fd2luZG93S2V5ID0gJ2x1JyArIGk7XG4gICAgd2luZG93W3RoaXMuX3dpbmRvd0tleV0gPSB7fTtcblxuICAgIHZhciBzdWJkb21haW5zID0gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnM7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zdWJkb21haW5zID0gc3ViZG9tYWlucy5zcGxpdCgnJyk7XG4gICAgfVxuICB9LFxuXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICB2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cbiAgICBpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8IHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1hcC5vbignY2xpY2snLCB0aGlzLl9jbGljaywgdGhpcyk7XG4gICAgbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3ZlLCB0aGlzKTtcbiAgICBtYXAub24oJ21vdmVlbmQnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuICB9LFxuXG4gIG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICBtYXAub2ZmKCdjbGljaycsIHRoaXMuX2NsaWNrLCB0aGlzKTtcbiAgICBtYXAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3ZlLCB0aGlzKTtcbiAgICBtYXAub2ZmKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcbiAgfSxcblxuICBfY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgdGhpcy5maXJlKCdjbGljaycsIHRoaXMuX29iamVjdEZvckV2ZW50KGUpKTtcbiAgfSxcbiAgX21vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fb2JqZWN0Rm9yRXZlbnQoZSk7XG5cbiAgICBpZiAob24uZGF0YSAhPT0gdGhpcy5fbW91c2VPbikge1xuICAgICAgaWYgKHRoaXMuX21vdXNlT24pIHtcbiAgICAgICAgdGhpcy5maXJlKCdtb3VzZW91dCcsIHsgbGF0bG5nOiBlLmxhdGxuZywgZGF0YTogdGhpcy5fbW91c2VPbiB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb2ludGVyQ3Vyc29yKSB7XG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob24uZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ21vdXNlb3ZlcicsIG9uKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb2ludGVyQ3Vyc29yKSB7XG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9tb3VzZU9uID0gb24uZGF0YTtcbiAgICB9IGVsc2UgaWYgKG9uLmRhdGEpIHtcbiAgICAgIHRoaXMuZmlyZSgnbW91c2Vtb3ZlJywgb24pO1xuICAgIH1cbiAgfSxcblxuICBfb2JqZWN0Rm9yRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgcG9pbnQgPSBtYXAucHJvamVjdChlLmxhdGxuZyksXG4gICAgICAgIHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplLFxuICAgICAgICByZXNvbHV0aW9uID0gdGhpcy5vcHRpb25zLnJlc29sdXRpb24sXG4gICAgICAgIHggPSBNYXRoLmZsb29yKHBvaW50LnggLyB0aWxlU2l6ZSksXG4gICAgICAgIHkgPSBNYXRoLmZsb29yKHBvaW50LnkgLyB0aWxlU2l6ZSksXG4gICAgICAgIGdyaWRYID0gTWF0aC5mbG9vcigocG9pbnQueCAtICh4ICogdGlsZVNpemUpKSAvIHJlc29sdXRpb24pLFxuICAgICAgICBncmlkWSA9IE1hdGguZmxvb3IoKHBvaW50LnkgLSAoeSAqIHRpbGVTaXplKSkgLyByZXNvbHV0aW9uKSxcbiAgICAgIG1heCA9IG1hcC5vcHRpb25zLmNycy5zY2FsZShtYXAuZ2V0Wm9vbSgpKSAvIHRpbGVTaXplO1xuXG4gICAgeCA9ICh4ICsgbWF4KSAlIG1heDtcbiAgICB5ID0gKHkgKyBtYXgpICUgbWF4O1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLl9jYWNoZVttYXAuZ2V0Wm9vbSgpICsgJ18nICsgeCArICdfJyArIHldO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIHsgbGF0bG5nOiBlLmxhdGxuZywgZGF0YTogbnVsbCB9O1xuICAgIH1cblxuICAgIHZhciBpZHggPSB0aGlzLl91dGZEZWNvZGUoZGF0YS5ncmlkW2dyaWRZXS5jaGFyQ29kZUF0KGdyaWRYKSksXG4gICAgICAgIGtleSA9IGRhdGEua2V5c1tpZHhdLFxuICAgICAgICByZXN1bHQgPSBkYXRhLmRhdGFba2V5XTtcblxuICAgIGlmICghZGF0YS5kYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbGF0bG5nOiBlLmxhdGxuZywgZGF0YTogcmVzdWx0fTtcbiAgfSxcblxuICAvL0xvYWQgdXAgYWxsIHJlcXVpcmVkIGpzb24gZ3JpZCBmaWxlc1xuICAvL1RPRE86IExvYWQgZnJvbSBjZW50ZXIgZXRjXG4gIF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcbiAgICAgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCksXG4gICAgICAgIHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXG4gICAgaWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fCB6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbndUaWxlUG9pbnQgPSBuZXcgTC5Qb2ludChcbiAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWluLnggLyB0aWxlU2l6ZSksXG4gICAgICAgIE1hdGguZmxvb3IoYm91bmRzLm1pbi55IC8gdGlsZVNpemUpKSxcbiAgICAgIHNlVGlsZVBvaW50ID0gbmV3IEwuUG9pbnQoXG4gICAgICAgIE1hdGguZmxvb3IoYm91bmRzLm1heC54IC8gdGlsZVNpemUpLFxuICAgICAgICBNYXRoLmZsb29yKGJvdW5kcy5tYXgueSAvIHRpbGVTaXplKSksXG4gICAgICAgIG1heCA9IHRoaXMuX21hcC5vcHRpb25zLmNycy5zY2FsZSh6b29tKSAvIHRpbGVTaXplO1xuXG4gICAgLy9Mb2FkIGFsbCByZXF1aXJlZCBvbmVzXG4gICAgZm9yICh2YXIgeCA9IG53VGlsZVBvaW50Lng7IHggPD0gc2VUaWxlUG9pbnQueDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gbndUaWxlUG9pbnQueTsgeSA8PSBzZVRpbGVQb2ludC55OyB5KyspIHtcblxuICAgICAgICB2YXIgeHcgPSAoeCArIG1heCkgJSBtYXgsIHl3ID0gKHkgKyBtYXgpICUgbWF4O1xuICAgICAgICB2YXIga2V5ID0gem9vbSArICdfJyArIHh3ICsgJ18nICsgeXc7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVba2V5XSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZUpzb25QKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkVGlsZVAoem9vbSwgeHcsIHl3KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbG9hZFRpbGUoem9vbSwgeHcsIHl3KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX2xvYWRUaWxlUDogZnVuY3Rpb24gKHpvb20sIHgsIHkpIHtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0sXG4gICAgICAgIGtleSA9IHpvb20gKyAnXycgKyB4ICsgJ18nICsgeSxcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gJ2x1XycgKyBrZXksXG4gICAgICAgIHdrID0gdGhpcy5fd2luZG93S2V5LFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIHZhciB1cmwgPSBMLlV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBMLlV0aWwuZXh0ZW5kKHtcbiAgICAgIHM6IEwuVGlsZUxheWVyLnByb3RvdHlwZS5fZ2V0U3ViZG9tYWluLmNhbGwodGhpcywgeyB4OiB4LCB5OiB5IH0pLFxuICAgICAgejogem9vbSxcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgY2I6IHdrICsgJy4nICsgZnVuY3Rpb25OYW1lXG4gICAgfSwgdGhpcy5vcHRpb25zKSk7XG5cbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2phdmFzY3JpcHQnKTtcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdzcmMnLCB1cmwpO1xuXG4gICAgd2luZG93W3drXVtmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHNlbGYuX2NhY2hlW2tleV0gPSBkYXRhO1xuICAgICAgZGVsZXRlIHdpbmRvd1t3a11bZnVuY3Rpb25OYW1lXTtcbiAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICB9O1xuXG4gICAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9LFxuXG4gIF9sb2FkVGlsZTogZnVuY3Rpb24gKHpvb20sIHgsIHkpIHtcbiAgICB2YXIgdXJsID0gTC5VdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgTC5VdGlsLmV4dGVuZCh7XG4gICAgICBzOiBMLlRpbGVMYXllci5wcm90b3R5cGUuX2dldFN1YmRvbWFpbi5jYWxsKHRoaXMsIHsgeDogeCwgeTogeSB9KSxcbiAgICAgIHo6IHpvb20sXG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0sIHRoaXMub3B0aW9ucykpO1xuXG4gICAgdmFyIGtleSA9IHpvb20gKyAnXycgKyB4ICsgJ18nICsgeTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgTC5VdGlsLmFqYXgodXJsLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgc2VsZi5fY2FjaGVba2V5XSA9IGRhdGE7XG4gICAgfSk7XG4gIH0sXG5cbiAgX3V0ZkRlY29kZTogZnVuY3Rpb24gKGMpIHtcbiAgICBpZiAoYyA+PSA5Mykge1xuICAgICAgYy0tO1xuICAgIH1cbiAgICBpZiAoYyA+PSAzNSkge1xuICAgICAgYy0tO1xuICAgIH1cbiAgICByZXR1cm4gYyAtIDMyO1xuICB9XG59KTtcblxuXG5MLnV0ZkdyaWQgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgTC5VdGZHcmlkKHVybCwgb3B0aW9ucyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTC5VdGZHcmlkO1xuIiwiLyogZ2xvYmFsIEwgKi9cbid1c2Ugc3RyaWN0JztcblxuXG4vKipcbiAqIFNpbXBsZSBleHRlbnNpb24gdG8gY29udHJvbCBpbiBvcmRlciB0byBhbGlnbiBnZW5lcmF0ZWQgbWFya3VwIHdpdGhcbiAqIEhhekRldiB0ZW1wbGF0ZSBzdHlsZXMuXG4gKlxuICovXG52YXIgSGF6RGV2TGF5ZXJzID0gTC5Db250cm9sLkxheWVycy5leHRlbmQoe1xuICBfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBjaGVja2VkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGZyYWdtZW50LFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgbGFiZWw7XG5cbiAgICBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpO1xuXG4gICAgaWYgKG9iai5vdmVybGF5KSB7XG4gICAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICBpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgIGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcbiAgICAgIGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnMnLCBjaGVja2VkKTtcbiAgICB9XG5cbiAgICBpbnB1dC5sYXllcklkID0gTC5zdGFtcChvYmoubGF5ZXIpO1xuICAgIGlucHV0LmlkID0gJ2xlYWZsZXQtbGF5ZXItY29udHJvbC1zZWxlY3Rvci0nICsgaW5wdXQubGF5ZXJJZDtcblxuICAgIEwuRG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XG5cblxuICAgIGxhYmVsLmlubmVySFRNTCA9IG9iai5uYW1lO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgaW5wdXQuaWQpO1xuXG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIGNvbnRhaW5lciA9IG9iai5vdmVybGF5ID8gdGhpcy5fb3ZlcmxheXNMaXN0IDogdGhpcy5fYmFzZUxheWVyc0xpc3Q7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxufSk7XG5cblxuTC5Db250cm9sLkhhekRldkxheWVycyA9IEhhekRldkxheWVycztcblxuTC5jb250cm9sLmhhekRldkxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IEhhekRldkxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTC5jb250cm9sLmhhekRldkxheWVycztcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gQ29weXJpZ2h0IDIwMTIgQXJkaGkgTHVraWFudG9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmRoaS9MZWFmbGV0Lk1vdXNlUG9zaXRpb25cbnZhciBNb3VzZVBvc2l0aW9uID0gTC5Db250cm9sLmV4dGVuZCh7XG4gIG9wdGlvbnM6IHtcbiAgICBwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcbiAgICBzZXBhcmF0b3I6ICcgOiAnLFxuICAgIGVtcHR5U3RyaW5nOiAnVW5hdmFpbGFibGUnLFxuICAgIGxuZ0ZpcnN0OiBmYWxzZSxcbiAgICBudW1EaWdpdHM6IDMsXG4gICAgbG5nRm9ybWF0dGVyOiBmdW5jdGlvbihuKSB7IHJldHVybiBbTWF0aC5hYnMobikudG9GaXhlZCgzKSwgJyZkZWc7JyxcbiAgICAgICAgICAgIChuPDA/J1cnOidFJyldLmpvaW4oJycpOyB9LFxuICAgIGxhdEZvcm1hdHRlcjogZnVuY3Rpb24obikgeyByZXR1cm4gW01hdGguYWJzKG4pLnRvRml4ZWQoMyksICcmZGVnOycsXG4gICAgICAgICAgICAobjwwPydTJzonTicpXS5qb2luKCcnKTsgfVxuICB9LFxuXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JyxcbiAgICAgICAgJ2xlYWZsZXQtY29udHJvbC1iYWNrZ3JvdW5kIGxlYWZsZXQtY29udHJvbC1tb3VzZXBvc2l0aW9uJyk7XG4gICAgTC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xuICAgIG1hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUw9dGhpcy5vcHRpb25zLmVtcHR5U3RyaW5nO1xuICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gIH0sXG5cbiAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgICBtYXAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gIH0sXG5cbiAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBsbmcgPSBMLlV0aWwuZm9ybWF0TnVtKGUubGF0bG5nLmxuZywgdGhpcy5vcHRpb25zLm51bURpZ2l0cyk7XG4gICAgLy8gbmVlZCB0byBjb3JyZWN0IGZvciByb2xsb3ZlciBvZiBtYXAgaWYgdXNlciBzY3JvbGxzXG4gICAgaWYobG5nID49IDApIHtcbiAgICAgIGxuZz0oKGxuZysxODApJTM2MCktMTgwO1xuICAgIH0gZWxzZSB7XG4gICAgICBsbmc9KCgobG5nKzE4MCkrKE1hdGguY2VpbChNYXRoLmFicyhsbmcrMTgwKS8zNjApKjM2MCkpJTM2MCktMTgwO1xuICAgIH1cbiAgICB2YXIgbGF0ID0gTC5VdGlsLmZvcm1hdE51bShlLmxhdGxuZy5sYXQsIHRoaXMub3B0aW9ucy5udW1EaWdpdHMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG5nRm9ybWF0dGVyKSB7XG4gICAgICBsbmcgPSB0aGlzLm9wdGlvbnMubG5nRm9ybWF0dGVyKGxuZyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubGF0Rm9ybWF0dGVyKSB7XG4gICAgICBsYXQgPSB0aGlzLm9wdGlvbnMubGF0Rm9ybWF0dGVyKGxhdCk7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHRoaXMub3B0aW9ucy5sbmdGaXJzdCA/XG4gICAgICAgICAgICBsbmcgKyB0aGlzLm9wdGlvbnMuc2VwYXJhdG9yICsgbGF0IDpcbiAgICAgICAgICAgIGxhdCArIHRoaXMub3B0aW9ucy5zZXBhcmF0b3IgKyBsbmc7XG4gICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHZhbHVlO1xuICB9XG59KTtcblxuXG5MLkNvbnRyb2wuTW91c2VQb3NpdGlvbiA9IE1vdXNlUG9zaXRpb247XG5cbkwuY29udHJvbC5tb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNb3VzZVBvc2l0aW9uKG9wdGlvbnMpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEwuY29udHJvbC5tb3VzZVBvc2l0aW9uO1xuIiwiLyogZ2xvYmFsIEwgKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgWGhyID0gcmVxdWlyZSgndXRpbC9YaHInKTtcblxuXG4vKipcbiAqIEEgTGVhZmxldCBHZW9KU09OIGxheWVyIHRoYXQgbG9hZHMgaXRzIGRhdGEgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGxheWVyXG4gKiBpcyBhZGRlZCB0byB0aGUgbWFwIChpbiBvbkFkZCkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICAgICBhbGwgb3B0aW9ucyBhcmUgcGFzc2VkIHRvIEwuR2VvSlNPTi5cbiAqIEBwYXJhbSBvcHRpb25zLnVybCB7U3RyaW5nfVxuICogICAgICAgIHVybCBjb250YWluaW5nIGRhdGEgdG8gbG9hZC5cbiAqL1xudmFyIEFzeW5jaHJvbm91c0dlb0pzb24gPSBMLkdlb0pTT04uZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuX3VybCA9IG9wdGlvbnMudXJsO1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuXG4gICAgTC5HZW9KU09OLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgW10sIG9wdGlvbnMpO1xuICB9LFxuXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKHRoaXMuX2RhdGEgPT09IG51bGwpIHtcbiAgICAgIC8vIGZsYWcgdGhhdCBkYXRhIGlzIGJlaW5nIGxvYWRlZFxuICAgICAgdGhpcy5fZGF0YSA9ICdsb2FkaW5nJztcbiAgICAgIC8vIHNjb3BlIGZvciBYaHIgY2FsbGJhY2tzXG4gICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBYaHIuYWpheCh7XG4gICAgICAgIHVybDogdGhpcy5fdXJsLFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIC8vIHBhcnNlIGlmIG5lZWRlZFxuICAgICAgICAgIGRhdGEgPSAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShkYXRhKSA6IGRhdGEpO1xuICAgICAgICAgIC8vIGZsYWcgdGhhdCBkYXRhIGlzIGxvYWRlZFxuICAgICAgICAgIF90aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgICAvLyBhZGQgZGF0YSB0byBsYXllciAoYW5kIG1hcCBpZiBsYXllciBzdGlsbCB2aXNpYmxlKVxuICAgICAgICAgIF90aGlzLmFkZERhdGEoZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZmFpbGVkIHRvIGxvYWQsIGNsZWFyIGxvYWRpbmcgaW4gY2FzZSByZS1hZGRlZFxuICAgICAgICAgIF90aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYWx3YXlzIGFkZCBsYXllciwgZGF0YSBhZGRlZCBhc3luY2hyb25vdXNseVxuICAgIEwuR2VvSlNPTi5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICB9XG5cbn0pO1xuXG5cbkwuQXN5bmNocm9ub3VzR2VvSnNvbiA9IEFzeW5jaHJvbm91c0dlb0pzb247XG5cbkwuYXN5bmNocm9ub3VzR2VvSlNPTiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQXN5bmNocm9ub3VzR2VvSnNvbihvcHRpb25zKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMLmFzeW5jaHJvbm91c0dlb0pzb247XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFRpbGVQcm92aWRlciA9IHJlcXVpcmUoJ2xlYWZsZXQvbGF5ZXIvVGlsZVByb3ZpZGVyJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfQ0FSVE9EQixcbiAgICBfREVGQVVMVFMsXG4gICAgX0VTUkksXG4gICAgX1BST1ZJREVSX0lORk87XG5cblxuX0NBUlRPREIgPSAnY2FydG9kYic7XG5fRVNSSSA9ICdlc3JpJztcbl9QUk9WSURFUl9JTkZPID0ge307XG5cbl9ERUZBVUxUUyA9IHtcbiAgcHJvdmlkZXI6IF9FU1JJXG59O1xuXG5fUFJPVklERVJfSU5GT1tfQ0FSVE9EQl0gPSB7XG4gIHVybDogJ2h0dHBzOi8vY2FydG9kYi1iYXNlbWFwcy17c30uZ2xvYmFsLnNzbC5mYXN0bHkubmV0L2xpZ2h0X2FsbC97en0ve3h9L3t5fUAyeC5wbmcnLFxuICBvcHRpb25zOiB7XG4gICAgc3ViZG9tYWluczogJ2FiY2QnLFxuICAgIGF0dHJpYnV0aW9uOiAnPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiPicgK1xuICAgICAgICAnT3BlblN0cmVldE1hcDwvYT4gJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL2NhcnRvZGIuY29tL2F0dHJpYnV0aW9uc1wiPicgK1xuICAgICAgICAnQ2FydG9EQjwvYT4nXG4gIH1cbn07XG5cbl9QUk9WSURFUl9JTkZPW19FU1JJXSA9IHtcbiAgdXJsOiAnaHR0cHM6Ly97c30uYXJjZ2lzb25saW5lLmNvbS9BcmNHSVMvcmVzdC9zZXJ2aWNlcy8nICtcbiAgICAgICdDYW52YXMvV29ybGRfTGlnaHRfR3JheV9CYXNlL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9LmpwZycsXG4gIG9wdGlvbnM6IHtcbiAgICBzdWJkb21haW5zOiBbJ3NlcnZlcicsICdzZXJ2aWNlcyddLFxuICAgIGF0dHJpYnV0aW9uOiAnU291cmNlczogRXNyaSwgRGVMb3JtZSwgSEVSRSwgTWFwbXlJbmRpYSwgICZjb3B5OyAnICtcbiAgICAgICAgJ09wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzLCBhbmQgdGhlIEdJUyBjb21tdW5pdHknXG4gIH1cbn07XG5cblxuLyoqXG4qIEZhY3RvcnkgZm9yIEdyYXlzY2FsZSBiYXNlIGxheWVyLlxuKi9cbnZhciBHcmF5c2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB0cnkge1xuICAgIHJldHVybiBUaWxlUHJvdmlkZXIuY3JlYXRlKFxuICAgICAgX1BST1ZJREVSX0lORk8sXG4gICAgICBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKVxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gVGlsZVByb3ZpZGVyLmNyZWF0ZShcbiAgICAgIF9QUk9WSURFUl9JTkZPLFxuICAgICAgX0RFRkFVTFRTXG4gICAgKTtcbiAgfVxufTtcblxuXG5HcmF5c2NhbGUuQ0FSVE9EQiA9IF9DQVJUT0RCO1xuR3JheXNjYWxlLkVTUkkgPSBfRVNSSTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXlzY2FsZTtcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ISVNUT1JJQ19TRUlTTUlDSVRZX1VSTCA9ICdodHRwczovL2VhcnRocXVha2UudXNncy5nb3YvYXJjZ2lzL3Jlc3QnICtcbiAgICAnL3NlcnZpY2VzL2VxL2NhdGFsb2dfMjAxNS9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fSc7XG5cblxuLyoqXG4gKiBIaXN0b3JpYyBzZWlzbWljaXR5IGxheWVyLlxuICpcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgIEFueSBvcHRpb25zIHRoYXQgY291bGQgYmUgcHJvdmlkZWQgdG8gYW4gTC50aWxlTGF5ZXJcbiAqL1xudmFyIEhpc3RvcmljU2Vpc21pY2l0eSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XG4gICAgdGlsZVVybDogX0hJU1RPUklDX1NFSVNNSUNJVFlfVVJMXG4gIH0sIG9wdGlvbnMpO1xuXG4gIHJldHVybiBMLnRpbGVMYXllcihvcHRpb25zLnRpbGVVcmwsIG9wdGlvbnMpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEhpc3RvcmljU2Vpc21pY2l0eTtcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFV0ZkdyaWQgPSByZXF1aXJlKCdsZWFmbGV0L1V0ZkdyaWQnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIENMQVNTRVMgPSAnbGVhZmxldC1tb3VzZW92ZXItdG9vbHRpcCc7XG5cblxuTC5Nb3VzZU92ZXJMYXllciA9IEwuTGF5ZXJHcm91cC5leHRlbmQoe1xuXG4gIF9pbml0aWFsaXplZDogZmFsc2UsIC8vIEZsYWcgdG8gdGVsbCBpZiBjb25zdHJ1Y3RvciBoYXMgZmluaXNoZWRcblxuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogICAgICB0aWxlVXJsOiBVUkwgdG8gaW1hZ2UgdGlsZXNcbiAgICogICAgICBkYXRhVXJsOiBVUkwgdG8gVXRmR3JpZCB0aWxlcyAocmVxdWlyZXMgY2FsbGJhY2s9e2NifSlcbiAgICogICAgICB0aWxlT3B0czogT3B0aW9ucyB0byBiZSB1c2VkIG9uIEwuVGlsZUxheWVyIGZvciBpbWFnZSB0aWxlc1xuICAgKiAgICAgIGRhdGFPcHRzOiBPcHRpb25zIHRvIGJlIHVzZWQgb24gTC5VdGZHcmlkIGZvciBncmlkIHRpbGVzXG4gICAqICAgICAgdGlwdGV4dDogVGVtcGxhdGUgc3RyaW5nIHRvIGJlIHVzZWQgZm9yIGF1dG8tdG9vbHRpcHBpbmcgb24gaG92ZXJcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHR3byBsYXllcnNcbiAgICB0aGlzLl90aWxlTGF5ZXIgPSBuZXcgTC5UaWxlTGF5ZXIob3B0aW9ucy50aWxlVXJsLCBvcHRpb25zLnRpbGVPcHRzKTtcbiAgICB0aGlzLl9kYXRhTGF5ZXIgPSBuZXcgVXRmR3JpZChvcHRpb25zLmRhdGFVcmwsIG9wdGlvbnMuZGF0YU9wdHMpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRpcHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl90aXB0ZXh0ID0gb3B0aW9ucy50aXB0ZXh0O1xuICAgICAgdGhpcy5fdG9vbHRpcCA9IEwuRG9tVXRpbC5jcmVhdGUoJ3NwYW4nLCBDTEFTU0VTKTtcbiAgICAgIHRoaXMub24oJ21vdXNlb3ZlcicsIHRoaXMuX29uTW91c2VPdmVyLCB0aGlzKTtcbiAgICAgIHRoaXMub24oJ21vdXNlb3V0JywgdGhpcy5fb25Nb3VzZU91dCwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbCBwYXJlbnQgY29uc3RydWN0b3JcbiAgICBMLkxheWVyR3JvdXAucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBbXSk7XG4gICAgdGhpcy5hZGRMYXllcih0aGlzLl90aWxlTGF5ZXIpO1xuICAgIGlmICghVXRpbC5pc01vYmlsZSgpKSB7XG4gIHRoaXMuYWRkTGF5ZXIodGhpcy5fZGF0YUxheWVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gIH0sXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRGVsZWdhdGUgZXZlbnQgaGFuZGxpbmcgdG8gdGhlIGRhdGEgbGF5ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBvbjogZnVuY3Rpb24gKCkge1xuICAgIFV0ZkdyaWQucHJvdG90eXBlLm9uLmFwcGx5KHRoaXMuX2RhdGFMYXllciwgYXJndW1lbnRzKTtcbiAgfSxcblxuICBvZmY6IGZ1bmN0aW9uICgpIHtcbiAgICBVdGZHcmlkLnByb3RvdHlwZS5vZmYuYXBwbHkodGhpcy5fZGF0YUxheWVyLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE92ZXJyaWRlIHRoZXNlIG1ldGhvZHMgaW5oZXJpdGVkIGZyb20gTGF5ZXJHcm91cFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgTC5MYXllckdyb3VwLnByb3RvdHlwZS5vbkFkZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgICAgIG1hcC5nZXRQYW5lcygpLnBvcHVwUGFuZS5hcHBlbmRDaGlsZCh0aGlzLl90b29sdGlwKTtcbiAgICB9XG4gIH0sXG5cbiAgb25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICBMLkxheWVyR3JvdXAucHJvdG90eXBlLm9uUmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLl90b29sdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuX3Rvb2x0aXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl90b29sdGlwKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gU3VwcHJlc3MgdGhlc2UgbWV0aG9kcyBpbmhlcml0ZWQgZnJvbSBMYXllckdyb3VwXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgYWRkTGF5ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBMLkxheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7Y29uc29sZS5sb2coJ01vdXNlT3ZlckxheWVyOjphZGRMYXllciAtIEltbXV0YWJsZSBvYmplY3QnKTt9XG4gICAgICBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgfSxcbiAgcmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBMLkxheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7Y29uc29sZS5sb2coJ01vdXNlT3ZlckxheWVyOjpyZW1vdmVMYXllciAtIEltbXV0YWJsZSBvYmplY3QnKTt9XG4gICAgICBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgfSxcbiAgY2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBMLkxheWVyR3JvdXAucHJvdG90eXBlLmNsZWFyTGF5ZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7Y29uc29sZS5sb2coJ01vdXNlT3ZlckxheWVyOjpjbGVhckxheWVycyAtIEltbXV0YWJsZSBvYmplY3QnKTt9XG4gICAgICBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgfSxcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBdXRvIGhvdmVyIHRvb2x0aXAgaGVscGVyIG1ldGhvZHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBfb25Nb3VzZU92ZXI6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAvLyBVcGRhdGUgdGV4dFxuICAgIHRoaXMuX3Rvb2x0aXAuaW5uZXJIVE1MID0gTC5VdGlsLnRlbXBsYXRlKHRoaXMuX3RpcHRleHQsIGV2dC5kYXRhKTtcblxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvblxuICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl90b29sdGlwLCB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFxuICAgICAgICBldnQubGF0bG5nKSk7XG5cbiAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgdGhpcy5fdG9vbHRpcC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfSxcblxuICBfb25Nb3VzZU91dDogZnVuY3Rpb24gKCkge1xuICAgIC8vIEhpZGUgdGhlIHRvb2x0aXBcbiAgICB0aGlzLl90b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgfVxufSk7XG5cblxuTC5tb3VzZU92ZXJMYXllciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgTC5Nb3VzZU92ZXJMYXllcihvcHRpb25zKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMLm1vdXNlT3ZlckxheWVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUaWxlUHJvdmlkZXIgPSByZXF1aXJlKCdsZWFmbGV0L2xheWVyL1RpbGVQcm92aWRlcicpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxudmFyIF9ERUZBVUxUUyxcbiAgICBfRVNSSSxcbiAgICBfTUFQUVVFU1QsXG4gICAgX1BST1ZJREVSX0lORk87XG5cbl9FU1JJID0gJ2VzcmknO1xuX01BUFFVRVNUID0gJ21hcHF1ZXN0Jztcbl9QUk9WSURFUl9JTkZPID0ge307XG5cbl9ERUZBVUxUUyA9IHtcbiAgcHJvdmlkZXI6IF9FU1JJXG59O1xuXG5fUFJPVklERVJfSU5GT1tfRVNSSV0gPSB7XG4gIHVybDogJ2h0dHBzOi8ve3N9LmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvJyArXG4gICAgICAnV29ybGRfSW1hZ2VyeS9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fScsXG4gIG9wdGlvbnM6IHtcbiAgICBzdWJkb21haW5zOiBbJ3NlcnZlcicsICdzZXJ2aWNlcyddLFxuICAgIGF0dHJpYnV0aW9uOiAnVGlsZXMgJmNvcHk7IEVzcmkgJm1kYXNoOyBTb3VyY2U6IEVzcmksIGktY3ViZWQsIFVTREEsICcgK1xuICAgICAgICAnVVNHUywgQUVYLCBHZW9FeWUsIEdldG1hcHBpbmcsIEFlcm9ncmlkLCBJR04sIElHUCwgVVBSLUVHUCwgYW5kIHRoZSAnICtcbiAgICAgICAgJ0dJUyBVc2VyIENvbW11bml0eSdcbiAgfVxufTtcblxuX1BST1ZJREVSX0lORk9bX01BUFFVRVNUXSA9IHtcbiAgdXJsOiAnaHR0cHM6Ly9vdGlsZXtzfS1zLm1xY2RuLmNvbS90aWxlcy8xLjAuMC9zYXQve3p9L3t4fS97eX0uanBnJyxcbiAgb3B0aW9uczoge1xuICAgIHN1YmRvbWFpbnM6ICcxMjM0JyxcbiAgICBhdHRyaWJ1dGlvbjogJ0RhdGEsIGltYWdlcnkgYW5kIG1hcCBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSBNYXBRdWVzdCwnICtcbiAgICAgICAgJyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4nICtcbiAgICAgICAgJyBhbmQgY29udHJpYnV0b3JzLCcgK1xuICAgICAgICAnIDxhIGhyZWY9XCJodHRwczovL3dpa2kub3BlbnN0cmVldG1hcC5vcmcvd2lraS9MZWdhbF9GQVEjM2EuJyArXG4gICAgICAgICdfSV93b3VsZF9saWtlX3RvX3VzZV9PcGVuU3RyZWV0TWFwX21hcHMuJyArXG4gICAgICAgICdfSG93X3Nob3VsZF9JX2NyZWRpdF95b3UuM0ZcIj4nICtcbiAgICAgICAgJ09EYkw8L2E+J1xuICB9XG59O1xuXG5cbi8qKlxuKiBGYWN0b3J5IGZvciBTYXRlbGxpdGUgYmFzZSBsYXllci5cbiovXG52YXIgU2F0ZWxsaXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gVGlsZVByb3ZpZGVyLmNyZWF0ZShcbiAgICAgIF9QUk9WSURFUl9JTkZPLFxuICAgICAgVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucylcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFRpbGVQcm92aWRlci5jcmVhdGUoXG4gICAgICBfUFJPVklERVJfSU5GTyxcbiAgICAgIF9ERUZBVUxUU1xuICAgICk7XG4gIH1cbn07XG5cblxuU2F0ZWxsaXRlLkVTUkkgPSBfRVNSSTtcblNhdGVsbGl0ZS5NQVBRVUVTVCA9IF9NQVBRVUVTVDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNhdGVsbGl0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVGlsZVByb3ZpZGVyID0gcmVxdWlyZSgnbGVhZmxldC9sYXllci9UaWxlUHJvdmlkZXInKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ERUZBVUxUUyxcbiAgICBfRVNSSSxcbiAgICBfTUFQUVVFU1QsXG4gICAgX1BST1ZJREVSX0lORk87XG5cblxuX0VTUkkgPSAnZXNyaSc7XG5fTUFQUVVFU1QgPSAnbWFwcXVlc3QnO1xuX1BST1ZJREVSX0lORk8gPSB7fTtcblxuX0RFRkFVTFRTID0ge1xuICBwcm92aWRlcjogX0VTUklcbn07XG5cbl9QUk9WSURFUl9JTkZPW19FU1JJXSA9IHtcbiAgdXJsOiAnaHR0cHM6Ly97c30uYXJjZ2lzb25saW5lLmNvbS9BcmNHSVMvcmVzdC9zZXJ2aWNlcy8nICtcbiAgICAgICdXb3JsZF9TdHJlZXRfTWFwL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9JyxcbiAgb3B0aW9uczoge1xuICAgIHN1YmRvbWFpbnM6IFsnc2VydmVyJywgJ3NlcnZpY2VzJ10sXG4gICAgYXR0cmlidXRpb246ICdUaWxlcyAmY29weTsgRXNyaSAmbWRhc2g7IEVzcmksIERlTG9ybWUsIE5BVlRFUSwgVG9tVG9tLCAnICtcbiAgICAgICAgJ0ludGVybWFwLCBpUEMsIFVTR1MsIEZBTywgTlBTLCBOUkNBTiwgR2VvQmFzZSwgS2FkYXN0ZXIgTkwsICcgK1xuICAgICAgICAnT3JkbmFuY2UgU3VydmV5LCBFc3JpIEphcGFuLCBNRVRJLCBFc3JpIENoaW5hIChIb25nIEtvbmcpLCBhbmQgdGhlICcgK1xuICAgICAgICAnR0lTIFVzZXIgQ29tbXVuaXR5J1xuICB9XG59O1xuXG5fUFJPVklERVJfSU5GT1tfTUFQUVVFU1RdID0ge1xuICB1cmw6ICdodHRwczovL290aWxle3N9Lm1xY2RuLmNvbS90aWxlcy8xLjAuMC9vc20ve3p9L3t4fS97eX0uanBnJyxcbiAgb3B0aW9uczoge1xuICAgIHN1YmRvbWFpbnM6ICcxMjM0JyxcbiAgICBhdHRyaWJ1dGlvbjogJ0RhdGEsIGltYWdlcnkgYW5kIG1hcCBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSBNYXBRdWVzdCwnICtcbiAgICAgICAgJyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4nICtcbiAgICAgICAgJyBhbmQgY29udHJpYnV0b3JzLCcgK1xuICAgICAgICAnIDxhIGhyZWY9XCJodHRwczovL3dpa2kub3BlbnN0cmVldG1hcC5vcmcvd2lraS8nICtcbiAgICAgICAgJ0xlZ2FsX0ZBUSMzYS5fSV93b3VsZF9saWtlX3RvX3VzZV9PcGVuU3RyZWV0TWFwX21hcHMuJyArXG4gICAgICAgICdfSG93X3Nob3VsZF9JX2NyZWRpdF95b3UuM0ZcIj4nICtcbiAgICAgICAgJ09EYkw8L2E+J1xuICB9XG59O1xuXG5cbi8qKlxuKiBGYWN0b3J5IGZvciBTdHJlZXQgYmFzZSBsYXllci5cbiovXG52YXIgU3RyZWV0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gVGlsZVByb3ZpZGVyLmNyZWF0ZShcbiAgICAgIF9QUk9WSURFUl9JTkZPLFxuICAgICAgVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucylcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFRpbGVQcm92aWRlci5jcmVhdGUoXG4gICAgICBfUFJPVklERVJfSU5GTyxcbiAgICAgIF9ERUZBVUxUU1xuICAgICk7XG4gIH1cbn07XG5cblxuU3RyZWV0LkVTUkkgPSBfRVNSSTtcblN0cmVldC5NQVBRVUVTVCA9IF9NQVBRVUVTVDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVldDtcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIF9QTEFURVNfVVJMID0gJ2h0dHBzOi8vZWFydGhxdWFrZS51c2dzLmdvdi9iYXNlbWFwL3RpbGVzL3BsYXRlcyc7XG5cblxudmFyIFRlY3RvbmljUGxhdGVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgcmV0dXJuIEwudGlsZUxheWVyKF9QTEFURVNfVVJMICsgJy97en0ve3h9L3t5fS5wbmcnLCBvcHRpb25zKTtcbn07XG5cblxuTC50ZWN0b25pY1BsYXRlcyA9IFRlY3RvbmljUGxhdGVzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRlY3RvbmljUGxhdGVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUaWxlUHJvdmlkZXIgPSByZXF1aXJlKCdsZWFmbGV0L2xheWVyL1RpbGVQcm92aWRlcicpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0RFRkFVTFRTLFxuICAgIF9FU1JJLFxuICAgIF9OQVRHRU8sXG4gICAgX1BST1ZJREVSX0lORk87XG5cblxuX0VTUkkgPSAnZXNyaSc7XG5fTkFUR0VPID0gJ25hdGdlbyc7XG5fUFJPVklERVJfSU5GTyA9IHt9O1xuXG5fREVGQVVMVFMgPSB7XG4gIHByb3ZpZGVyOiBfRVNSSVxufTtcblxuX1BST1ZJREVSX0lORk9bX0VTUkldID0ge1xuICB1cmw6ICdodHRwczovL3tzfS5hcmNnaXNvbmxpbmUuY29tL0FyY0dJUy9yZXN0L3NlcnZpY2VzLycgK1xuICAgICAgJ1dvcmxkX1RvcG9fTWFwL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9JyxcbiAgb3B0aW9uczoge1xuICAgIHN1YmRvbWFpbnM6IFsnc2VydmVyJywgJ3NlcnZpY2VzJ10sXG4gICAgYXR0cmlidXRpb246ICdUaWxlcyAmY29weTsgRXNyaSAmbWRhc2g7IEVzcmksIERlTG9ybWUsIE5BVlRFUSwgVG9tVG9tLCAnICtcbiAgICAgICAgJ0ludGVybWFwLCBpUEMsIFVTR1MsIEZBTywgTlBTLCBOUkNBTiwgR2VvQmFzZSwgS2FkYXN0ZXIgTkwsICcgK1xuICAgICAgICAnT3JkbmFuY2UgU3VydmV5LCBFc3JpIEphcGFuLCBNRVRJLCBFc3JpIENoaW5hIChIb25nIEtvbmcpLCBhbmQgdGhlICcgK1xuICAgICAgICAnR0lTIFVzZXIgQ29tbXVuaXR5J1xuICB9XG59O1xuXG5fUFJPVklERVJfSU5GT1tfTkFUR0VPXSA9IHtcbiAgdXJsOiAnaHR0cHM6Ly97c30uYXJjZ2lzb25saW5lLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy8nICtcbiAgICAgICdOYXRHZW9fV29ybGRfTWFwL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9JyxcbiAgb3B0aW9uczoge1xuICAgIHN1YmRvbWFpbnM6IFsnc2VydmVyJywgJ3NlcnZpY2VzJ10sXG4gICAgYXR0cmlidXRpb246ICdDb250ZW50IG1heSBub3QgcmVmbGVjdCBOYXRpb25hbCBHZW9ncmFwaGljXFwncyAnICtcbiAgICAgICAgICAnY3VycmVudCBtYXAgcG9saWN5LiBTb3VyY2VzOiBOYXRpb25hbCBHZW9ncmFwaGljLCBFc3JpLCAnICtcbiAgICAgICAgICAnRGVMb3JtZSwgSEVSRSwgVU5FUC1XQ01DLCBVU0dTLCBOQVNBLCBFU0EsIE1FVEksIE5SQ0FOLCAnICtcbiAgICAgICAgICAnR0VCQ08sIE5PQUEsIGluY3JlbWVudCBQIENvcnAuJ1xuICB9XG59O1xuXG5cblxuLyoqXG4gKiBGYWN0b3J5IGZvciBUZXJyYWluIGJhc2UgbGF5ZXIuXG4gKi9cbnZhciBUZXJyYWluID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gVGlsZVByb3ZpZGVyLmNyZWF0ZShcbiAgICAgIF9QUk9WSURFUl9JTkZPLFxuICAgICAgVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucylcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFRpbGVQcm92aWRlci5jcmVhdGUoXG4gICAgICBfUFJPVklERVJfSU5GTyxcbiAgICAgIF9ERUZBVUxUU1xuICAgICk7XG4gIH1cbn07XG5cblxuVGVycmFpbi5FU1JJID0gX0VTUkk7XG5UZXJyYWluLk5BVEdFTyA9IF9OQVRHRU87XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUZXJyYWluO1xuIiwiLyogZ2xvYmFsIEwgKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBhIHN0YXRpYyBidWlsZGVyIHRvIGNyZWF0ZSBUaWxlTGF5ZXJzIGJhc2VkIG9uIHByb3ZpZGVyXG4gKiBpbmZvLiBGb3IgY2xhcml0eSwgc2V2ZXJhbCBcInR5cGVzXCIgb2YgbWFwcyAoXCJHcmF5c2NhbGVcIiwgXCJUZXJyYWluXCIsIGV0Yy4uLilcbiAqIGhhdmUgdGhlaXIgb3duIHN1YmNsYXNzIHdoaWNoIGVzc2VudGlhbGx5IGp1c3QgY2FsbHMgdGhlIGNyZWF0ZSBtZXRob2RcbiAqIGltcGxlbWVudGVkIGhlcmUuXG4gKlxuICovXG52YXIgVGlsZVByb3ZpZGVyID0ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBMLlRpbGVMYXllciBiYXNlZCBvbiBhIG1hcCBvZiBwcm92aWRlciBpbmZvIGFuZFxuICAgKiB1c2VyLXNwZWNpZmllZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gaW5mb01hcCB7T2JqZWN0fVxuICAgKiAgICAgQSBtYXAgb2YgcHJvdmlkZXIgaW5mbyBrZXllZCBieSBwcm92aWRlciBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICAgKiAgICAgVXNlci1zcGVjaWZpZWQgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBhbiBMLnRpbGVMYXllci4gTXVzdCBhbHNvXG4gICAqICAgICBpbmNsdWRlIGEgXCJwcm92aWRlclwiIGtleSB3aG9zZSB2YWx1ZSBwb2ludHMgdG8gYSBrbm93biBwcm92aWRlciBuYW1lXG4gICAqICAgICBpbiB0aGUgaW5mb01hcC5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqICAgICBJZiB0aGUgaW5mb01hcCBkb2VzIG5vdCBjb250YWluIHRoZSB1c2VyLXNwZWNpZmllZCBvcHRpb25zLnByb3ZpZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtMLlRpbGVMYXllcn1cbiAgICogICAgIEEgbmV3IEwuVGlsZUxheWVyIGJhc2VkIG9uIHRoZSBjb25maWd1cmVkIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgY3JlYXRlOiBmdW5jdGlvbiAoaW5mb01hcCwgb3B0aW9ucykge1xuICAgIHZhciBsYXllck9wdGlvbnMsXG4gICAgICAgIGxheWVyVXJsLFxuICAgICAgICBwcm92aWRlcjtcblxuICAgIHByb3ZpZGVyID0gaW5mb01hcFtvcHRpb25zLnByb3ZpZGVyXTtcbiAgICBsYXllclVybCA9IHByb3ZpZGVyLnVybDtcbiAgICBsYXllck9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgcHJvdmlkZXIub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAobGF5ZXJPcHRpb25zLmhhc093blByb3BlcnR5KCdwcm92aWRlcicpKSB7XG4gICAgICBkZWxldGUgbGF5ZXJPcHRpb25zLnByb3ZpZGVyO1xuICAgIH1cblxuICAgIHJldHVybiBMLnRpbGVMYXllcihsYXllclVybCwgbGF5ZXJPcHRpb25zKTtcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVQcm92aWRlcjtcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIE1vdXNlT3ZlckxheWVyID0gcmVxdWlyZSgnbGVhZmxldC9sYXllci9Nb3VzZU92ZXJMYXllcicpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0ZBVUxUU19VUkwgPSAnaHR0cHM6Ly9lYXJ0aHF1YWtlLnVzZ3MuZ292L2Jhc2VtYXAvdGlsZXMvZmF1bHRzJztcblxuXG52YXIgVXNGYXVsdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7XG4gICAgdGlsZVVybDogX0ZBVUxUU19VUkwgKyAnL3t6fS97eH0ve3l9LnBuZycsXG4gICAgZGF0YVVybDogX0ZBVUxUU19VUkwgKyAnL3t6fS97eH0ve3l9LmdyaWQuanNvbj9jYWxsYmFjaz17Y2J9JyxcbiAgICB0aXB0ZXh0OiAne05BTUV9J1xuICB9LCBvcHRpb25zKTtcblxuICByZXR1cm4gTW91c2VPdmVyTGF5ZXIob3B0aW9ucyk7XG59O1xuXG5cbkwudXNGYXVsdCA9IFVzRmF1bHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gVXNGYXVsdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIHRvIGdldCB0aGUgY29uZmlkZW5jZSBmb3IgYSBsb2NhdGlvbi5cbiAqIENvbmZpZGVuY2UgZm9yIGEgbG9jYXRpb24gaXMgMSB0byA1LlxuICovXG52YXIgQ29uZmlkZW5jZUNhbGN1bGF0b3IgPSB7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgQ29uZmlkZW5jZSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLiBMYXRpdHVkZSBhbmQgbG9uZ2l0dWRlXG4gICAqIG11c3QgYmUgc3RyaW5ncyB0byBrZWVwIGFjY3VyYWN5LlxuICAgKiBDb25maWRlbmNlIGlzIGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgZGlnaXRzIHBhc3QgdGhlIGRlY2ltYWwuXG4gICAqXG4gICAqIEBwYXJhbXMgbGF0aXRpdHVkZSB7U3RyaW5nfVxuICAgKiBAcGFyYW1zIGxvbmdpdHVkZSB7U3RyaW5nfVxuICAgKlxuICAgKi9cbiAgY29tcHV0ZUZyb21Db29yZGluYXRlczogZnVuY3Rpb24gKGxhdGl0dWRlLCBsb25naXR1ZGUpIHtcbiAgICBpZiAodHlwZW9mIGxhdGl0dWRlICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgbG9uZ2l0dWRlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIENvbmZpZGVuY2VDYWxjdWxhdG9yLk5PVF9DT01QVVRFRDtcbiAgICB9XG5cbiAgICB2YXIgbGF0aXR1ZGVQaWVjZXMgPSBsYXRpdHVkZS5zcGxpdCgnLicpLFxuICAgICAgICBsb25naXR1ZGVQaWVjZXMgPSBsb25naXR1ZGUuc3BsaXQoJy4nKSxcbiAgICAgICAgbWluRGVjaW1hbHM7XG5cbiAgICBpZiAobGF0aXR1ZGVQaWVjZXMubGVuZ3RoID09PSAxIHx8IGxvbmdpdHVkZVBpZWNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIG1pbkRlY2ltYWxzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluRGVjaW1hbHMgPSBNYXRoLm1pbihsYXRpdHVkZVBpZWNlc1sxXS5sZW5ndGgsXG4gICAgICAgICAgbG9uZ2l0dWRlUGllY2VzWzFdLmxlbmd0aCk7XG4gICAgfVxuXG5cbiAgICBpZiAobWluRGVjaW1hbHMgPj0gNSkge1xuICAgICAgcmV0dXJuIENvbmZpZGVuY2VDYWxjdWxhdG9yLkhJR0hfQ09ORklERU5DRTtcbiAgICB9IGVsc2UgaWYgKG1pbkRlY2ltYWxzID49IDQpIHtcbiAgICAgIHJldHVybiBDb25maWRlbmNlQ2FsY3VsYXRvci5BQk9WRV9BVkVSQUdFX0NPTkZJREVOQ0U7XG4gICAgfSBlbHNlIGlmIChtaW5EZWNpbWFscyA+PSAzKSB7XG4gICAgICByZXR1cm4gQ29uZmlkZW5jZUNhbGN1bGF0b3IuQVZFUkFHRV9DT05GSURFTkNFO1xuICAgIH0gZWxzZSBpZiAobWluRGVjaW1hbHMgPj0gMikge1xuICAgICAgcmV0dXJuIENvbmZpZGVuY2VDYWxjdWxhdG9yLkJFTE9XX0FWRVJBR0VfQ09ORklERU5DRTtcbiAgICB9IGVsc2UgaWYgKG1pbkRlY2ltYWxzID49IDEpIHtcbiAgICAgIHJldHVybiBDb25maWRlbmNlQ2FsY3VsYXRvci5MT1dfQ09ORklERU5DRTtcbiAgICB9IGVsc2UgaWYgKG1pbkRlY2ltYWxzID49IDApIHtcbiAgICAgIHJldHVybiBDb25maWRlbmNlQ2FsY3VsYXRvci5OT19DT05GSURFTkNFO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQ29uZmlkZW5jZUNhbGN1bGF0b3IuTk9UX0NPTVBVVEVEO1xuICAgIH1cblxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlIENvbmZpZGVuY2UgZ2l2ZW4gYSB6b29tIGxldmVsLlxuICAgKiBAcGFyYW1zIHpvb20ge251bWJlcn0gaW5kaWNhdGVzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXG4gICAqL1xuICBjb21wdXRlRnJvbVBvaW50OiBmdW5jdGlvbiAoem9vbSkge1xuICAgIGlmICh6b29tID4gMTYpIHtcbiAgICAgIHJldHVybiBDb25maWRlbmNlQ2FsY3VsYXRvci5ISUdIX0NPTkZJREVOQ0U7XG4gICAgfSBlbHNlIGlmICh6b29tID4gMTIpIHtcbiAgICAgIHJldHVybiBDb25maWRlbmNlQ2FsY3VsYXRvci5BQk9WRV9BVkVSQUdFX0NPTkZJREVOQ0U7XG4gICAgfSBlbHNlIGlmICh6b29tID4gOCkge1xuICAgICAgcmV0dXJuIENvbmZpZGVuY2VDYWxjdWxhdG9yLkFWRVJBR0VfQ09ORklERU5DRTtcbiAgICB9IGVsc2UgaWYgKHpvb20gPiA0KSB7XG4gICAgICByZXR1cm4gQ29uZmlkZW5jZUNhbGN1bGF0b3IuQkVMT1dfQVZFUkFHRV9DT05GSURFTkNFO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQ29uZmlkZW5jZUNhbGN1bGF0b3IuTE9XX0NPTkZJREVOQ0U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiByZXR1cm5zIHJvdW5kZWQgdmFsdWUgYmFzZWQgb24gY29uZmlkZW5jZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nIHwgbnVtYmVyfSB2YWx1ZVxuICAgKiAgICAgICAgICAgdmFsdWUgdG8gYmUgcm91bmRlZFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbmZpZGVuY2VcbiAgICogICAgICAgICAgIGNvbmZpZGVuY2UgdmFsdWVcbiAgICogQHJldHVybiB7bnVtYmVyfSByb3VuZGVkIHZhbHVlXG4gICAqXG4gICAqL1xuICByb3VuZExvY2F0aW9uOiBmdW5jdGlvbiAodmFsdWUsIGNvbmZpZGVuY2UpIHtcbiAgICB2YXIgcm91bmRlZCxcbiAgICAgICAgZGVjaW1hbHMgPSBjb25maWRlbmNlO1xuXG4gICAgaWYgKGNvbmZpZGVuY2UgPT09IENvbmZpZGVuY2VDYWxjdWxhdG9yLk5PVF9DT01QVVRFRCkge1xuICAgICAgZGVjaW1hbHMgPSAwO1xuICAgIH1cblxuICAgIHJvdW5kZWQgPSBwYXJzZUZsb2F0KHZhbHVlKS50b0ZpeGVkKGRlY2ltYWxzKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChyb3VuZGVkKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZSB6b29tIGxldmVsIGdpdmVuIGEgY29uZmlkZW5jZS5cbiAgICogQHBhcmFtcyBjb25maWRlbmNlIHtudW1iZXJ9IGluZGljYXRlcyB0aGUgY29uZmlkZW5jZSBsZXZlbFxuICAgKi9cbiAgY29tcHV0ZVpvb21Gcm9tQ29uZmlkZW5jZTogZnVuY3Rpb24gKGNvbmZpZGVuY2UpIHtcbiAgICBpZiAoY29uZmlkZW5jZSA9PT0gQ29uZmlkZW5jZUNhbGN1bGF0b3IuSElHSF9DT05GSURFTkNFKSB7XG4gICAgICByZXR1cm4gMTY7XG4gICAgfSBlbHNlIGlmKCBjb25maWRlbmNlID09PSBDb25maWRlbmNlQ2FsY3VsYXRvci5BQk9WRV9BVkVSQUdFX0NPTkZJREVOQ0UpIHtcbiAgICAgIHJldHVybiAxMztcbiAgICB9IGVsc2UgaWYoIGNvbmZpZGVuY2UgPT09IENvbmZpZGVuY2VDYWxjdWxhdG9yLkFWRVJBR0VfQ09ORklERU5DRSkge1xuICAgICAgcmV0dXJuIDk7XG4gICAgfSBlbHNlIGlmKCBjb25maWRlbmNlID09PSBDb25maWRlbmNlQ2FsY3VsYXRvci5CRUxPV19BVkVSQUdFX0NPTkZJREVOQ0UpIHtcbiAgICAgIHJldHVybiA1O1xuICAgIH0gZWxzZSBpZiggY29uZmlkZW5jZSA9PT0gQ29uZmlkZW5jZUNhbGN1bGF0b3IuTE9XX0NPTkZJREVOQ0UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcHV0ZVpvb21Gcm9tR2VvY29kZTogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHZhciBjb25maWRlbmNlID0gdGhpcy5jb21wdXRlRnJvbUdlb2NvZGUocmVzdWx0KTtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlWm9vbUZyb21Db25maWRlbmNlKGNvbmZpZGVuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlIENvbmZpZGVuY2UgZ2l2ZW4gYSBhY2N1cmFjeSBpbiBtZXRlcnMuXG4gICAqIHVzZWQgYnkgR2VvTG9jYXRlLlxuICAgKiBAcGFyYW1zIGFjY3VyYWN5IHtudW1iZXJ9IGluZGljYXRlcyB0aGUgYWNjdXJhY3kgaW4gbWV0ZXJzIGF0IDk1JVxuICAgKiAgICAgICAgIGNvbmZpZGVuY2UuXG4gICAqL1xuICBjb21wdXRlRnJvbUdlb2xvY2F0ZTogZnVuY3Rpb24gKGFjY3VyYWN5KSB7XG4gICAgaWYgKGFjY3VyYWN5ID4gMTAwMDAwKSB7XG4gICAgICByZXR1cm4gQ29uZmlkZW5jZUNhbGN1bGF0b3IuTE9XX0NPTkZJREVOQ0U7XG4gICAgfSBlbHNlIGlmIChhY2N1cmFjeSA+IDEwMDAwKSB7XG4gICAgICByZXR1cm4gQ29uZmlkZW5jZUNhbGN1bGF0b3IuQkVMT1dfQVZFUkFHRV9DT05GSURFTkNFO1xuICAgIH0gZWxzZSBpZiAoYWNjdXJhY3kgPiAxMDAwKSB7XG4gICAgICByZXR1cm4gQ29uZmlkZW5jZUNhbGN1bGF0b3IuQVZFUkFHRV9DT05GSURFTkNFO1xuICAgIH0gZWxzZSBpZiAoYWNjdXJhY3kgPiAxMDApIHtcbiAgICAgIHJldHVybiBDb25maWRlbmNlQ2FsY3VsYXRvci5BQk9WRV9BVkVSQUdFX0NPTkZJREVOQ0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBDb25maWRlbmNlQ2FsY3VsYXRvci5ISUdIX0NPTkZJREVOQ0U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlIENvbmZpZGVuY2UgZ2l2ZW4gYSBnZW9jb2RlIHJlc3VsdCBsb2NhdGlvbiB3aXRoIGFuIGV4dGVudC5cbiAgICpcbiAgICogQHBhcmFtcyBnZW9jb2RlTG9jYXRpb24ge29iamVjdH1cbiAgICogICAgICBhbiBlc3JpIHJlc3BvbnNlIHZpYSB0aGUgQXJjR0lTIFJFU1QgQVBJXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmFyY2dpcy5jb20vZW4vZmVhdHVyZXMvZ2VvY29kaW5nL1xuICAgKi9cbiAgY29tcHV0ZUZyb21HZW9jb2RlOiBmdW5jdGlvbiAoZ2VvY29kZUxvY2F0aW9uKSB7XG4gICAgdmFyIGNvbmZpZGVuY2UsXG4gICAgICAgIGV4dGVudCxcbiAgICAgICAgbWF4O1xuXG4gICAgZXh0ZW50ID0gZ2VvY29kZUxvY2F0aW9uLmV4dGVudDtcblxuICAgIC8vIGZpbmQgdGhlIGxhcmdlc3QgZGltZW5zaW9uIG9mIHRoZSBleHRlbnRcbiAgICBpZiAoZXh0ZW50KSB7XG4gICAgICBtYXggPSBNYXRoLm1heChNYXRoLmFicyhleHRlbnQueG1heCAtIGV4dGVudC54bWluKSxcbiAgICAgICAgICBNYXRoLmFicyhleHRlbnQueW1heCAtIGV4dGVudC55bWluKSk7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSBjb25maWRlbmNlIGJhc2VkIG9uIHRoZSBsb2NhdGlvbidzIGV4dGVudFxuICAgICAgaWYgKG1heCA8IDAuMDAxKSB7XG4gICAgICAgIGNvbmZpZGVuY2UgPSBDb25maWRlbmNlQ2FsY3VsYXRvci5ISUdIX0NPTkZJREVOQ0U7XG4gICAgICB9IGVsc2UgaWYgKG1heCA8IDAuMDEpIHtcbiAgICAgICAgY29uZmlkZW5jZSA9IENvbmZpZGVuY2VDYWxjdWxhdG9yLkFCT1ZFX0FWRVJBR0VfQ09ORklERU5DRTtcbiAgICAgIH0gZWxzZSBpZiAobWF4IDwgMC4xKSB7XG4gICAgICAgIGNvbmZpZGVuY2UgPSBDb25maWRlbmNlQ2FsY3VsYXRvci5BVkVSQUdFX0NPTkZJREVOQ0U7XG4gICAgICB9IGVsc2UgaWYgKG1heCA8IDEpIHtcbiAgICAgICAgY29uZmlkZW5jZSA9IENvbmZpZGVuY2VDYWxjdWxhdG9yLkJFTE9XX0FWRVJBR0VfQ09ORklERU5DRTtcbiAgICAgIH0gZWxzZSBpZiAobWF4IDwgMTApIHtcbiAgICAgICAgY29uZmlkZW5jZSA9IENvbmZpZGVuY2VDYWxjdWxhdG9yLkxPV19DT05GSURFTkNFO1xuICAgICAgfSBlbHNlIGlmIChtYXggPj0gMTApIHtcbiAgICAgICAgY29uZmlkZW5jZSA9IENvbmZpZGVuY2VDYWxjdWxhdG9yLk5PX0NPTkZJREVOQ0U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoY29uZmlkZW5jZSA9PT0gQ29uZmlkZW5jZUNhbGN1bGF0b3IuSElHSF9DT05GSURFTkNFIHx8XG4gICAgICAgIGNvbmZpZGVuY2UgPT09IENvbmZpZGVuY2VDYWxjdWxhdG9yLkFCT1ZFX0FWRVJBR0VfQ09ORklERU5DRSB8fFxuICAgICAgICBjb25maWRlbmNlID09PSBDb25maWRlbmNlQ2FsY3VsYXRvci5BVkVSQUdFX0NPTkZJREVOQ0UgfHxcbiAgICAgICAgY29uZmlkZW5jZSA9PT0gQ29uZmlkZW5jZUNhbGN1bGF0b3IuQkVMT1dfQVZFUkFHRV9DT05GSURFTkNFIHx8XG4gICAgICAgIGNvbmZpZGVuY2UgPT09IENvbmZpZGVuY2VDYWxjdWxhdG9yLkxPV19DT05GSURFTkNFIHx8XG4gICAgICAgIGNvbmZpZGVuY2UgPT09IENvbmZpZGVuY2VDYWxjdWxhdG9yLk5PX0NPTkZJREVOQ0UpKSB7XG4gICAgICAvLyBjb25maWRlbmNlIGRpZCBub3QgbWF0Y2ggYW55IHZhbHVlLCBiYWlsXG4gICAgICBjb25maWRlbmNlID0gQ29uZmlkZW5jZUNhbGN1bGF0b3IuTk9UX0NPTVBVVEVEO1xuICAgIH1cblxuICAgIHJldHVybiBjb25maWRlbmNlO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWMgU3RhdGljIFZhcmlhYmxlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKiogQ29uc3RhbnQgdXNlZCB0byBpbmRpY2F0ZSBoaWdoIGRlZ3JlZSBvZiBjb25maWRlbmNlLiAqL1xuQ29uZmlkZW5jZUNhbGN1bGF0b3IuSElHSF9DT05GSURFTkNFID0gNTtcblxuLyoqIENvbnN0YW50IHVzZWQgdG8gaW5kaWNhdGUgYWJvdmUgYXZlcmFnZSBjb25maWRlbmNlLiAqL1xuQ29uZmlkZW5jZUNhbGN1bGF0b3IuQUJPVkVfQVZFUkFHRV9DT05GSURFTkNFID0gNDtcblxuLyoqIENvbnN0YW50IHVzZWQgdG8gaW5kaWNhdGUgbW9kZXJhdGUgZGVncmVlIG9mIGNvbmZpZGVuY2UuICovXG5Db25maWRlbmNlQ2FsY3VsYXRvci5BVkVSQUdFX0NPTkZJREVOQ0UgPSAzO1xuXG4vKiogQ29uc3RhbnQgdXNlZCB0byBpbmRpY2F0ZSBiZWxvdyBhdmVyYWdlIGNvbmZpZGVuY2UuICovXG5Db25maWRlbmNlQ2FsY3VsYXRvci5CRUxPV19BVkVSQUdFX0NPTkZJREVOQ0UgPSAyO1xuXG4vKiogQ29uc3RhbnQgdXNlZCB0byBpbmRpY2F0ZSBsb3cgZGVncmVlIG9mIGNvbmZpZGVuY2UuICovXG5Db25maWRlbmNlQ2FsY3VsYXRvci5MT1dfQ09ORklERU5DRSA9IDE7XG5cbi8qKiBDb25zdGFudCB1c2VkIHRvIGluZGljYXRlIHZlcnkgbG93IGRlZ3JlZSBvZiBjb25maWRlbmNlLiAqL1xuQ29uZmlkZW5jZUNhbGN1bGF0b3IuTk9fQ09ORklERU5DRSA9IDA7XG5cbi8qKlxuICogQ29uc3RhbnQgdXNlZCB0byBpbmRpY2F0ZSBjb25maWRlbmNlIHdhcyBub3QgY29tcHV0ZWQgb3IgYW4gZXJyb3Igb2NjdXJyZWRcbiAqIHdoaWxlIGNvbXB1dGluZyB0aGUgY29uZmlkZW5jZVxuICovXG5Db25maWRlbmNlQ2FsY3VsYXRvci5OT1RfQ09NUFVURUQgPSAtMTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbmZpZGVuY2VDYWxjdWxhdG9yO1xuIiwiLyogZ2xvYmFsIEwgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbmZpZGVuY2VDYWxjdWxhdG9yID0gcmVxdWlyZSgnbG9jYXRpb252aWV3L0NvbmZpZGVuY2VDYWxjdWxhdG9yJyk7XG5cblxudmFyIENMQVNTX05BTUUgPSAnbG9jYXRpb24tY29vcmRpbmF0ZS1jb250cm9sJyxcbiAgICBDTEFTU19FTkFCTEVEID0gJ2xvY2F0aW9uLWNvbnRyb2wtZW5hYmxlZCcsXG4gICAgQ0xBU1NfSU5QVVQgPSAnZXhwYW5kYWJsZScsXG4gICAgQ0xBU1NfU1VCTUlUID0gJ2xvY2F0aW9uLWNvbnRyb2wtc3VibWl0JztcblxudmFyIE1FVEhPRCA9ICdjb29yZGluYXRlJztcblxudmFyIERFRkFVTFRTID0ge1xuICAnbWV0aG9kJzogTUVUSE9ELFxuICAncG9zaXRpb24nOiAndG9wbGVmdCcsXG4gICdkZWZhdWx0RW5hYmxlZCc6IGZhbHNlLFxuICAnaWNvbkNsYXNzJzogJ2xvY2F0aW9uLWNvbnRyb2wtaWNvbicsXG4gICdoZWxwVGV4dCc6ICdFbnRlciBDb29yZGluYXRlcycsXG4gICdpbmZvVGV4dCc6ICc8Yj5FbnRlciBjb29yZGluYXRlczwvYj4sIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuJ1xufTtcblxudmFyIENvb3JkaW5hdGVDb250cm9sID0gIEwuQ29udHJvbC5leHRlbmQoe1xuICBpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBMLlV0aWwuZXh0ZW5kKHt9LCBERUZBVUxUUywgb3B0aW9ucykpO1xuICB9LFxuXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHN0b3AgPSBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICB0b2dnbGUsXG4gICAgICAgIGNvbnRyb2w7XG5cbiAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbG9jYXRpb24tY29udHJvbCcpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUUpO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBbXG4gICAgICAnPGEgY2xhc3M9XCInLCBvcHRpb25zLmljb25DbGFzcywgJ1wiPjwvYT4nLFxuICAgICAgJzxzcGFuIGNsYXNzPVwiaGVscFwiPicsIG9wdGlvbnMuaGVscFRleHQsICc8L3NwYW4+JyxcbiAgICAgICc8ZGl2IGNsYXNzPVwiJywgQ0xBU1NfSU5QVVQsICdcIj4nLFxuICAgICAgICAnPGlucHV0IG5hbWU9XCJsYXRpdHVkZVwiIHRpdGxlPVwibGF0aXR1ZGVcIiBjbGFzcz1cImxhdGl0dWRlXCIgJyxcbiAgICAgICAgICAgICdwbGFjZWhvbGRlcj1cIkxhdGl0dWRlXCIgLz4nLFxuICAgICAgICAnPGlucHV0IG5hbWU9XCJsb25naXR1ZGVcIiB0aXRsZT1cImxvbmdpdHVkZVwiIGNsYXNzPVwibG9uZ2l0dWRlXCIgJyxcbiAgICAgICAgICAgICdwbGFjZWhvbGRlcj1cIkxvbmdpdHVkZVwiIC8+JyxcbiAgICAgICAgJzxidXR0b24gdHlwZT1cInNlYXJjaFwiIGNsYXNzPVwiJywgQ0xBU1NfU1VCTUlULCAnXCI+U2VhcmNoPC9idXR0b24+JyxcbiAgICAgICc8L2Rpdj4nXG4gICAgXS5qb2luKCcnKTtcblxuICAgIHRvZ2dsZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhJyk7XG4gICAgY29udHJvbCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuJyArIENMQVNTX0lOUFVUKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLl90b2dnbGUgPSB0b2dnbGU7XG4gICAgdGhpcy5fY29udHJvbCA9IGNvbnRyb2w7XG4gICAgdGhpcy5fbGF0aXR1ZGUgPSBjb250cm9sLnF1ZXJ5U2VsZWN0b3IoJy5sYXRpdHVkZScpO1xuICAgIHRoaXMuX2xvbmdpdHVkZSA9IGNvbnRyb2wucXVlcnlTZWxlY3RvcignLmxvbmdpdHVkZScpO1xuICAgIHRoaXMuX3N1Ym1pdCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuJyArIENMQVNTX1NVQk1JVCk7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWZhdWx0RW5hYmxlZCkge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG5cblxuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIodG9nZ2xlLCAnY2xpY2snLCB0aGlzLnRvZ2dsZSwgdGhpcyk7XG4gICAgLy8gQmluZCB0byBhIHN1Ym1pdCBidXR0b24gY2xpY2tcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKHRoaXMuX3N1Ym1pdCwgJ2NsaWNrJywgdGhpcy5fb25TdWJtaXQsIHRoaXMpO1xuICAgIC8vIEJpbmQgZXZlbnQgZm9yIHRoZSBcImVudGVyXCIga2V5XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250cm9sLCAna2V5cHJlc3MnLCB0aGlzLl9vbktleVByZXNzLCB0aGlzKTtcbiAgICAvLyBzdG9wcyBtYXAgZnJvbSB6b29taW5nIG9uIGRvdWJsZSBjbGlja1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnY2xpY2snLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2RibGNsaWNrJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdrZXlkb3duJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdrZXl1cCcsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAna2V5cHJlc3MnLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ21vdXNlZG93bicsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIodGhpcy5fbG9uZ2l0dWRlLCAndG91Y2hzdGFydCcsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIodGhpcy5fbGF0aXR1ZGUsICd0b3VjaHN0YXJ0Jywgc3RvcCk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9LFxuXG4gIHRvZ2dsZTogZnVuY3Rpb24gKCkge1xuICAgIC8vIGlmIG9wdGlvbnMgaXMgbm90IGRlZmluZWQsIHRoZW4gdG9nZ2xlIHRoZSBjb250cm9sXG4gICAgaWYgKEwuRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9jb250YWluZXIsIENMQVNTX0VOQUJMRUQpKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgQ0xBU1NfRU5BQkxFRCk7XG4gICAgdGhpcy5fbGF0aXR1ZGUuZm9jdXMoKTtcbiAgICB0aGlzLmZpcmUoJ2VuYWJsZWQnKTtcbiAgfSxcblxuICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgQ0xBU1NfRU5BQkxFRCk7XG5cbiAgICB0aGlzLmZpcmUoJ2Rpc2FibGVkJyk7XG4gIH0sXG5cbiAgb25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RvcCA9IEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uLFxuICAgICAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG4gICAgICAgIHRvZ2dsZSA9IHRoaXMuX3RvZ2dsZSxcbiAgICAgICAgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG5cbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKHRvZ2dsZSwgJ2NsaWNrJywgdGhpcy50b2dnbGUpO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5fc3VibWl0LCAnY2xpY2snLCB0aGlzLl9vblN1Ym1pdCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250cm9sLCAna2V5cHJlc3MnLCB0aGlzLl9vbktleVByZXNzKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRhaW5lciwgJ2NsaWNrJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250YWluZXIsICdkYmxjbGljaycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGFpbmVyLCAna2V5ZG93bicsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGFpbmVyLCAna2V5dXAnLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRhaW5lciwgJ2tleXByZXNzJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250YWluZXIsICdtb3VzZWRvd24nLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX2xvbmdpdHVkZSwgJ3RvdWNoc3RhcnQnLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX2xhdGl0dWRlLCAndG91Y2hzdGFydCcsIHN0b3ApO1xuXG4gICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICB0aGlzLl9jb250cm9sID0gbnVsbDtcbiAgICB0aGlzLl90b2dnbGUgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5fbGF0aXR1ZGUgPSBudWxsO1xuICAgIHRoaXMuX2xvbmdpdHVkZSA9IG51bGw7XG4gICAgdGhpcy5fc3VibWl0ID0gbnVsbDtcbiAgfSxcblxuICBzZXRMb2NhdGlvbjogZnVuY3Rpb24gKGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvY2F0aW9uID09PSBudWxsKSB7XG4gICAgICAvLyByZXNldCBsb2NhdGlvblxuICAgICAgdGhpcy5fbGF0aXR1ZGUudmFsdWUgPSAnJztcbiAgICAgIHRoaXMuX2xvbmdpdHVkZS52YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgbGF0L2xvbiBpbnB1dHNcbiAgICAgIHRoaXMuX2xhdGl0dWRlLnZhbHVlID0gQ29uZmlkZW5jZUNhbGN1bGF0b3IuXG4gICAgICAgICAgcm91bmRMb2NhdGlvbihsb2NhdGlvbi5sYXRpdHVkZSwgbG9jYXRpb24uY29uZmlkZW5jZSk7XG4gICAgICB0aGlzLl9sb25naXR1ZGUudmFsdWUgPSBDb25maWRlbmNlQ2FsY3VsYXRvci5cbiAgICAgICAgICByb3VuZExvY2F0aW9uKGxvY2F0aW9uLmxvbmdpdHVkZSwgbG9jYXRpb24uY29uZmlkZW5jZSk7XG4gICAgfVxuICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWxlbnQpKSB7XG4gICAgICB0aGlzLmZpcmUoJ2xvY2F0aW9uJywgeydsb2NhdGlvbic6IGxvY2F0aW9ufSk7XG4gICAgfVxuICB9LFxuXG4gIF9vblN1Ym1pdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYXRpdHVkZSA9IHRoaXMuX2xhdGl0dWRlLnZhbHVlLFxuICAgICAgICBsb25naXR1ZGUgPSB0aGlzLl9sb25naXR1ZGUudmFsdWUsXG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZUxvY2F0aW9uKGxhdGl0dWRlLCBsb25naXR1ZGUpO1xuXG4gICAgLy8gZmlyZSBhIGxvY2F0aW9uIGNoYW5nZVxuICAgIHRoaXMuc2V0TG9jYXRpb24obG9jYXRpb24pO1xuICAgIHRoaXMuX2xhdGl0dWRlLmJsdXIoKTtcbiAgICB0aGlzLl9sb25naXR1ZGUuYmx1cigpO1xuICB9LFxuXG4gIF9nZXRDb29yZGluYXRlTG9jYXRpb246IGZ1bmN0aW9uIChsYXRpdHVkZSwgbG9uZ2l0dWRlKSB7XG4gICAgdmFyIGNvbmZpZGVuY2UgPSBDb25maWRlbmNlQ2FsY3VsYXRvci5cbiAgICAgICAgICAgIGNvbXB1dGVGcm9tQ29vcmRpbmF0ZXMobGF0aXR1ZGUsIGxvbmdpdHVkZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgJ3BsYWNlJzogbnVsbCxcbiAgICAgICdsb25naXR1ZGUnOiBwYXJzZUZsb2F0KGxvbmdpdHVkZSksXG4gICAgICAnbGF0aXR1ZGUnOiBwYXJzZUZsb2F0KGxhdGl0dWRlKSxcbiAgICAgICdtZXRob2QnOiBNRVRIT0QsXG4gICAgICAnY29uZmlkZW5jZSc6IGNvbmZpZGVuY2VcbiAgICB9O1xuICB9LFxuXG4gIF9vbktleVByZXNzOiBmdW5jdGlvbiAoa2V5UHJlc3MpIHtcbiAgICBpZihrZXlQcmVzcy5rZXlDb2RlID09PSAxMykge1xuICAgICAgdGhpcy5fb25TdWJtaXQoKTtcbiAgICB9XG4gIH1cblxufSk7XG5cbi8vIGV4cG9zZSB0aGUgY29vcmRpbmF0ZSBjb250cm9sIG1ldGhvZCB0eXBlXG5Db29yZGluYXRlQ29udHJvbC5NRVRIT0QgPSBNRVRIT0Q7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb29yZGluYXRlQ29udHJvbDtcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBHZW9jb2RlciA9IHJlcXVpcmUoJ2xvY2F0aW9udmlldy9HZW9jb2RlcicpO1xuXG5cbnZhciBDTEFTU19OQU1FID0gJ2xvY2F0aW9uLWdlb2NvZGUtY29udHJvbCcsXG4gICAgQ0xBU1NfRU5BQkxFRCA9ICdsb2NhdGlvbi1jb250cm9sLWVuYWJsZWQnLFxuICAgIENMQVNTX0lOUFVUID0gJ2V4cGFuZGFibGUnLFxuICAgIENMQVNTX1NVQk1JVCA9ICdsb2NhdGlvbi1jb250cm9sLXN1Ym1pdCc7XG5cbnZhciBNRVRIT0QgPSAnZ2VvY29kZSc7XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIG1ldGhvZDogTUVUSE9ELFxuICBwb3NpdGlvbjogJ3RvcGxlZnQnLFxuICBkZWZhdWx0TG9jYXRpb246IG51bGwsXG4gIGRlZmF1bHRFbmFibGVkOiBmYWxzZSxcbiAgaWNvbkNsYXNzOiAnbG9jYXRpb24tY29udHJvbC1pY29uJyxcbiAgaGVscFRleHQ6ICdTZWFyY2ggZm9yIEFkZHJlc3MnLFxuICBpbmZvVGV4dDogJzxiPlNlYXJjaDwvYj4gZm9yIGEgbG9jYXRpb24gdXNpbmcgYW4gPGI+YWRkcmVzczwvYj4uJ1xufTtcblxudmFyIEdlb2NvZGVDb250cm9sID0gTC5Db250cm9sLmV4dGVuZCh7XG4gIGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIEwuVXRpbC5leHRlbmQoe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucykpO1xuICAgIHRoaXMuX2dlb2NvZGVyID0gbmV3IEdlb2NvZGVyKCk7XG4gICAgdGhpcy5fZ2VvY29kZVN1Y2Nlc3MgPSB0aGlzLl9nZW9jb2RlU3VjY2Vzcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2dlb2NvZGVFcnJvciA9IHRoaXMuX2dlb2NvZGVFcnJvci5iaW5kKHRoaXMpO1xuICB9LFxuXG4gIHNldExvY2F0aW9uOiBmdW5jdGlvbiAobG9jYXRpb24sIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uO1xuXG4gICAgaWYgKCFsb2NhdGlvbiB8fCAhbG9jYXRpb24uaGFzT3duUHJvcGVydHkoJ3BsYWNlJykpIHtcbiAgICAgIHRoaXMuX2FkZHJlc3MudmFsdWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkcmVzcy52YWx1ZSA9IGxvY2F0aW9uLnBsYWNlO1xuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWxlbnQpKSB7XG4gICAgICB0aGlzLmZpcmUoJ2xvY2F0aW9uJywgeydsb2NhdGlvbic6IGxvY2F0aW9ufSk7XG4gICAgfVxuICB9LFxuXG4gIGdldExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uO1xuICB9LFxuXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHN0b3AgPSBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBjb250cm9sLFxuICAgICAgICB0b2dnbGU7XG5cbiAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbG9jYXRpb24tY29udHJvbCcpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUUpO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBbXG4gICAgICAnPGEgY2xhc3M9XCInLCBvcHRpb25zLmljb25DbGFzcywgJ1wiPjwvYT4nLFxuICAgICAgJzxzcGFuIGNsYXNzPVwiaGVscFwiPicsIG9wdGlvbnMuaGVscFRleHQsICc8L3NwYW4+JyxcbiAgICAgICc8ZGl2IGNsYXNzPVwiJywgQ0xBU1NfSU5QVVQsICdcIj4nLFxuICAgICAgICAnPGlucHV0IG5hbWU9XCJhZGRyZXNzXCIgdGl0bGU9XCJhZGRyZXNzXCIgY2xhc3M9XCJhZGRyZXNzXCIgJyxcbiAgICAgICAgICAgICdwbGFjZWhvbGRlcj1cIkFkZHJlc3NcIi8+JyxcbiAgICAgICAgJzxidXR0b24gdHlwZT1cInNlYXJjaFwiIGNsYXNzPVwiJywgQ0xBU1NfU1VCTUlULCAnXCI+U2VhcmNoPC9idXR0b24+JyxcbiAgICAgICc8L2Rpdj4nXG4gICAgXS5qb2luKCcnKTtcblxuICAgIHRvZ2dsZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhJyk7XG4gICAgY29udHJvbCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuJyArIENMQVNTX0lOUFVUKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLl90b2dnbGUgPSB0b2dnbGU7XG4gICAgdGhpcy5fY29udHJvbCA9IGNvbnRyb2w7XG4gICAgdGhpcy5fYWRkcmVzcyA9IGNvbnRyb2wucXVlcnlTZWxlY3RvcignLmFkZHJlc3MnKTtcbiAgICB0aGlzLl9zdWJtaXQgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLicgKyBDTEFTU19TVUJNSVQpO1xuICAgIHRoaXMuX21hcCA9IG1hcDtcblxuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIodGhpcy5fYWRkcmVzcywgJ2tleXVwJywgdGhpcy5fb25LZXlVcCwgdGhpcyk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcih0aGlzLl9zdWJtaXQsICdjbGljaycsIHRoaXMuX29uU2VhcmNoQ2xpY2ssIHRoaXMpO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIodG9nZ2xlLCAnY2xpY2snLCB0aGlzLnRvZ2dsZSwgdGhpcyk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdjbGljaycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnZGJsY2xpY2snLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2tleWRvd24nLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2tleXVwJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdrZXlwcmVzcycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnbW91c2Vkb3duJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcih0aGlzLl9hZGRyZXNzLCAndG91Y2hzdGFydCcsIHN0b3ApO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfSxcblxuICBvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24sXG4gICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgICAgdG9nZ2xlID0gdGhpcy5fdG9nZ2xlO1xuXG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9hZGRyZXNzLCAna2V5dXAnLCB0aGlzLl9vbktleVVwKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX3N1Ym1pdCwgJ2NsaWNrJywgdGhpcy5fb25TZWFyY2hDbGljayk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcih0b2dnbGUsICdjbGljaycsIHRoaXMudG9nZ2xlKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRhaW5lciwgJ2NsaWNrJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250YWluZXIsICdkYmxjbGljaycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGFpbmVyLCAna2V5ZG93bicsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGFpbmVyLCAna2V5dXAnLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRhaW5lciwgJ2tleXByZXNzJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250YWluZXIsICdtb3VzZWRvd24nLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX2FkZHJlc3MsICd0b3VjaHN0YXJ0Jywgc3RvcCk7XG4gIH0sXG5cbiAgX2RvR2VvY29kZTogZnVuY3Rpb24gKHRleHRBZGRyZXNzKSB7XG4gICAgdGhpcy5fc2V0TG9hZGluZyh0cnVlKTtcbiAgICB0aGlzLl9nZW9jb2Rlci5mb3J3YXJkKHRleHRBZGRyZXNzLFxuICAgICAgICB0aGlzLl9nZW9jb2RlU3VjY2VzcywgdGhpcy5fZ2VvY29kZUVycm9yKTtcbiAgfSxcblxuICBfb25LZXlVcDogZnVuY3Rpb24gKGtleUV2ZW50KSB7XG4gICAgaWYgKGtleUV2ZW50LmtleUNvZGUgPT09IDEzICYmIHRoaXMuX2FkZHJlc3MudmFsdWUgIT09ICcnKSB7XG4gICAgICB0aGlzLl9kb0dlb2NvZGUodGhpcy5fYWRkcmVzcy52YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9vblNlYXJjaENsaWNrOiBmdW5jdGlvbiAoLypjbGlja0V2ZW50Ki8pIHtcbiAgICBpZiAodGhpcy5fYWRkcmVzcy52YWx1ZSAhPT0gJycpIHtcbiAgICAgIHRoaXMuX2RvR2VvY29kZSh0aGlzLl9hZGRyZXNzLnZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgdG9nZ2xlOiBmdW5jdGlvbiAoLypjbGlja0V2ZW50Ki8pIHtcbiAgICBpZiAoTC5Eb21VdGlsLmhhc0NsYXNzKHRoaXMuX2NvbnRhaW5lciwgQ0xBU1NfRU5BQkxFRCkpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH1cbiAgfSxcblxuICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCBDTEFTU19FTkFCTEVEKTtcbiAgICB0aGlzLl9hZGRyZXNzLmZvY3VzKCk7XG5cbiAgICB0aGlzLmZpcmUoJ2VuYWJsZWQnKTtcbiAgfSxcblxuICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgQ0xBU1NfRU5BQkxFRCk7XG5cbiAgICB0aGlzLmZpcmUoJ2Rpc2FibGVkJyk7XG4gIH0sXG5cbiAgX2dlb2NvZGVTdWNjZXNzOiBmdW5jdGlvbiAobG9jKSB7XG4gICAgdGhpcy5fc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgdGhpcy5zZXRMb2NhdGlvbihsb2MpO1xuICAgIHRoaXMuX2FkZHJlc3MuYmx1cigpO1xuICB9LFxuXG4gIF9nZW9jb2RlRXJyb3I6IGZ1bmN0aW9uIChzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgdGhpcy5fc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgdGhpcy5maXJlKCdsb2NhdGlvbkVycm9yJywge1xuICAgICAgY29kZTogc3RhdHVzQ29kZSxcbiAgICAgIG1lc3NhZ2U6IHN0YXR1c01lc3NhZ2VcbiAgICB9KTtcbiAgfSxcblxuICBfc2V0TG9hZGluZzogZnVuY3Rpb24gKGxvYWRpbmcpIHtcbiAgICBpZiAobG9hZGluZykge1xuICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xvYWRpbmcnKTtcbiAgICAgIHRoaXMuX2FkZHJlc3MuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fc3VibWl0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xvYWRpbmcnKTtcbiAgICAgIHRoaXMuX2FkZHJlc3MuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3N1Ym1pdC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fYWRkcmVzcy5mb2N1cygpO1xuICAgIH1cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvY29kZUNvbnRyb2w7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIENvbmZpZGVuY2VDYWxjdWxhdG9yID0gcmVxdWlyZSgnbG9jYXRpb252aWV3L0NvbmZpZGVuY2VDYWxjdWxhdG9yJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbi8vIFN0YXRpYyBpbmNyZW1lbnRvciBmb3IgdW5pcXVlbmVzc1xudmFyIEdFT0NPREVfUkVRVUVTVF9JRCA9IDA7XG52YXIgTUVUSE9EX0dFT0NPREUgPSAnZ2VvY29kZSc7XG5cbi8vIEZvcndhcmQgYW5kIHJldmVyc2UgVXJsIHNob3VsZCBjb25mb3JtIHRvIEVTUkkgQVBJXG52YXIgREVGQVVMVFMgPSB7XG4gIC8vIEFQSSBlbmRwb2ludCBmb3IgZm9yd2FyZCBnZW9jb2RlIHNlYXJjaGVzXG4gIGZvcndhcmRVcmw6ICdodHRwczovL2dlb2NvZGUuYXJjZ2lzLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZC9HZW9jb2RlU2VydmVyL2ZpbmQnLFxuXG4gICAvLyBSYWRpYWwgZGlzdGFuY2UgaW4gbWV0ZXJzIGZvciByZXZzZXJzZSBnZW9jb2RlIHNlYXJjaGVzXG4gIHJldmVyc2VSYWRpdXM6IDUwMDAsXG5cbiAgLy8gQVBJIGVuZHBvaW50IGZvciByZXZlcnNlIGdlb2NvZGUgc2VhcmNoZXNcbiAgcmV2ZXJzZVVybDogJ2h0dHBzOi8vZ2VvY29kZS5hcmNnaXMuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1dvcmxkL0dlb2NvZGVTZXJ2ZXIvcmV2ZXJzZUdlb2NvZGUnLFxufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZ2VvY29kZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gKiAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIERFRkFVTFRTIGZvciBkZXRhaWxzLlxuICogICAgICB7Zm9yd2FyZFVybH0gYW5kL29yIHtyZXZlcnNlVXJsfS5cbiAqL1xudmFyIEdlb2NvZGVyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2ZvcndhcmRVcmwsXG4gICAgICBfcmV2ZXJzZVJhZGl1cyxcbiAgICAgIF9yZXZlcnNlVXJsLFxuXG4gICAgICBfYnVpbGRMb2NhdGlvblJlc3VsdCxcbiAgICAgIF9idWlsZFBsYWNlTmFtZSxcbiAgICAgIF9nZXRDYWxsYmFja05hbWU7XG5cblxuICBfdGhpcyA9IHt9O1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHBhcmFtcyA9IFV0aWwuZXh0ZW5kKHt9LCBERUZBVUxUUywgcGFyYW1zKTtcblxuICAgIF9mb3J3YXJkVXJsID0gcGFyYW1zLmZvcndhcmRVcmw7XG4gICAgX3JldmVyc2VVcmwgPSBwYXJhbXMucmV2ZXJzZVVybDtcbiAgICBfcmV2ZXJzZVJhZGl1cyA9IHBhcmFtcy5yZXZlcnNlUmFkaXVzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFByaXZhdGUgc3RhdGljIG1ldGhvZC5cbiAgICpcbiAgICogQ3JlYXRlcyBhIHtsb2NhdGlvbn0gb2JqZWN0IGZyb20gdGhlIGdpdmVuIHtnZW9jb2RlUmVzcG9uc2V9IGFuZFxuICAgKiB7b3JpZ2luYWxSZXF1ZXN0fS5cbiAgICpcbiAgICogQHBhcmFtIGdlb2NvZGVSZXNwb25zZSB7T2JqZWN0fVxuICAgKiAgICAgIFRoZSBmaXJzdCBsb2NhdGlvbiBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIEpTT05QIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBvcmlnaW5hbFJlcXVlc3Qge09iamVjdH1cbiAgICogICAgICBUaGUgcGFyYW1ldGVycyB1c2VkIHRvIGNyZWF0ZSB0aGUgb3JpZ2luYWwgSlNPTlAgcmVxdWVzdC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgIEEgbG9jYXRpb24gb2JqZWN0IGZvciB1c2Ugd2l0aCBMb2NhdGlvblZpZXcgYW5kIExvY2F0aW9uQ29udHJvbFxuICAgKiAgICAgIGNvbXBvbmVudHMuXG4gICAqL1xuICBfYnVpbGRMb2NhdGlvblJlc3VsdCA9IGZ1bmN0aW9uIChnZW9jb2RlUmVzcG9uc2UsIG9yaWdpbmFsUmVxdWVzdCkge1xuICAgIHZhciBsb2NhdGlvbixcbiAgICAgICAgcHJvdmlkZWRMb2NhdGlvbixcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgbG9jYXRpb24gPSB7XG4gICAgICBtZXRob2Q6IE1FVEhPRF9HRU9DT0RFLFxuICAgICAgcGxhY2U6IG51bGwsXG4gICAgICBsYXRpdHVkZTogbnVsbCxcbiAgICAgIGxvbmdpdHVkZTogbnVsbCxcbiAgICAgIGNvbmZpZGVuY2U6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKG9yaWdpbmFsUmVxdWVzdC5sb2NhdGlvbikge1xuICAgICAgLy8gcmV2ZXJzZSBsb29rdXBcbiAgICAgIHJlc3VsdCA9IGdlb2NvZGVSZXNwb25zZS5hZGRyZXNzO1xuICAgICAgcHJvdmlkZWRMb2NhdGlvbiA9IG9yaWdpbmFsUmVxdWVzdC5sb2NhdGlvbi5zcGxpdCgnLCcpO1xuXG4gICAgICBsb2NhdGlvbi5wbGFjZSA9IHJlc3VsdC5NYXRjaF9hZGRyO1xuICAgICAgbG9jYXRpb24ubGF0aXR1ZGUgPSBnZW9jb2RlUmVzcG9uc2UubG9jYXRpb24ueTtcbiAgICAgIGxvY2F0aW9uLmxvbmdpdHVkZSA9IGdlb2NvZGVSZXNwb25zZS5sb2NhdGlvbi54O1xuICAgICAgbG9jYXRpb24uY29uZmlkZW5jZSA9IENvbmZpZGVuY2VDYWxjdWxhdG9yLmNvbXB1dGVGcm9tQ29vcmRpbmF0ZXMoXG4gICAgICAgICAgcHJvdmlkZWRMb2NhdGlvblsxXSwgcHJvdmlkZWRMb2NhdGlvblswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvcndhcmQgbG9va3VwXG4gICAgICByZXN1bHQgPSBnZW9jb2RlUmVzcG9uc2UubG9jYXRpb25zWzBdO1xuXG4gICAgICBsb2NhdGlvbi5wbGFjZSA9IG9yaWdpbmFsUmVxdWVzdC50ZXh0IHx8IHJlc3VsdC5uYW1lO1xuICAgICAgbG9jYXRpb24ubGF0aXR1ZGUgPSByZXN1bHQuZmVhdHVyZS5nZW9tZXRyeS55O1xuICAgICAgbG9jYXRpb24ubG9uZ2l0dWRlID0gcmVzdWx0LmZlYXR1cmUuZ2VvbWV0cnkueDtcbiAgICAgIGxvY2F0aW9uLmNvbmZpZGVuY2UgPSBDb25maWRlbmNlQ2FsY3VsYXRvci5jb21wdXRlRnJvbUdlb2NvZGUocmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSByZXNwb25zZUxvY2F0aW9uIHtPYmplY3R9XG4gICAqICAgICAgQSBsb2NhdGlvbiBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgZ2VvY29kaW5nIGFwaVxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICAgQSBwbGFjZW5hbWVcbiAgICovXG4gIF9idWlsZFBsYWNlTmFtZSA9IGZ1bmN0aW9uIChyZXNwb25zZUxvY2F0aW9uKSB7XG4gICAgdmFyIHBsYWNlbmFtZTtcblxuICAgIHBsYWNlbmFtZSA9IFtdO1xuXG4gICAgaWYgKHJlc3BvbnNlTG9jYXRpb24uc3RyZWV0KSB7XG4gICAgICBwbGFjZW5hbWUucHVzaChyZXNwb25zZUxvY2F0aW9uLnN0cmVldCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlTG9jYXRpb24uYWRtaW5BcmVhNSkge1xuICAgICAgcGxhY2VuYW1lLnB1c2gocmVzcG9uc2VMb2NhdGlvbi5hZG1pbkFyZWE1KTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2VMb2NhdGlvbi5hZG1pbkFyZWEzKSB7XG4gICAgICBwbGFjZW5hbWUucHVzaChyZXNwb25zZUxvY2F0aW9uLmFkbWluQXJlYTMpO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZUxvY2F0aW9uLnBvc3RhbENvZGUpIHtcbiAgICAgIHBsYWNlbmFtZS5wdXNoKHJlc3BvbnNlTG9jYXRpb24ucG9zdGFsQ29kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsYWNlbmFtZS5qb2luKCcsICcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIHN0YXRpYyBtZXRob2QuXG4gICAqXG4gICAqIENvbXB1dGVzIGEgdW5pcXVlIHN0cmluZyBzdWl0YWJsZSBmb3IgdXNlIGluIGNyZWF0aW5nIGEgbmV3IGdsb2JhbFxuICAgKiBjYWxsYmFjayBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgICBBIHVuaXF1ZSBzdHJpbmcuXG4gICAqL1xuICBfZ2V0Q2FsbGJhY2tOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFjayA9ICdnZW9jb2RlXycgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgJ18nICtcbiAgICAgICAgR0VPQ09ERV9SRVFVRVNUX0lEO1xuXG4gICAgR0VPQ09ERV9SRVFVRVNUX0lEICs9IDE7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGFzeW5jaHJvbm91cyBmb3J3YXJkIGdlb2NvZGUgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzU3RyaW5nIHtTdHJpbmd9XG4gICAqICAgICAgVGhlIGFkZHJlc3Mgc3RyaW5nIHRvIGdlb2NvZGUuXG4gICAqIEBwYXJhbSBzdWNjZXNzQ2FsbGJhY2sge0Z1bmN0aW9ufVxuICAgKiAgICAgIFRoZSBjYWxsYmFjayBtZXRob2QgdG8gZXhlY3V0ZSBvbiBzdWNjZXNzLiBUaGlzIGNhbGxiYWNrIHNob3VsZCBleHBlY3RcbiAgICogICAgICBhIHtsb2NhdGlvbn0gb2JqZWN0IGFzIGl0cyBzaW5nYWwgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0gZXJyb3JDYWxsYmFjayB7RnVuY3Rpb259XG4gICAqICAgICAgVGhlIGNhbGxiYWNrIG1ldGhvZCB0byBleGVjdXRlIG9uIGVycm9yLiBUaGlzIGNhbGxiYWNrIHNob3VsZCBleHBlY3RcbiAgICogICAgICB7c3RhdHVzQ29kZX0gYW5kIHtzdGF0dXNNZXNzYWdlfSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgX3RoaXMuZm9yd2FyZCA9IF90aGlzLmdlb2NvZGUgPSBmdW5jdGlvbiAoYWRkcmVzc1N0cmluZywgc3VjY2Vzc0NhbGxiYWNrLFxuICAgICAgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgdGV4dDogYWRkcmVzc1N0cmluZ1xuICAgIH07XG5cbiAgICBfdGhpcy5zdWJtaXRSZXF1ZXN0KHJlcXVlc3QsIF9mb3J3YXJkVXJsLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhc3luY2hyb25vdXMgcmV2ZXJzZSBnZW9jb2RlIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAcGFyYW0gbGF0aXR1ZGUge1N0cmluZ31cbiAgICogICAgICBUaGUgbGF0aXR1ZGUgb2YgdGhlIGNvb3JkaW5hdGUgdG8gcmV2ZXJzZSBnZW9jb2RlLlxuICAgKiBAcGFyYW0gbG9uZ2l0dWRlIHtTdHJpbmd9XG4gICAqICAgICAgVGhlIGxvbmdpdHVkZSBvZiB0aGUgY29vcmRpbmF0ZSB0byByZXZlcnNlIGdlb2NvZGUuXG4gICAqIEBwYXJhbSBzdWNjZXNzQ2FsbGJhY2sge0Z1bmN0aW9ufVxuICAgKiAgICAgIFRoZSBjYWxsYmFjayBtZXRob2QgdG8gZXhlY3V0ZSBvbiBzdWNjZXNzLiBUaGlzIGNhbGxiYWNrIHNob3VsZCBleHBlY3RcbiAgICogICAgICBhIHtsb2NhdGlvbn0gb2JqZWN0IGFzIGl0cyBzaW5nYWwgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0gZXJyb3JDYWxsYmFjayB7RnVuY3Rpb259XG4gICAqICAgICAgVGhlIGNhbGxiYWNrIG1ldGhvZCB0byBleGVjdXRlIG9uIGVycm9yLiBUaGlzIGNhbGxiYWNrIHNob3VsZCBleHBlY3RcbiAgICogICAgICB7c3RhdHVzQ29kZX0gYW5kIHtzdGF0dXNNZXNzYWdlfSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgX3RoaXMucmV2ZXJzZSA9IF90aGlzLnJldmVyc2VHZW9jb2RlID0gZnVuY3Rpb24gKGxhdGl0dWRlLCBsb25naXR1ZGUsXG4gICAgICBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgIGxvY2F0aW9uOiAnJyArIGxvbmdpdHVkZSArICcsJyArIGxhdGl0dWRlLFxuICAgICAgZGlzdGFuY2U6IF9yZXZlcnNlUmFkaXVzXG4gICAgfTtcblxuICAgIF90aGlzLnN1Ym1pdFJlcXVlc3QocmVxdWVzdCwgX3JldmVyc2VVcmwsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgbWV0aG9kLlxuICAgKlxuICAgKiBFeGVjdXRlcyB0aGUgSlNPTlAgcmVxdWVzdC4gQ2FsbGVkIGludGVybmFsbHkgYnkge2ZvcndhcmR9IGFuZCB7cmV2ZXJzZX1cbiAgICogbWV0aG9kcy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyB7T2JqZWN0fVxuICAgKiAgICAgIFBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gdXJsIHtTdHJpbmd9XG4gICAqICAgICAgVGhlIHdlYnNlcnZpY2UgVVJMIGFnYWluc3Qgd2hpY2ggdG8gcGVyZm9ybSB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHN1Y2Nlc3NDYWxsYmFjayB7RnVuY3Rpb259XG4gICAqICAgICAgVGhlIGNhbGxiYWNrIG1ldGhvZCB0byBleGVjdXRlIG9uIHN1Y2Nlc3MuIFRoaXMgY2FsbGJhY2sgc2hvdWxkIGV4cGVjdFxuICAgKiAgICAgIGEge2xvY2F0aW9ufSBvYmplY3QgYXMgaXRzIHNpbmdhbCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSBlcnJvckNhbGxiYWNrIHtGdW5jdGlvbn1cbiAgICogICAgICBUaGUgY2FsbGJhY2sgbWV0aG9kIHRvIGV4ZWN1dGUgb24gZXJyb3IuIFRoaXMgY2FsbGJhY2sgc2hvdWxkIGV4cGVjdFxuICAgKiAgICAgIHtzdGF0dXNDb2RlfSBhbmQge3N0YXR1c01lc3NhZ2V9IHBhcmFtZXRlcnMuXG4gICAqL1xuICBfdGhpcy5zdWJtaXRSZXF1ZXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgdXJsLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcblxuICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcbiAgICAgICAgaW5zZXJ0QXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHQnKSxcbiAgICAgICAgcmVxdWVzdCA9IFsnZj1wanNvbiddLFxuICAgICAgICBjYWxsYmFja05hbWUgPSBfZ2V0Q2FsbGJhY2tOYW1lKCksXG4gICAgICAgIGtleSA9IG51bGwsIGNsZWFudXAgPSBudWxsLCBjbGVhbmVkVXAgPSBmYWxzZTtcblxuXG4gICAgcmVxdWVzdC5wdXNoKCdjYWxsYmFjaz0nICsgY2FsbGJhY2tOYW1lKTtcbiAgICByZXF1ZXN0LnB1c2goJ2Y9cGpzb24nKTtcblxuICAgIC8vIGJ1aWxkIHVwIHRoZSBmdWxsIHJlcXVlc3QgVVJMIGJhc2VkIG9uIHRoZSBpbnB1dCBwYXJhbWV0ZXJzXG4gICAgZm9yIChrZXkgaW4gcGFyYW1zKSB7XG4gICAgICByZXF1ZXN0LnB1c2goa2V5ICsgJz0nICsgcGFyYW1zW2tleV0pO1xuICAgIH1cblxuICAgIC8vIGNhbGxiYWNrIG1ldGhvZCB1c2VkIHRvIGNsZWFuIHVwIG1lbW9yeSBmb2xsb3dpbmcgdGhlIEpTT05QIHJlc3BvbnNlXG4gICAgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjbGVhbmVkVXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IG51bGw7XG4gICAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrTmFtZV07XG5cbiAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICBzY3JpcHQgPSBudWxsO1xuXG4gICAgICBjbGVhbmVkVXAgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvLyBKU09OUCBjYWxsYmFjayBtZXRob2QgKGF0dGFjaGVkIHRvIGdsb2JhbCB3aW5kb3cpXG4gICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHZhciBlcnJvcjtcblxuICAgICAgaWYgKCggLy8gZmFpbGVkIGZvcndhcmQgbG9va3VwXG4gICAgICAgICAgICAhcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ2xvY2F0aW9ucycpIHx8XG4gICAgICAgICAgICByZXNwb25zZS5sb2NhdGlvbnMubGVuZ3RoID09PSAwXG4gICAgICAgICAgKSAmJlxuICAgICAgICAgIC8vIGZhaWxlZCByZXZlcnNlIGxvb2t1cFxuICAgICAgICAgICFyZXNwb25zZS5oYXNPd25Qcm9wZXJ0eSgnYWRkcmVzcycpKSB7ICAgIC8vIGZhaWxlZCByZXZlcnNlIGxvb2t1cFxuICAgICAgICBlcnJvciA9IHJlc3BvbnNlLmVycm9yIHx8IHt9O1xuXG4gICAgICAgIC8vIEZhaWx1cmVcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnJvci5jb2RlIHx8IDQwNCxcbiAgICAgICAgICAgIChlcnJvci5kZXRhaWxzICYmIGVycm9yLmRldGFpbHMubGVuZ3RoKSA/IGVycm9yLmRldGFpbHNbMF0gOlxuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgfHwgJ05vIGxvY2F0aW9uIGZvdW5kLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3VjY2VzcyBJIGd1ZXNzLi4uXG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhfYnVpbGRMb2NhdGlvblJlc3VsdChyZXNwb25zZSwgcGFyYW1zKSk7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLyBmaXJlIG9mZiB0aGUgSlNPTlAgcmVxdWVzdFxuICAgIHNjcmlwdC5zcmMgPSB1cmwgKyAnPycgKyByZXF1ZXN0LmpvaW4oJyYnKTtcbiAgICBzY3JpcHQub25Mb2FkID0gY2xlYW51cDtcbiAgICBzY3JpcHQub25FcnJvciA9IGNsZWFudXA7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShwYXJhbXMpO1xuICBwYXJhbXMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gR2VvY29kZXI7XG4iLCIvKiBnbG9iYWwgTCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBDb25maWRlbmNlQ2FsY3VsYXRvciA9IHJlcXVpcmUoJ2xvY2F0aW9udmlldy9Db25maWRlbmNlQ2FsY3VsYXRvcicpO1xuXG5cbnZhciBDTEFTU19OQU1FID0gJ2xvY2F0aW9uLWdlb2xvY2F0aW9uLWNvbnRyb2wnO1xudmFyIE1FVEhPRCA9ICdnZW9sb2NhdGlvbic7XG52YXIgRU5BQkxFRF9DTEFTUyA9ICdsb2NhdGlvbi1jb250cm9sLWVuYWJsZWQnO1xuXG5cbnZhciBERUZBVUxUUyA9IHtcbiAgJ21ldGhvZCc6IE1FVEhPRCxcbiAgJ2dlb2xvY2F0aW9uJzogbmF2aWdhdG9yLmdlb2xvY2F0aW9uLFxuICAncG9zaXRpb24nOiAndG9wbGVmdCcsXG4gICdpY29uQ2xhc3MnOiAnbG9jYXRpb24tY29udHJvbC1pY29uJyxcbiAgJ2hlbHBUZXh0JzogJ1VzZSBDdXJyZW50IExvY2F0aW9uJyxcbiAgJ2luZm9UZXh0JzogJ0F0dGVtcHQgdG8gYXV0b21hdGljYWxseSBsb2NhdGUgbXkgPGI+Y3VycmVudCBsb2NhdGlvbjwvYj4uJ1xufTtcblxuXG5cbi8qKlxuICogQHBhcmFtcyBnZW9sb2NhdGlvbiB7b2JqZWN0fSBvcHRpb25hbCBhcGkgdG8gcmVwbGFjZSBuYXZpZ2F0b3IuZ2VvbG9jYXRpb25cbiAqICAgICAgICAgc2hvdWxkIGhhdmUgYSBnZXRDdXJyZW50UG9zaXRpb24gY2FsbC5cbiAqL1xudmFyIEdlb2xvY2F0aW9uQ29udHJvbCA9IEwuQ29udHJvbC5leHRlbmQoe1xuICBpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBMLlV0aWwuZXh0ZW5kKHt9LCBERUZBVUxUUywgb3B0aW9ucykpO1xuICAgIHRoaXMuX2dlb2xvY2F0ZVN1Y2Nlc3MgPSB0aGlzLl9nZW9sb2NhdGVTdWNjZXNzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fZ2VvbG9jYXRlRXJyb3IgPSB0aGlzLl9nZW9sb2NhdGVFcnJvci5iaW5kKHRoaXMpO1xuICB9LFxuXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHN0b3AgPSBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICB0b2dnbGU7XG5cbiAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbG9jYXRpb24tY29udHJvbCcpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUUpO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBbXG4gICAgICAnPGEgY2xhc3M9XCInLCBvcHRpb25zLmljb25DbGFzcywgJ1wiPjwvYT4nLFxuICAgICAgJzxzcGFuIGNsYXNzPVwiaGVscFwiPicsIG9wdGlvbnMuaGVscFRleHQsICc8L3NwYW4+J1xuICAgIF0uam9pbignJyk7XG5cbiAgICB0b2dnbGUgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignYScpO1xuXG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLl90b2dnbGUgPSB0b2dnbGU7XG5cbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKHRvZ2dsZSwgJ2NsaWNrJywgdGhpcy50b2dnbGUsIHRoaXMpO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnY2xpY2snLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2RibGNsaWNrJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdrZXlkb3duJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdrZXl1cCcsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAna2V5cHJlc3MnLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ21vdXNlZG93bicsIHN0b3ApO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfSxcblxuICBvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24sXG4gICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgICAgdG9nZ2xlID0gdGhpcy5fdG9nZ2xlO1xuXG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcih0b2dnbGUsICdjbGljaycsIHRoaXMudG9nZ2xlKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRhaW5lciwgJ2NsaWNrJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250YWluZXIsICdkYmxjbGljaycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGFpbmVyLCAna2V5ZG93bicsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGFpbmVyLCAna2V5dXAnLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRhaW5lciwgJ2tleXByZXNzJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250YWluZXIsICdtb3VzZWRvd24nLCBzdG9wKTtcbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuX3RvZ2dsZSA9IG51bGw7XG4gICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgfSxcblxuICBkb0dlb2xvY2F0ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW9sb2NhdGlvbiA9IHRoaXMub3B0aW9ucy5nZW9sb2NhdGlvbjtcblxuICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKEVOQUJMRURfQ0xBU1MpO1xuXG4gICAgaWYgKGdlb2xvY2F0aW9uKSB7XG4gICAgICBnZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24odGhpcy5fZ2VvbG9jYXRlU3VjY2VzcyxcbiAgICAgICAgdGhpcy5fZ2VvbG9jYXRlRXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nZW9sb2NhdGVFcnJvcih7XG4gICAgICAgIGNvZGU6IDAsXG4gICAgICAgIG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5maXJlKCdlbmFibGVkJyk7XG4gIH0sXG5cbiAgX2dlb2xvY2F0ZVN1Y2Nlc3M6IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKEVOQUJMRURfQ0xBU1MpO1xuXG4gICAgdGhpcy5zZXRMb2NhdGlvbih7XG4gICAgICAgIHBsYWNlOiBudWxsLFxuICAgICAgICBsYXRpdHVkZTogcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGU6IHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUsXG4gICAgICAgIG1ldGhvZDogTUVUSE9ELFxuICAgICAgICBjb25maWRlbmNlOiBDb25maWRlbmNlQ2FsY3VsYXRvci5jb21wdXRlRnJvbUdlb2xvY2F0ZShcbiAgICAgICAgICBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3kpXG4gICAgfSk7XG4gIH0sXG5cbiAgX2dlb2xvY2F0ZUVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShFTkFCTEVEX0NMQVNTKTtcblxuICAgIHRoaXMuZmlyZSgnbG9jYXRpb25FcnJvcicsIGVycm9yKTtcbiAgfSxcblxuICBzZXRMb2NhdGlvbjogZnVuY3Rpb24gKGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgLy8gQVBJIG1ldGhvZCwgdGhpcyBjb250cm9sIGhhcyBub3RoaW5nIHRvIGRvXG4gICAgaWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLnNpbGVudCkpIHtcbiAgICAgIHRoaXMuZmlyZSgnbG9jYXRpb24nLCB7J2xvY2F0aW9uJzogbG9jYXRpb259KTtcbiAgICB9XG4gIH0sXG5cbiAgdG9nZ2xlOiBmdW5jdGlvbiAoY2xpY2tFdmVudCkge1xuICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgTC5Eb21FdmVudC5zdG9wKGNsaWNrRXZlbnQpO1xuICB9LFxuXG4gIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZG9HZW9sb2NhdGUoKTtcbiAgfSxcblxuICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQVBJIG1ldGhvZCwgdGhpcyBjb250cm9sIGhhcyBub3RoaW5nIHRvIGRvXG4gIH1cblxufSk7XG5cblxuR2VvbG9jYXRpb25Db250cm9sLk1FVEhPRCA9IE1FVEhPRDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb2xvY2F0aW9uQ29udHJvbDtcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIENvbmZpZGVuY2VDYWxjdWxhdG9yID0gcmVxdWlyZSgnbG9jYXRpb252aWV3L0NvbmZpZGVuY2VDYWxjdWxhdG9yJyksXG4gICAgQ29vcmRpbmF0ZUNvbnRyb2wgPSByZXF1aXJlKCdsb2NhdGlvbnZpZXcvQ29vcmRpbmF0ZUNvbnRyb2wnKSxcbiAgICBHZW9jb2RlQ29udHJvbCA9IHJlcXVpcmUoJ2xvY2F0aW9udmlldy9HZW9jb2RlQ29udHJvbCcpLFxuICAgIEdlb2xvY2F0aW9uQ29udHJvbCA9IHJlcXVpcmUoJ2xvY2F0aW9udmlldy9HZW9sb2NhdGlvbkNvbnRyb2wnKSxcbiAgICBQb2ludENvbnRyb2wgPSByZXF1aXJlKCdsb2NhdGlvbnZpZXcvUG9pbnRDb250cm9sJyk7XG5cblxudmFyIENMQVNTX05BTUUgPSAnbG9jYXRpb24tbG9jYXRpb24tY29udHJvbCcsXG4gICAgQ0xBU1NfRU5BQkxFRCA9IENMQVNTX05BTUUgKyAnLWVuYWJsZWQnO1xuXG5cbnZhciBERUZBVUxUUyA9IHtcbiAgJ2xvY2F0aW9uJzogbnVsbCxcbiAgJ3Bvc2l0aW9uJzogJ2JvdHRvbWxlZnQnLFxuICAnZWwnOiBudWxsLFxuICAnaWNvbkNsYXNzJzogQ0xBU1NfTkFNRSArICctaWNvbiBsb2NhdGlvbi1jb250cm9sLWljb24nLFxuICAnaGVscFRleHQnOiAnU2hvdyBMb2NhdGlvbiBPcHRpb25zJ1xufTtcblxudmFyIExPQ0FUSU9OX0RFRkFVTFRTID0ge1xuICAncGxhY2UnOiBudWxsLFxuICAnbGF0aXR1ZGUnOiAwLFxuICAnbG9uZ2l0dWRlJzogMCxcbiAgJ21ldGhvZCc6ICd1bnNwZWNpZmllZCcsXG4gICdjb25maWRlbmNlJzogQ29uZmlkZW5jZUNhbGN1bGF0b3IuTk9UX0NPTVBVVEVEXG59O1xuXG5cbnZhciBMb2NhdGlvbkNvbnRyb2wgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcbiAgaW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRyb2xzO1xuXG4gICAgb3B0aW9ucyA9IEwuVXRpbC5leHRlbmQoe30sIERFRkFVTFRTLCBvcHRpb25zKTtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2VsID0gdGhpcy5vcHRpb25zLmVsIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgdGhpcy5fbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMubG9jYXRpb247XG5cbiAgICBjb250cm9scyA9IFtdO1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVHZW9sb2NhdGlvbkNvbnRyb2wpIHtcbiAgICAgIGNvbnRyb2xzLnB1c2gob3B0aW9ucy5nZW9sb2NhdGlvbkNvbnRyb2wgfHwgbmV3IEdlb2xvY2F0aW9uQ29udHJvbCgpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZUdlb2NvZGVDb250cm9sKSB7XG4gICAgICBjb250cm9scy5wdXNoKG9wdGlvbnMuZ2VvY29kZUNvbnRyb2wgfHwgbmV3IEdlb2NvZGVDb250cm9sKCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlQ29vcmRpbmF0ZUNvbnRyb2wpIHtcbiAgICAgIGNvbnRyb2xzLnB1c2gob3B0aW9ucy5jb29yZGluYXRlQ29udHJvbCB8fCBuZXcgQ29vcmRpbmF0ZUNvbnRyb2woKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQb2ludENvbnRyb2wpIHtcbiAgICAgIGNvbnRyb2xzLnB1c2gob3B0aW9ucy5wb2ludENvbnRyb2wgfHwgbmV3IFBvaW50Q29udHJvbCgpKTtcbiAgICB9XG4gICAgdGhpcy5fY29udHJvbHMgPSBjb250cm9scztcbiAgfSxcblxuICBfZWFjaENvbnRyb2w6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBjb250cm9scyA9IHRoaXMuX2NvbnRyb2xzLFxuICAgICAgICBjb250cm9sLFxuICAgICAgICBpLCBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb250cm9scy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29udHJvbCA9IGNvbnRyb2xzW2ldO1xuICAgICAgY2FsbGJhY2soY29udHJvbCwgaSwgY29udHJvbHMpO1xuICAgIH1cbiAgfSxcblxuICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgdG9nZ2xlLFxuICAgICAgICBkZXRhaWxzO1xuXG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VuYWJsZWQgPSBudWxsO1xuXG4gICAgdGhpcy5fZWFjaENvbnRyb2woZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgIG1hcC5hZGRDb250cm9sKGNvbnRyb2wpO1xuICAgICAgY29udHJvbC5vbignbG9jYXRpb24nLCB0aGlzLnNldExvY2F0aW9uLCB0aGlzKTtcbiAgICAgIGNvbnRyb2wub24oJ2xvY2F0aW9uRXJyb3InLCB0aGlzLl9vbkxvY2F0aW9uRXJyb3IsIHRoaXMpO1xuICAgICAgY29udHJvbC5vbignZW5hYmxlZCcsIHRoaXMuX29uQ29udHJvbEVuYWJsZWQsIHRoaXMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vbignZW5hYmxlZCcsIHRoaXMuX29uQ29udHJvbEVuYWJsZWQsIHRoaXMpO1xuXG4gICAgLy8gQ3JlYXRlIEluZm9ybWF0aW9uIENvbnRyb2wgKGkpIGJ1dHRvblxuICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdsb2NhdGlvbi1jb250cm9sJyk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRSk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IFtcbiAgICAgICc8YSBjbGFzcz1cIicsIG9wdGlvbnMuaWNvbkNsYXNzLCAnXCI+aTwvYT4nLFxuICAgICAgJzxzcGFuIGNsYXNzPVwiaGVscFwiPicsIG9wdGlvbnMuaGVscFRleHQsICc8L3NwYW4+JyxcbiAgICBdLmpvaW4oJycpO1xuICAgIHRvZ2dsZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhJyk7XG5cbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5fdG9nZ2xlID0gdG9nZ2xlO1xuXG4gICAgLy8gY3JlYXRlIG92ZXJsYXkgd2l0aCBjb250cm9sIGluZm9ybWF0aW9uXG4gICAgdGhpcy5fY3JlYXRlSW5mb3JtYXRpb25NZW51KCk7XG4gICAgZGV0YWlscyA9IHRoaXMuX2RldGFpbHM7XG4gICAgdGhpcy5fZWwuYXBwZW5kQ2hpbGQoZGV0YWlscyk7XG5cblxuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIodG9nZ2xlLCAnY2xpY2snLCB0aGlzLnRvZ2dsZSwgdGhpcyk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihkZXRhaWxzLCAnY2xpY2snLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGRldGFpbHMsICdkYmxjbGljaycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoZGV0YWlscywgJ2tleWRvd24nLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGRldGFpbHMsICdrZXl1cCcsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoZGV0YWlscywgJ2tleXByZXNzJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihkZXRhaWxzLCAnbW91c2Vkb3duJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdjbGljaycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnZGJsY2xpY2snLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2tleWRvd24nLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2tleXVwJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdrZXlwcmVzcycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnbW91c2Vkb3duJywgc3RvcCk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9LFxuXG4gIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgdmFyIHN0b3AgPSBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbixcbiAgICAgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuICAgICAgICB0b2dnbGUgPSB0aGlzLl90b2dnbGUsXG4gICAgICAgIGRldGFpbHMgPSB0aGlzLl9kZXRhaWxzO1xuXG4gICAgdGhpcy5fZWFjaENvbnRyb2woZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgIG1hcC5yZW1vdmVDb250cm9sKGNvbnRyb2wpO1xuICAgICAgY29udHJvbC5vZmYoJ2xvY2F0aW9uJywgdGhpcy5zZXRMb2NhdGlvbiwgdGhpcyk7XG4gICAgICBjb250cm9sLm9mZignbG9jYXRpb25FcnJvcicsIHRoaXMuX29uTG9jYXRpb25FcnJvciwgdGhpcyk7XG4gICAgICBjb250cm9sLm9mZignZW5hYmxlZCcsIHRoaXMuX29uQ29udHJvbEVuYWJsZWQsIHRoaXMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vZmYoJ2VuYWJsZWQnLCB0aGlzLl9vbkNvbnRyb2xFbmFibGVkLCB0aGlzKTtcblxuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIodG9nZ2xlLCAnY2xpY2snLCB0aGlzLnRvZ2dsZSk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihkZXRhaWxzLCAnY2xpY2snLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGRldGFpbHMsICdkYmxjbGljaycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoZGV0YWlscywgJ2tleWRvd24nLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGRldGFpbHMsICdrZXl1cCcsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoZGV0YWlscywgJ2tleXByZXNzJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihkZXRhaWxzLCAnbW91c2Vkb3duJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250YWluZXIsICdjbGljaycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGFpbmVyLCAnZGJsY2xpY2snLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRhaW5lciwgJ2tleWRvd24nLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRhaW5lciwgJ2tleXVwJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250YWluZXIsICdrZXlwcmVzcycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGFpbmVyLCAnbW91c2Vkb3duJywgc3RvcCk7XG5cbiAgICB0aGlzLl9lbC5yZW1vdmVDaGlsZChkZXRhaWxzKTtcbiAgICB0aGlzLl9kZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuX3RvZ2dsZSA9IG51bGw7XG4gICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgaGVscC9pbmZvIG1lbnUgd2l0aCBkZXRhaWxlZCBkZXNjcmlwdGlvbnMgb2YgZWFjaCBjb250cm9sXG4gICAqXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgX2NyZWF0ZUluZm9ybWF0aW9uTWVudTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24sXG4gICAgICAgIHBhbmVsLFxuICAgICAgICBsaXN0O1xuXG4gICAgcGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwYW5lbC5jbGFzc0xpc3QuYWRkKCdpbmZvcm1hdGlvbi1saXN0LW1hc2snKTtcbiAgICBwYW5lbC5pbm5lckhUTUwgPSAnPHVsIGNsYXNzPVwiaW5mb3JtYXRpb24tbGlzdFwiPjwvdWw+JztcbiAgICBsaXN0ID0gcGFuZWwucXVlcnlTZWxlY3RvcignLmluZm9ybWF0aW9uLWxpc3QnKTtcblxuICAgIHRoaXMuX2VhY2hDb250cm9sKGZ1bmN0aW9uIChjb250cm9sLCBpbmRleCkge1xuICAgICAgdmFyIGNvbnRyb2xPcHRpb25zID0gY29udHJvbC5vcHRpb25zLFxuICAgICAgICAgIGNvbnRyb2xFbCA9IGNvbnRyb2wuX19pbmZvRWw7XG5cbiAgICAgIGlmICghY29udHJvbEVsKSB7XG4gICAgICAgIGNvbnRyb2xFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIGNvbnRyb2xFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBpbmRleCk7XG4gICAgICAgIGNvbnRyb2xFbC5pbm5lckhUTUwgPSBbXG4gICAgICAgICAgJzxzcGFuIHRpdGxlPVwiJywgY29udHJvbE9wdGlvbnMuaGVscFRleHQsICdcIicsXG4gICAgICAgICAgICAgICcgY2xhc3M9XCJsb2NhdGlvbi1jb250cm9sLWljb24gJyxcbiAgICAgICAgICAgICAgY29udHJvbE9wdGlvbnMuaWNvbkNsYXNzLCAnLScsIGNvbnRyb2xPcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgJ1wiPjwvc3Bhbj4nLFxuICAgICAgICAgICc8cD4nLCBjb250cm9sT3B0aW9ucy5pbmZvVGV4dCwgJzwvcD4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udHJvbEVsLCAnY2xpY2snLCBjb250cm9sLmVuYWJsZSwgY29udHJvbCk7XG4gICAgICAgIGNvbnRyb2wuX19pbmZvRWwgPSBjb250cm9sRWw7XG4gICAgICB9XG5cbiAgICAgIGxpc3QuYXBwZW5kQ2hpbGQoY29udHJvbEVsKTtcbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSBkaXYgZm9yIGluZm9ybWF0aW9uIG1lbnVcbiAgICB0aGlzLl9kZXRhaWxzID0gcGFuZWw7XG5cbiAgICAvLyBzdG9wIGludGVyYWN0aW9uIHdpdGggbWFwIHdoZW4gdGhlIGluZm9ybWF0aW9uIG1lbnUgaXMgdmlzaWJsZVxuICAgIEwuRG9tRXZlbnQub24ocGFuZWwsICdtb3VzZWRvd24nLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50Lm9uKHBhbmVsLCAnZGJsY2xpY2snLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50Lm9uKHBhbmVsLCAnd2hlZWwnLCBzdG9wKTtcbiAgfSxcblxuICB0b2dnbGU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2VsLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19FTkFCTEVEKSkge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuICB9LFxuXG4gIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2VsLmNsYXNzTGlzdC5hZGQoQ0xBU1NfRU5BQkxFRCk7XG5cbiAgICB0aGlzLmZpcmUoJ2VuYWJsZWQnKTtcbiAgfSxcblxuICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZWwuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19FTkFCTEVEKTtcblxuICAgIHRoaXMuZmlyZSgnZGlzYWJsZWQnKTtcbiAgfSxcblxuICBfb25Db250cm9sRW5hYmxlZDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gbnVsbDtcblxuICAgIGlmIChlKSB7XG4gICAgICB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICB9XG5cbiAgICB0aGlzLl9lYWNoQ29udHJvbChmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgaWYgKGNvbnRyb2wgIT09IHRhcmdldCkge1xuICAgICAgICBjb250cm9sLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0YXJnZXQgIT09IHRoaXMpIHtcbiAgICAgIC8vIGhpZGUgZGV0YWlsc1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuICB9LFxuXG4gIHNldExvY2F0aW9uOiBmdW5jdGlvbiAoZSwgb3B0aW9ucykge1xuICAgIHZhciB6b29tTGV2ZWwsXG4gICAgICAgIGxvY2F0aW9uID0gZTtcblxuICAgIGlmIChlKSB7XG4gICAgICBpZiAoZS50eXBlID09PSAnbG9jYXRpb24nKSB7XG4gICAgICAgIGxvY2F0aW9uID0gZS5sb2NhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24gIT09IG51bGwpIHtcbiAgICAgIGxvY2F0aW9uID0ge1xuICAgICAgICBwbGFjZTogbG9jYXRpb24ucGxhY2UgfHwgTE9DQVRJT05fREVGQVVMVFMucGxhY2UsXG4gICAgICAgIGxhdGl0dWRlOiBsb2NhdGlvbi5sYXRpdHVkZSB8fCBMT0NBVElPTl9ERUZBVUxUUy5sYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlOiBsb2NhdGlvbi5sb25naXR1ZGUgfHwgTE9DQVRJT05fREVGQVVMVFMubG9uZ2l0dWRlLFxuICAgICAgICBjb25maWRlbmNlOiBsb2NhdGlvbi5jb25maWRlbmNlIHx8IExPQ0FUSU9OX0RFRkFVTFRTLmNvbmZpZGVuY2UsXG4gICAgICAgIG1ldGhvZDogbG9jYXRpb24ubWV0aG9kIHx8IExPQ0FUSU9OX0RFRkFVTFRTLm1ldGhvZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIHRoaXMuX2VhY2hDb250cm9sKGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICBjb250cm9sLnNldExvY2F0aW9uKGxvY2F0aW9uLCB7J3NpbGVudCc6IHRydWV9KTtcbiAgICB9KTtcblxuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgem9vbUxldmVsID0gQ29uZmlkZW5jZUNhbGN1bGF0b3IuY29tcHV0ZVpvb21Gcm9tQ29uZmlkZW5jZShcbiAgICAgICAgICBsb2NhdGlvbi5jb25maWRlbmNlKTtcbiAgICAgIC8vIGRvIG5vdCB6b29tIHRoZSB1c2VyIG91dFxuICAgICAgaWYgKHpvb21MZXZlbCA8IHRoaXMuX21hcC5fem9vbSkge1xuICAgICAgICB6b29tTGV2ZWwgPSB0aGlzLl9tYXAuX3pvb207XG4gICAgICB9XG5cbiAgICAgIC8vIGNlbnRlciB0aGUgbWFwIG9uIHRoZSBuZXcgcG9pbnRcbiAgICAgIHRoaXMuX2NlbnRlck1hcE9uUG9pbnQobG9jYXRpb24sIHpvb21MZXZlbCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW5hYmxlIHRoZSBsb2NhdGlvbiBjb250cm9sXG4gICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWxlbnQpKSB7XG4gICAgICB0aGlzLmZpcmUoJ2xvY2F0aW9uJywgeydsb2NhdGlvbic6bG9jYXRpb259KTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0TG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYXRpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiBwb2ludCBpcyBjdXJyZW50bHkgdmlzaWJsZSB3aXRoIG1hcCBib3VuZHMuXG4gICAqIElmIHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIG1hcCBib3VuZHMgZG8gbm90IHBhbiB0aGUgbWFwLlxuICAgKiBDZW50ZXIgd2hlbiB0aGUgbmV3IGxvY2F0aW9uIGlzIG5vdCB2aXNpYmxlIG9yIHRoZSBtYXBcbiAgICogaXMgYmVpbmcgem9vbWVkLWluLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGxvY2F0aW9uLCBsZWFmbGV0IGxvY2F0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSBuZXdab29tTGV2ZWwsIGN1cnJlbnQgbWFwIHpvb20gbGV2ZWxcbiAgICpcbiAgICovXG4gIF9jZW50ZXJNYXBPblBvaW50OiBmdW5jdGlvbiAobG9jYXRpb24sIG5ld1pvb21MZXZlbCkge1xuICAgIHZhciBjZW50ZXJNYXAgPSBmYWxzZSxcbiAgICAgICAgb2xkWm9vbUxldmVsID0gdGhpcy5fbWFwLl96b29tLFxuICAgICAgICBtYXBCb3VuZHMgPSB0aGlzLl9tYXAuZ2V0Qm91bmRzKCksXG4gICAgICAgIG5ld0xvY2F0aW9uID0gW2xvY2F0aW9uLmxhdGl0dWRlLCBsb2NhdGlvbi5sb25naXR1ZGVdO1xuXG4gICAgaWYgKCFtYXBCb3VuZHMuY29udGFpbnMobmV3TG9jYXRpb24pIHx8IG5ld1pvb21MZXZlbCA+IG9sZFpvb21MZXZlbCkge1xuICAgICAgY2VudGVyTWFwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2VudGVyTWFwKSB7XG4gICAgICB0aGlzLl9tYXAuc2V0Vmlldyh7XG4gICAgICAgICAgbG9uOiBsb2NhdGlvbi5sb25naXR1ZGUsXG4gICAgICAgICAgbGF0OiBsb2NhdGlvbi5sYXRpdHVkZVxuICAgICAgICB9LFxuICAgICAgICBuZXdab29tTGV2ZWxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbnRlck1hcDtcbiAgfSxcblxuICBfb25Mb2NhdGlvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAvLyBUT0RPLCBtYWtlIHRoaXMgYmV0dGVyXG4gICAgd2luZG93LmFsZXJ0KGVycm9yLm1lc3NhZ2UpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2F0aW9uQ29udHJvbDtcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJ3V0aWwvRXZlbnRzJyksXG4gICAgTG9jYXRpb25Db250cm9sID0gcmVxdWlyZSgnbG9jYXRpb252aWV3L0xvY2F0aW9uQ29udHJvbCcpLFxuICAgIE1vZGFsVmlldyA9IHJlcXVpcmUoJ212Yy9Nb2RhbFZpZXcnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIERFRkFVTFRTID0ge1xuICBhdXRvT3BlbjogZmFsc2UsXG4gIGluY2x1ZGVQb2ludENvbnRyb2w6IHRydWUsICAgICAgIC8vIE1hbmFnZXMgbG9jYXRpb24gdmlhIHBpbiBvbiBtYXBcbiAgaW5jbHVkZUNvb3JkaW5hdGVDb250cm9sOiB0cnVlLCAgLy8gTWFuYWdlcyBsb2NhdGlvbiB2aWEgbGF0L2xuZyBpbnB1dFxuICBpbmNsdWRlR2VvY29kZUNvbnRyb2w6IHRydWUsICAgICAvLyBNYW5hZ2VzIGxvY2F0aW9uIHZpYSBhZGRyZXNzIGlucHV0XG4gIGluY2x1ZGVHZW9sb2NhdGlvbkNvbnRyb2w6ICAgICAgIC8vIE1hbmFnZXMgbG9jYXRpb24gdmlhIGF1dG8tZGV0ZWN0IChXM0MpXG4gICAgICBuYXZpZ2F0b3IgJiYgJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IsXG4gIGNhbGxiYWNrOiBmdW5jdGlvbiAoLypsb2NhdGlvbiovKSB7fVxufTtcblxuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gZ2V0IFVSTHMgZm9yIGFueSBBcmNHSVMgT25saW5lIG1hcCB0aWxlcy5cbiAqXG4gKiBAcGFyYW0gc2VydmljZU5hbWUge1N0cmluZ31cbiAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgbWFwIHRpbGUgc2VydmljZSBmb3Igd2hpY2ggdG8gcmV0dXJuIGEgVVJMIHRlbXBsYXRlLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqICAgICAgICAgVGhlIHNlcnZpY2UgVVJMIHRlbXBsYXRlIGZvciB1c2UgaW4gYW4gTC5UaWxlTGF5ZXIuXG4gKi9cbnZhciBfX2dldF9hcmNnaXNvbmxpbmVfdXJsID0gZnVuY3Rpb24gKHNlcnZpY2VOYW1lKSB7XG4gIHZhciB1cmxQcmVmaXggPSAnLy9zZXJ2ZXIuYXJjZ2lzb25saW5lLmNvbS9BcmNHSVMvcmVzdC9zZXJ2aWNlcy8nLFxuICAgICAgdXJsU3VmZml4ID0gJy9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fSc7XG5cbiAgcmV0dXJuIHVybFByZWZpeCArIHNlcnZpY2VOYW1lICsgdXJsU3VmZml4O1xufTtcblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQ3JlYXRlcyBhIG5ldyBMb2NhdGlvblZpZXcuXG4gKlxuICogQHBhcmFtIHBhcmFtcyB7T2JqZWN0fVxuICogICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIGNvbmZpZ3VyYXRpb24gcGFyYW1zLiBTZWUgREVGQVVMVFMgZm9yXG4gKiAgICAgICAgZGV0YWlsZWQgZG9jdW1lbnRhdGlvbiBvbiB3aGF0IGNhbiBiZSBzcGVjaWZpZWQuXG4gKi9cbnZhciBMb2NhdGlvblZpZXcgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfY2FsbGJhY2ssXG4gICAgICBfaW5jbHVkZUNvb3JkaW5hdGVDb250cm9sLFxuICAgICAgX2luY2x1ZGVHZW9jb2RlQ29udHJvbCxcbiAgICAgIF9pbmNsdWRlR2VvbG9jYXRpb25Db250cm9sLFxuICAgICAgX2luY2x1ZGVQb2ludENvbnRyb2wsXG4gICAgICBfbG9jYXRpb25Db250cm9sLFxuICAgICAgX21hcCxcbiAgICAgIF9tYXBDb250YWluZXIsXG4gICAgICBfbW9kYWwsXG5cbiAgICAgIF9jcmVhdGVNYXAsXG4gICAgICBfY3JlYXRlTW9kYWwsXG4gICAgICBfb25Mb2NhdGlvbjtcblxuXG4gIF90aGlzID0gRXZlbnRzKCk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGFyYW1zID0gVXRpbC5leHRlbmQoe30sIERFRkFVTFRTLCBwYXJhbXMgfHwge30pO1xuXG4gICAgX2NhbGxiYWNrID0gcGFyYW1zLmNhbGxiYWNrO1xuICAgIF9pbmNsdWRlUG9pbnRDb250cm9sID0gcGFyYW1zLmluY2x1ZGVQb2ludENvbnRyb2w7XG4gICAgX2luY2x1ZGVHZW9sb2NhdGlvbkNvbnRyb2wgPSBwYXJhbXMuaW5jbHVkZUdlb2xvY2F0aW9uQ29udHJvbDtcbiAgICBfaW5jbHVkZUdlb2NvZGVDb250cm9sID0gcGFyYW1zLmluY2x1ZGVHZW9jb2RlQ29udHJvbDtcbiAgICBfaW5jbHVkZUNvb3JkaW5hdGVDb250cm9sID0gcGFyYW1zLmluY2x1ZGVDb29yZGluYXRlQ29udHJvbDtcblxuICAgIF9jcmVhdGVNYXAoKTsgICAvLyBEZWZpbmVzIHRoaXMuX21hcCBhcyBhIExlYWZsZXQgbWFwXG4gICAgX2NyZWF0ZU1vZGFsKCk7IC8vIERlZmluZXMgdGhpcy5fbW9kYWwgYXMgYSBNb2RhbFZpZXdcblxuICAgIGlmIChwYXJhbXMuYXV0b09wZW4pIHtcbiAgICAgIF90aGlzLnNob3coKTtcbiAgICB9XG5cbiAgICBwYXJhbXMgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAUHJpdmF0ZUluaXRpYWxpemVyXG4gICAqIENhbGxlZCBkdXJpbmcgY29uc3RydWN0aW9uLiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgbWFwIGNvbXBvbmVudC5cbiAgICpcbiAgICogRGVmaW5lczpcbiAgICogICAgICBfbWFwIHtMLk1hcH1cbiAgICogICAgICBfbWFwQ29udGFpbmVyIHtEb21FbGVtZW50fVxuICAgKiAgICAgIF9sb2NhdGlvbkNvbnRyb2wge0xvY2F0aW9uQ29udHJvbH1cbiAgICpcbiAgICovXG4gIF9jcmVhdGVNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxheWVyQ29udHJvbCA9IG5ldyBMLkNvbnRyb2wuTGF5ZXJzKCk7XG5cbiAgICBfbWFwQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX21hcENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdsb2NhdGlvbnZpZXctbWFwJyk7XG5cbiAgICBfbWFwID0gbmV3IEwuTWFwKF9tYXBDb250YWluZXIsIHtcbiAgICAgIHpvb21Db250cm9sOiAhVXRpbC5pc01vYmlsZSgpLFxuICAgICAgYXR0cmlidXRpb25Db250cm9sOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgX21hcC5maXRCb3VuZHMoW1s3MC4wLCAtMTcwLjBdLCBbLTUwLjAsIDE3MC4wXV0pO1xuXG4gICAgbGF5ZXJDb250cm9sLmFkZEJhc2VMYXllcihuZXcgTC5UaWxlTGF5ZXIoXG4gICAgICAgIF9fZ2V0X2FyY2dpc29ubGluZV91cmwoJ05hdEdlb19Xb3JsZF9NYXAnKSlcbiAgICAgICAgLmFkZFRvKF9tYXApLCAnVG9wb2dyYXBoeScpO1xuICAgIGxheWVyQ29udHJvbC5hZGRCYXNlTGF5ZXIobmV3IEwuVGlsZUxheWVyKFxuICAgICAgICBfX2dldF9hcmNnaXNvbmxpbmVfdXJsKCdDYW52YXMvV29ybGRfTGlnaHRfR3JheV9CYXNlJykpLCAnR3JheXNjYWxlJyk7XG4gICAgbGF5ZXJDb250cm9sLmFkZEJhc2VMYXllcihuZXcgTC5UaWxlTGF5ZXIoXG4gICAgICAgIF9fZ2V0X2FyY2dpc29ubGluZV91cmwoJ1dvcmxkX0ltYWdlcnknKSksICdTYXRlbGxpdGUnKTtcblxuICAgIC8vIFRPRE8gOjogVXNlIGEgcmVhbCBsb2NhdGlvbiBjb250cm9sXG4gICAgX2xvY2F0aW9uQ29udHJvbCA9IG5ldyBMb2NhdGlvbkNvbnRyb2woe1xuICAgICAgZWw6IF9tYXBDb250YWluZXIsXG4gICAgICBpbmNsdWRlUG9pbnRDb250cm9sOiBfaW5jbHVkZVBvaW50Q29udHJvbCxcbiAgICAgIGluY2x1ZGVDb29yZGluYXRlQ29udHJvbDogX2luY2x1ZGVDb29yZGluYXRlQ29udHJvbCxcbiAgICAgIGluY2x1ZGVHZW9jb2RlQ29udHJvbDogX2luY2x1ZGVHZW9jb2RlQ29udHJvbCxcbiAgICAgIGluY2x1ZGVHZW9sb2NhdGlvbkNvbnRyb2w6IF9pbmNsdWRlR2VvbG9jYXRpb25Db250cm9sXG4gICAgfSk7XG4gICAgX2xvY2F0aW9uQ29udHJvbC5lbmFibGUoKTtcbiAgICBfbWFwLmFkZENvbnRyb2wobGF5ZXJDb250cm9sKTsgICAgICAgICAgLy8gTGF5ZXIgc3dpdGNoZXJcbiAgICBfbWFwLmFkZENvbnRyb2woX2xvY2F0aW9uQ29udHJvbCk7IC8vIE1ldGhvZHMgdG8gc2V0IGxvY2F0aW9uc1xuICB9O1xuXG4gIC8qKlxuICAgKiBAUHJpdmF0ZUluaXRpYWxpemVyXG4gICAqIENhbGxlZCBkdXJpbmcgY29uc3RydWN0aW9uLiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgbW9kYWwgY29tcG9uZW50LlxuICAgKlxuICAgKiBEZWZpbmVzOlxuICAgKiAgICAgIHRoaXMuX21vZGFsIHtNb2RhbFZpZXd9XG4gICAqXG4gICAqL1xuICBfY3JlYXRlTW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgX21vZGFsID0gbmV3IE1vZGFsVmlldyhfbWFwQ29udGFpbmVyLCB7XG4gICAgICB0aXRsZTogJ1NwZWNpZnkgYSBMb2NhdGlvbicsXG4gICAgICBjbGFzc2VzOiBbJ2xvY2F0aW9udmlldyddLFxuICAgICAgYnV0dG9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgdGV4dDogJ1VzZSB0aGlzIExvY2F0aW9uJyxcbiAgICAgICAgICBjbGFzc2VzOiBbJ2xvY2F0aW9udmlldy1idXR0b24nXSxcbiAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2NhbGxiYWNrKF9sb2NhdGlvbkNvbnRyb2wuZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgICBfbW9kYWwuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICAgIF9sb2NhdGlvbkNvbnRyb2wub24oJ2xvY2F0aW9uJywgX29uTG9jYXRpb24pO1xuICAgIC8qIENhbGxlZCBpbml0aWFsbHkgdG8gZGlzYWJsZSB0aGUgYnV0dG9uIGlmIHlvdSBlbnRlciB0aGUgbG9jYXRpb24gdmlld1xuICAgICAqIHdpdGggbm8gbG9jYXRpb24gaW5mb3JtYXRpb24sIG9yIGVuYWJsZSBpdCBpZiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBleGlzdHNcbiAgICAgKi9cbiAgICBfb25Mb2NhdGlvbigpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBQcml2YXRlSW5pdGlhbGl6ZXJcbiAgICogVG9nZ2xlcyB0aGUgXCJVc2UgdGhpcyBMb2NhdGlvblwiIGJ1dHRvbiBpbiB0aGUgZm9vdGVyIG9mIHRoZSBtb2RhbCB2aWV3IHRvXG4gICAqIHRvIGJlIGRpc2FibGVkIHdoZW4gdGhlIGxvY2F0aW9uIGlzIG51bGwgYW5kIGVuYWJsZWQgb3RoZXJ3aXNlLlxuICAgKlxuICAgKi9cbiAgX29uTG9jYXRpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBidXR0b24gPSBfbW9kYWwuZWwucXVlcnlTZWxlY3RvcignLmxvY2F0aW9udmlldy1idXR0b24nKSxcbiAgICAgICAgbG9jYXRpb247XG5cbiAgICBpZiAoZSkge1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgICBsb2NhdGlvbiA9IGUubG9jYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMudHJpZ2dlcignbG9jYXRpb24nLCBsb2NhdGlvbik7XG5cbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdVc2UgdGhpcyBMb2NhdGlvbic7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnbG9jYXRpb252aWV3LWJ1dHRvbi1lbmFibGVkJyk7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnbG9jYXRpb252aWV3LWJ1dHRvbi1kaXNhYmxlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdObyBMb2NhdGlvbiBTZWxlY3RlZCc7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnbG9jYXRpb252aWV3LWJ1dHRvbi1kaXNhYmxlZCcpO1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2xvY2F0aW9udmlldy1idXR0b24tZW5hYmxlZCcpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAQVBJTWV0aG9kXG4gICAqIEhpZGVzIHRoZSBMb2NhdGlvblZpZXcuXG4gICAqXG4gICAqL1xuICBfdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIF9tb2RhbC5oaWRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBBUElNZXRob2RcbiAgICogU2hvd3MgdGhlIExvY2F0aW9uVmlldy4gSWYgbm8gb3B0aW9ucyBhcmUgc3BlY2lmaWVkLCB0aGVyZSBpcyBubyBkZWZhdWx0XG4gICAqIGxvY2F0aW9uIGRpc3BsYXllZCBhbmQgdGhlIG1hcCB3aWxsIHNob3cgcm91Z2hseSBvbmUgaW5zdGFuY2Ugb2YgdGhlXG4gICAqIGVudGlyZSB3b3JsZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgZGVmYXVsdCBleHRlbnQgYW5kIGxvY2F0aW9uIHdoZW4gdGhlXG4gICAqICAgICAgICBMb2NhdGlvblZpZXcgaXMgc2hvd24uXG4gICAqXG4gICAqICAgICAgICBleHRlbnQge0FycmF5e0FycmF5e051bWJlcn19fVxuICAgKiAgICAgICAgICAgICBBbiBhcnJheSBkZWZpbmluZyB0aGUgbWFwIGV4dGVudC4gVGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhpc1xuICAgKiAgICAgICAgICAgICBhcnJheSBpcyBhbiBhcnJheSBjb250YWluaW5nIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZVxuICAgKiAgICAgICAgICAgICBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC5cbiAgICogICAgICAgICAgICAgVGhlIHNlY29uZCBlbGVtZW50IG9mIHRoaXMgYXJyYXkgaXMgYW4gYXJyYXkgY29udGFpbmluZ1xuICAgKiAgICAgICAgICAgICBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBvZiB0aGUgYm90dG9tXG4gICAqICAgICAgICAgICAgIHJpZ2h0IGNvcm5lciBvZiB0aGUgZXh0ZW50LlxuICAgKiAgICAgICAgbG9jYXRpb24ge09iamVjdH1cbiAgICogICAgICAgICAgICAgQSBsb2NhdGlvbiBvYmplY3QgdG8gdXNlIGFzIHRoZSBzdGFydGluZyBsb2NhdGlvbi4gVGhpc1xuICAgKiAgICAgICAgICAgICBsb2NhdGlvbiB3aWxsIGJlIGRpc3BsYXllZCBpbml0aWFsbHkgYW5kIGFsc28gcmV0dXJuZWQgaWYgdGhlXG4gICAqICAgICAgICAgICAgIHVzZXIgZG9lcyBub3QgY2hhbmdlIGl0LiBJZiBudWxsLCBhbnkgcHJldmlvdXNseSBzZXQgbG9jYXRpb25cbiAgICogICAgICAgICAgICAgaXMgY2xlYXJlZC5cbiAgICovXG4gIF90aGlzLnNob3cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF9tb2RhbC5zaG93KCk7XG4gICAgX3RoaXMudXBkYXRlTWFwKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAQVBJTWV0aG9kXG4gICAqIFNldHMgaW5pdGlhbCBtYXAgZGlzcGxheSB3aGVuIHNob3dpbmcgdGhlIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogICAgICAgIE9wdGlvbnMgZm9yIHNldHRpbmcgaW5pdGlhbCBtYXAgZGlzcGxheSBwcm9wZXJ0aWVzIHdoZW4gc2hvd2luZ1xuICAgKiAgICAgICAgdGhlIGxvY2F0aW9uIHZpZXcuIFNlZSBMb2NhdGlvblZpZXcuc2hvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgX3RoaXMudXBkYXRlTWFwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfbWFwLmludmFsaWRhdGVTaXplKCk7XG5cbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbG9jYXRpb24nKSkge1xuICAgICAgX2xvY2F0aW9uQ29udHJvbC5zZXRMb2NhdGlvbihvcHRpb25zLmxvY2F0aW9uKTtcbiAgICAgIF9sb2NhdGlvbkNvbnRyb2wuZGlzYWJsZSgpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdleHRlbnQnKSkge1xuICAgICAgX21hcC5maXRCb3VuZHMob3B0aW9ucy5leHRlbnQpO1xuICAgIH1cbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKCk7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhdGlvblZpZXc7XG4iLCIvKiBnbG9iYWwgTCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29uZmlkZW5jZUNhbGN1bGF0b3IgPSByZXF1aXJlKCdsb2NhdGlvbnZpZXcvQ29uZmlkZW5jZUNhbGN1bGF0b3InKTtcblxuXG52YXIgQ0xBU1NfTkFNRSA9ICdsb2NhdGlvbi1wb2ludC1jb250cm9sJztcbnZhciBDTEFTU19FTkFCTEVEID0gJ2xvY2F0aW9uLWNvbnRyb2wtZW5hYmxlZCc7XG52YXIgQ0xBU1NfTE9DQVRJT04gPSBDTEFTU19OQU1FICsgJy1hY3RpdmUnO1xudmFyIE1FVEhPRCA9ICdwb2ludCc7XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIG1ldGhvZDogTUVUSE9ELFxuICBwb3NpdGlvbjogJ3RvcGxlZnQnLFxuICBkZWZhdWx0TG9jYXRpb246IG51bGwsXG4gIGRlZmF1bHRFbmFibGVkOiBmYWxzZSxcbiAgaWNvbkNsYXNzOiAnbG9jYXRpb24tY29udHJvbC1pY29uJyxcbiAgaGVscFRleHQ6ICdEcm9wIFBpbicsXG4gIGluZm9UZXh0OiAnPGI+RHJvcCBwaW48L2I+IG9uIHRoZSBtYXAgdG8gc3BlY2lmeSBhIGxvY2F0aW9uLidcbn07XG5cblxudmFyIFBvaW50Q29udHJvbCA9IEwuQ29udHJvbC5leHRlbmQoe1xuICBpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXG5cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gTC5VdGlsLmV4dGVuZCh7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2lzRW5hYmxlZCA9IG9wdGlvbnMuZGVmYXVsdEVuYWJsZWQ7XG4gICAgdGhpcy5fbWFya2VyID0gbmV3IEwuTWFya2VyKFswLCAwXSwge2RyYWdnYWJsZTogdHJ1ZX0pO1xuICAgIHRoaXMuX21hcmtlci5iaW5kUG9wdXAoKTtcbiAgICB0aGlzLnNldExvY2F0aW9uKG9wdGlvbnMuZGVmYXVsdExvY2F0aW9uKTtcbiAgfSxcblxuICBzZXRMb2NhdGlvbjogZnVuY3Rpb24gKGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgbWFya2VyID0gdGhpcy5fbWFya2VyO1xuXG4gICAgaWYgKGxvY2F0aW9uICE9PSBudWxsKSB7XG4gICAgICAvLyB1cGRhdGUgbWFya2VyXG4gICAgICBtYXJrZXIuc2V0TGF0TG5nKG5ldyBMLkxhdExuZyhsb2NhdGlvbi5sYXRpdHVkZSwgbG9jYXRpb24ubG9uZ2l0dWRlKSk7XG4gICAgICBtYXJrZXIuc2V0UG9wdXBDb250ZW50KHRoaXMuX2Zvcm1hdExvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICAvLyBhZGQgbWFya2VyXG4gICAgICBpZiAobWFwICYmICFtYXJrZXIuX21hcCkge1xuICAgICAgICBtYXJrZXIuYWRkVG8obWFwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2xlYXIgcG9wdXAgY29udGVudFxuICAgICAgbWFya2VyLnNldFBvcHVwQ29udGVudCgnJyk7XG4gICAgICAvLyByZW1vdmUgbWFya2VyXG4gICAgICBpZiAobWFwICYmIG1hcmtlci5fbWFwKSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihtYXJrZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2lsZW50JykgJiYgb3B0aW9ucy5zaWxlbnQpKSB7XG4gICAgICB0aGlzLmZpcmUoJ2xvY2F0aW9uJywgeydsb2NhdGlvbic6IGxvY2F0aW9ufSk7XG4gICAgfVxuICB9LFxuXG4gIGdldExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9tYXJrZXIuX21hcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVQb2ludExvY2F0aW9uKHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKSk7XG4gIH0sXG5cbiAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgc3RvcCA9IEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHRvZ2dsZTtcblxuICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdsb2NhdGlvbi1jb250cm9sJyk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRSk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IFtcbiAgICAgICc8YSBjbGFzcz1cIicsIG9wdGlvbnMuaWNvbkNsYXNzLCAnXCI+PC9hPicsXG4gICAgICAnPHNwYW4gY2xhc3M9XCJoZWxwXCI+Jywgb3B0aW9ucy5oZWxwVGV4dCwgJzwvc3Bhbj4nXG4gICAgXS5qb2luKCcnKTtcblxuICAgIHRvZ2dsZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhJyk7XG5cbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuX3RvZ2dsZSA9IHRvZ2dsZTtcblxuICAgIC8vIElmIGVuYWJsZWQsIGJpbmQgbWFwIGNsaWNrIGhhbmRsZXJzXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWZhdWx0RW5hYmxlZCkge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG5cbiAgICAvLyBFbmFibGUvZGlzYWJsZSBjb250cm9sIGlmIHVzZXIgY2xpY2tzIG9uIGl0XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcih0b2dnbGUsICdjbGljaycsIHRoaXMudG9nZ2xlLCB0aGlzKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2NsaWNrJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdkYmxjbGljaycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAna2V5ZG93bicsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAna2V5dXAnLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2tleXByZXNzJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihjb250YWluZXIsICdtb3VzZWRvd24nLCBzdG9wKTtcbiAgICB0aGlzLl9tYXJrZXIub24oJ2RyYWdlbmQnLCB0aGlzLl9vbkRyYWdFbmQsIHRoaXMpO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfSxcblxuICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICAgIHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24sXG4gICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgICAgICAgdG9nZ2xlID0gdGhpcy5fdG9nZ2xlO1xuXG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuXG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcih0b2dnbGUsICdjbGljaycsIHRoaXMudG9nZ2xlKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRhaW5lciwgJ2NsaWNrJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250YWluZXIsICdkYmxjbGljaycsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGFpbmVyLCAna2V5ZG93bicsIHN0b3ApO1xuICAgIEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGFpbmVyLCAna2V5dXAnLCBzdG9wKTtcbiAgICBMLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRhaW5lciwgJ2tleXByZXNzJywgc3RvcCk7XG4gICAgTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lcihjb250YWluZXIsICdtb3VzZWRvd24nLCBzdG9wKTtcbiAgICB0aGlzLl9tYXJrZXIub2ZmKCdkcmFnZW5kJywgdGhpcy5fb25EcmFnRW5kLCB0aGlzKTtcblxuICAgIG1hcC5yZW1vdmVMYXllcih0aGlzLl9tYXJrZXIpO1xuXG4gICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuX3RvZ2dsZSA9IG51bGw7XG4gIH0sXG5cbiAgX2JpbmRNYXBFdmVudEhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICAgIHRoaXMuX21hcC5vbignYm94em9vbXN0YXJ0JywgdGhpcy5fb25Cb3hab29tU3RhcnQsIHRoaXMpO1xuICB9LFxuXG4gIF91bmJpbmRNYXBFdmVudEhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcbiAgICB0aGlzLl9tYXAub2ZmKCdib3h6b29tc3RhcnQnLCB0aGlzLl9vbkJveFpvb21TdGFydCwgdGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1hcCBldmVudCBsaXN0ZW5lci4gVGhpcyBsaXN0ZW5lciBpcyBvbmx5IGFjdGl2ZSB3aGVuIHRoaXMgY29udHJvbCBpc1xuICAgKiBlbmFibGVkLiBUaGUgX3t1bn1iaW5kTWFwRXZlbnRIYW5kbGVycyBtZXRob2RzIHdpbGwgYWRkIGFuZCByZW1vdmUgdGhlXG4gICAqIGxpc3RlbmVyIHRoYXQgYWN0aXZhdGVzIHRoaXMgbWV0aG9kIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSBtb3VzZUV2ZW50IHtNb3VzZUV2ZW50fVxuICAgKi9cbiAgX29uQ2xpY2s6IGZ1bmN0aW9uIChtb3VzZUV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2JveFpvb21TdGFydGVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9ib3hab29tU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldExvY2F0aW9uKHRoaXMuX2NyZWF0ZVBvaW50TG9jYXRpb24obW91c2VFdmVudC5sYXRsbmcpKTtcbiAgfSxcblxuICBfb25EcmFnRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXRMb2NhdGlvbih0aGlzLl9jcmVhdGVQb2ludExvY2F0aW9uKHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKSkpO1xuICB9LFxuXG4gIF9vbkJveFpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JveFpvb21TdGFydGVkID0gdHJ1ZTtcbiAgfSxcblxuICBfY3JlYXRlUG9pbnRMb2NhdGlvbjogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgIHJldHVybiB7XG4gICAgICBwbGFjZTogbnVsbCxcbiAgICAgIGxhdGl0dWRlOiBsYXRsbmcubGF0LFxuICAgICAgbG9uZ2l0dWRlOiBsYXRsbmcubG5nLFxuICAgICAgbWV0aG9kOiBNRVRIT0QsXG4gICAgICBjb25maWRlbmNlOiB0aGlzLl9jb21wdXRlQ29uZmlkZW5jZSgpXG4gICAgfTtcbiAgfSxcblxuICBfY29tcHV0ZUNvbmZpZGVuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQ29uZmlkZW5jZUNhbGN1bGF0b3IuY29tcHV0ZUZyb21Qb2ludCh0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgfSxcblxuICB0b2dnbGU6IGZ1bmN0aW9uIChjbGlja0V2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgfVxuICAgIEwuRG9tRXZlbnQuc3RvcChjbGlja0V2ZW50KTtcbiAgfSxcblxuICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWFwQ29udGFpbmVyID0gdGhpcy5fbWFwLmdldENvbnRhaW5lcigpO1xuXG4gICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgQ0xBU1NfRU5BQkxFRCk7XG4gICAgTC5Eb21VdGlsLmFkZENsYXNzKG1hcENvbnRhaW5lciwgQ0xBU1NfTE9DQVRJT04pO1xuXG4gICAgdGhpcy5fYmluZE1hcEV2ZW50SGFuZGxlcnMoKTtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuX2JveFpvb21TdGFydGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmZpcmUoJ2VuYWJsZWQnKTtcbiAgfSxcblxuICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcENvbnRhaW5lciA9IHRoaXMuX21hcCA/IHRoaXMuX21hcC5nZXRDb250YWluZXIoKSA6IG51bGw7XG5cbiAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCBDTEFTU19FTkFCTEVEKTtcbiAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3MobWFwQ29udGFpbmVyLCBDTEFTU19MT0NBVElPTik7XG5cbiAgICB0aGlzLl91bmJpbmRNYXBFdmVudEhhbmRsZXJzKCk7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmZpcmUoJ2Rpc2FibGVkJyk7XG4gIH0sXG5cbiAgX2Zvcm1hdExvY2F0aW9uOiBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICB2YXIgbGF0ID0gbG9jYXRpb24ubGF0aXR1ZGUsXG4gICAgICAgIGxuZyA9IGxvY2F0aW9uLmxvbmdpdHVkZSxcbiAgICAgICAgY29uZmlkZW5jZSA9IGxvY2F0aW9uLmNvbmZpZGVuY2UsXG4gICAgICAgIHBsYWNlID0gbG9jYXRpb24ucGxhY2UsXG4gICAgICAgIGxhdFN0ciA9IChsYXQgPCAwLjApID8gJyZkZWc7UycgOiAnJmRlZztOJyxcbiAgICAgICAgbG5nU3RyID0gKGxuZyA8IDAuMCkgPyAnJmRlZztXJyA6ICcmZGVnO0UnLFxuICAgICAgICBidWYgPSBbXTtcblxuICAgIGxhdCA9IENvbmZpZGVuY2VDYWxjdWxhdG9yLnJvdW5kTG9jYXRpb24oTWF0aC5hYnMobGF0KSwgY29uZmlkZW5jZSk7XG4gICAgbG5nID0gQ29uZmlkZW5jZUNhbGN1bGF0b3Iucm91bmRMb2NhdGlvbihNYXRoLmFicyhsbmcpLCBjb25maWRlbmNlKTtcblxuICAgIGlmIChwbGFjZSAhPT0gbnVsbCkge1xuICAgICAgYnVmLnB1c2goJzxwPicsIHBsYWNlLCAnPC9wPicpO1xuICAgIH1cbiAgICBidWYucHVzaChsYXQsIGxhdFN0ciwgJywgJywgbG5nLCBsbmdTdHIpO1xuICAgIHJldHVybiBidWYuam9pbignJyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50Q29udHJvbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKSxcbiAgICBWaWV3ID0gcmVxdWlyZSgnbXZjL1ZpZXcnKTtcblxuXG4vLyBEZWZhdWx0IHZhbHVlcyB1c2VkIGJ5IGNvbnN0cnVjdG9yLlxudmFyIF9ERUZBVUxUUyA9IHtcbiAgLy8gbGFiZWwgLSBUaGUgcXVlc3Rpb24gYmVpbmcgYXNrZWRcbiAgbGFiZWw6IG51bGwsXG4gIC8vIG11bHRpU2VsZWN0IC0gZmFsc2UgPSByYWRpbyBidXR0b25zLCB0cnVlID0gb3IgY2hlY2tib3hlcywgcmFkaW8gaXMgZGVmYXVsdFxuICBtdWx0aVNlbGVjdDogZmFsc2UsXG4gIC8vIHNlbGVjdGVkQW5zd2VyIC0gQW55IGFuc3dlcnMgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQgYnkgZGVmYXVsdFxuICBzZWxlY3RlZEFuc3dlcjogbnVsbCxcbiAgLy8gYW5zd2VycyAtIEFycmF5IG9mIGFuc3dlcnMsIGVhY2ggd2l0aCBhdHRyaWJ1dGVzOlxuICAvLyAgICAgIHZhbHVlIC0gVGhlIFwidmFsdWVcIiBmb3IgdGhlIGlucHV0XG4gIC8vICAgICAgbGFiZWwgLSBUaGUgYW5zd2VyIHRvIHNob3cgdGhlIHVzZXJcbiAgLy8gICAgICBvdGhlclZhbHVlIC0gT3B0aW9uYWwgZXh0cmEgdmFsdWUgZm9yIG1vcmUgaW5mb1xuICAvLyAgICAgIG90aGVyTGFiZWwgLSBRdWVzdGlvbiB0byBhc2sgYXNzb2NpYXRlIHdpdGggb3RoZXJWYWx1ZVxuICBhbnN3ZXJzOiBudWxsXG59O1xuXG52YXIgX0lEX1NFUVVFTkNFID0gMDtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbml0aWFsaXphdGlvbiBNZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQ2xhc3M6IFF1ZXN0aW9uVmlld1xuICogQ3JlYXRlcyBhIG5ldyBRdWVzdGlvblZpZXcuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFNlZSBfREVGQVVMVFMgYWJvdmUgZm9yXG4gKiAgICAgICAgZGV0YWlsZWQgZG9jdW1lbnRhdGlvbiBvbiB3aGF0IGNhbiBiZSBzcGVjaWZpZWQuXG4gKi9cbnZhciBRdWVzdGlvblZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2Fuc3dlckluZGV4LFxuICAgICAgX2Fuc3dlckxpc3QsXG4gICAgICBfb3B0aW9ucyxcblxuICAgICAgX2FkZEFuc3dlcixcbiAgICAgIF9hZGRBbnN3ZXJzLFxuICAgICAgX29uQmx1cixcbiAgICAgIF9vbkNoYW5nZTtcblxuXG4gIF90aGlzID0gVmlldyhvcHRpb25zKTtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBzZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuXG4gICAgX29wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgICBfYW5zd2VySW5kZXggPSBbXTtcblxuICAgIHNlY3Rpb24uY2xhc3NMaXN0LmFkZCgncXVlc3Rpb24nKTtcblxuICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQoX2FkZEFuc3dlcnMoKSk7XG5cbiAgICBfdGhpcy5zZXRBbnN3ZXJzKF9vcHRpb25zLnNlbGVjdGVkQW5zd2VyKTtcblxuICAgIF90aGlzLmVsLmlubmVySFRNTCA9ICcnO1xuICAgIF90aGlzLmVsLmFwcGVuZENoaWxkKHNlY3Rpb24pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFdyYXAgYSBzaW5nbGUgYW5zd2VyIGluIGFwcHJvcHJpYXRlIGh0bWwuXG4gICAqXG4gICAqIEBwYXJhbSBhbnN3ZXIge09iamVjdH1cbiAgICogICAgICAgIHFJZCB7SW50ZWdlcn0gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBxdWVzdGlvblxuICAgKiAgICAgICAgdWwge0RvY3VtZW50LkVsZW1lbnR9IENvbnRhaW5lciBlbGVtZW50IGZvciB0aGUgYW5zd2Vyc1xuICAgKlxuICAgKiBAcmV0dXJuIFN0cmluZ1xuICAgKiAgICAgICAgIENvbnRhaW5zIGFuIGFuc3dlciB3cmFwcGVkIGluIGFwcHJvcHJpYXRlIEhUTUwuXG4gICAqXG4gICAqL1xuICBfYWRkQW5zd2VyID0gZnVuY3Rpb24gKGFuc3dlciwgcUlkLCB1bCkge1xuICAgIHZhciBfbGFiZWwgPSBhbnN3ZXIubGFiZWwsXG4gICAgICAgIF9vdGhlckxhYmVsID0gYW5zd2VyLm90aGVyTGFiZWwsXG4gICAgICAgIF9vdGhlclZhbHVlID0gYW5zd2VyLm90aGVyVmFsdWUsXG4gICAgICAgIF92YWx1ZSA9IGFuc3dlci52YWx1ZSxcbiAgICAgICAgYW5zd2VySWQgPSAnYW5zd2VyLScgKyAoKytfSURfU0VRVUVOQ0UpLFxuICAgICAgICBpbnB1dFR5cGUgPSAoX29wdGlvbnMubXVsdGlTZWxlY3QgPyAnY2hlY2tib3gnIDogJ3JhZGlvJyksXG4gICAgICAgIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSxcbiAgICAgICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxuICAgICAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JyksXG4gICAgICAgIGFuc3dlclRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShfbGFiZWwpO1xuXG4gICAgaW5wdXQudHlwZSA9IGlucHV0VHlwZTtcbiAgICBpbnB1dC5uYW1lID0gcUlkO1xuICAgIGlucHV0LmlkID0gYW5zd2VySWQ7XG4gICAgaW5wdXQudmFsdWUgPSBfdmFsdWU7XG5cbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIGFuc3dlcklkKTtcbiAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdhbnN3ZXInKTtcbiAgICBsYWJlbC5hcHBlbmRDaGlsZChhbnN3ZXJUZXh0KTtcblxuICAgIGxpLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICBsaS5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgICBpZiAodHlwZW9mIF9vdGhlckxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHRleHRib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgdGV4dGJveC50eXBlID0gJ3RleHQnO1xuICAgICAgdGV4dGJveC5uYW1lID0gcUlkICsgJy1vdGhlcic7XG4gICAgICB0ZXh0Ym94LmlkID0gYW5zd2VySWQgKyAnLW90aGVyJztcbiAgICAgIHRleHRib3gudmFsdWUgPSBfb3RoZXJWYWx1ZTtcbiAgICAgIHRleHRib3guY2xhc3NMaXN0LmFkZCgncXVlc3Rpb24tb3RoZXInKTtcbiAgICAgIHRleHRib3gucGxhY2Vob2xkZXIgPSBfb3RoZXJMYWJlbDtcbiAgICAgIGxpLmFwcGVuZENoaWxkKHRleHRib3gpO1xuICAgIH1cbiAgICB1bC5hcHBlbmRDaGlsZChsaSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbGwgYW5zd2VycyB0byB0aGUgbGlzdCBvZiBhbnN3ZXJzLlxuICAgKlxuICAgKiBAcmV0dXJuIFN0cmluZ1xuICAgKiAgICAgICAgIENvbnRhaW5zIGEgbGlzdCBvZiBhbnN3ZXIgb3B0aW9ucyB3cmFwcGVkIGluIGFwcHJvcHJpYXRlIEhUTUwuXG4gICAqXG4gICAqL1xuICBfYWRkQW5zd2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYW5zd2VycyA9IF9vcHRpb25zLmFuc3dlcnMsXG4gICAgICAgIGFuc3dlckVsZW1lbnQsXG4gICAgICAgIHF1ZXN0aW9uSWQgPSAncXVlc3Rpb24tJyArICgrK19JRF9TRVFVRU5DRSksXG4gICAgICAgIGxlZ2VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xlZ2VuZCcpLFxuICAgICAgICB1bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyksXG4gICAgICAgIGFuc3dlckluZGV4ID0gX2Fuc3dlckluZGV4LFxuICAgICAgICBhbnN3ZXIsXG4gICAgICAgIGksXG4gICAgICAgIGxlbjtcblxuICAgIHVsLmNsYXNzTGlzdC5hZGQoJ3F1ZXN0aW9uLWFuc3dlcnMnKTtcbiAgICBfYW5zd2VyTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ZpZWxkc2V0Jyk7XG4gICAgX2Fuc3dlckxpc3QubmFtZSA9IHF1ZXN0aW9uSWQ7XG4gICAgbGVnZW5kLnRleHRDb250ZW50ID0gb3B0aW9ucy5sYWJlbDtcbiAgICBfYW5zd2VyTGlzdC5hcHBlbmRDaGlsZChsZWdlbmQpO1xuXG4gICAgaWYgKGFuc3dlcnMgIT09IG51bGwpIHtcbiAgICAgIGZvciAoaT0wLCBsZW49YW5zd2Vycy5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgX2FkZEFuc3dlcihhbnN3ZXJzW2ldLCBxdWVzdGlvbklkLCB1bCk7XG4gICAgICB9XG4gICAgICBfYW5zd2VyTGlzdC5hcHBlbmRDaGlsZCh1bCk7XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgYW5zd2VycyB3aXRoIGFycmF5IG9mIGFuc3dlciBvYmplY3RzLlxuICAgICAgZm9yIChpPTAsIGxlbj1hbnN3ZXJzLmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICBhbnN3ZXIgPSBhbnN3ZXJzW2ldO1xuXG4gICAgICAgIGFuc3dlckluZGV4W2Fuc3dlci52YWx1ZV0gPSBpO1xuICAgICAgfVxuXG4gICAgICBhbnN3ZXJFbGVtZW50ID0gX2Fuc3dlckxpc3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJyk7XG4gICAgICBmb3IgKGk9MCwgbGVuPWFuc3dlckVsZW1lbnQubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBhbnN3ZXJFbGVtZW50W2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpO1xuICAgICAgICBpbnB1dHNbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgX29uQ2hhbmdlKTtcbiAgICAgICAgaWYgKGlucHV0c1sxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5wdXRzWzFdLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBfb25CbHVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYW5zd2VyTGlzdDtcbiAgfTtcblxuICAvKipcbiAgICogRXZlbnQgbGlzdGVuZXIgZm9yIFwib3RoZXJcIiBpbnB1dHMuXG4gICAqIFRleHQgYm94ZXMuXG4gICAqICAgICAgSWYgdGhlIHZhbHVlIGluIHRoZSB0ZXh0IGJveCBjaGFuZ2VzLCBzYXZlIHRoZSBjaGFuZ2UuXG4gICAqXG4gICAqL1xuICBfb25CbHVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIF90YXJnZXQgPSBldi50YXJnZXQsXG4gICAgICAgIGFuc3dlcnMgPSBfb3B0aW9ucy5hbnN3ZXJzLFxuICAgICAgICBhbnN3ZXJFbGVtZW50ID0gX2Fuc3dlckxpc3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJyksXG4gICAgICAgIGksXG4gICAgICAgIGxlbiA9IGFuc3dlckVsZW1lbnQubGVuZ3RoO1xuXG4gICAgZm9yIChpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgIHZhciBpbnB1dHMgPSBhbnN3ZXJFbGVtZW50W2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpO1xuICAgICAgaWYgKGlucHV0c1sxXSA9PT0gX3RhcmdldCkge1xuICAgICAgICBpZiAoYW5zd2Vyc1tpXS5vdGhlclZhbHVlICE9PSBfdGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgYW5zd2Vyc1tpXS5vdGhlclZhbHVlID0gX3RhcmdldC52YWx1ZTtcbiAgICAgICAgICBfdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCBfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVudCBsaXN0ZW5lciBmb3IgXCJvdGhlclwiIGlucHV0cy5cbiAgICogUmFkaW8gYnV0dG9ucyAmIGNoZWNrIGJveGVzLlxuICAgKiAgICAgICBFbmFibGUgb3IgZGlzYWJsZSB0ZXh0IGJveGVzIGFzc29jaWF0ZWQgd2l0aCBcIm90aGVyXCIuXG4gICAqICAgICAgIFB1dCBmb2N1cyBpbiB0ZXh0IGJveCB3aGVuIGFzc29jaWF0ZWQgcmFkaW8vY2hlY2tib3ggaXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqL1xuICBfb25DaGFuZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICB2YXIgX3RhcmdldCA9IGV2LnRhcmdldCxcbiAgICAgICAgYW5zd2VyRWxlbWVudCA9IF9hbnN3ZXJMaXN0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpLFxuICAgICAgICBpLFxuICAgICAgICBsZW4gPSBhbnN3ZXJFbGVtZW50Lmxlbmd0aCxcbiAgICAgICAgY2hlY2tlZDtcblxuICAgIGZvciAoaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICB2YXIgaW5wdXRzID0gYW5zd2VyRWxlbWVudFtpXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFuIFwib3RoZXJcIiBpbnB1dCB0ZXh0Ym94XG4gICAgICBpZiAoaW5wdXRzWzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2hlY2tlZCA9IGlucHV0c1swXS5jaGVja2VkO1xuICAgICAgICBpbnB1dHNbMV0uZGlzYWJsZWQgPSAhY2hlY2tlZDtcbiAgICAgICAgLy8gSWYgdGhlIFwib3RoZXJcIiBpbnB1dCBjaGVja2JveCBmb3IgdGhpcyB0ZXh0Ym94IGlzIHRhcmdldFxuICAgICAgICBpZiAoaW5wdXRzWzBdID09PSBfdGFyZ2V0ICYmIGNoZWNrZWQpIHtcbiAgICAgICAgICBpbnB1dHNbMV0uZm9jdXMoKTtcbiAgICAgICAgICBpbnB1dHNbMV0uc2V0U2VsZWN0aW9uUmFuZ2UoMCwgaW5wdXRzWzFdLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMudHJpZ2dlcignY2hhbmdlJywgX3RoaXMpO1xuICB9O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpYyBNZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGFuc3dlcnMuXG4gICAqICAgICAgIFVuY2hlY2sgYWxsIGNoZWNrIGJveGVzIGFuZCByYWRpbyBidXR0b25zLlxuICAgKiAgICAgICBEaXNhYmxlIGFsbCB0ZXh0IGJveGVzIGZvciBcIm90aGVyXCIgZmllbGRzLlxuICAgKi9cbiAgX3RoaXMuY2xlYXJBbnN3ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhbnN3ZXJFbGVtZW50ID0gX2Fuc3dlckxpc3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJyksXG4gICAgICAgIGksXG4gICAgICAgIGxlbiA9IGFuc3dlckVsZW1lbnQubGVuZ3RoO1xuXG4gICAgZm9yIChpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgIHZhciBpbnB1dHMgPSBhbnN3ZXJFbGVtZW50W2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpO1xuICAgICAgaW5wdXRzWzBdLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFuIFwib3RoZXJcIiBpbnB1dCB0ZXh0Ym94XG4gICAgICBpZiAoaW5wdXRzWzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5wdXRzWzFdLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGV2ZW50IGxpc3RlbmVycywgcmVtb3ZlIGxpc3Qgb2YgYW5zd2Vyc1xuICAgKlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYW5zd2VyRWxlbWVudCA9IF9hbnN3ZXJMaXN0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpLFxuICAgICAgICBpLFxuICAgICAgICBsZW4gPSBhbnN3ZXJFbGVtZW50Lmxlbmd0aDtcblxuICAgIF9hbnN3ZXJMaXN0ID0gbnVsbDtcbiAgICBmb3IgKGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgdmFyIGlucHV0cyA9IGFuc3dlckVsZW1lbnRbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0Jyk7XG4gICAgICBpbnB1dHNbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgX29uQ2hhbmdlKTtcbiAgICAgIGlmIChpbnB1dHNbMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbnB1dHNbMV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIF9vbkJsdXIpO1xuICAgICAgfVxuICAgICAgaW5wdXRzID0gbnVsbDtcbiAgICB9XG4gICAgYW5zd2VyRWxlbWVudCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBsaXN0IG9mIGFuc3dlcnMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdHxBcnJheX1cbiAgICogICAgICAgICBOdWxsIGlmIG5vIGFuc3dlcnMgYXJlIHNlbGVjdGVkXG4gICAqICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBzaW5nbGUgYW5zd2VyIGlmIG9ubHkgMSBpcyBzZWxlY3RlZFxuICAgKiAgICAgICAgIEFuIGFycmF5IG9mIGFuc3dlciBvYmplY3RzIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiAxXG4gICAqL1xuICBfdGhpcy5nZXRBbnN3ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50QW5zd2VyID0gW10sXG4gICAgICAgIGFuc3dlckVsZW1lbnQgPSBfYW5zd2VyTGlzdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKSxcbiAgICAgICAgY2hlY2tlZEFuc3dlcixcbiAgICAgICAgaSxcbiAgICAgICAgbGVuID0gYW5zd2VyRWxlbWVudC5sZW5ndGg7XG5cbiAgICBmb3IgKGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgdmFyIGlucHV0cyA9IGFuc3dlckVsZW1lbnRbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0Jyk7XG4gICAgICBpZiAoaW5wdXRzWzBdLmNoZWNrZWQpIHtcbiAgICAgICAgaWYgKGlucHV0c1sxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2hlY2tlZEFuc3dlciA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBpbnB1dHNbMF0udmFsdWUsXG4gICAgICAgICAgICBsYWJlbDogYW5zd2VyRWxlbWVudFtpXS5pbm5lclRleHQsXG4gICAgICAgICAgICBvdGhlclZhbHVlOiBpbnB1dHNbMV0udmFsdWUsXG4gICAgICAgICAgICBvdGhlckxhYmVsOiBpbnB1dHNbMV0ucGxhY2Vob2xkZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrZWRBbnN3ZXIgPSB7XG4gICAgICAgICAgICB2YWx1ZTogaW5wdXRzWzBdLnZhbHVlLFxuICAgICAgICAgICAgbGFiZWw6IGFuc3dlckVsZW1lbnRbaV0uaW5uZXJUZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QW5zd2VyLnB1c2goXG4gICAgICAgICAgY2hlY2tlZEFuc3dlclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50QW5zd2VyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChfb3B0aW9ucy5tdWx0aVNlbGVjdCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRBbnN3ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdXJyZW50QW5zd2VyWzBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBpbnB1dC5jaGVja2VkIG9uIGlucHV0IGVsZW1lbnRzLlxuICAgKiBBc3N1bWVzIGEgc3RyaW5nIGZvciB0aGUgXCJ2YWx1ZVwiIG9mIGEgc2luZ2xlIGFuc3dlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9XG4gICAqICAgICAgICBUaGUgXCJ2YWx1ZVwiIG9mIHRoZSBzZWxlY3RlZCBhbnN3ZXIuXG4gICAqL1xuICBfdGhpcy5zZWxlY3RBbnN3ZXJzID0gZnVuY3Rpb24gKGFuc3dlcikge1xuICAgIHZhciBpbnB1dHM7XG5cbiAgICBpZiAodHlwZW9mIGFuc3dlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlucHV0cyA9IGFuc3dlci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcbiAgICAgIGlmIChpbnB1dHNbMF0pIHtcbiAgICAgICAgaW5wdXRzWzBdLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBcIm90aGVyXCIgaW5wdXQgdGV4dGJveFxuICAgICAgICBpZiAoaW5wdXRzWzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbnB1dHNbMV0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmluZHMgYWxsIG9mIHRoZSBzZWxlY3RlZCBhbnN3ZXJzLlxuICAgKiBDYWxscyBzZWxlY3RBbnN3ZXIgd2l0aCBlYWNoIG9mIHRoZW0uXG4gICAqXG4gICAqIEFzc3VtZXMgYSBzdHJpbmcgZm9yIHRoZSB2YWx1ZSBvZiBhIHNpbmdsZSBhbnN3ZXIgaWYgbXVsdGlTZWxlY3Q6ZmFsc2VcbiAgICogQXNzdW1lcyBhbiBhcnJheSBvZiBhbnN3ZXIgdmFsdWVzIGlmIG11bHRpU2VsZWN0OnRydWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9XG4gICAqICAgICAgICBBIHN0cmluZyBjb250YWluaW5nIHRoZSBcInZhbHVlXCIgb2YgdGhlIHNlbGVjdGVkIGFuc3dlci5cbiAgICogICAgICAgIFRoZSBsaXN0IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBhbnN3ZXJzIGFzIHN0cmluZ3MuXG4gICAqL1xuICBfdGhpcy5zZXRBbnN3ZXJzID0gZnVuY3Rpb24gKHNlbGVjdGVkQW5zd2VyKSB7XG4gICAgdmFyIGFuc3dlckVsZW1lbnQsXG4gICAgICAgIGFuc3dlcixcbiAgICAgICAgaSxcbiAgICAgICAgbGVuO1xuXG4gICAgaWYgKF9hbnN3ZXJMaXN0ICE9PSBudWxsKSB7XG4gICAgICBhbnN3ZXJFbGVtZW50ID0gX2Fuc3dlckxpc3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJyk7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBldmVyeXRoaW5nIGlzIHVuY2hlY2tlZCBmaXJzdFxuICAgICAgX3RoaXMuY2xlYXJBbnN3ZXJzKCk7XG5cbiAgICAgIGlmIChzZWxlY3RlZEFuc3dlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ZWRBbnN3ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFuc3dlciA9IGFuc3dlckVsZW1lbnRbX2Fuc3dlckluZGV4W3NlbGVjdGVkQW5zd2VyXV07XG4gICAgICAgIF90aGlzLnNlbGVjdEFuc3dlcnMoYW5zd2VyKTtcbiAgICAgIH0gZWxzZSB7ICAvLyBBcnJheSBvZiBzdHJpbmdzXG4gICAgICAgIGZvciAoaT0wLCBsZW49c2VsZWN0ZWRBbnN3ZXIubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgICAgYW5zd2VyID0gYW5zd2VyRWxlbWVudFtfYW5zd2VySW5kZXhbc2VsZWN0ZWRBbnN3ZXJbaV1dXTtcbiAgICAgICAgICBfdGhpcy5zZWxlY3RBbnN3ZXJzKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXN0aW9uVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvciA9IHJlcXVpcmUoJy4vVmVjdG9yJyk7XG5cblxuLy8gc3RhdGljIG1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFycmF5c1xudmFyIF9fY29sLFxuICAgIF9fZGlhZ29uYWwsXG4gICAgX19nZXQsXG4gICAgX19pZGVudGl0eSxcbiAgICBfX2luZGV4LFxuICAgIF9famFjb2JpLFxuICAgIF9fbXVsdGlwbHksXG4gICAgX19yb3csXG4gICAgX19zZXQsXG4gICAgX19zdHJpbmdpZnksXG4gICAgX190cmFuc3Bvc2U7XG5cblxuLyoqXG4gKiBFeHRyYWN0IGEgY29sdW1uIGZyb20gdGhpcyBtYXRyaXguXG4gKlxuICogQHBhcmFtIGRhdGEge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgbWF0cml4IGRhdGEuXG4gKiBAcGFyYW0gbSB7TnVtYmVyfVxuICogICAgICAgIG51bWJlciBvZiByb3dzLlxuICogQHBhcmFtIG4ge051bWJlcn1cbiAqICAgICAgICBudW1iZXIgb2YgY29sdW1ucy5cbiAqIEBwYXJhbSBjb2wge051bWJlcn1cbiAqICAgICAgICBpbmRleCBvZiBjb2x1bW4sIGluIHJhbmdlIFswLG4pXG4gKiBAdGhyb3dzIEVycm9yIGlmIGNvbHVtbiBvdXQgb2YgcmFuZ2UuXG4gKiBAcmV0dXJuIHtBcnJheTxOdW1iZXI+fSBjb2x1bW4gZWxlbWVudHMuXG4gKi9cbl9fY29sID0gZnVuY3Rpb24gKGRhdGEsIG0sIG4sIGNvbCkge1xuICB2YXIgcm93LFxuICAgICAgdmFsdWVzID0gW107XG4gIGlmIChjb2wgPCAwIHx8IGNvbCA+PSBuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb2x1bW4gJyArIGNvbCArICcgb3V0IG9mIHJhbmdlIFswLCcgKyBuICsgJyknKTtcbiAgfVxuICBpZiAobiA9PT0gMSkge1xuICAgIC8vIG9ubHkgb25lIGNvbHVtbiBpbiBtYXRyaXhcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICB2YWx1ZXMgPSBbXTtcbiAgZm9yIChyb3cgPSAwOyByb3cgPCBtOyByb3crKykge1xuICAgIHZhbHVlcy5wdXNoKGRhdGFbX19pbmRleChtLCBuLCByb3csIGNvbCldKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBHZXQgYXJyYXkgb2YgZWxlbWVudHMgb24gdGhlIGRpYWdvbmFsLlxuICpcbiAqIEBwYXJhbSBkYXRhIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIG1hdHJpeCBkYXRhLlxuICogQHBhcmFtIG0ge051bWJlcn1cbiAqICAgICAgICBudW1iZXIgb2Ygcm93cy5cbiAqIEBwYXJhbSBuIHtOdW1iZXJ9XG4gKiAgICAgICAgbnVtYmVyIG9mIGNvbHVtbnMuXG4gKiBAcmV0dXJuIHtBcnJheTxOdW1iZXI+fSBlbGVtZW50cyBvbiB0aGUgZGlhZ29uYWwuXG4gKi9cbl9fZGlhZ29uYWwgPSBmdW5jdGlvbiAoZGF0YSwgbSwgbikge1xuICB2YXIgbGVuID0gTWF0aC5taW4obSwgbiksXG4gICAgICBkaWFnID0gW10sXG4gICAgICBpO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBkaWFnLnB1c2goZGF0YVtfX2luZGV4KG0sIG4sIGksIGkpXSk7XG4gIH1cbiAgcmV0dXJuIGRpYWc7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCBvZiB0aGlzIG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0gZGF0YSB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICBtYXRyaXggZGF0YS5cbiAqIEBwYXJhbSBtIHtOdW1iZXJ9XG4gKiAgICAgICAgbnVtYmVyIG9mIHJvd3MuXG4gKiBAcGFyYW0gbiB7TnVtYmVyfVxuICogICAgICAgIG51bWJlciBvZiBjb2x1bW5zLlxuICogQHBhcmFtIHJvdyB7TnVtYmVyfVxuICogICAgICAgIHJvdyBvZiBlbGVtZW50LCBpbiByYW5nZSBbMCxtKVxuICogQHBhcmFtIGNvbCB7TnVtYmVyfVxuICogICAgICAgIGNvbHVtbiBvZiBlbGVtZW50LCBpbiByYW5nZSBbMCxuKVxuICogQHRocm93cyBFcnJvciBpZiByb3cgb3IgY29sIGFyZSBvdXQgb2YgcmFuZ2UuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlLlxuICovXG5fX2dldCA9IGZ1bmN0aW9uIChkYXRhLCBtLCBuLCByb3csIGNvbCkge1xuICByZXR1cm4gZGF0YVtfX2luZGV4KG0sIG4sIHJvdywgY29sKV07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpZGVudGl0eSBNYXRyaXguXG4gKlxuICogQHBhcmFtIG4ge051bWJlcn1cbiAqICAgICAgICBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucy5cbiAqIEByZXR1cm4gaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgbi5cbiAqL1xuX19pZGVudGl0eSA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgIHJvdyxcbiAgICAgIGNvbDtcbiAgZm9yIChyb3cgPSAwOyByb3cgPCBuOyByb3crKykge1xuICAgIGZvciAoY29sID0gMDsgY29sIDwgbjsgY29sKyspIHtcbiAgICAgIHZhbHVlcy5wdXNoKChyb3cgPT09IGNvbCkgPyAxIDogMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCBvZiB0aGlzIG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0gZGF0YSB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICBtYXRyaXggZGF0YS5cbiAqIEBwYXJhbSBtIHtOdW1iZXJ9XG4gKiAgICAgICAgbnVtYmVyIG9mIHJvd3MuXG4gKiBAcGFyYW0gbiB7TnVtYmVyfVxuICogICAgICAgIG51bWJlciBvZiBjb2x1bW5zLlxuICogQHBhcmFtIHJvdyB7TnVtYmVyfVxuICogICAgICAgIHJvdyBvZiBlbGVtZW50LCBpbiByYW5nZSBbMCxtKVxuICogQHBhcmFtIGNvbCB7TnVtYmVyfVxuICogICAgICAgIGNvbHVtbiBvZiBlbGVtZW50LCBpbiByYW5nZSBbMCxuKVxuICogQHJldHVybiB7TnVtYmVyfSBpbmRleC5cbiAqL1xuX19pbmRleCA9IGZ1bmN0aW9uIChtLCBuLCByb3csIGNvbCkge1xuICByZXR1cm4gbiAqIHJvdyArIGNvbDtcbn07XG5cbi8qKlxuICogSmFjb2JpIGVpZ2VudmFsdWUgYWxnb3JpdGhtLlxuICpcbiAqIFBvcnRlZCBmcm9tOlxuICogICAgIGh0dHA6Ly91c2Vycy1waHlzLmF1LmRrL2ZlZG9yb3YvbnVjbHRoZW8vTnVtZXJpYy9ub3cvZWlnZW4ucGRmXG4gKlxuICogQW4gaXRlcmF0aXZlIG1ldGhvZCBmb3IgZWlnZW52YWx1ZXMgYW5kIGVpZ2VudmVjdG9ycyxcbiAqIG9ubHkgd29ya3Mgb24gc3ltbWV0cmljIG1hdHJpY2VzLlxuICpcbiAqIEBwYXJhbSBkYXRhIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIG1hdHJpeCBkYXRhLlxuICogQHBhcmFtIG0ge051bWJlcn1cbiAqICAgICAgICBudW1iZXIgb2Ygcm93cy5cbiAqIEBwYXJhbSBuIHtOdW1iZXJ9XG4gKiAgICAgICAgbnVtYmVyIG9mIGNvbHVtbnMuXG4gKiBAcGFyYW0gbWF4Um90YXRpb25zIHtOdW1iZXJ9XG4gKiAgICAgICAgbWF4aW11bSBudW1iZXIgb2Ygcm90YXRpb25zLlxuICogICAgICAgIE9wdGlvbmFsLCBkZWZhdWx0IDEwMC5cbiAqIEByZXR1cm4ge0FycmF5PFZlY3Rvcj59IGFycmF5IG9mIGVpZ2VudmVjdG9ycywgbWFnbml0dWRlIGlzIGVpZ2VudmFsdWUuXG4gKi9cbl9famFjb2JpID0gZnVuY3Rpb24gKGRhdGEsIG0sIG4sIG1heFJvdGF0aW9ucykge1xuICB2YXIgYSxcbiAgICAgIGFpcCxcbiAgICAgIGFpcSxcbiAgICAgIGFwaSxcbiAgICAgIGFwcCxcbiAgICAgIGFwcDEsXG4gICAgICBhcHEsXG4gICAgICBhcWksXG4gICAgICBhcXEsXG4gICAgICBhcXExLFxuICAgICAgYyxcbiAgICAgIGNoYW5nZWQsXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIGlwLFxuICAgICAgaXEsXG4gICAgICBwLFxuICAgICAgcGhpLFxuICAgICAgcGksXG4gICAgICBxLFxuICAgICAgcWksXG4gICAgICByb3RhdGlvbnMsXG4gICAgICBzLFxuICAgICAgdixcbiAgICAgIHZlY3RvcixcbiAgICAgIHZlY3RvcnMsXG4gICAgICB2aXAsXG4gICAgICB2aXE7XG5cbiAgaWYgKG0gIT09IG4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0phY29iaSBvbmx5IHdvcmtzIG9uIHN5bW1ldHJpYywgc3F1YXJlIG1hdHJpY2VzJyk7XG4gIH1cblxuICAvLyBzZXQgYSBkZWZhdWx0IG1heFxuICBtYXhSb3RhdGlvbnMgPSBtYXhSb3RhdGlvbnMgfHwgMTAwO1xuICBhID0gZGF0YS5zbGljZSgwKTtcbiAgZSA9IF9fZGlhZ29uYWwoZGF0YSwgbSwgbik7XG4gIHYgPSBfX2lkZW50aXR5KG4pO1xuICByb3RhdGlvbnMgPSAwO1xuXG4gIGRvIHtcbiAgICBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBmb3IgKHA9MDsgcDxuOyBwKyspIHtcbiAgICAgIGZvciAocT1wKzE7IHE8bjsgcSsrKSB7XG4gICAgICAgIGFwcCA9IGVbcF07XG4gICAgICAgIGFxcSA9IGVbcV07XG4gICAgICAgIGFwcSA9IGFbbiAqIHAgKyBxXTtcbiAgICAgICAgcGhpID0gMC41ICogTWF0aC5hdGFuMigyICogYXBxLCBhcXEgLSBhcHApO1xuICAgICAgICBjID0gTWF0aC5jb3MocGhpKTtcbiAgICAgICAgcyA9IE1hdGguc2luKHBoaSk7XG4gICAgICAgIGFwcDEgPSBjICogYyAqIGFwcCAtIDIgKiBzICogYyAqIGFwcSArIHMgKiBzICogYXFxO1xuICAgICAgICBhcXExID0gcyAqIHMgKiBhcHAgKyAyICogcyAqIGMgKiBhcHEgKyBjICogYyAqIGFxcTtcblxuICAgICAgICBpZiAoYXBwMSAhPT0gYXBwIHx8IGFxcTEgIT09IGFxcSkge1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHJvdGF0aW9ucysrO1xuXG4gICAgICAgICAgZVtwXSA9IGFwcDE7XG4gICAgICAgICAgZVtxXSA9IGFxcTE7XG4gICAgICAgICAgYVtuICogcCArIHFdID0gMDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgICAgIGlwID0gbiAqIGkgKyBwO1xuICAgICAgICAgICAgaXEgPSBuICogaSArIHE7XG4gICAgICAgICAgICBhaXAgPSBhW2lwXTtcbiAgICAgICAgICAgIGFpcSA9IGFbaXFdO1xuICAgICAgICAgICAgYVtpcF0gPSBjICogYWlwIC0gcyAqIGFpcTtcbiAgICAgICAgICAgIGFbaXFdID0gYyAqIGFpcSArIHMgKiBhaXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaSA9IHAgKyAxOyBpIDwgcTsgaSsrKSB7XG4gICAgICAgICAgICBwaSA9IG4gKiBwICsgaTtcbiAgICAgICAgICAgIGlxID0gbiAqIGkgKyBxO1xuICAgICAgICAgICAgYXBpID0gYVtwaV07XG4gICAgICAgICAgICBhaXEgPSBhW2lxXTtcbiAgICAgICAgICAgIGFbcGldID0gYyAqIGFwaSAtIHMgKiBhaXE7XG4gICAgICAgICAgICBhW2lxXSA9IGMgKiBhaXEgKyBzICogYXBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGkgPSBxICsgMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcGkgPSBuICogcCArIGk7XG4gICAgICAgICAgICBxaSA9IG4gKiBxICsgaTtcbiAgICAgICAgICAgIGFwaSA9IGFbcGldO1xuICAgICAgICAgICAgYXFpID0gYVtxaV07XG4gICAgICAgICAgICBhW3BpXSA9IGMgKiBhcGkgLSBzICogYXFpO1xuICAgICAgICAgICAgYVtxaV0gPSBjICogYXFpICsgcyAqIGFwaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaXAgPSBuICogaSArIHA7XG4gICAgICAgICAgICBpcSA9IG4gKiBpICsgcTtcbiAgICAgICAgICAgIHZpcCA9IHZbaXBdO1xuICAgICAgICAgICAgdmlxID0gdltpcV07XG4gICAgICAgICAgICB2W2lwXSA9IGMgKiB2aXAgLSBzICogdmlxO1xuICAgICAgICAgICAgdltpcV0gPSBjICogdmlxICsgcyAqIHZpcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKGNoYW5nZWQgJiYgKHJvdGF0aW9ucyA8IG1heFJvdGF0aW9ucykpO1xuXG4gIGlmIChjaGFuZ2VkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gY29udmVyZ2UnKTtcbiAgfVxuXG4gIHZlY3RvcnMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgIC8vIGktdGggdmVjdG9yIGlzIGktdGggY29sdW1uXG4gICAgdmVjdG9yID0gVmVjdG9yKF9fY29sKHYsIG0sIG4sIGkpKTtcbiAgICB2ZWN0b3IuZWlnZW52YWx1ZSA9IGVbaV07XG4gICAgdmVjdG9ycy5wdXNoKHZlY3Rvcik7XG4gIH1cblxuICByZXR1cm4gdmVjdG9ycztcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgdGhpcyBtYXRyaXggYnkgYW5vdGhlciBtYXRyaXguXG4gKlxuICogQHBhcmFtIGRhdGExIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIGZpcnN0IG1hdHJpeCBkYXRhLlxuICogQHBhcmFtIG0xIHtOdW1iZXJ9XG4gKiAgICAgICAgbnVtYmVyIG9mIHJvd3MgaW4gZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIG4xIHtOdW1iZXJ9XG4gKiAgICAgICAgbnVtYmVyIG9mIGNvbHVtbnMgaW4gZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIGRhdGEyIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHNlY29uZCBtYXRyaXggZGF0YS5cbiAqIEBwYXJhbSBtMiB7TnVtYmVyfVxuICogICAgICAgIG51bWJlciBvZiByb3dzIGluIHNlY29uZCBtYXRyaXguXG4gKiBAcGFyYW0gbjIge051bWJlcn1cbiAqICAgICAgICBudW1iZXIgb2YgY29sdW1ucyBpbiBzZWNvbmQgbWF0cml4LlxuICogQHRocm93cyBFcnJvciBpZiBuMSAhPT0gbTJcbiAqIEByZXR1cm4gcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIChvcmlnaW5hbCBtYXRyaXggaXMgdW5jaGFuZ2VkKS5cbiAqL1xuX19tdWx0aXBseSA9IGZ1bmN0aW9uIChkYXRhMSwgbTEsIG4xLCBkYXRhMiwgbTIsIG4yKSB7XG4gIHZhciBjb2wsXG4gICAgICBjb2wyLFxuICAgICAgcm93LFxuICAgICAgcm93MSxcbiAgICAgIHZhbHVlcztcblxuICBpZiAobjEgIT09IG0yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBjb21iaW5hdGlvbiBvZiByb3dzIGFuZCBjb2xzJyk7XG4gIH1cbiAgdmFsdWVzID0gW107XG4gIGZvciAocm93ID0gMDsgcm93IDwgbTE7IHJvdysrKSB7XG4gICAgcm93MSA9IF9fcm93KGRhdGExLCBtMSwgbjEsIHJvdyk7XG4gICAgZm9yIChjb2wgPSAwOyBjb2wgPCBuMjsgY29sKyspIHtcbiAgICAgIGNvbDIgPSBfX2NvbChkYXRhMiwgbTIsIG4yLCBjb2wpO1xuICAgICAgLy8gcmVzdWx0IGlzIGRvdCBwcm9kdWN0XG4gICAgICB2YWx1ZXMucHVzaChWZWN0b3IuZG90KHJvdzEsIGNvbDIpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn07XG5cbi8qKlxuICogRXh0cmFjdCBhIHJvdyBmcm9tIHRoaXMgbWF0cml4LlxuICpcbiAqIEBwYXJhbSBkYXRhIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIG1hdHJpeCBkYXRhLlxuICogQHBhcmFtIG0ge051bWJlcn1cbiAqICAgICAgICBudW1iZXIgb2Ygcm93cy5cbiAqIEBwYXJhbSBuIHtOdW1iZXJ9XG4gKiAgICAgICAgbnVtYmVyIG9mIGNvbHVtbnMuXG4gKiBAcGFyYW0gcm93IHtOdW1iZXJ9XG4gKiAgICAgICAgaW5kZXggb2Ygcm93LCBpbiByYW5nZSBbMCxtKVxuICogQHRocm93cyBFcnJvciBpZiByb3cgb3V0IG9mIHJhbmdlLlxuICogQHJldHVybiB7QXJyYXk8TnVtYmVyPn0gcm93IGVsZW1lbnRzLlxuICovXG5fX3JvdyA9IGZ1bmN0aW9uIChkYXRhLCBtLCBuLCByb3cpIHtcbiAgdmFyIGNvbCxcbiAgICAgIHZhbHVlcztcbiAgaWYgKHJvdyA8IDAgfHwgcm93ID49IG0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdyAnICsgcm93ICsgJyBvdXQgb2YgcmFuZ2UgWzAsJyArIG0gKyAnKScpO1xuICB9XG4gIHZhbHVlcyA9IFtdO1xuICBmb3IgKGNvbCA9IDA7IGNvbCA8IG47IGNvbCsrKSB7XG4gICAgdmFsdWVzLnB1c2goZGF0YVtfX2luZGV4KG0sIG4sIHJvdywgY29sKV0pO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCBvZiB0aGlzIG1hdHJpeC5cbiAqXG4gKiBOT1RFOiB0aGlzIG1ldGhvZCBtb2RpZmllcyB0aGUgY29udGVudHMgb2YgdGhpcyBtYXRyaXguXG4gKlxuICogQHBhcmFtIGRhdGEge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgbWF0cml4IGRhdGEuXG4gKiBAcGFyYW0gbSB7TnVtYmVyfVxuICogICAgICAgIG51bWJlciBvZiByb3dzLlxuICogQHBhcmFtIG4ge051bWJlcn1cbiAqICAgICAgICBudW1iZXIgb2YgY29sdW1ucy5cbiAqIEBwYXJhbSByb3cge051bWJlcn1cbiAqICAgICAgICByb3cgb2YgZWxlbWVudCwgaW4gcmFuZ2UgWzAsbSlcbiAqIEBwYXJhbSBjb2wge051bWJlcn1cbiAqICAgICAgICBjb2x1bW4gb2YgZWxlbWVudCwgaW4gcmFuZ2UgWzAsbilcbiAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfVxuICogICAgICAgIHZhbHVlIHRvIHNldC5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgcm93IG9yIGNvbCBhcmUgb3V0IG9mIHJhbmdlLlxuICovXG5fX3NldCA9IGZ1bmN0aW9uIChkYXRhLCBtLCBuLCByb3csIGNvbCwgdmFsdWUpIHtcbiAgZGF0YVtfX2luZGV4KG0sIG4sIHJvdywgY29sKV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogRGlzcGxheSBtYXRyaXggYXMgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGRhdGEge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgbWF0cml4IGRhdGEuXG4gKiBAcGFyYW0gbSB7TnVtYmVyfVxuICogICAgICAgIG51bWJlciBvZiByb3dzLlxuICogQHBhcmFtIG4ge051bWJlcn1cbiAqICAgICAgICBudW1iZXIgb2YgY29sdW1ucy5cbiAqIEByZXR1cm4ge1N0cmluZ30gZm9ybWF0dGVkIG1hdHJpeC5cbiAqL1xuX19zdHJpbmdpZnkgPSBmdW5jdGlvbiAoZGF0YSwgbSwgbikge1xuICB2YXIgbGFzdFJvdyA9IG0gLSAxLFxuICAgICAgbGFzdENvbCA9IG4gLSAxLFxuICAgICAgYnVmID0gW10sXG4gICAgICByb3csXG4gICAgICBjb2w7XG5cbiAgYnVmLnB1c2goJ1snKTtcbiAgZm9yIChyb3cgPSAwOyByb3cgPCBtOyByb3crKykge1xuICAgIGZvciAoY29sID0gMDsgY29sIDwgbjsgY29sKyspIHtcbiAgICAgIGJ1Zi5wdXNoKFxuICAgICAgICAgIGRhdGFbbiAqIHJvdyArIGNvbF0sXG4gICAgICAgICAgKGNvbCAhPT0gbGFzdENvbCB8fCByb3cgIT09IGxhc3RSb3cpID8gJywgJyA6ICcnKTtcbiAgICB9XG4gICAgaWYgKHJvdyAhPT0gbGFzdFJvdykge1xuICAgICAgYnVmLnB1c2goJ1xcbiAnKTtcbiAgICB9XG4gIH1cbiAgYnVmLnB1c2goJ10nKTtcbiAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoaXMgbWF0cml4LlxuICpcbiAqIEBwYXJhbSBkYXRhIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIG1hdHJpeCBkYXRhLlxuICogQHBhcmFtIG0ge051bWJlcn1cbiAqICAgICAgICBudW1iZXIgb2Ygcm93cy5cbiAqIEBwYXJhbSBuIHtOdW1iZXJ9XG4gKiAgICAgICAgbnVtYmVyIG9mIGNvbHVtbnMuXG4gKiBAcmV0dXJuIHRyYW5zcG9zZWQgbWF0cml4IChvcmlnaW5hbCBtYXRyaXggaXMgdW5jaGFuZ2VkKS5cbiAqL1xuX190cmFuc3Bvc2UgPSBmdW5jdGlvbiAoZGF0YSwgbSwgbikge1xuICB2YXIgdmFsdWVzID0gW10sXG4gICAgICByb3csXG4gICAgICBjb2w7XG4gIGZvciAoY29sID0gMDsgY29sIDwgbjsgY29sKyspIHtcbiAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IG07IHJvdysrKSB7XG4gICAgICB2YWx1ZXMucHVzaChkYXRhW19faW5kZXgobSwgbiwgcm93LCBjb2wpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG5cbi8qKlxuICogQ29uc3RydWN0IGEgbmV3IE1hdHJpeCBvYmplY3QuXG4gKlxuICogSWYgbSBhbmQgbiBhcmUgb21pdHRlZCwgTWF0cml4IGlzIGFzc3VtZWQgdG8gYmUgc3F1YXJlIGFuZFxuICogZGF0YSBsZW5ndGggaXMgdXNlZCB0byBjb21wdXRlIHNpemUuXG4gKlxuICogSWYgbSBvciBuIGFyZSBvbWl0dGVkLCBkYXRhIGxlbmd0aCBpcyB1c2VkIHRvIGNvbXB1dGUgb21pdHRlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZGF0YSB7QXJyYXl9XG4gKiAgICAgICAgbWF0cml4IGRhdGEuXG4gKiBAcGFyYW0gbSB7TnVtYmVyfVxuICogICAgICAgIG51bWJlciBvZiByb3dzLlxuICogQHBhcmFtIG4ge051bWJlcn1cbiAqICAgICAgICBudW1iZXIgb2YgY29sdW1ucy5cbiAqL1xudmFyIE1hdHJpeCA9IGZ1bmN0aW9uIChkYXRhLCBtLCBuKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuICAgICAgLy8gdmFyaWFibGVzXG4gICAgICBfZGF0YSxcbiAgICAgIF9tLFxuICAgICAgX247XG5cblxuICBfdGhpcyA9IHt9O1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKGRhdGEsIG0sIG4pIHtcbiAgICBfZGF0YSA9IGRhdGE7XG4gICAgX20gPSBtO1xuICAgIF9uID0gbjtcblxuICAgIGlmIChtICYmIG4pIHtcbiAgICAgIC8vIGRvbmVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0cnkgdG8gY29tcHV0ZSBzaXplIGJhc2VkIG9uIGRhdGFcbiAgICBpZiAoIW0gJiYgIW4pIHtcbiAgICAgIHZhciBzaWRlID0gTWF0aC5zcXJ0KGRhdGEubGVuZ3RoKTtcbiAgICAgIGlmIChzaWRlICE9PSBwYXJzZUludChzaWRlLCAxMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXRyaXggbSxuIHVuc3BlY2lmaWVkLCBhbmQgbWF0cml4IG5vdCBzcXVhcmUnKTtcbiAgICAgIH1cbiAgICAgIF9tID0gc2lkZTtcbiAgICAgIF9uID0gc2lkZTtcbiAgICB9IGVsc2UgaWYgKCFtKSB7XG4gICAgICBfbSA9IGRhdGEubGVuZ3RoIC8gbjtcbiAgICAgIGlmIChfbSAhPT0gcGFyc2VJbnQoX20sIDEwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBkYXRhIGVsZW1lbnRzJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbikge1xuICAgICAgX24gPSBkYXRhLmxlbmd0aCAvIG07XG4gICAgICBpZiAoX24gIT09IHBhcnNlSW50KF9uLCAxMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZGF0YSBlbGVtZW50cycpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIG1hdHJpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdGhhdCB7TWF0cml4fVxuICAgKiAgICAgICAgbWF0cml4IHRvIGFkZC5cbiAgICogQHRocm93cyBFcnJvciBpZiBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaC5cbiAgICogQHJldHVybiByZXN1bHQgb2YgYWRkaXRpb24gKG9yaWdpbmFsIG1hdHJpeCBpcyB1bmNoYW5nZWQpLlxuICAgKi9cbiAgX3RoaXMuYWRkID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICBpZiAoX20gIT09IHRoYXQubSgpIHx8IG4gIT09IHRoYXQubigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hdHJpY2VzIG11c3QgYmUgc2FtZSBzaXplJyk7XG4gICAgfVxuICAgIHJldHVybiBNYXRyaXgoVmVjdG9yLmFkZChfZGF0YSwgdGhhdC5kYXRhKCkpLCBfbSwgX24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBjb2x1bW4gZnJvbSB0aGlzIG1hdHJpeC5cbiAgICpcbiAgICogQHBhcmFtIGNvbCB7TnVtYmVyfVxuICAgKiAgICAgICAgemVyby1iYXNlZCBjb2x1bW4gaW5kZXguXG4gICAqIEByZXR1cm4ge0FycmF5PE51bWJlcj59IGFycmF5IGNvbnRhaW5pbmcgZWxlbWVudHMgZnJvbSBjb2x1bW4uXG4gICAqL1xuICBfdGhpcy5jb2wgPSBmdW5jdGlvbiAoY29sKSB7XG4gICAgcmV0dXJuIF9fY29sKF9kYXRhLCBfbSwgX24sIGNvbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICovXG4gIF90aGlzLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kYXRhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRpYWdvbmFsIGZyb20gdGhpcyBtYXRyaXguXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PE51bWJlcj59IGFycmF5IGNvbnRhaW5pbmcgZWxlbWVudHMgZnJvbSBkaWFnb25hbC5cbiAgICovXG4gIF90aGlzLmRpYWdvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2RpYWdvbmFsKF9kYXRhLCBfbSwgX24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWx1ZSBmcm9tIHRoaXMgbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gcm93IHtOdW1iZXJ9XG4gICAqICAgICAgICB6ZXJvLWJhc2VkIGluZGV4IG9mIHJvdy5cbiAgICogQHBhcmFtIGNvbCB7TnVtYmVyfVxuICAgKiAgICAgICAgemVyby1iYXNlZCBpbmRleCBvZiBjb2x1bW4uXG4gICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgYXQgKHJvdywgY29sKS5cbiAgICovXG4gIF90aGlzLmdldCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xuICAgIHJldHVybiBfX2dldChfZGF0YSwgX20sIF9uLCByb3csIGNvbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIGVpZ2VudmVjdG9ycyBvZiB0aGlzIG1hdHJpeC5cbiAgICpcbiAgICogTk9URTogTWF0cml4IHNob3VsZCBiZSAzeDMgYW5kIHN5bW1ldHJpYy5cbiAgICpcbiAgICogQHBhcmFtIG1heFJvdGF0aW9ucyB7TnVtYmVyfVxuICAgKiAgICAgICAgZGVmYXVsdCAxMDAuXG4gICAqICAgICAgICBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zLlxuICAgKiBAcmV0dXJuIHtBcnJheTxWZWN0b3I+fSBlaWdlbnZlY3RvcnMuXG4gICAqICAgICAgICAgTWFnbml0dWRlIG9mIGVhY2ggdmVjdG9yIGlzIGVpZ2VudmFsdWUuXG4gICAqL1xuICBfdGhpcy5qYWNvYmkgPSBmdW5jdGlvbiAobWF4Um90YXRpb25zKSB7XG4gICAgcmV0dXJuIF9famFjb2JpKF9kYXRhLCBfbSwgX24sIG1heFJvdGF0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gbWF0cml4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgICAgICAgbnVtYmVyIG9mIHJvd3MuXG4gICAqL1xuICBfdGhpcy5tID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbTtcbiAgfTtcblxuICAvKipcbiAgICogTXVsdGlwbHkgbWF0cmljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB0aGF0IHtNYXRyaXh9XG4gICAqICAgICAgICBtYXRyaXggdG8gbXVsdGlwbHkuXG4gICAqIEByZXR1cm4ge01hdHJpeH0gcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uLlxuICAgKi9cbiAgX3RoaXMubXVsdGlwbHkgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgIHJldHVybiBNYXRyaXgoX19tdWx0aXBseShfZGF0YSwgX20sIF9uLCB0aGF0LmRhdGEoKSwgdGhhdC5tKCksIHRoYXQubigpKSxcbiAgICAgICAgLy8gdXNlIHRoYXQuTlxuICAgICAgICBfbSwgdGhhdC5uKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgbnVtYmVyIG9mIGNvbHVtbnMgaW4gbWF0cml4LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG51bWJlciBvZiBjb2x1bW5zLlxuICAgKi9cbiAgX3RoaXMubiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX247XG4gIH07XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBieSAtMS5cbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSByZXN1bHQgb2YgbmVnYXRpb24uXG4gICAqL1xuICBfdGhpcy5uZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0cml4KFZlY3Rvci5tdWx0aXBseShfZGF0YSwgLTEpLCBfbSwgX24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSByb3cgZnJvbSB0aGlzIG1hdHJpeC5cbiAgICpcbiAgICogQHBhcmFtIHJvdyB7TnVtYmVyfVxuICAgKiAgICAgICAgemVyby1iYXNlZCBpbmRleCBvZiByb3cuXG4gICAqIEByZXR1cm4ge0FycmF5PE51bWJlcj59IGVsZW1lbnRzIGZyb20gcm93LlxuICAgKi9cbiAgX3RoaXMucm93ID0gZnVuY3Rpb24gKHJvdykge1xuICAgIHJldHVybiBfX3JvdyhfZGF0YSwgX20sIF9uLCByb3cpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBpbiB0aGlzIG1hdHJpeC5cbiAgICpcbiAgICogQHBhcmFtIHJvdyB7TnVtYmVyfVxuICAgKiAgICAgICAgemVyby1iYXNlZCByb3cgaW5kZXguXG4gICAqIEBwYXJhbSBjb2wge051bWJlcn1cbiAgICogICAgICAgIHplcm8tYmFzZWQgY29sdW1uIGluZGV4LlxuICAgKiBAcGFyYW0gdmFsdWUge051bWJlcn1cbiAgICogICAgICAgIHZhbHVlIHRvIHNldC5cbiAgICovXG4gIF90aGlzLnNldCA9IGZ1bmN0aW9uIChyb3csIGNvbCwgdmFsdWUpIHtcbiAgICBfX3NldChfZGF0YSwgX20sIF9uLCByb3csIGNvbCwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhbm90aGVyIG1hdHJpeCBmcm9tIHRoaXMgbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gdGhhdCB7TWF0cml4fVxuICAgKiAgICAgICAgbWF0cml4IHRvIHN1YnRyYWN0LlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoLlxuICAgKiBAcmV0dXJuIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiAob3JpZ2luYWwgbWF0cml4IGlzIHVuY2hhbmdlZCkuXG4gICAqL1xuICBfdGhpcy5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgaWYgKF9tICE9PSB0aGF0Lm0oKSB8fCBuICE9PSB0aGF0Lm4oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXRyaWNlcyBtdXN0IGJlIHNhbWUgc2l6ZScpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0cml4KFZlY3Rvci5zdWJ0cmFjdChfZGF0YSwgdGhhdC5kYXRhKCkpLCBfbSwgX24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwbGF5IG1hdHJpeCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgbWF0cml4LlxuICAgKi9cbiAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fc3RyaW5naWZ5KF9kYXRhLCBfbSwgX24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFuc3Bvc2UgbWF0cml4LlxuICAgKlxuICAgKiBDb2x1bW5zIGJlY29tZSByb3dzLCBhbmQgcm93cyBiZWNvbWUgY29sdW1ucy5cbiAgICpcbiAgICogQHJldHVybiB7TWF0cml4fSByZXN1bHQgb2YgdHJhbnNwb3NlLlxuICAgKi9cbiAgX3RoaXMudHJhbnNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRyaXgoX190cmFuc3Bvc2UoX2RhdGEsIF9tLCBfbiksXG4gICAgICAgIC8vIHN3YXAgTSBhbmQgTlxuICAgICAgICBfbiwgX20pO1xuICB9O1xuXG4gIF9pbml0aWFsaXplKGRhdGEsIG0sIG4pO1xuICBkYXRhID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG4vLyBleHBvc2Ugc3RhdGljIG1ldGhvZHMuXG5NYXRyaXguY29sID0gX19jb2w7XG5NYXRyaXguZGlhZ29uYWwgPSBfX2RpYWdvbmFsO1xuTWF0cml4LmdldCA9IF9fZ2V0O1xuTWF0cml4LmlkZW50aXR5ID0gX19pZGVudGl0eTtcbk1hdHJpeC5pbmRleCA9IF9faW5kZXg7XG5NYXRyaXguamFjb2JpID0gX19qYWNvYmk7XG5NYXRyaXgubXVsdGlwbHkgPSBfX211bHRpcGx5O1xuTWF0cml4LnJvdyA9IF9fcm93O1xuTWF0cml4LnNldCA9IF9fc2V0O1xuTWF0cml4LnN0cmluZ2lmeSA9IF9fc3RyaW5naWZ5O1xuTWF0cml4LnRyYW5zcG9zZSA9IF9fdHJhbnNwb3NlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIHN0YXRpYyBtZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhcnJheXNcbnZhciBfX2FkZCxcbiAgICBfX2FuZ2xlLFxuICAgIF9fYXppbXV0aCxcbiAgICBfX2Nyb3NzLFxuICAgIF9fZG90LFxuICAgIF9fZXF1YWxzLFxuICAgIF9fbWFnbml0dWRlLFxuICAgIF9fbXVsdGlwbHksXG4gICAgX19wbHVuZ2UsXG4gICAgX191bml0LFxuICAgIF9fcm90YXRlLFxuICAgIF9fc3VidHJhY3QsXG4gICAgX194LFxuICAgIF9feSxcbiAgICBfX3o7XG5cblxuLyoqXG4gKiBBZGQgdHdvIHZlY3RvcnMuXG4gKlxuICogQHBhcmFtIHYxIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0gdjIge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgdGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgICByZXN1bHQgb2YgYWRkaXRpb24uXG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiB2ZWN0b3JzIGFyZSBkaWZmZXJlbnQgbGVuZ3Rocy5cbiAqL1xuX19hZGQgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gIHZhciBpLFxuICAgICAgdjtcbiAgaWYgKHYxLmxlbmd0aCAhPT0gdjIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2ZWN0b3JzIG11c3QgYmUgc2FtZSBsZW5ndGgnKTtcbiAgfVxuICB2ID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgIHYucHVzaCh2MVtpXSArIHYyW2ldKTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzLlxuICpcbiAqIEBwYXJhbSB2MSB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICB0aGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHYyIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybiB7TnVtYmVyfVxuICogICAgICAgICBhbmdsZSBiZXR3ZWVuIHZlY3RvcnMgaW4gcmFkaWFucy5cbiAqL1xuX19hbmdsZSA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgcmV0dXJuIE1hdGguYWNvcyhfX2RvdCh2MSwgdjIpIC8gKF9fbWFnbml0dWRlKHYxKSAqIF9fbWFnbml0dWRlKHYyKSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBhemltdXRoIG9mIGEgdmVjdG9yLlxuICpcbiAqIEBwYXJhbSB2MSB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICB0aGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHYyIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybiB7TnVtYmVyfVxuICogICAgICAgICBhbmdsZSBiZXR3ZWVuIHZlY3RvcnMgaW4gcmFkaWFucy5cbiAqL1xuX19hemltdXRoID0gZnVuY3Rpb24gKHYxKSB7XG4gIGlmICh2MS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhemltdXRoIHJlcXVpcmVzIGF0IGxlYXN0IDIgZGltZW5zaW9ucycpO1xuICB9XG4gIGlmICh2MVswXSA9PT0gMCAmJiB2MVsxXSA9PT0gMCkge1xuICAgIC8vIGlmIHZlY3RvciBpcyB6ZXJvLCBvciB2ZXJ0aWNhbCwgYXppbXV0aCBpcyB6ZXJvLlxuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiAoTWF0aC5QSSAvIDIpIC0gTWF0aC5hdGFuMih2MVsxXSwgdjFbMF0pO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHZlY3RvciBjcm9zcyBwcm9kdWN0LlxuICpcbiAqIE5vdGU6IG9ubHkgY29tcHV0ZXMgY3Jvc3MgcHJvZHVjdCBpbiAzIGRpbWVuc2lvbnMuXG4gKlxuICogQHBhcmFtIHYxIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0gdjIge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgdGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgICB0aGUgMyBkaW1lbnNpb25hbCBjcm9zcyBwcm9kdWN0LlxuICogICAgICAgICB0aGUgcmVzdWx0aW5nIHZlY3RvciBmb2xsb3dzIHRoZSByaWdodC1oYW5kIHJ1bGU6IGlmIHRoZSBmaW5nZXJzIG9uXG4gKiAgICAgICAgIHlvdXIgcmlnaHQgaGFuZCBwb2ludCB0byB2MSwgYW5kIHlvdSBjbG9zZSB5b3VyIGhhbmQgdG8gZ2V0IHRvIHYyLFxuICogICAgICAgICB0aGUgcmVzdWx0aW5nIHZlY3RvciBwb2ludHMgaW4gdGhlIGRpcmVjdGlvbiBvZiB5b3VyIHRodW1iLlxuICovXG5fX2Nyb3NzID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICBpZiAodjEubGVuZ3RoICE9PSB2Mi5sZW5ndGggfHwgdjEubGVuZ3RoIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcignY3Jvc3MgcHJvZHVjdCByZXF1aXJlcyBhdCBsZWFzdCAzIGRpbWVuc2lvbnMnKTtcbiAgfVxuICByZXR1cm4gW1xuICAgIHYxWzFdICogdjJbMl0gLSB2MlsxXSAqIHYxWzJdLFxuICAgIHYxWzJdICogdjJbMF0gLSB2MlsyXSAqIHYxWzBdLFxuICAgIHYxWzBdICogdjJbMV0gLSB2MlswXSAqIHYxWzFdXG4gIF07XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdmVjdG9yIGRvdCBwcm9kdWN0LlxuICpcbiAqIEBwYXJhbSB2MSB7QXJyYXk8TnVtYmVyfVxuICogICAgICAgIHRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0gdjIge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgdGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiAgICAgICAgIHRoZSBkb3QgcHJvZHVjdC5cbiAqL1xuX19kb3QgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gIHZhciBpLFxuICAgICAgc3VtO1xuICBzdW0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspIHtcbiAgICBzdW0gKz0gdjFbaV0gKiB2MltpXTtcbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIHYxIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0gdjIge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgdGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICAgICAgICB0cnVlIGlmIHZlY3RvcnMgYXJlIHNhbWUgbGVuZ3RoIGFuZCBhbGwgZWxlbWVudHMgYXJlIGVxdWFsLlxuICovXG5fX2VxdWFscyA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgdmFyIGk7XG4gIGlmICh2MS5sZW5ndGggIT09IHYyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodjFbaV0gIT09IHYyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGxlbmd0aCBvZiB2ZWN0b3IuXG4gKlxuICogQHBhcmFtIHYxIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHZlY3Rvci5cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqICAgICAgICAgbWFnbml0dWRlIG9mIHZlY3Rvci5cbiAqL1xuX19tYWduaXR1ZGUgPSBmdW5jdGlvbiAodjEpIHtcbiAgdmFyIGksXG4gICAgICBzdW07XG4gIHN1bSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgIHN1bSArPSB2MVtpXSAqIHYxW2ldO1xuICB9XG4gIHJldHVybiBNYXRoLnNxcnQoc3VtKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgdmVjdG9yIGJ5IGEgY29uc3RhbnQuXG4gKlxuICogQHBhcmFtIHYxIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHZlY3RvciB0byBtdWx0aXBseS5cbiAqIEBwYXJhbSBuIHtOdW1iZXJ9XG4gKiAgICAgICAgbnVtYmVyIHRvIG11bHRpcGx5IGJ5LlxuICogQHJldHVybiB7QXJyYXk8TnVtYmVyfVxuICogICAgICAgICByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24uXG4gKi9cbl9fbXVsdGlwbHkgPSBmdW5jdGlvbiAodjEsIG4pIHtcbiAgdmFyIGksXG4gICAgICB2O1xuXG4gIHYgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKSB7XG4gICAgdi5wdXNoKHYxW2ldICogbik7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgYW5nbGUgZnJvbSBwbGFuZSB6PTAgdG8gdmVjdG9yLlxuICpcbiAqIEBwYXJhbSB2IHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHRoZSB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiAgICAgICAgIGFuZ2xlIGZyb20gcGxhbmUgej0wIHRvIHZlY3Rvci5cbiAqICAgICAgICAgYW5nbGUgaXMgcG9zaXRpdmUgd2hlbiB6ID4gMCwgbmVnYXRpdmUgd2hlbiB6IDwgMC5cbiAqL1xuX19wbHVuZ2UgPSBmdW5jdGlvbiAodikge1xuICBpZiAodi5sZW5ndGggPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdfX2F6aW11dGg6IHZlY3RvciBtdXN0IGhhdmUgYXQgbGVhc3QgMyBkaW1lbnNpb25zJyk7XG4gIH1cbiAgcmV0dXJuIE1hdGguYXNpbih2WzJdIC8gX19tYWduaXR1ZGUodikpO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYXJvdW5kIGFuIGF4aXMuXG4gKlxuICogRnJvbSBcIjYuMiBUaGUgbm9ybWFsaXplZCBtYXRyaXggZm9yIHJvdGF0aW9uIGFib3V0IGFuIGFyYml0cmFyeSBsaW5lXCIsXG4gKiAgICAgIGh0dHA6Ly9pbnNpZGUubWluZXMuZWR1L35nbXVycmF5L0FyYml0cmFyeUF4aXNSb3RhdGlvbi9cbiAqXG4gKiBAcGFyYW0gdjEge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgdGhlIFwicG9pbnRcIiB0byByb3RhdGUuXG4gKiBAcGFyYW0gYXhpcyB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICBkaXJlY3Rpb24gdmVjdG9yIG9mIHJvdGF0aW9uIGF4aXMuXG4gKiBAcGFyYW0gdGhldGEge051bWJlcn1cbiAqICAgICAgICBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zLlxuICogQHBhcmFtIG9yaWdpbiB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICBkZWZhdWx0IFswLCAwLCAwXS5cbiAqICAgICAgICBvcmlnaW4gb2YgYXhpcyBvZiByb3RhdGlvbi5cbiAqL1xuX19yb3RhdGUgPSBmdW5jdGlvbiAodjEsIGF4aXMsIHRoZXRhLCBvcmlnaW4pIHtcbiAgdmFyIGEsXG4gICAgICBhdSxcbiAgICAgIGF2LFxuICAgICAgYXcsXG4gICAgICBiLFxuICAgICAgYnUsXG4gICAgICBidixcbiAgICAgIGJ3LFxuICAgICAgYyxcbiAgICAgIGN1LFxuICAgICAgY3YsXG4gICAgICBjdyxcbiAgICAgIGNvc1QsXG4gICAgICBzaW5ULFxuICAgICAgdSxcbiAgICAgIHV1LFxuICAgICAgdXgsXG4gICAgICB1eSxcbiAgICAgIHV6LFxuICAgICAgdixcbiAgICAgIHZ2LFxuICAgICAgdngsXG4gICAgICB2eSxcbiAgICAgIHZ6LFxuICAgICAgdyxcbiAgICAgIHd3LFxuICAgICAgd3gsXG4gICAgICB3eSxcbiAgICAgIHd6LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6O1xuXG4gIG9yaWdpbiA9IG9yaWdpbiB8fCBbMCwgMCwgMF07XG4gIGEgPSBvcmlnaW5bMF07XG4gIGIgPSBvcmlnaW5bMV07XG4gIGMgPSBvcmlnaW5bMl07XG4gIHUgPSBheGlzWzBdO1xuICB2ID0gYXhpc1sxXTtcbiAgdyA9IGF4aXNbMl07XG4gIHggPSB2MVswXTtcbiAgeSA9IHYxWzFdO1xuICB6ID0gdjFbMl07XG5cbiAgY29zVCA9IE1hdGguY29zKHRoZXRhKTtcbiAgc2luVCA9IE1hdGguc2luKHRoZXRhKTtcbiAgYXUgPSBhICogdTtcbiAgYXYgPSBhICogdjtcbiAgYXcgPSBhICogdztcbiAgYnUgPSBiICogdTtcbiAgYnYgPSBiICogdjtcbiAgYncgPSBiICogdztcbiAgY3UgPSBjICogdTtcbiAgY3YgPSBjICogdjtcbiAgY3cgPSBjICogdztcbiAgdXUgPSB1ICogdTtcbiAgdXggPSB1ICogeDtcbiAgdXkgPSB1ICogeTtcbiAgdXogPSB1ICogejtcbiAgdnYgPSB2ICogdjtcbiAgdnggPSB2ICogeDtcbiAgdnkgPSB2ICogeTtcbiAgdnogPSB2ICogejtcbiAgd3cgPSB3ICogdztcbiAgd3ggPSB3ICogeDtcbiAgd3kgPSB3ICogeTtcbiAgd3ogPSB3ICogejtcblxuICByZXR1cm4gW1xuICAgIChhICogKHZ2ICsgd3cpIC0gdSAqIChidiArIGN3IC0gdXggLSB2eSAtIHd6KSkgKiAoMSAtIGNvc1QpICtcbiAgICAgICAgeCAqIGNvc1QgKyAoLWN2ICsgYncgLSB3eSArIHZ6KSAqIHNpblQsXG4gICAgKGIgKiAodXUgKyB3dykgLSB2ICogKGF1ICsgY3cgLSB1eCAtIHZ5IC0gd3opKSAqICgxIC0gY29zVCkgK1xuICAgICAgICB5ICogY29zVCArIChjdSAtIGF3ICsgd3ggLSB1eikgKiBzaW5ULFxuICAgIChjICogKHV1ICsgdnYpIC0gdyAqIChhdSArIGJ2IC0gdXggLSB2eSAtIHd6KSkgKiAoMSAtIGNvc1QpICtcbiAgICAgICAgeiAqIGNvc1QgKyAoLWJ1ICsgYXYgLSB2eCArIHV5KSAqIHNpblRcbiAgXTtcbn07XG5cbi8qKlxuICogU3VidHJhY3QgdHdvIHZlY3RvcnMuXG4gKlxuICogQHBhcmFtIHYxIHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0gdjIge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgdGhlIHZlY3RvciB0byBzdWJ0cmFjdC5cbiAqIEByZXR1cm4ge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIHZlY3RvcnMgYXJlIGRpZmZlcmVudCBsZW5ndGhzLlxuICovXG5fX3N1YnRyYWN0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICB2YXIgaSxcbiAgICAgIHY7XG5cbiAgaWYgKHYxLmxlbmd0aCAhPT0gdjIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdfX3N1YnRyYWN0OiB2ZWN0b3JzIG11c3QgYmUgc2FtZSBsZW5ndGgnKTtcbiAgfVxuICB2ID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgIHYucHVzaCh2MVtpXSAtIHYyW2ldKTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQ29udmVydCB2ZWN0b3IgdG8gbGVuZ3RoIDEuXG4gKlxuICogU2FtZSBhcyBfX211bHRpcGx5KHYxLCAxIC8gX19tYWduaXR1ZGUodjEpKVxuICpcbiAqIEBwYXJhbSB2MSB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICB0aGUgdmVjdG9yLlxuICogQHJldHVybiB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICAgdmVjdG9yIGNvbnZlcnRlZCB0byBsZW5ndGggMS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB2ZWN0b3IgbWFnbml0dWRlIGlzIDAuXG4gKi9cbl9fdW5pdCA9IGZ1bmN0aW9uICh2MSkge1xuICB2YXIgbWFnID0gX19tYWduaXR1ZGUodjEpO1xuICBpZiAobWFnID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdfX3VuaXQ6IGNhbm5vdCBjb252ZXJ0IHplcm8gdmVjdG9yIHRvIHVuaXQgdmVjdG9yJyk7XG4gIH1cbiAgcmV0dXJuIF9fbXVsdGlwbHkodjEsIDEgLyBtYWcpO1xufTtcblxuLyoqXG4gKiBHZXQsIGFuZCBvcHRpb25hbGx5IHNldCwgdGhlIHggY29tcG9uZW50IG9mIGEgdmVjdG9yLlxuICpcbiAqIEBwYXJhbSB2IHtBcnJheTxOdW1iZXI+fVxuICogICAgICAgIHRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0gdmFsdWUge051bWJlcn1cbiAqICAgICAgICBkZWZhdWx0IHVuZGVmaW5lZC5cbiAqICAgICAgICB3aGVuIGRlZmluZWQsIHNldCB4IGNvbXBvbmVudC5cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqICAgICAgICAgdGhlIHggY29tcG9uZW50LlxuICovXG5fX3ggPSBmdW5jdGlvbiAodiwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB2WzBdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZbMF07XG59O1xuXG4vKipcbiAqIEdldCwgYW5kIG9wdGlvbmFsbHkgc2V0LCB0aGUgeSBjb21wb25lbnQgb2YgYSB2ZWN0b3IuXG4gKlxuICogQHBhcmFtIHYge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgdGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfVxuICogICAgICAgIGRlZmF1bHQgdW5kZWZpbmVkLlxuICogICAgICAgIHdoZW4gZGVmaW5lZCwgc2V0IHkgY29tcG9uZW50LlxuICogQHJldHVybiB7TnVtYmVyfVxuICogICAgICAgICB0aGUgeSBjb21wb25lbnQuXG4gKi9cbl9feSA9IGZ1bmN0aW9uICh2LCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHZbMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdlsxXTtcbn07XG5cbi8qKlxuICogR2V0LCBhbmQgb3B0aW9uYWxseSBzZXQsIHRoZSB6IGNvbXBvbmVudCBvZiBhIHZlY3Rvci5cbiAqXG4gKiBAcGFyYW0gdiB7QXJyYXk8TnVtYmVyPn1cbiAqICAgICAgICB0aGUgdmVjdG9yLlxuICogQHBhcmFtIHZhbHVlIHtOdW1iZXJ9XG4gKiAgICAgICAgZGVmYXVsdCB1bmRlZmluZWQuXG4gKiAgICAgICAgd2hlbiBkZWZpbmVkLCBzZXQgeiBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiAgICAgICAgIHRoZSB6IGNvbXBvbmVudC5cbiAqL1xuX196ID0gZnVuY3Rpb24gKHYsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdlsyXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB2WzJdO1xufTtcblxuXG4vKipcbiAqIEEgdmVjdG9yIG9iamVjdCB0aGF0IHdyYXBzIGFuIGFycmF5LlxuICpcbiAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBvYmplY3QgdG8gY2FsbCB0aGUgc3RhdGljIG1ldGhvZHMgb24gdGhlIHdyYXBwZWQgYXJyYXkuXG4gKiBPbmx5IHRoZSBtZXRob2RzIHgoKSwgeSgpLCBhbmQgeigpIG1vZGlmeSBkYXRhOyBvdGhlciBtZXRob2RzIHJldHVybiBuZXdcbiAqIFZlY3RvciBvYmplY3RzIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBleGlzdGluZyBvYmplY3QuXG4gKlxuICogQHBhcmFtIGRhdGEge0FycmF5PE51bWJlcj59XG4gKiAgICAgICAgYXJyYXkgdG8gd3JhcC5cbiAqL1xudmFyIFZlY3RvciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuICAgICAgLy8gdmFyaWFibGVzXG4gICAgICBfZGF0YTtcblxuICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YS5kYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gY29weSBleGlzdGluZyBvYmplY3RcbiAgICBkYXRhID0gZGF0YS5kYXRhKCkuc2xpY2UoMCk7XG4gIH1cblxuXG4gIF90aGlzID0ge1xuICAgIF9pc2FfdmVjdG9yOiB0cnVlXG4gIH07XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIF9kYXRhID0gZGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHR3byB2ZWN0b3JzLlxuICAgKlxuICAgKiBAcGFyYW0gdGhhdCB7VmVjdG9yfEFycmF5PE51bWJlcj59XG4gICAqICAgICAgICB2ZWN0b3IgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtWZWN0b3J9XG4gICAqICAgICAgICAgcmVzdWx0IG9mIGFkZGl0aW9uLlxuICAgKi9cbiAgX3RoaXMuYWRkID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICB0aGF0ID0gKHRoYXQuX2lzYV92ZWN0b3IgPyB0aGF0LmRhdGEoKSA6IHRoYXQpO1xuICAgIHJldHVybiBWZWN0b3IoX19hZGQoX2RhdGEsIHRoYXQpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29tcHV0ZSBhbmdsZSBiZXR3ZWVuIHZlY3RvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB0aGF0IHtWZWN0b3J8QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgIHZlY3RvciB0byBjb21wdXRlIGFuZ2xlIGJldHdlZW4uXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGUgYmV0d2VlbiB2ZWN0b3JzIGluIHJhZGlhbnMuXG4gICAqL1xuICBfdGhpcy5hbmdsZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgdGhhdCA9ICh0aGF0Ll9pc2FfdmVjdG9yID8gdGhhdC5kYXRhKCkgOiB0aGF0KTtcbiAgICByZXR1cm4gX19hbmdsZShfZGF0YSwgdGhhdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgYXppbXV0aCBvZiB0aGlzIHZlY3Rvci5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBhemltdXRoIG9mIHRoaXMgdmVjdG9yIGluIHJhZGlhbnMuXG4gICAqL1xuICBfdGhpcy5hemltdXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2F6aW11dGgoX2RhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBjcm9zcyBwcm9kdWN0IGJldHdlZW4gdmVjdG9ycy5cbiAgICpcbiAgICogQHBhcmFtIHRoYXQge1ZlY3RvcnxBcnJheTxOdW1iZXI+fVxuICAgKiAgICAgICAgdGhlIHZlY3RvciB0byBjcm9zcy5cbiAgICogQHJldHVybiB7VmVjdG9yfSByZXN1bHQgb2YgdGhlIGNyb3NzIHByb2R1Y3QuXG4gICAqL1xuICBfdGhpcy5jcm9zcyA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgdGhhdCA9ICh0aGF0Ll9pc2FfdmVjdG9yID8gdGhhdC5kYXRhKCkgOiB0aGF0KTtcbiAgICByZXR1cm4gVmVjdG9yKF9fY3Jvc3MoX2RhdGEsIHRoYXQpKTtcbiAgfTtcblxuICAvKipcbiAgICogQWNjZXNzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxOdW1iZXI+fVxuICAgKiAgICAgICAgIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgKi9cbiAgX3RoaXMuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2RhdGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgZG90IHByb2R1Y3QgYmV0d2VlbiB2ZWN0b3JzLlxuICAgKlxuICAgKiBAcGFyYW0gdGhhdCB7VmVjdG9yfEFycmF5PE51bWJlcj59XG4gICAqICAgICAgICB2ZWN0b3IgdG8gZG90LlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJlc3VsdCBvZiBkb3QgcHJvZHVjdC5cbiAgICovXG4gIF90aGlzLmRvdCA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgdGhhdCA9ICh0aGF0Ll9pc2FfdmVjdG9yID8gdGhhdC5kYXRhKCkgOiB0aGF0KTtcbiAgICByZXR1cm4gX19kb3QoX2RhdGEsIHRoYXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWwuXG4gICAqXG4gICAqIEBwYXJhbSB0aGF0IHtWZWN0b3J8QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgIHZlY3RvciB0byBjb21wYXJlLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBfdGhpcy5lcXVhbHMgPSBmdW5jdGlvbiAodGhhdCkge1xuICAgIHRoYXQgPSAodGhhdC5faXNhX3ZlY3RvciA/IHRoYXQuZGF0YSgpIDogdGhhdCk7XG4gICAgcmV0dXJuIF9fZXF1YWxzKF9kYXRhLCB0aGF0KTtcbiAgfTtcblxuICAvKipcbiAgICogQ29tcHV0ZSBsZW5ndGggb2YgdGhpcyB2ZWN0b3IuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICogICAgICAgICBTcXVhcmUgcm9vdCBvZiB0aGUgc3VtIG9mIHNxdWFyZXMgb2YgYWxsIGNvbXBvbmVudHMuXG4gICAqL1xuICBfdGhpcy5tYWduaXR1ZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fbWFnbml0dWRlKF9kYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogTXVsdGlwbHkgdGhpcyB2ZWN0b3IgYnkgYSBudW1iZXIuXG4gICAqXG4gICAqIEBwYXJhbSBuIHtOdW1iZXJ9XG4gICAqICAgICAgICBudW1iZXIgdG8gbXVsdGlwbHkuXG4gICAqIEByZXR1cm4ge1ZlY3Rvcn0gcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uLlxuICAgKi9cbiAgX3RoaXMubXVsdGlwbHkgPSBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBWZWN0b3IoX19tdWx0aXBseShfZGF0YSwgbikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTYW1lIGFzIG11bHRpcGx5KC0xKS5cbiAgICovXG4gIF90aGlzLm5lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5tdWx0aXBseSgtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgcGx1bmdlIG9mIHRoaXMgdmVjdG9yLlxuICAgKlxuICAgKiBQbHVuZ2UgaXMgdGhlIGFuZ2xlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIHRoZSBwbGFuZSB6PTAuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gcGx1bmdlIGluIHJhZGlhbnMuXG4gICAqICAgICAgICAgcG9zaXRpdmUgd2hlbiB6PjAsIG5lZ2F0aXZlIHdoZW4gejwwLlxuICAgKi9cbiAgX3RoaXMucGx1bmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX3BsdW5nZShfZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGlzIHZlY3RvciBhcm91bmQgYW4gYXJiaXRyYXJ5IGF4aXMuXG4gICAqXG4gICAqIEBwYXJhbSBheGlzIHtWZWN0b3J8QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgIGRpcmVjdGlvbiBvZiBheGlzIG9mIHJvdGF0aW9uLlxuICAgKiBAcGFyYW0gdGhldGEge051bWJlcn1cbiAgICogICAgICAgIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSBvcmlnaW4ge1ZlY3RvcnxBcnJheTxOdW1iZXI+fVxuICAgKiAgICAgICAgb3JpZ2luIG9mIGF4aXMgb2Ygcm90YXRpb24uXG4gICAqIEByZXR1cm4ge1ZlY3Rvcn0gcmVzdWx0IG9mIHJvdGF0aW9uLlxuICAgKi9cbiAgX3RoaXMucm90YXRlID0gZnVuY3Rpb24gKGF4aXMsIHRoZXRhLCBvcmlnaW4pIHtcbiAgICBheGlzID0gKGF4aXMuX2lzYV92ZWN0b3IgPyBheGlzLmRhdGEoKSA6IGF4aXMpO1xuICAgIG9yaWdpbiA9IChvcmlnaW4gJiYgb3JpZ2luLl9pc2FfdmVjdG9yID8gb3JpZ2luLmRhdGEoKSA6IG9yaWdpbik7XG4gICAgcmV0dXJuIFZlY3RvcihfX3JvdGF0ZShfZGF0YSwgYXhpcywgdGhldGEsIG9yaWdpbikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhbm90aGVyIHZlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHRoYXQge1ZlY3RvcnxBcnJheTxOdW1iZXI+fVxuICAgKiAgICAgICAgdmVjdG9yIHRvIHN1YnRyYWN0LlxuICAgKiBAcmV0dXJuIHtWZWN0b3J9IHJlc3VsdCBvZiBzdWJ0cmFjdGlvbi5cbiAgICovXG4gIF90aGlzLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICB0aGF0ID0gKHRoYXQuX2lzYV92ZWN0b3IgPyB0aGF0LmRhdGEoKSA6IHRoYXQpO1xuICAgIHJldHVybiBWZWN0b3IoX19zdWJ0cmFjdChfZGF0YSwgdGhhdCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHZlY3RvciB0byBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gd3JhcHBlZCBhcnJheSBjb252ZXJ0ZWQgdG8gc3RyaW5nLlxuICAgKi9cbiAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgX2RhdGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhpcyB2ZWN0b3IgdG8gbGVuZ3RoIDEuXG4gICAqXG4gICAqIEByZXR1cm4ge1ZlY3Rvcn0gdmVjdG9yIC8gfHZlY3RvcnwuXG4gICAqL1xuICBfdGhpcy51bml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBWZWN0b3IoX191bml0KF9kYXRhKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgeCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfVxuICAgKiAgICAgICAgd2hlbiBkZWZpbmVkLCBzZXQgeCBjb21wb25lbnQgdG8gdmFsdWUuXG4gICAqIEByZXR1cm4ge051bWJlcn0geCBjb21wb25lbnQgdmFsdWUuXG4gICAqL1xuICBfdGhpcy54ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9feChfZGF0YSwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHkgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUge051bWJlcn1cbiAgICogICAgICAgIHdoZW4gZGVmaW5lZCwgc2V0IHkgY29tcG9uZW50IHRvIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHkgY29tcG9uZW50IHZhbHVlLlxuICAgKi9cbiAgX3RoaXMueSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBfX3koX2RhdGEsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB6IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIHtOdW1iZXJ9XG4gICAqICAgICAgICB3aGVuIGRlZmluZWQsIHNldCB6IGNvbXBvbmVudCB0byB2YWx1ZS5cbiAgICogQHJldHVybiB7TnVtYmVyfSB6IGNvbXBvbmVudCB2YWx1ZS5cbiAgICovXG4gIF90aGlzLnogPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gX196KF9kYXRhLCB2YWx1ZSk7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShkYXRhKTtcbiAgZGF0YSA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuLy8gZXhwb3NlIHN0YXRpYyBtZXRob2RzXG5WZWN0b3IuYWRkID0gX19hZGQ7XG5WZWN0b3IuYW5nbGUgPSBfX2FuZ2xlO1xuVmVjdG9yLmF6aW11dGggPSBfX2F6aW11dGg7XG5WZWN0b3IuY3Jvc3MgPSBfX2Nyb3NzO1xuVmVjdG9yLmRvdCA9IF9fZG90O1xuVmVjdG9yLm1hZ25pdHVkZSA9IF9fbWFnbml0dWRlO1xuVmVjdG9yLm11bHRpcGx5ID0gX19tdWx0aXBseTtcblZlY3Rvci5wbHVuZ2UgPSBfX3BsdW5nZTtcblZlY3Rvci5yb3RhdGUgPSBfX3JvdGF0ZTtcblZlY3Rvci5zdWJ0cmFjdCA9IF9fc3VidHJhY3Q7XG5WZWN0b3IudW5pdCA9IF9fdW5pdDtcblZlY3Rvci54ID0gX194O1xuVmVjdG9yLnkgPSBfX3k7XG5WZWN0b3IueiA9IF9fejtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvcjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQSBMaWdodHdlaWdodCBjb2xsZWN0aW9uLCBpbnNwaXJlZCBieSBiYWNrYm9uZS5cbiAqXG4gKiBMYXppbHkgYnVpbGRzIGluZGV4ZXMgdG8gYXZvaWQgb3ZlcmhlYWQgdW50aWwgbmVlZGVkLlxuICovXG5cbnZhciBFdmVudHMgPSByZXF1aXJlKCcuLi91dGlsL0V2ZW50cycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBDb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBkYXRhIHtBcnJheX1cbiAqICAgICAgV2hlbiBvbWl0dGVkIGEgbmV3IGFycmF5IGlzIGNyZWF0ZWQuXG4gKi9cbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gKGRhdGEpIHtcblxuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2RhdGEsXG4gICAgICBfaWRzLFxuICAgICAgX3NlbGVjdGVkLFxuXG4gICAgICBfaXNTaWxlbnQ7XG5cblxuICBfdGhpcyA9IEV2ZW50cygpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIF9kYXRhID0gZGF0YSB8fCBbXTtcbiAgICBfaWRzID0gbnVsbDtcbiAgICBfc2VsZWN0ZWQgPSBudWxsO1xuXG4gICAgZGF0YSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgXCJzaWxlbnRcIiBvcHRpb24gaXMgdHJ1ZS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lsZW50IHtCb29sZWFufVxuICAgKiAgICAgICAgZGVmYXVsdCBmYWxzZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvcHRpb25zLnNpbGVudCBpcyB0cnVlLlxuICAgKi9cbiAgX2lzU2lsZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnNpbGVudCA9PT0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIG9iamVjdHMgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIENhbGxzIHdyYXBwZWQgYXJyYXkucHVzaCwgYW5kIGNsZWFycyB0aGUgaWQgY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN04oCmfVxuICAgKiAgICAgIGEgdmFyaWFibGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYXBwZW5kIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAZGVwcmVjYXRlZCBzZWUgI2FkZEFsbCgpXG4gICAqL1xuICBfdGhpcy5hZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuYWRkQWxsKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgb2JqZWN0cyB0byB0aGUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQ2FsbHMgd3JhcHBlZCBhcnJheS5wdXNoLCBhbmQgY2xlYXJzIHRoZSBpZCBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtIHRvYWRkIHtBcnJheTxPYmplY3Q+fVxuICAgKiAgICAgICAgb2JqZWN0cyB0byBiZSBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gICBfdGhpcy5hZGRBbGwgPSBmdW5jdGlvbiAodG9hZGQsIG9wdGlvbnMpIHtcbiAgICAgX2RhdGEucHVzaC5hcHBseShfZGF0YSwgdG9hZGQpO1xuICAgICBfaWRzID0gbnVsbDtcbiAgICAgaWYgKCFfaXNTaWxlbnQob3B0aW9ucykpIHtcbiAgICAgICBfdGhpcy50cmlnZ2VyKCdhZGQnLCB0b2FkZCk7XG4gICAgIH1cbiAgIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICpcbiAgICogQHJldHVyblxuICAgKiAgICAgIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgKi9cbiAgX3RoaXMuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2RhdGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc2VsZWN0IGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgKi9cbiAgX3RoaXMuZGVzZWxlY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChfc2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRTZWxlY3RlZCA9IF9zZWxlY3RlZDtcbiAgICAgIF9zZWxlY3RlZCA9IG51bGw7XG4gICAgICBpZiAoIV9pc1NpbGVudChvcHRpb25zKSkge1xuICAgICAgICBfdGhpcy50cmlnZ2VyKCdkZXNlbGVjdCcsIG9sZFNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZyZWUgdGhlIGFycmF5IGFuZCBpZCBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogICAgICAgIHBhc3NlZCB0byAjZGVzZWxlY3QoKS5cbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBfZGF0YSA9IG51bGw7XG4gICAgX2lkcyA9IG51bGw7XG4gICAgX3NlbGVjdGVkID0gbnVsbDtcbiAgICBpZiAoIV9pc1NpbGVudChvcHRpb25zKSkge1xuICAgICAgX3RoaXMudHJpZ2dlcignZGVzdHJveScpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3QgaW4gdGhlIGNvbGxlY3Rpb24gYnkgSUQuXG4gICAqXG4gICAqIFVzZXMgZ2V0SWRzKCksIHNvIGJ1aWxkcyBtYXAgb2YgSUQgdG8gSU5ERVggb24gZmlyc3QgYWNjZXNzIE8oTikuXG4gICAqIFN1YnNlcXVlbnQgYWNjZXNzIHNob3VsZCBiZSBPKDEpLlxuICAgKlxuICAgKiBAcGFyYW0gaWQge0FueX1cbiAgICogICAgICBpZiB0aGUgY29sbGVjdGlvbiBjb250YWlucyBtb3JlIHRoYW4gb25lIG9iamVjdCB3aXRoIHRoZSBzYW1lIGlkLFxuICAgKiAgICAgIHRoZSBsYXN0IGVsZW1lbnQgd2l0aCB0aGF0IGlkIGlzIHJldHVybmVkLlxuICAgKi9cbiAgX3RoaXMuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGlkcyA9IF90aGlzLmdldElkcygpO1xuXG4gICAgaWYgKGlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIC8vIHVzZSBjYWNoZWQgaW5kZXhcbiAgICAgIHJldHVybiBfZGF0YVtpZHNbaWRdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBtYXAgZnJvbSBJRCB0byBJTkRFWC5cbiAgICpcbiAgICogQHBhcmFtIGZvcmNlIHtCb29sZWFufVxuICAgKiAgICAgIHJlYnVpbGQgdGhlIG1hcCBldmVuIGlmIGl0IGV4aXN0cy5cbiAgICovXG4gIF90aGlzLmdldElkcyA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbGVuID0gX2RhdGEubGVuZ3RoLFxuICAgICAgICBpZDtcblxuICAgIGlmIChmb3JjZSB8fCBfaWRzID09PSBudWxsKSB7XG4gICAgICAvLyBidWlsZCB1cCBpZHMgZmlyc3QgdGltZSB0aHJvdWdoXG4gICAgICBfaWRzID0ge307XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWQgPSBfZGF0YVtpXS5pZDtcblxuICAgICAgICBpZiAoX2lkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICB0aHJvdyAnbW9kZWwgd2l0aCBkdXBsaWNhdGUgaWQgXCInICsgaWQgKyAnXCIgZm91bmQgaW4gY29sbGVjdGlvbic7XG4gICAgICAgIH1cblxuICAgICAgICBfaWRzW2lkXSA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9pZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9iamVjdC5cbiAgICovXG4gIF90aGlzLmdldFNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc2VsZWN0ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBvYmplY3RzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGNhbGxzIGFycmF5LnNwbGljZSB0byByZW1vdmUgaXRlbSBmcm9tIGFycmF5LlxuICAgKiBSZXNldCB3b3VsZCBiZSBmYXN0ZXIgaWYgbW9kaWZ5aW5nIGxhcmdlIGNodW5rcyBvZiB0aGUgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSBvIHtPYmplY3R9XG4gICAqICAgICAgb2JqZWN0IHRvIHJlbW92ZS5cbiAgICogQGRlcHJlY2F0ZWQgc2VlICNyZW1vdmVBbGwoKVxuICAgKi9cbiAgX3RoaXMucmVtb3ZlID0gZnVuY3Rpb24gKC8qIG8gKi8pIHtcbiAgICAvLyB0cmlnZ2VyIHJlbW92ZSBldmVudFxuICAgIF90aGlzLnJlbW92ZUFsbChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIG9iamVjdHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogUmVzZXQgaXMgZmFzdGVyIGlmIG1vZGlmeWluZyBsYXJnZSBjaHVua3Mgb2YgdGhlIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gdG9yZW1vdmUge0FycmF5PE9iamVjdD59XG4gICAqICAgICAgICBvYmplY3RzIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lsZW50IHtCb29sZWFufVxuICAgKiAgICAgICAgZGVmYXVsdCBmYWxzZS5cbiAgICogICAgICAgIHdoZXRoZXIgdG8gdHJpZ2dlciBldmVudHMgKGZhbHNlKSwgb3Igbm90ICh0cnVlKS5cbiAgICovXG4gIF90aGlzLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICh0b3JlbW92ZSwgb3B0aW9ucykge1xuICAgIHZhciBpLFxuICAgICAgICBsZW4gPSB0b3JlbW92ZS5sZW5ndGgsXG4gICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgaWRzID0gX3RoaXMuZ2V0SWRzKCksXG4gICAgICAgIG87XG5cbiAgICAvLyBzZWxlY3QgaW5kZXhlcyB0byBiZSByZW1vdmVkXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvID0gdG9yZW1vdmVbaV07XG5cbiAgICAgIC8vIGNsZWFyIGN1cnJlbnQgc2VsZWN0aW9uIGlmIGJlaW5nIHJlbW92ZWRcbiAgICAgIGlmIChvID09PSBfc2VsZWN0ZWQpIHtcbiAgICAgICAgX3RoaXMuZGVzZWxlY3QoKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRvIGxpc3QgdG8gYmUgcmVtb3ZlZFxuICAgICAgaWYgKGlkcy5oYXNPd25Qcm9wZXJ0eShvLmlkKSkge1xuICAgICAgICBpbmRleGVzLnB1c2goaWRzW28uaWRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICdyZW1vdmluZyBvYmplY3Qgbm90IGluIGNvbGxlY3Rpb24nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBpbiBkZXNjZW5kaW5nIGluZGV4IG9yZGVyXG4gICAgaW5kZXhlcy5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYS1iOyB9KTtcblxuICAgIGZvciAoaSA9IGluZGV4ZXMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBfZGF0YS5zcGxpY2UoaW5kZXhlc1tpXSwgMSk7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgaWQgY2FjaGVcbiAgICBfaWRzID0gbnVsbDtcblxuICAgIGlmICghX2lzU2lsZW50KG9wdGlvbnMpKSB7XG4gICAgICAvLyB0cmlnZ2VyIHJlbW92ZSBldmVudFxuICAgICAgX3RoaXMudHJpZ2dlcigncmVtb3ZlJywgdG9yZW1vdmUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgd3JhcHBlZCBhcnJheSB3aXRoIGEgbmV3IG9uZS5cbiAgICovXG4gIF90aGlzLnJlc2V0ID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAvLyBjaGVjayBmb3IgZXhpc3Rpbmcgc2VsZWN0aW9uXG4gICAgdmFyIHNlbGVjdGVkSWQgPSBudWxsO1xuICAgIGlmIChfc2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgIHNlbGVjdGVkSWQgPSBfc2VsZWN0ZWQuaWQ7XG4gICAgfVxuXG4gICAgLy8gZnJlZSBhcnJheSBhbmQgaWQgY2FjaGVcbiAgICBfZGF0YSA9IG51bGw7XG4gICAgX2lkcyA9IG51bGw7XG4gICAgX3NlbGVjdGVkID0gbnVsbDtcblxuICAgIC8vIHNldCBuZXcgYXJyYXlcbiAgICBfZGF0YSA9IGRhdGEgfHwgW107XG5cbiAgICAvLyBub3RpZnkgbGlzdGVuZXJzXG4gICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuc2lsZW50ICE9PSB0cnVlKSB7XG4gICAgICBfdGhpcy50cmlnZ2VyKCdyZXNldCcsIGRhdGEpO1xuICAgIH1cblxuICAgIC8vIHJlc2VsZWN0IGlmIHRoZXJlIHdhcyBhIHByZXZpb3VzIHNlbGVjdGlvblxuICAgIGlmIChzZWxlY3RlZElkICE9PSBudWxsKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBfdGhpcy5nZXQoc2VsZWN0ZWRJZCk7XG4gICAgICBpZiAoc2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zLCB7J3Jlc2V0JzogdHJ1ZX0pO1xuICAgICAgICBfdGhpcy5zZWxlY3Qoc2VsZWN0ZWQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2VsZWN0IGFuIG9iamVjdCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG9iaiB7T2JqZWN0fVxuICAgKiAgICAgIG9iamVjdCBpbiB0aGUgY29sbGVjdGlvbiB0byBzZWxlY3QuXG4gICAqIEB0aHJvd3MgZXhjZXB0aW9uXG4gICAqICAgICAgaWYgb2JqIG5vdCBpbiBjb2xsZWN0aW9uLlxuICAgKi9cbiAgX3RoaXMuc2VsZWN0ID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucykge1xuICAgIC8vIG5vIHNlbGVjdGlvblxuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgIF90aGlzLmRlc2VsZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFscmVhZHkgc2VsZWN0ZWRcbiAgICBpZiAob2JqID09PSBfc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZGVzZWxlY3QgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgaWYgKF9zZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgX3RoaXMuZGVzZWxlY3Qob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PT0gX3RoaXMuZ2V0KG9iai5pZCkpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBpdCdzIHBhcnQgb2YgdGhpcyBjb2xsZWN0aW9u4oCmXG4gICAgICBfc2VsZWN0ZWQgPSBvYmo7XG4gICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5zaWxlbnQgIT09IHRydWUpIHtcbiAgICAgICAgX3RoaXMudHJpZ2dlcignc2VsZWN0JywgX3NlbGVjdGVkLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ3NlbGVjdGluZyBvYmplY3Qgbm90IGluIGNvbGxlY3Rpb24nO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgdG8gc2VsZWN0IGNvbGxlY3Rpb24gaXRlbSB1c2luZyBpdHMgaWQuXG4gICAqXG4gICAqIFNlbGVjdHMgbWF0Y2hpbmcgaXRlbSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSBjbGVhcnMgYW55IHNlbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlkIHs/fVxuICAgKiAgICAgICAgaWQgb2YgaXRlbSB0byBzZWxlY3QuXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqICAgICAgICBvcHRpb25zIHBhc3NlZCB0byAjc2VsZWN0KCkgb3IgI2Rlc2VsZWN0KCkuXG4gICAqL1xuICBfdGhpcy5zZWxlY3RCeUlkID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IF90aGlzLmdldChpZCk7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCkge1xuICAgICAgX3RoaXMuc2VsZWN0KG9iaiwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmRlc2VsZWN0KG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU29ydHMgdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBtZXRob2Qge0Z1bmN0aW9ufVxuICAgKiAgICAgICAgamF2YXNjcmlwdCBzb3J0IG1ldGhvZC5cbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogICAgICAgIHBhc3NlZCB0byAjcmVzZXQoKVxuICAgKi9cbiAgX3RoaXMuc29ydCA9IGZ1bmN0aW9uIChtZXRob2QsIG9wdGlvbnMpIHtcbiAgICBfZGF0YS5zb3J0KG1ldGhvZCk7XG5cbiAgICAvLyBcInJlc2V0XCIgdG8gbmV3IHNvcnQgb3JkZXJcbiAgICBfdGhpcy5yZXNldChfZGF0YSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRvSlNPTiBtZXRob2QgdG8gc2VyaWFsaXplIG9ubHkgY29sbGVjdGlvbiBkYXRhLlxuICAgKi9cbiAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBqc29uID0gX2RhdGEuc2xpY2UoMCksXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIGksXG4gICAgICAgIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGpzb24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBqc29uW2ldO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIGl0ZW0gIT09IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgaXRlbS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAganNvbltpXSA9IGl0ZW0udG9KU09OKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb247XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZSgpO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyksXG4gICAgVmlldyA9IHJlcXVpcmUoJy4vVmlldycpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIC8vIGNsYXNzbmFtZSBhZGRlZCB0byBzZWxlY3QgYm94XG4gIGNsYXNzTmFtZTogJ2NvbGxlY3Rpb24tc2VsZWN0Ym94JyxcbiAgaW5jbHVkZUJsYW5rT3B0aW9uOiBmYWxzZSxcbiAgYmxhbmtPcHRpb246IHtcbiAgICB0ZXh0OiAnUGxlYXNlIHNlbGVjdCZoZWxsaXA7JyxcbiAgICB2YWx1ZTogJy0xJ1xuICB9LFxuXG4gIC8vIGNhbGxiYWNrIHRvIGZvcm1hdCBlYWNoIGNvbGxlY3Rpb24gaXRlbVxuICBmb3JtYXQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uaWQ7XG4gIH0sXG5cbiAgLy8gd2hldGhlciB0byByZW5kZXIgZHVyaW5nIGluaXRpYWxpemVcbiAgcmVuZGVyTm93OiB0cnVlXG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBDb2xsZWN0aW9uU2VsZWN0Qm94IHRvIHNlbGVjdCBhIGNvbGxlY3Rpb24gaXRlbS5cbiAqXG4gKiBAcGFyYW0gcGFyYW1zIHtPYmplY3R9XG4gKiBAcGFyYW0gcGFyYW1zLmZvcm1hdCB7RnVuY3Rpb24oT2JqZWN0KX1cbiAqICAgICAgICBjYWxsYmFjayBmdW5jdGlvbiB0byBmb3JtYXQgc2VsZWN0IGJveCBpdGVtcy5cbiAqIEBwYXJhbSBwYXJhbXMuY2xhc3NOYW1lIHtTdHJpbmd9XG4gKiAgICAgICAgRGVmYXVsdCAnY29sbGVjdGlvbi1zZWxlY3Rib3gnLlxuICogICAgICAgIENsYXNzIG5hbWUgZm9yIHNlbGVjdCBib3guXG4gKiBAcGFyYW0gcGFyYW1zLmNvbGxlY3Rpb24ge0NvbGxlY3Rpb259XG4gKiAgICAgICAgdGhlIGNvbGxlY3Rpb24gdG8gZGlzcGxheS5cbiAqICAgICAgICBOT1RFOiB0aGUgY29sbGVjdGlvbiBzaG91bGQgaGF2ZSBhbiBleGlzdGluZyBzZWxlY3Rpb247XG4gKiAgICAgICAgb3RoZXJ3aXNlLCB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgc2VsZWN0IGJveCB3aWxsIGJlIHNlbGVjdGVkXG4gKiAgICAgICAgaW4gdGhlIFVJIGFuZCBub3QgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKiBAc2VlIG12Yy9WaWV3XG4gKi9cbnZhciBDb2xsZWN0aW9uU2VsZWN0Qm94ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2JsYW5rT3B0aW9uLFxuICAgICAgX2NvbGxlY3Rpb24sXG4gICAgICBfZm9ybWF0LFxuICAgICAgX2dldFZhbGlkT3B0aW9ucyxcbiAgICAgIF9pbmNsdWRlQmxhbmtPcHRpb24sXG4gICAgICBfc2VsZWN0Qm94LFxuXG4gICAgICBfY3JlYXRlQmxhbmtPcHRpb24sXG4gICAgICBfZGVmYXVsdEdldFZhbGlkT3B0aW9ucyxcbiAgICAgIF9vbkNoYW5nZSxcbiAgICAgIF9vblNlbGVjdDtcblxuXG4gIHBhcmFtcyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIHBhcmFtcyk7XG4gIF90aGlzID0gVmlldyhwYXJhbXMpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICovXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBlbDtcblxuICAgIGVsID0gX3RoaXMuZWw7XG5cbiAgICBfYmxhbmtPcHRpb24gPSBwYXJhbXMuYmxhbmtPcHRpb247XG4gICAgX2NvbGxlY3Rpb24gPSBwYXJhbXMuY29sbGVjdGlvbjtcbiAgICBfZm9ybWF0ID0gcGFyYW1zLmZvcm1hdDtcbiAgICBfZ2V0VmFsaWRPcHRpb25zID0gcGFyYW1zLmdldFZhbGlkT3B0aW9ucyB8fCBfZGVmYXVsdEdldFZhbGlkT3B0aW9ucztcbiAgICBfaW5jbHVkZUJsYW5rT3B0aW9uID0gcGFyYW1zLmluY2x1ZGVCbGFua09wdGlvbjtcblxuICAgIC8vIHJldXNlIG9yIGNyZWF0ZSBzZWxlY3QgYm94XG4gICAgaWYgKGVsLm5vZGVOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgX3NlbGVjdEJveCA9IGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBfc2VsZWN0Qm94ID0gZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0JykpO1xuICAgIH1cbiAgICBfc2VsZWN0Qm94LmNsYXNzTGlzdC5hZGQocGFyYW1zLmNsYXNzTmFtZSk7XG5cbiAgICAvLyBiaW5kIHRvIGV2ZW50cyBvbiB0aGUgY29sbGVjdGlvblxuICAgIF9jb2xsZWN0aW9uLm9uKCdhZGQnLCBfdGhpcy5yZW5kZXIpO1xuICAgIF9jb2xsZWN0aW9uLm9uKCdyZW1vdmUnLCBfdGhpcy5yZW5kZXIpO1xuICAgIF9jb2xsZWN0aW9uLm9uKCdyZXNldCcsIF90aGlzLnJlbmRlcik7XG4gICAgX2NvbGxlY3Rpb24ub24oJ3NlbGVjdCcsIF9vblNlbGVjdCk7XG4gICAgX2NvbGxlY3Rpb24ub24oJ2Rlc2VsZWN0JywgX29uU2VsZWN0KTtcblxuICAgIC8vIGJpbmQgdG8gZXZlbnRzIG9uIHRoaXMuX3NlbGVjdEJveFxuICAgIF9zZWxlY3RCb3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgX29uQ2hhbmdlKTtcblxuICAgIC8vIHBvcHVsYXRlIHNlbGVjdCBib3hcbiAgICBpZiAocGFyYW1zLnJlbmRlck5vdykge1xuICAgICAgX3RoaXMucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVCbGFua09wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICc8b3B0aW9uICcsXG4gICAgICAgICd2YWx1ZT1cIicsIF9ibGFua09wdGlvbi52YWx1ZSwgJ1wiPicsXG4gICAgICBfYmxhbmtPcHRpb24udGV4dCxcbiAgICAnPC9vcHRpb24+J1xuICAgIF0uam9pbignJyk7XG4gIH07XG5cbiAgX2RlZmF1bHRHZXRWYWxpZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jb2xsZWN0aW9uLmRhdGEoKS5tYXAoZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8uaWQ7IH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgc2VsZWN0Ym94IGNoYW5nZSBldmVudHMuXG4gICAqL1xuICBfb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgdmFsdWUgPSBfc2VsZWN0Qm94LnZhbHVlO1xuXG4gICAgaWYgKF9pbmNsdWRlQmxhbmtPcHRpb24gJiYgdmFsdWUgPT09IF9ibGFua09wdGlvbi52YWx1ZSkge1xuICAgICAgX2NvbGxlY3Rpb24uZGVzZWxlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2NvbGxlY3Rpb24uc2VsZWN0QnlJZCh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgY29sbGVjdGlvbiBzZWxlY3QgZXZlbnRzLlxuICAgKi9cbiAgX29uU2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxlY3RlZCxcbiAgICAgICAgdmFsaWRPcHRpb25zO1xuXG4gICAgc2VsZWN0ZWQgPSBfY29sbGVjdGlvbi5nZXRTZWxlY3RlZCgpO1xuICAgIHZhbGlkT3B0aW9ucyA9IF9nZXRWYWxpZE9wdGlvbnMoKTtcblxuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgaWYgKHZhbGlkT3B0aW9ucy5pbmRleE9mKHNlbGVjdGVkLmlkKSA9PT0gLTEpIHtcbiAgICAgICAgX2NvbGxlY3Rpb24uZGVzZWxlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zZWxlY3RCb3gudmFsdWUgPSBzZWxlY3RlZC5pZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9pbmNsdWRlQmxhbmtPcHRpb24pIHtcbiAgICAgIF9zZWxlY3RCb3gudmFsdWUgPSBfYmxhbmtPcHRpb24udmFsdWU7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgQ29sbGVjdGlvblNlbGVjdEJveC5cbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIF9jb2xsZWN0aW9uLm9mZignYWRkJywgX3RoaXMucmVuZGVyKTtcbiAgICBfY29sbGVjdGlvbi5vZmYoJ3JlbW92ZScsIF90aGlzLnJlbmRlcik7XG4gICAgX2NvbGxlY3Rpb24ub2ZmKCdyZXNldCcsIF90aGlzLnJlbmRlcik7XG4gICAgX2NvbGxlY3Rpb24ub2ZmKCdzZWxlY3QnLCBfb25TZWxlY3QpO1xuICAgIF9jb2xsZWN0aW9uLm9mZignZGVzZWxlY3QnLCBfb25TZWxlY3QpO1xuXG4gICAgX3NlbGVjdEJveC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBfb25DaGFuZ2UpO1xuXG4gICAgX2JsYW5rT3B0aW9uID0gbnVsbDtcbiAgICBfY29sbGVjdGlvbiA9IG51bGw7XG4gICAgX2Zvcm1hdCA9IG51bGw7XG4gICAgX2dldFZhbGlkT3B0aW9ucyA9IG51bGw7XG4gICAgX2luY2x1ZGVCbGFua09wdGlvbiA9IG51bGw7XG4gICAgX3NlbGVjdEJveCA9IG51bGw7XG5cbiAgICBfY3JlYXRlQmxhbmtPcHRpb24gPSBudWxsO1xuICAgIF9kZWZhdWx0R2V0VmFsaWRPcHRpb25zID0gbnVsbDtcbiAgICBfb25DaGFuZ2UgPSBudWxsO1xuICAgIF9vblNlbGVjdCA9IG51bGw7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogVXBkYXRlIHNlbGVjdCBib3ggaXRlbXMuXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEsXG4gICAgICAgIGksXG4gICAgICAgIGlkLFxuICAgICAgICBsZW4sXG4gICAgICAgIG1hcmt1cCxcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgIHZhbGlkT3B0aW9ucztcblxuICAgIGRhdGEgPSBfY29sbGVjdGlvbi5kYXRhKCk7XG4gICAgbWFya3VwID0gW107XG4gICAgc2VsZWN0ZWQgPSBfY29sbGVjdGlvbi5nZXRTZWxlY3RlZCgpO1xuXG4gICAgaWYgKF9pbmNsdWRlQmxhbmtPcHRpb24gPT09IHRydWUpIHtcbiAgICAgIG1hcmt1cC5wdXNoKF9jcmVhdGVCbGFua09wdGlvbigpKTtcbiAgICB9XG5cbiAgICB2YWxpZE9wdGlvbnMgPSBfZ2V0VmFsaWRPcHRpb25zKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZCA9IGRhdGFbaV0uaWQ7XG5cbiAgICAgIG1hcmt1cC5wdXNoKCc8b3B0aW9uIHZhbHVlPVwiJyArIGlkICsgJ1wiJyArXG4gICAgICAgICAgKHNlbGVjdGVkID09PSBkYXRhW2ldID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInIDogJycpICtcbiAgICAgICAgICAodmFsaWRPcHRpb25zLmluZGV4T2YoaWQpID09PSAtMSA/ICcgZGlzYWJsZWQ9XCJkaXNhYmxlZFwiJyA6ICcnKSArXG4gICAgICAgICAgJz4nICsgX2Zvcm1hdChkYXRhW2ldKSArICc8L29wdGlvbj4nKTtcbiAgICB9XG5cbiAgICBfc2VsZWN0Qm94LmlubmVySFRNTCA9IG1hcmt1cC5qb2luKCcnKTtcbiAgICBfb25TZWxlY3QoKTtcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKHBhcmFtcyk7XG4gIHBhcmFtcyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvblNlbGVjdEJveDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKSxcbiAgICBWaWV3ID0gcmVxdWlyZSgnLi9WaWV3Jyk7XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcbiAgLy8gY2xhc3MgbmFtZSBmb3IgdGFibGVcbiAgY2xhc3NOYW1lOiAnY29sbGVjdGlvbi10YWJsZScsXG4gIC8vIGNsaWNrIG9uIHRhYmxlIHJvd3MgdG8gdHJpZ2dlciBzZWxlY3QgaW4gY29sbGVjdGlvblxuICBjbGlja1RvU2VsZWN0OiBmYWxzZSxcbiAgLy8gY29sdW1ucyBvZiBkYXRhIHRvIGRpc3BsYXlcbiAgY29sdW1uczogW1xuICAgIC8ve1xuICAgICAgLy8gY2xhc3MgbmFtZSBmb3IgaGVhZGVyIGFuZCBkYXRhIGNlbGxzXG4gICAgICAvLyAgIGNsYXNzTmFtZTogJycsXG4gICAgICAvLyBoZWFkZXIgY29udGVudCBmb3IgY29sdW1uXG4gICAgICAvLyAgIHRpdGxlOiAnJyxcbiAgICAgIC8vIGZvcm1hdCBmdW5jdGlvbiBmb3IgZGF0YSBjZWxsc1xuICAgICAgLy8gICBmb3JtYXQ6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAnJzsgfVxuICAgICAgLy8gd2hldGhlciBjb2x1bW4gaXMgaGVhZGVyIGZvciBpdHMgcm93XG4gICAgICAvLyAgIGhlYWRlcjogZmFsc2VcbiAgICAvL31cbiAgXSxcbiAgZW1wdHlNYXJrdXA6ICdObyBkYXRhIHRvIGRpc3BsYXknLFxuICAvLyB3aGV0aGVyIHRvIHJlbmRlciBhZnRlciBpbml0aWFsaXphdGlvblxuICByZW5kZXJOb3c6IHRydWVcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBDb2xsZWN0aW9uVGFibGUgdG8gZGlzcGxheSBhIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHBhcmFtcyB7T2JqZWN0fVxuICogQHBhcmFtIHBhcmFtcy5jb2xsZWN0aW9uIHtDb2xsZWN0aW9ufVxuICogICAgICAgIENvbGxlY3Rpb24gdG8gZGlzcGxheS5cbiAqIEBwYXJhbSBwYXJhbXMuY29sdW1ucyB7QXJyYXk8T2JqZWN0Pn1cbiAqICAgICAgICBBcnJheSBvZiBjb2x1bW4gb2JqZWN0cyBkZWZpbmluZyBkaXNwbGF5LlxuICogICAgICAgIEVhY2ggb2JqZWN0IHNob3VsZCBoYXZlIHRoZXNlIHByb3BlcnRpZXM6XG4gKiAgICAgICAgLSBjbGFzc05hbWUge1N0cmluZ30gY2xhc3MgbmFtZSBmb3IgaGVhZGVyIGFuZCBkYXRhIGNlbGxzLlxuICogICAgICAgIC0gdGl0bGUge1N0cmluZ30gbWFya3VwIGZvciBoZWFkZXIgY2VsbC5cbiAqICAgICAgICAtIGZvcm1hdCB7RnVuY3Rpb24oaXRlbSl9IGZ1bmN0aW9uIHRvIGZvcm1hdCBkYXRhIGNlbGwuXG4gKiAgICAgICAgLSBoZWFkZXIge0Jvb2xlYW59IGRlZmF1bHQgZmFsc2UuXG4gKiAgICAgICAgICB3aGV0aGVyIGNvbHVtbiBpcyByb3cgaGVhZGVyIGFuZCBzaG91bGQgdXNlIHRoIHNjb3BlPXJvdyAodHJ1ZSksXG4gKiAgICAgICAgICBvciBhIHJlZ3VsYXIgZGF0YSBjZWxsIGFuZCBzaG91bGQgdXNlIHRkIChmYWxzZSkuXG4gKiBAcGFyYW0gcGFyYW1zLmNsaWNrVG9TZWxlY3Qge0Jvb2xlYW59XG4gKiAgICAgICAgRGVmYXVsdCBmYWxzZS4gIFdoZXRoZXIgY2xpY2tpbmcgb24gdGFibGUgcm93cyBzaG91bGQgc2VsZWN0XG4gKiAgICAgICAgdGhlIGNvcnJlc3BvbmRpbmcgY29sbGVjdGlvbiBpdGVtLlxuICogQHNlZSBtdmMvVmlld1xuICovXG52YXIgQ29sbGVjdGlvblRhYmxlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2NsYXNzTmFtZSxcbiAgICAgIF9jbGlja1RvU2VsZWN0LFxuICAgICAgX2NvbGxlY3Rpb24sXG4gICAgICBfY29sdW1ucyxcbiAgICAgIF9lbXB0eU1hcmt1cCxcblxuICAgICAgX29uQ2xpY2ssXG4gICAgICBfb25TZWxlY3Q7XG5cblxuICBwYXJhbXMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBwYXJhbXMpO1xuICBfdGhpcyA9IFZpZXcocGFyYW1zKTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfY2xhc3NOYW1lID0gcGFyYW1zLmNsYXNzTmFtZTtcbiAgICBfY2xpY2tUb1NlbGVjdCA9IHBhcmFtcy5jbGlja1RvU2VsZWN0O1xuICAgIF9jb2xsZWN0aW9uID0gcGFyYW1zLmNvbGxlY3Rpb247XG4gICAgX2NvbHVtbnMgPSBwYXJhbXMuY29sdW1ucztcbiAgICBfZW1wdHlNYXJrdXAgPSBwYXJhbXMuZW1wdHlNYXJrdXA7XG5cbiAgICAvLyByZXNwb25kIHRvIGNvbGxlY3Rpb24gZXZlbnRzXG4gICAgX2NvbGxlY3Rpb24ub24oJ2FkZCcsIF90aGlzLnJlbmRlcik7XG4gICAgX2NvbGxlY3Rpb24ub24oJ3JlbW92ZScsIF90aGlzLnJlbmRlcik7XG4gICAgX2NvbGxlY3Rpb24ub24oJ3Jlc2V0JywgX3RoaXMucmVuZGVyKTtcbiAgICBfY29sbGVjdGlvbi5vbignc2VsZWN0JywgX29uU2VsZWN0KTtcbiAgICBfY29sbGVjdGlvbi5vbignZGVzZWxlY3QnLCBfb25TZWxlY3QpO1xuXG4gICAgLy8gYWRkIGNsaWNrIGhhbmRsZXJcbiAgICBpZiAoX2NsaWNrVG9TZWxlY3QpIHtcbiAgICAgIF90aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX29uQ2xpY2spO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMucmVuZGVyTm93KSB7XG4gICAgICBfdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogSGFuZGxlIHRhYmxlIGNsaWNrIGV2ZW50cy5cbiAgICogTGlzdGVuZXIgaXMgb25seSBhZGRlZCB3aGVuIG9wdGlvbnMuY2xpY2tUb1NlbGVjdCBpcyB0cnVlLlxuICAgKi9cbiAgX29uQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCxcbiAgICAgICAgcm93ID0gVXRpbC5nZXRQYXJlbnROb2RlKHRhcmdldCwgJ1RSJywgX3RoaXMuZWwpO1xuXG4gICAgaWYgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgaWYgKHJvdy5wYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdUQk9EWScpIHtcbiAgICAgICAgX2NvbGxlY3Rpb24uc2VsZWN0QnlJZChyb3cuZ2V0QXR0cmlidXRlKCdkYXRhLWlkJykpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGNvbGxlY3Rpb24gc2VsZWN0IGFuZCBkZXNlbGVjdCBldmVudHMuXG4gICAqL1xuICBfb25TZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gX3RoaXMuZWwsXG4gICAgICAgIHNlbGVjdGVkO1xuXG4gICAgLy8gcmVtb3ZlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgIHNlbGVjdGVkID0gZWwucXVlcnlTZWxlY3RvcignLnNlbGVjdGVkJyk7XG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICBzZWxlY3RlZC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgIH1cblxuICAgIC8vIHNldCBuZXcgc2VsZWN0aW9uXG4gICAgc2VsZWN0ZWQgPSBfY29sbGVjdGlvbi5nZXRTZWxlY3RlZCgpO1xuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgc2VsZWN0ZWQgPSBlbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cIicgKyBzZWxlY3RlZC5pZCArICdcIl0nKTtcbiAgICAgIHNlbGVjdGVkLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFVuZG8gaW5pdGlhbGl6YXRpb24gYW5kIGZyZWUgcmVmZXJlbmNlcy5cbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuXG4gICAgX2NvbGxlY3Rpb24ub2ZmKCdhZGQnLCBfdGhpcy5yZW5kZXIpO1xuICAgIF9jb2xsZWN0aW9uLm9mZigncmVtb3ZlJywgX3RoaXMucmVuZGVyKTtcbiAgICBfY29sbGVjdGlvbi5vZmYoJ3Jlc2V0JywgX3RoaXMucmVuZGVyKTtcbiAgICBfY29sbGVjdGlvbi5vZmYoJ3NlbGVjdCcsIF9vblNlbGVjdCk7XG4gICAgX2NvbGxlY3Rpb24ub2ZmKCdkZXNlbGVjdCcsIF9vblNlbGVjdCk7XG4gICAgX2NvbGxlY3Rpb24gPSBudWxsO1xuXG4gICAgaWYgKF9jbGlja1RvU2VsZWN0KSB7XG4gICAgICBfdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF9vbkNsaWNrKTtcbiAgICB9XG4gICAgX2NsaWNrVG9TZWxlY3QgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSB2aWV3LlxuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjLFxuICAgICAgICBjTGVuLFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGksXG4gICAgICAgIGlkLFxuICAgICAgICBpTGVuLFxuICAgICAgICBpdGVtLFxuICAgICAgICBtYXJrdXA7XG5cbiAgICBkYXRhID0gX2NvbGxlY3Rpb24uZGF0YSgpO1xuICAgIG1hcmt1cCA9IFtdO1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSBfZW1wdHlNYXJrdXA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWFya3VwLnB1c2goJzx0YWJsZSBjbGFzcz1cIicsIF9jbGFzc05hbWUsICdcIj48dGhlYWQ+Jyk7XG4gICAgZm9yIChjID0gMCwgY0xlbiA9IF9jb2x1bW5zLmxlbmd0aDsgYyA8IGNMZW47IGMrKykge1xuICAgICAgY29sdW1uID0gX2NvbHVtbnNbY107XG4gICAgICBtYXJrdXAucHVzaCgnPHRoIGNsYXNzPVwiJyArIGNvbHVtbi5jbGFzc05hbWUgKyAnXCI+JyArXG4gICAgICAgICAgY29sdW1uLnRpdGxlICsgJzwvdGg+Jyk7XG4gICAgfVxuICAgIG1hcmt1cC5wdXNoKCc8L3RoZWFkPjx0Ym9keT4nKTtcbiAgICBmb3IgKGkgPSAwLCBpTGVuID0gZGF0YS5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBkYXRhW2ldO1xuICAgICAgaWQgPSAoJycgKyBpdGVtLmlkKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgICBtYXJrdXAucHVzaCgnPHRyIGRhdGEtaWQ9XCInICsgaWQgKyAnXCI+Jyk7XG4gICAgICBmb3IgKGMgPSAwLCBjTGVuID0gX2NvbHVtbnMubGVuZ3RoOyBjIDwgY0xlbjsgYysrKSB7XG4gICAgICAgIGNvbHVtbiA9IF9jb2x1bW5zW2NdO1xuICAgICAgICBtYXJrdXAucHVzaCgnPCcgKyAoY29sdW1uLmhlYWRlciA/ICd0aCBzY29wZT1cInJvd1wiJyA6ICd0ZCcpICtcbiAgICAgICAgICAgICcgY2xhc3M9XCInICsgY29sdW1uLmNsYXNzTmFtZSArICdcIj4nICtcbiAgICAgICAgICAgIGNvbHVtbi5mb3JtYXQoaXRlbSkgKyAnPC90ZD4nKTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKCc8L3RyPicpO1xuICAgIH1cbiAgICBtYXJrdXAucHVzaCgnPC90Ym9keT48L3RhYmxlPicpO1xuXG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gbWFya3VwLmpvaW4oJycpO1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUoKTtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uVGFibGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBDb2xsZWN0aW9uVGFibGUgPSByZXF1aXJlKCcuL0NvbGxlY3Rpb25UYWJsZScpLFxuICAgIERvd25sb2FkVmlldyA9IHJlcXVpcmUoJy4vRG93bmxvYWRWaWV3JyksXG4gICAgU29ydFZpZXcgPSByZXF1aXJlKCcuL1NvcnRWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpLFxuICAgIFZpZXcgPSByZXF1aXJlKCcuL1ZpZXcnKTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBEYXRhVGFibGUgdG8gZGlzcGxheSBhIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHBhcmFtcyB7T2JqZWN0fVxuICogICAgICAgIGFsbCBwYXJhbXMgZXhjZXB0IFwiZWxcIiBhcmUgcGFzc2VkIHRvIENvbGxlY3Rpb25UYWJsZS5cbiAqIEBwYXJhbSBwYXJhbXMuc29ydHMge0FycmF5PE9iamVjdD59XG4gKiAgICAgICAgc29ydCBvYmplY3RzIHVzZWQgYnkgU29ydFZpZXcuXG4gKiBAcGFyYW0gcGFyYW1zLmZvcm1hdERvd25sb2FkIHtGdW5jdGlvbihDb2xsZWN0aW9uKX1cbiAqICAgICAgICBPcHRpb25hbCwgZGVmYXVsdCBpcyBUYWIgU2VwYXJhdGVkIFZhbHVlcy5cbiAqIEBwYXJhbSBwYXJhbXMuY29sdW1ucyB7QXJyYXk8T2JqZWN0Pn1cbiAqICAgICAgICBjb2x1bW4gb2JqZWN0cyB1c2VkIGJ5IENvbGxlY3Rpb25UYWJsZS5cbiAqIEBwYXJhbSBwYXJhbXMuY29sdW1uc1tYXS5kb3dubG9hZEZvcm1hdCB7RnVuY3Rpb24oT2JqZWN0KX1cbiAqICAgICAgICBPcHRpb25hbCwgZGVmYXVsdCBpcyBjb2x1bW4uZm9ybWF0LlxuICogICAgICAgIEZ1bmN0aW9uIHVzZWQgdG8gZm9ybWF0IGEgY29sdW1uIHZhbHVlIGZvciBkb3dubG9hZC5cbiAqICAgICAgICBVc2VkIGJ5IERhdGFUYWJsZS5fZm9ybWF0RG93bmxvYWQuXG4gKiBAcGFyYW0gcGFyYW1zLmNvbHVtbnNbWF0uZG93bmxvYWRUaXRsZSB7c3RyaW5nfVxuICogICAgICAgIE9wdGlvbmFsLCBkZWZhdWx0IGlzIGNvbHVtbi50aXRsZS5cbiAqICAgICAgICBjb2x1bW4gdGl0bGUgdmFsdWUgZm9yIGRvd25sb2FkLlxuICogICAgICAgIFVzZWQgYnkgRGF0YVRhYmxlLl9mb3JtYXREb3dubG9hZC5cbiAqIEBzZWUgQ29sbGVjdGlvblRhYmxlXG4gKiBAc2VlIFNvcnRWaWV3XG4gKiBAc2VlIERvd25sb2FkVmlld1xuICovXG52YXIgRGF0YVRhYmxlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2NvbGxlY3Rpb24sXG4gICAgICBfY29sbGVjdGlvblRhYmxlLFxuICAgICAgX2NvbHVtbnMsXG4gICAgICBfZG93bmxvYWRCdXR0b24sXG4gICAgICBfZG93bmxvYWRWaWV3LFxuICAgICAgX3NvcnRzLFxuICAgICAgX3NvcnRWaWV3LFxuXG4gICAgICBfZm9ybWF0RG93bmxvYWQ7XG5cblxuICBfdGhpcyA9IFZpZXcocGFyYW1zKTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgRGF0YVRhYmxlLlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsLFxuICAgICAgICB0b29scztcblxuICAgIGVsID0gX3RoaXMuZWw7XG4gICAgZWwuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJkYXRhdGFibGUtdG9vbHNcIj48L2Rpdj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRhdGFibGUtZGF0YVwiPjwvZGl2Pic7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnZGF0YXRhYmxlJyk7XG4gICAgdG9vbHMgPSBlbC5xdWVyeVNlbGVjdG9yKCcuZGF0YXRhYmxlLXRvb2xzJyk7XG5cbiAgICBfY29sbGVjdGlvbiA9IHBhcmFtcy5jb2xsZWN0aW9uO1xuICAgIF9jb2x1bW5zID0gcGFyYW1zLmNvbHVtbnM7XG5cbiAgICAvLyBzb3J0XG4gICAgX3NvcnRzID0gcGFyYW1zLnNvcnRzO1xuICAgIGlmIChfc29ydHMpIHtcbiAgICAgIF9zb3J0VmlldyA9IG5ldyBTb3J0Vmlldyh7XG4gICAgICAgIGNvbGxlY3Rpb246IF9jb2xsZWN0aW9uLFxuICAgICAgICBzb3J0czogX3NvcnRzLFxuICAgICAgICBkZWZhdWx0U29ydDogcGFyYW1zLmRlZmF1bHRTb3J0XG4gICAgICB9KTtcbiAgICAgIHRvb2xzLmFwcGVuZENoaWxkKF9zb3J0Vmlldy5lbCk7XG4gICAgfVxuXG4gICAgLy8gZGF0YVxuICAgIF9jb2xsZWN0aW9uVGFibGUgPSBuZXcgQ29sbGVjdGlvblRhYmxlKFxuICAgICAgICBVdGlsLmV4dGVuZCh7fSwgcGFyYW1zLCB7XG4gICAgICAgICAgZWw6IGVsLnF1ZXJ5U2VsZWN0b3IoJy5kYXRhdGFibGUtZGF0YScpXG4gICAgICAgIH0pKTtcblxuICAgIC8vIGRvd25sb2FkXG4gICAgX2Rvd25sb2FkVmlldyA9IG5ldyBEb3dubG9hZFZpZXcoe1xuICAgICAgY29sbGVjdGlvbjogX2NvbGxlY3Rpb24sXG4gICAgICBoZWxwOiBwYXJhbXMuaGVscCB8fCAnQ29weSB0aGVuIHBhc3RlIGludG8gYSBzcHJlYWRzaGVldCBhcHBsaWNhdGlvbicsXG4gICAgICBmb3JtYXQ6IHBhcmFtcy5mb3JtYXREb3dubG9hZCB8fCBfZm9ybWF0RG93bmxvYWRcbiAgICB9KTtcblxuICAgIF9kb3dubG9hZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIF9kb3dubG9hZEJ1dHRvbi5pbm5lckhUTUwgPSAnRG93bmxvYWQnO1xuICAgIF9kb3dubG9hZEJ1dHRvbi5jbGFzc05hbWUgPSAnZG93bmxvYWQnO1xuICAgIF9kb3dubG9hZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF9kb3dubG9hZFZpZXcuc2hvdyk7XG4gICAgdG9vbHMuYXBwZW5kQ2hpbGQoX2Rvd25sb2FkQnV0dG9uKTtcblxuXG4gICAgcGFyYW1zID0gbnVsbDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB1c2VkIHRvIGZvcm1hdCBkb3dubG9hZHMuXG4gICAqIFRoaXMgaW1wbGVtZW50YXRpb24gb3V0cHV0cyBUYWIgU2VwYXJhdGVkIFZhbHVlcy5cbiAgICovXG4gIF9mb3JtYXREb3dubG9hZCA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGMsXG4gICAgICAgIGNMZW4sXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICBpLFxuICAgICAgICBpTGVuLFxuICAgICAgICBpdGVtLFxuICAgICAgICByb3c7XG5cbiAgICBjb250ZW50ID0gW107XG4gICAgZGF0YSA9IGNvbGxlY3Rpb24uZGF0YSgpO1xuICAgIHJvdyA9IFtdO1xuXG4gICAgZm9yIChjID0gMCwgY0xlbiA9IF9jb2x1bW5zLmxlbmd0aDsgYyA8IGNMZW47IGMrKykge1xuICAgICAgY29sdW1uID0gX2NvbHVtbnNbY107XG4gICAgICByb3cucHVzaChjb2x1bW4uZG93bmxvYWRUaXRsZSB8fCBjb2x1bW4udGl0bGUpO1xuICAgIH1cbiAgICBjb250ZW50LnB1c2gocm93LmpvaW4oJ1xcdCcpKTtcblxuICAgIGZvciAoaSA9IDAsIGlMZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgaXRlbSA9IGRhdGFbaV07XG4gICAgICByb3cgPSBbXTtcbiAgICAgIGZvciAoYyA9IDAsIGNMZW4gPSBfY29sdW1ucy5sZW5ndGg7IGMgPCBjTGVuOyBjKyspIHtcbiAgICAgICAgY29sdW1uID0gX2NvbHVtbnNbY107XG4gICAgICAgIGZvcm1hdCA9IGNvbHVtbi5kb3dubG9hZEZvcm1hdCB8fCBjb2x1bW4uZm9ybWF0O1xuICAgICAgICByb3cucHVzaChmb3JtYXQoaXRlbSkpO1xuICAgICAgfVxuICAgICAgY29udGVudC5wdXNoKHJvdy5qb2luKCdcXHQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQuam9pbignXFxuJyk7XG4gIH07XG5cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgRGF0YVRhYmxlLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9zb3J0Vmlldykge1xuICAgICAgX3NvcnRWaWV3LmRlc3Ryb3koKTtcbiAgICAgIF9zb3J0VmlldyA9IG51bGw7XG4gICAgfVxuXG4gICAgX2Rvd25sb2FkQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX2Rvd25sb2FkVmlldy5zaG93KTtcbiAgICBfZG93bmxvYWRCdXR0b24gPSBudWxsO1xuXG4gICAgX2Rvd25sb2FkVmlldy5kZXN0cm95KCk7XG4gICAgX2Rvd25sb2FkVmlldyA9IG51bGw7XG5cbiAgICBfY29sbGVjdGlvblRhYmxlLmRlc3Ryb3koKTtcbiAgICBfY29sbGVjdGlvblRhYmxlID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cblxuICBfaW5pdGlhbGl6ZSgpO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFUYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGFsVmlldyA9IHJlcXVpcmUoJy4vTW9kYWxWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpLFxuICAgIFZpZXcgPSByZXF1aXJlKCcuL1ZpZXcnKTtcblxuXG52YXIgX0RFRkFVTFRTID0ge1xuICAvLyB0aXRsZSBvZiBtb2RhbCBkaWFsb2cuXG4gIHRpdGxlOiAnRG93bmxvYWQnLFxuICAvLyBtYXJrdXAgdG8gZGVzY3JpYmUgZG93bmxvYWQgY29udGVudC5cbiAgaGVscDogJycsXG4gIC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZvcm1hdCBjb2xsZWN0aW9uIGZvciBkb3dubG9hZC5cbiAgZm9ybWF0OiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjb2xsZWN0aW9uKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIERvd25sb2FkVmlldy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogQHBhcmFtIG9wdGlvbnMudGl0bGUge1N0cmluZ31cbiAqICAgICAgICBEZWZhdWx0ICdEb3dubG9hZCcuXG4gKiAgICAgICAgTW9kYWwgZGlhbG9nIHRpdGxlLlxuICogQHBhcmFtIG9wdGlvbnMuZm9ybWF0IHtGdW5jdGlvbihDb2xsZWN0aW9uKX1cbiAqICAgICAgICBEZWZhdWx0IEpTT04uc3RyaW5naWZ5LlxuICogICAgICAgIGZ1bmN0aW9uIHRvIGZvcm1hdCBjb2xsZWN0aW9uIGZvciBkb3dubG9hZC5cbiAqIEBzZWUgbXZjL1ZpZXdcbiAqL1xudmFyIERvd25sb2FkVmlldyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9jb2xsZWN0aW9uLFxuICAgICAgX2Zvcm1hdCxcbiAgICAgIF9tb2RhbCxcbiAgICAgIF90ZXh0YXJlYSxcbiAgICAgIF90aXRsZTtcblxuXG4gIHBhcmFtcyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIHBhcmFtcyk7XG4gIF90aGlzID0gVmlldyhwYXJhbXMpO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBkb3dubG9hZCB2aWV3LlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gX3RoaXMuZWw7XG5cbiAgICBfY29sbGVjdGlvbiA9IHBhcmFtcy5jb2xsZWN0aW9uO1xuICAgIF9mb3JtYXQgPSBwYXJhbXMuZm9ybWF0O1xuICAgIF90aXRsZSA9IHBhcmFtcy50aXRsZTtcblxuICAgIGVsLmNsYXNzTmFtZSA9ICdkb3dubG9hZC12aWV3JztcbiAgICBlbC5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImhlbHBcIj4nICsgcGFyYW1zLmhlbHAgKyAnPC9kaXY+JyArXG4gICAgICAgICc8dGV4dGFyZWEgY2xhc3M9XCJkb3dubG9hZFwiIHJlYWRvbmx5PVwicmVhZG9ubHlcIj48L3RleHRhcmVhPic7XG4gICAgX3RleHRhcmVhID0gZWwucXVlcnlTZWxlY3RvcignLmRvd25sb2FkJyk7XG5cbiAgICBwYXJhbXMgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBkb3dubG9hZCB2aWV3LlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9tb2RhbCkge1xuICAgICAgLy8gVE9ETzogaGlkZSBmaXJzdD9cbiAgICAgIF9tb2RhbC5kZXN0cm95KCk7XG4gICAgICBfbW9kYWwgPSBudWxsO1xuICAgIH1cblxuICAgIF9jb2xsZWN0aW9uID0gbnVsbDtcbiAgICBfZm9ybWF0ID0gbnVsbDtcbiAgICBfdGV4dGFyZWEgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogRm9ybWF0IGNvbGxlY3Rpb24gZm9yIGRvd25sb2FkLlxuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF90ZXh0YXJlYS52YWx1ZSA9IF9mb3JtYXQoX2NvbGxlY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBkb3dubG9hZCB2aWV3LCBjYWxscyByZW5kZXIgYmVmb3JlIHNob3dpbmcgbW9kYWwuXG4gICAqL1xuICBfdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX21vZGFsKSB7XG4gICAgICBfbW9kYWwgPSBuZXcgTW9kYWxWaWV3KF90aGlzLmVsLCB7XG4gICAgICAgIHRpdGxlOiBfdGl0bGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF90aGlzLnJlbmRlcigpO1xuICAgIF9tb2RhbC5zaG93KCk7XG4gICAgX3RleHRhcmVhLnNlbGVjdCgpO1xuICB9O1xuXG4gIF9pbml0aWFsaXplKCk7XG4gIHJldHVybiBfdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRG93bmxvYWRWaWV3OyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogR2VuZXJpYyBjbGFzcyBmb3IgbW9kYWwgZGlhbG9nIHZpZXdzLiBNb2RhbCBkaWFsb2dzIHByZXNlbnQgYSBibG9ja2luZ1xuICogaW50ZXJmYWNlIHRvIHRoZSB1c2VyIGFuZCByZXF1aXJlIHVzZXItaW50ZXJhY3Rpb24gaW4gb3JkZXIgdG8gYmUgY2xvc2VkXG4gKiAoaS5lLiBjbGlja2luZyBhIGJ1dHRvbiBldGMuLi4pLlxuICpcbiAqIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgd2hpbGUgdGhlIGludGVyZmFjZSBhcHBlYXJzIGJsb2NrZWQgd2hpbGUgYVxuICogbW9kYWwgZGlhbG9nIGlzIG9wZW4sIEphdmFzY3JpcHQgY29udGludWVzIHRvIGV4ZWN1dGUgaW4gdGhlIGJhY2tncm91bmQuXG4gKlxuICogT25seSBvbmUgbW9kYWwgZGlhbG9nIGNhbiBiZSB2aXNpYmxlIGF0IGFueSBnaXZlbiB0aW1lLlxuICpcbiAqIElmIGEgc2Vjb25kIG1vZGFsIGRpYWxvZyBpcyBvcGVuZWQgd2hpbGUgdGhlIGZpcnN0IG1vZGFsIGRpYWxvZyBpcyBzdGlsbFxuICogdmlzaWJsZSwgdGhlIGZpcnN0IG1vZGFsIGRpYWxvZyBpcyBoaWRkZW4gYW5kIHRoZSBzZWNvbmQgaXMgc2hvd24uIFVwb25cbiAqIGNsb3NpbmcgdGhlIHNlY29uZCBtb2RhbCBkaWFsb2csIHRoZSBmaXJzdCBtb2RhbCBkaWFsb2cgaXMgcmUtc2hvd24gKHVubGVzc1xuICogdGhlIFwiY2xlYXJcIiBtZXRob2QgaXMgcGFzc2VkIHRvIHRoZSBoaWRlIG1ldGhvZCkuIFRoaXMgcHJvY2VzcyBjb250aW51ZXMgaW4gYVxuICogbGFzdC1pbiwgZmlyc3Qtb3V0IChzdGFjaykgb3JkZXJpbmcgdW50aWwgYWxsIG1vZGFsIGRpYWxvZ3MgYXJlIGNsb3NlZC5cbiAqXG4gKi9cblxudmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKSxcbiAgICBWaWV3ID0gcmVxdWlyZSgnLi9WaWV3Jyk7XG5cblxudmFyIF9fSU5JVElBTElaRURfXyA9IGZhbHNlLFxuICAgIF9ESUFMT0dfU1RBQ0sgPSBudWxsLFxuICAgIF9GT0NVU19TVEFDSyA9IG51bGwsXG4gICAgX01BU0sgPSBudWxsLFxuICAgIF9ERUZBVUxUUyA9IHtcbiAgICAgIGNsb3NhYmxlOiB0cnVlLCAvLyBTaG91bGQgbW9kYWwgYm94IGluY2x1ZGUgbGl0dGxlIFwiWCcgaW4gY29ybmVyXG4gICAgICBkZXN0cm95T25IaWRlOiBmYWxzZSxcbiAgICAgIHRpdGxlOiBkb2N1bWVudC50aXRsZSArICcgU2F5cy4uLidcbiAgICB9O1xuXG52YXIgX3N0YXRpY19pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAvLyBDcmVhdGUgdGhlIGRpYWxvZyBzdGFja1xuICBfRElBTE9HX1NUQUNLID0gW107XG5cbiAgLy8gQ3JlYXRlIHRoZSBmb2N1cyBzdGFja1xuICBfRk9DVVNfU1RBQ0sgPSBbXTtcblxuICAvLyBDcmVhdGUgdGhlIG1vZGFsIG1hc2tcbiAgX01BU0sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgX01BU0suY2xhc3NMaXN0LmFkZCgnbW9kYWwnKTtcblxuICBfX0lOSVRJQUxJWkVEX18gPSB0cnVlO1xufTtcblxuLy8gTm90ZTogXCJ0aGlzXCIgaXMgYSByZWZlcmVuY2UgdG8gdGhlIGJ1dHRvbSBET00gZWxlbWVudCBhbmQgaGFzIGFsbCB0aGVcbi8vICAgICAgIHByb3BlciBhdHRyaWJ1dGVzIHNldCBvbiBpdCBzdWNoIHRoYXQgdGhlIGltcGxlbWVudGF0aW9uIGJlbG93IGlzXG4vLyAgICAgICBjb3JyZWN0LiBJdCBkb2VzICpub3QqIG5lZWQgdG8gdXNlIF90aGlzIChhbHNvIGl0J3MgYSBzdGF0aWMgbWV0aG9kKS5cbnZhciBfYnV0dG9uQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gIGlmICh0aGlzLmluZm8gJiYgdGhpcy5pbmZvLmNhbGxiYWNrICYmXG4gICAgICB0eXBlb2YgdGhpcy5pbmZvLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5pbmZvLmNhbGxiYWNrKGV2dCwgdGhpcy5tb2RhbHx8e30pO1xuICB9XG59O1xuXG4vKipcbiAqIFB1bGxzIHRoZSBuZXh0IGVsZW1lbnQgb2ZmIHRoZSBmb2N1cyBzdGFjayBhbmQgYXR0ZW1wdHMgdG8gc2V0IHRoZVxuICogZm9jdXMgdG8gaXQuXG4gKlxuICovXG52YXIgX2ZvY3VzTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGU7XG5cbiAgbm9kZSA9IF9GT0NVU19TVEFDSy5wb3AoKTtcblxuICBpZiAobm9kZSAmJiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBub2RlLmZvY3VzKSB7XG4gICAgbm9kZS5mb2N1cygpO1xuICB9XG59O1xuXG52YXIgTW9kYWxWaWV3ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHBhcmFtcykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2J1dHRvbnMsXG4gICAgICBfY2xhc3NlcyxcbiAgICAgIF9jbG9zYWJsZSxcbiAgICAgIF9jbG9zZUJ1dHRvbixcbiAgICAgIF9jb250ZW50LFxuICAgICAgX2Rlc3Ryb3lPbkhpZGUsXG4gICAgICBfZm9vdGVyLFxuICAgICAgX21lc3NhZ2UsXG4gICAgICBfdGl0bGUsXG4gICAgICBfdGl0bGVFbCxcblxuICAgICAgX2NyZWF0ZUJ1dHRvbixcbiAgICAgIF9jcmVhdGVWaWV3U2tlbGV0b24sXG4gICAgICBfb25LZXlEb3duLFxuICAgICAgX29uTW9kYWxDbGljaztcblxuXG4gIHBhcmFtcyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIHBhcmFtcyk7XG4gIF90aGlzID0gVmlldyhwYXJhbXMpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuXG4gICAgX2J1dHRvbnMgPSBwYXJhbXMuYnV0dG9ucztcbiAgICBfY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzO1xuICAgIF9jbG9zYWJsZSA9IHBhcmFtcy5jbG9zYWJsZTtcbiAgICBfZGVzdHJveU9uSGlkZSA9IHBhcmFtcy5kZXN0cm95T25IaWRlO1xuICAgIF9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICBfdGl0bGUgPSBwYXJhbXMudGl0bGU7XG5cbiAgICBfdGhpcy5lbC5tb2RhbCA9IF90aGlzO1xuXG4gICAgX2NyZWF0ZVZpZXdTa2VsZXRvbigpO1xuICAgIF90aGlzLnJlbmRlcigpO1xuXG4gICAgaWYgKCFfX0lOSVRJQUxJWkVEX18pIHtcbiAgICAgIF9zdGF0aWNfaW5pdGlhbGl6ZSgpO1xuICAgIH1cblxuICAgIHBhcmFtcyA9IG51bGw7XG4gIH07XG5cblxuICBfY3JlYXRlQnV0dG9uID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbGVuLFxuICAgICAgICBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKSxcbiAgICAgICAgYnV0dG9uSW5mbztcblxuICAgIGJ1dHRvbkluZm8gPSBVdGlsLmV4dGVuZCh7fSwge1xuICAgICAgY2xhc3NlczogW10sXG4gICAgICB0ZXh0OiAnQ2xpY2sgTWUnLFxuICAgICAgdGl0bGU6ICcnLFxuICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSwgaW5mbyk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBidXR0b25JbmZvLmNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKGJ1dHRvbkluZm8uY2xhc3Nlc1tpXSk7XG4gICAgfVxuXG4gICAgYnV0dG9uLmlubmVySFRNTCA9IGJ1dHRvbkluZm8udGV4dDtcblxuICAgIGlmIChidXR0b25JbmZvLnRpdGxlICE9PSAnJykge1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBidXR0b25JbmZvLnRpdGxlKTtcbiAgICB9XG5cbiAgICBidXR0b24ubW9kYWwgPSBfdGhpcztcbiAgICBidXR0b24uaW5mbyA9IGJ1dHRvbkluZm87XG5cbiAgICBpZiAoYnV0dG9uSW5mby5jYWxsYmFjaykge1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX2J1dHRvbkNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnV0dG9uO1xuICB9O1xuXG4gIF9jcmVhdGVWaWV3U2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhlYWRlciwgaSwgbGVuO1xuXG4gICAgVXRpbC5lbXB0eShfdGhpcy5lbCk7XG4gICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnbW9kYWwtZGlhbG9nJyk7XG5cbiAgICAvLyBBZGQgY3VzdG9tIGNsYXNzZXMgdG8gdGhlIHZpZXdcbiAgICBpZiAoX2NsYXNzZXMgJiYgX2NsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gX2NsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZChfY2xhc3Nlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF90aXRsZSkge1xuICAgICAgaGVhZGVyID0gX3RoaXMuZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaGVhZGVyJykpO1xuICAgICAgaGVhZGVyLmNsYXNzTGlzdC5hZGQoJ21vZGFsLWhlYWRlcicpO1xuXG4gICAgICBfdGl0bGVFbCA9IGhlYWRlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpKTtcbiAgICAgIF90aXRsZUVsLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAnLTEnKTtcbiAgICAgIF90aXRsZUVsLmNsYXNzTGlzdC5hZGQoJ21vZGFsLXRpdGxlJyk7XG5cblxuICAgICAgaWYgKF9jbG9zYWJsZSkge1xuICAgICAgICBfY2xvc2VCdXR0b24gPSBoZWFkZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpKTtcbiAgICAgICAgX2Nsb3NlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ21vZGFsLWNsb3NlLWxpbmsnKTtcbiAgICAgICAgX2Nsb3NlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ21hdGVyaWFsLWljb25zJyk7XG4gICAgICAgIF9jbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ0Nsb3NlJyk7XG4gICAgICAgIF9jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnY2xvc2UnO1xuICAgICAgICBfY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5oaWRlKTtcbiAgICAgIH1cbiAgICB9ICBlbHNlIHtcbiAgICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ25vLWhlYWRlcicpO1xuICAgIH1cblxuICAgIF9jb250ZW50ID0gX3RoaXMuZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpKTtcbiAgICBfY29udGVudC5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgJy0xJyk7XG4gICAgX2NvbnRlbnQuY2xhc3NMaXN0LmFkZCgnbW9kYWwtY29udGVudCcpO1xuXG4gICAgaWYgKF9idXR0b25zICYmIF9idXR0b25zLmxlbmd0aCkge1xuICAgICAgX2Zvb3RlciA9IF90aGlzLmVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvb3RlcicpKTtcbiAgICAgIF9mb290ZXIuY2xhc3NMaXN0LmFkZCgnbW9kYWwtZm9vdGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ25vLWZvb3RlcicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgYm91bmQgdG8gdGhlIE1vZGFsVmlldyBpbnN0YW5jZSB1c2luZyB0aGVcbiAgICogRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgbWV0aG9kLCB0aHVzIHRoZSByZWZlcmVuY2UgdG8gXCJ0aGlzXCIgaXMgY29ycmVjdFxuICAgKiBldmVuIHRob3VnaCB0aGlzIGlzIGEga2V5ZG93biBldmVudCBoYW5kbGVyLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQge0tleUV2ZW50fVxuICAgKiAgICAgIFRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGNhbGwuXG4gICAqL1xuICBfb25LZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICBfdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG5cbiAgX29uTW9kYWxDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQuY2xhc3NOYW1lID09PSAnbW9kYWwnKSB7XG4gICAgICBfdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGFuZCBmcmVlIHJlZmVyZW5jZXMuXG4gICAqXG4gICAqIFlvdSBzaG91bGQgY2FsbCBoaWRlIGZpcnN0LlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnV0dG9uO1xuXG4gICAgX01BU0sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5oaWRlKTtcblxuICAgIGlmIChfYnV0dG9ucyAmJiBfYnV0dG9ucy5sZW5ndGgpIHtcbiAgICAgIHdoaWxlIChfZm9vdGVyLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBidXR0b24gPSBfZm9vdGVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF9idXR0b25DYWxsYmFjayk7XG4gICAgICAgIF9mb290ZXIucmVtb3ZlQ2hpbGQoYnV0dG9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX2Nsb3NlQnV0dG9uKSB7XG4gICAgICBfY2xvc2VCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5oaWRlKTtcbiAgICAgIF9jbG9zZUJ1dHRvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVsZXRlIF90aGlzLmVsLm1vZGFsO1xuXG4gICAgX2Zvb3RlciA9IG51bGw7XG4gICAgX3RpdGxlRWwgPSBudWxsO1xuICAgIF9jb250ZW50ID0gbnVsbDtcbiAgICBfZGVzdHJveU9uSGlkZSA9IG51bGw7XG4gICAgX3RoaXMuZWwgPSBudWxsO1xuICAgIF9vbk1vZGFsQ2xpY2sgPSBudWxsO1xuICB9O1xuXG4gIF90aGlzLmhpZGUgPSBmdW5jdGlvbiAoY2xlYXJBbGwpIHtcbiAgICB2YXIgaXNWaXNpYmxlO1xuXG4gICAgaXNWaXNpYmxlID0gKF90aGlzLmVsLnBhcmVudE5vZGUgPT09IF9NQVNLKTtcblxuICAgIGlmIChjbGVhckFsbCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gUmVtb3ZlIGFueS9hbGwgZGlhbG9ncyBhdHRhY2hlZCB0byBfTUFTS1xuICAgICAgVXRpbC5lbXB0eShfTUFTSyk7XG5cbiAgICAgIC8vIENsZWFyIHN0YWNrIG9mIHByZXZpb3VzIGRpYWxvZ3MgdG8gcmV0dXJuIHVzZXIgdG8gbm9ybWFsIGFwcGxpY2F0aW9uLlxuICAgICAgX0RJQUxPR19TVEFDSy5zcGxpY2UoMCwgX0RJQUxPR19TVEFDSy5sZW5ndGgpO1xuXG4gICAgICAvLyBDbGVhciBhbGwgYnV0IGxhc3QgZm9jdXMgZWxlbWVudFxuICAgICAgX0ZPQ1VTX1NUQUNLLnNwbGljZSgxLCBfRk9DVVNfU1RBQ0subGVuZ3RoKTtcblxuICAgICAgX2ZvY3VzTmV4dCgpO1xuXG4gICAgICBpZiAoaXNWaXNpYmxlKSB7IC8vIE9yIHJhdGhlciwgd2FzIHZpc2libGVcbiAgICAgICAgX3RoaXMudHJpZ2dlcignaGlkZScsIF90aGlzKTtcblxuICAgICAgICBpZiAoX2Rlc3Ryb3lPbkhpZGUpIHtcbiAgICAgICAgICBfdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgLy8gVGhpcyBtb2RhbCBpcyBjdXJyZW50bHkgdmlzaWJsZVxuICAgICAgX3RoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpcy5lbCk7XG5cbiAgICAgIC8vIENoZWNrIGlmIGFueSBvdGhlciBkaWFsb2dzIGV4aXN0IGluIHN0YWNrLCBpZiBzbywgc2hvdyBpdFxuICAgICAgaWYgKF9ESUFMT0dfU1RBQ0subGVuZ3RoID4gMCkge1xuICAgICAgICBfRElBTE9HX1NUQUNLLnBvcCgpLnNob3coKTtcbiAgICAgIH1cblxuICAgICAgX2ZvY3VzTmV4dCgpO1xuICAgICAgX3RoaXMudHJpZ2dlcignaGlkZScsIF90aGlzKTtcblxuICAgICAgaWYgKF9kZXN0cm95T25IaWRlKSB7XG4gICAgICAgIF90aGlzLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIV9NQVNLLmZpcnN0Q2hpbGQgJiYgX01BU0sucGFyZW50Tm9kZSkge1xuICAgICAgLy8gTm8gbW9yZSBkaWFsb2dzLCByZW1vdmUgdGhlIF9NQVNLXG4gICAgICBfTUFTSy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9NQVNLKTtcbiAgICAgIF9NQVNLLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX29uTW9kYWxDbGljayk7XG5cbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnYmFja2dyb3VuZFNjcm9sbERpc2FibGUnKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgX29uS2V5RG93bik7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdmFyIG0gPSBtZXNzYWdlIHx8IF9tZXNzYWdlLFxuICAgICAgICBidXR0b24gPSBudWxsLFxuICAgICAgICBidXR0b25zID0gX2J1dHRvbnMgfHwgW10sXG4gICAgICAgIGksIGxlbiA9IGJ1dHRvbnMubGVuZ3RoO1xuXG4gICAgLy8gU2V0IHRoZSBtb2RhbCBkaWFsb2cgY29udGVudFxuICAgIFV0aWwuZW1wdHkoX2NvbnRlbnQpO1xuXG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgX2NvbnRlbnQuaW5uZXJIVE1MID0gbTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gX3RoaXMucmVuZGVyKG0oX3RoaXMpKTtcbiAgICB9IGVsc2UgaWYgKG0gaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICBfY29udGVudC5hcHBlbmRDaGlsZChtKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIG1vZGFsIGRpYWxvZyB0aXRsZVxuICAgIGlmIChfdGl0bGUpIHtcbiAgICAgIF90aXRsZUVsLmlubmVySFRNTCA9IF90aXRsZTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBhbnkgb2xkIGZvb3RlciBjb250ZW50XG4gICAgaWYgKF9idXR0b25zICYmIF9idXR0b25zLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKF9mb290ZXIuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJ1dHRvbiA9IF9mb290ZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgVXRpbC5yZW1vdmVFdmVudChidXR0b24sICdjbGljaycsIF9idXR0b25DYWxsYmFjayk7XG4gICAgICAgIF9mb290ZXIucmVtb3ZlQ2hpbGQoYnV0dG9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgbmV3IGZvb3RlciBjb250ZW50XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBfZm9vdGVyLmFwcGVuZENoaWxkKF9jcmVhdGVCdXR0b24oYnV0dG9uc1tpXSkpO1xuICAgIH1cblxuICAgIF90aGlzLnRyaWdnZXIoJ3JlbmRlcicsIF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgX3RoaXMuc2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgX21lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gICAgX3RoaXMudHJpZ2dlcignbWVzc2FnZScsIF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgX3RoaXMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChwYXJhbXMsIGV4dGVuZCkge1xuICAgIGlmIChleHRlbmQpIHtcbiAgICAgIHBhcmFtcyA9IFV0aWwuZXh0ZW5kKHt9LCB7XG4gICAgICAgIGJ1dHRvbnM6IF9idXR0b25zLFxuICAgICAgICBjbGFzc2VzOiBfY2xhc3NlcyxcbiAgICAgICAgY2xvc2FibGU6IF9jbG9zYWJsZSxcbiAgICAgICAgbWVzc2FnZTogX21lc3NhZ2UsXG4gICAgICAgIHRpdGxlOiBfdGl0bGVcbiAgICAgIH0sIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgX2J1dHRvbnMgPSBwYXJhbXMuYnV0dG9ucztcbiAgICBfY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzO1xuICAgIF9jbG9zYWJsZSA9IHBhcmFtcy5jbG9zYWJsZTtcbiAgICBfbWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgX3RpdGxlID0gcGFyYW1zLnRpdGxlO1xuXG4gICAgX3RoaXMudHJpZ2dlcignb3B0aW9ucycsIF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgX3RoaXMuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2xkQ2hpbGQgPSBudWxsO1xuXG4gICAgLy8gRm9yIGFjY2Vzc2liaWxpdHksIGZvY3VzIHRoZSB0b3Agb2YgdGhpcyBuZXcgZGlhbG9nXG4gICAgX0ZPQ1VTX1NUQUNLLnB1c2goZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBmYWxzZSk7XG5cbiAgICAvLyBNYXNrIGFscmVhZHkgaGFzIGEgZGlhbG9nIGluIGl0LCBhZGQgdG8gZGlhbG9nIHN0YWNrIGFuZCBjb250aW51ZVxuICAgIHdoaWxlIChfTUFTSy5maXJzdENoaWxkKSB7XG4gICAgICBvbGRDaGlsZCA9IF9NQVNLLmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAob2xkQ2hpbGQubW9kYWwpIHtcbiAgICAgICAgX0RJQUxPR19TVEFDSy5wdXNoKG9sZENoaWxkLm1vZGFsKTtcbiAgICAgIH1cbiAgICAgIF9NQVNLLnJlbW92ZUNoaWxkKG9sZENoaWxkKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhpcyBkaWFsb2cgdG8gdGhlIG1hc2tcbiAgICBfTUFTSy5hcHBlbmRDaGlsZChfdGhpcy5lbCk7XG4gICAgX01BU0suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfb25Nb2RhbENsaWNrKTtcblxuICAgIC8vIFNob3cgdGhlIG1hc2sgaWYgbm90IHlldCB2aXNpYmxlXG4gICAgaWYgKCFfTUFTSy5wYXJlbnROb2RlKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKF9NQVNLKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnYmFja2dyb3VuZFNjcm9sbERpc2FibGUnKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgX29uS2V5RG93bik7XG4gICAgfVxuXG5cbiAgICBpZiAoX3RpdGxlKSB7XG4gICAgICBfdGl0bGVFbC5mb2N1cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfY29udGVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIF90aGlzLnRyaWdnZXIoJ3Nob3cnLCBfdGhpcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIF9pbml0aWFsaXplKCk7XG4gIHJldHVybiBfdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kYWxWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vQ29sbGVjdGlvbicpLFxuICAgIENvbGxlY3Rpb25TZWxlY3RCb3ggPSByZXF1aXJlKCcuL0NvbGxlY3Rpb25TZWxlY3RCb3gnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9VdGlsJyksXG4gICAgVmlldyA9IHJlcXVpcmUoJy4vVmlldycpO1xuXG4vKipcbiAqIENvbnN0cnVjdCBhIFNvcnRWaWV3LlxuICpcbiAqIFNvcnQgb2JqZWN0cyBjYW4gc3BlY2lmeSBhIGN1c3RvbSBzb3J0IGZ1bmN0aW9uIChzb3J0KSxcbiAqIG9yIGEgdmFsdWUgdG8gYmUgc29ydGVkIChzb3J0QnkpIGFuZCBzb3J0IG9yZGVyIChkZXNjZW5kaW5nKS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogQHBhcmFtIG9wdGlvbnMuc29ydHMge0FycmF5PE9iamVjdD59XG4gKiAgICAgICAgYXJyYXkgb2Ygc29ydCBvYmplY3RzLCB3aXRoIHByb3BlcnRpZXM6XG4gKiAgICAgICAgLSBpZCB7U3RyaW5nfE51bWJlcn0gdW5pcXVlIGlkZW50aWZpZXIgZm9yIHNvcnRcbiAqICAgICAgICAtIHRpdGxlIHtTdHJpbmd9IGRpc3BsYXkgbmFtZSBmb3Igc29ydFxuICogICAgICAgIEFuZDpcbiAqICAgICAgICAtIHNvcnQge0Z1bmN0aW9uKGEsIGIpfSBzb3J0aW5nIGZ1bmN0aW9uLlxuICogICAgICAgIE9yOlxuICogICAgICAgIC0gc29ydEJ5IHtGdW5jdGlvbihPYmplY3QpfSByZXR1cm4gdmFsdWUgZm9yIHNvcnRpbmcuXG4gKiAgICAgICAgLSBkZXNjZW5kaW5nIHtCb29sZWFufSBkZWZhdWx0IGZhbHNlLCB3aGV0aGVyIHRvXG4gKiAgICAgICAgICBzb3J0IGFzY2VuZGluZyAodHJ1ZSkgb3IgZGVzY2VuZGluZyAoZmFsc2UpLlxuICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdFNvcnQge0lEfVxuICogICAgICAgIE9wdGlvbmFsLlxuICogICAgICAgIElmIHNwZWNpZmllZCwgc2hvdWxkIG1hdGNoIFwiaWRcIiBvZiBhIHNvcnQgb2JqZWN0LlxuICogQHNlZSBtdmMvVmlld1xuICovXG52YXIgU29ydFZpZXcgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfY29sbGVjdGlvbixcbiAgICAgIF9zZWxlY3RWaWV3LFxuICAgICAgX3NvcnRDb2xsZWN0aW9uLFxuXG4gICAgICBfZ2V0U29ydEZ1bmN0aW9uLFxuICAgICAgX29uU2VsZWN0O1xuXG5cbiAgX3RoaXMgPSBWaWV3KHBhcmFtcyk7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIFNvcnRWaWV3LlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gX3RoaXMuZWw7XG5cbiAgICBfY29sbGVjdGlvbiA9IHBhcmFtcy5jb2xsZWN0aW9uO1xuXG4gICAgZWwuaW5uZXJIVE1MID0gJzxsYWJlbD5Tb3J0IGJ5IDxzZWxlY3Q+PC9zZWxlY3Q+PC9sYWJlbD4nO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3NvcnR2aWV3Jyk7XG5cbiAgICBfc29ydENvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbihwYXJhbXMuc29ydHMpO1xuICAgIF9zb3J0Q29sbGVjdGlvbi5vbignc2VsZWN0JywgX29uU2VsZWN0LCB0aGlzKTtcblxuICAgIC8vIGluaXRpYWwgc29ydCBvcmRlclxuICAgIGlmIChwYXJhbXMuZGVmYXVsdFNvcnQpIHtcbiAgICAgIF9zb3J0Q29sbGVjdGlvbi5zZWxlY3QoX3NvcnRDb2xsZWN0aW9uLmdldChwYXJhbXMuZGVmYXVsdFNvcnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3NvcnRDb2xsZWN0aW9uLnNlbGVjdChfc29ydENvbGxlY3Rpb24uZGF0YSgpWzBdKTtcbiAgICB9XG5cbiAgICBfc2VsZWN0VmlldyA9IG5ldyBDb2xsZWN0aW9uU2VsZWN0Qm94KHtcbiAgICAgIGVsOiBlbC5xdWVyeVNlbGVjdG9yKCdzZWxlY3QnKSxcbiAgICAgIGNvbGxlY3Rpb246IF9zb3J0Q29sbGVjdGlvbixcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udGl0bGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwYXJhbXMgPSBudWxsO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBzb3J0QnkgZnVuY3Rpb24gdG8gYSBzb3J0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gc29ydEJ5IHtGdW5jdGlvbihPYmplY3QpfVxuICAgKiAgICAgICAgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHNvcnQga2V5LlxuICAgKiBAcGFyYW0gZGVzY2VuZGluZyB7Qm9vbGVhbn1cbiAgICogICAgICAgIERlZmF1bHQgZmFsc2UuXG4gICAqICAgICAgICBXaGV0aGVyIHRvIHNvcnQgYXNjZW5kaW5nIChmYWxzZSkgb3IgZGVzY2VuZGluZyAodHJ1ZSkuXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9uKGEsIGIpfSBzb3J0IGZ1bmN0aW9uLlxuICAgKi9cbiAgX2dldFNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChzb3J0QnksIGRlc2NlbmRpbmcpIHtcbiAgICB2YXIgY2FjaGUgPSB7fTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGF2YWwgPSBjYWNoZVthLmlkXSxcbiAgICAgICAgICBidmFsID0gY2FjaGVbYi5pZF0sXG4gICAgICAgICAgdG1wO1xuXG4gICAgICBpZiAoIWF2YWwpIHtcbiAgICAgICAgYXZhbCA9IGNhY2hlW2EuaWRdID0gc29ydEJ5KGEpO1xuICAgICAgfVxuICAgICAgaWYgKCFidmFsKSB7XG4gICAgICAgIGJ2YWwgPSBjYWNoZVtiLmlkXSA9IHNvcnRCeShiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgICAgLy8gc3dhcCBjb21wYXJpc29uIG9yZGVyXG4gICAgICAgIHRtcCA9IGJ2YWw7XG4gICAgICAgIGJ2YWwgPSBhdmFsO1xuICAgICAgICBhdmFsID0gdG1wO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXZhbCA8IGJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChhdmFsID4gYnZhbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBzb3J0IGNvbGxlY3Rpb24gc2VsZWN0IGV2ZW50LlxuICAgKi9cbiAgX29uU2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxlY3RlZCA9IF9zb3J0Q29sbGVjdGlvbi5nZXRTZWxlY3RlZCgpLFxuICAgICAgICBzb3J0O1xuXG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICBzb3J0ID0gc2VsZWN0ZWQuc29ydDtcbiAgICAgIGlmICghc29ydCkge1xuICAgICAgICBzb3J0ID0gX2dldFNvcnRGdW5jdGlvbihzZWxlY3RlZC5zb3J0QnksIHNlbGVjdGVkLmRlc2NlbmRpbmcpO1xuICAgICAgfVxuICAgICAgX2NvbGxlY3Rpb24uc29ydChzb3J0KTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgU29ydFZpZXcuXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBfc29ydENvbGxlY3Rpb24ub2ZmKCdzZWxlY3QnLCBfb25TZWxlY3QsIHRoaXMpO1xuICAgIF9zb3J0Q29sbGVjdGlvbiA9IG51bGw7XG4gICAgX2NvbGxlY3Rpb24gPSBudWxsO1xuICAgIF9zZWxlY3RWaWV3LmRlc3Ryb3koKTtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cblxuICBfaW5pdGlhbGl6ZSgpO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvcnRWaWV3OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFhtbFV0aWwgPSByZXF1aXJlKCdxdWFrZW1sL1htbFV0aWwnKSxcbiAgICBRdWFrZW1sRXZlbnQgPSByZXF1aXJlKCdxdWFrZW1sL1F1YWtlbWxFdmVudCcpO1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFF1YWtlbWwgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gKiBAcGFyYW0gb3B0aW9ucy54bWwge1N0cmluZ3xYTUxEb2N1bWVudH1cbiAqICAgICAgICBxdWFrZW1sIHhtbCB0byBwYXJzZS5cbiAqICAgICAgICBJZiBhIHN0cmluZywgb3B0aW9ucy54bWwgaXMgcGFyc2VkIHVzaW5nIERPTVBhcnNlci5cbiAqIEBwYXJhbSBvcHRpb25zLmV2ZW50RWxlbWVudCB7U3RyaW5nfVxuICogICAgICAgIERlZmF1bHQgJ2V2ZW50Jy5cbiAqICAgICAgICBUaGUgZXZlbnQgZWxlbWVudCBpbnNpZGUgZXZlbnRQYXJhbWV0ZXJzIHRvIGZpbmQuXG4gKiAgICAgICAgVGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgaXMgcGFyc2VkIGR1cmluZyBfaW5pdGlhbGl6ZS5cbiAqL1xudmFyIFF1YWtlbWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2V2ZW50LFxuICAgICAgX3VwZGF0ZWQsXG4gICAgICBfcXVha2VtbDtcblxuXG4gIF90aGlzID0gT2JqZWN0LmNyZWF0ZSh7fSk7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHF1YWtlbWwgb2JqZWN0LlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBldixcbiAgICAgICAgZXZlbnRFbGVtZW50ID0gb3B0aW9ucy5ldmVudEVsZW1lbnQgfHwgJ2V2ZW50JyxcbiAgICAgICAgZXZlbnRQYXJhbWV0ZXJzLFxuICAgICAgICBqc29uLFxuICAgICAgICBxdWFrZW1sO1xuXG4gICAganNvbiA9IFhtbFV0aWwueG1sVG9Kc29uKG9wdGlvbnMueG1sKTtcbiAgICBxdWFrZW1sID0ganNvblsncTpxdWFrZW1sJ107XG4gICAgZXZlbnRQYXJhbWV0ZXJzID0gcXVha2VtbC5ldmVudFBhcmFtZXRlcnM7XG4gICAgZXYgPSBldmVudFBhcmFtZXRlcnNbZXZlbnRFbGVtZW50XTtcbiAgICBpZiAodHlwZW9mIGV2ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCBlbGVtZW50ICcgKyBldmVudEVsZW1lbnQgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIF9xdWFrZW1sID0gcXVha2VtbDtcbiAgICBfdXBkYXRlZCA9IGV2ZW50UGFyYW1ldGVycy5jcmVhdGlvbkluZm8uY3JlYXRpb25UaW1lO1xuICAgIF9ldmVudCA9IFF1YWtlbWxFdmVudCgoQXJyYXkuaXNBcnJheShldikgPyBldlswXSA6IGV2KSk7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gbWFnbml0dWRlcyBwYXJzZWQgZnJvbSBldmVudCBlbGVtZW50LlxuICAgKi9cbiAgX3RoaXMuZ2V0TWFnbml0dWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2V2ZW50LmdldE1hZ25pdHVkZXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gb3JpZ2lucyBwYXJzZWQgZnJvbSBldmVudCBlbGVtZW50LlxuICAgKi9cbiAgX3RoaXMuZ2V0T3JpZ2lucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2V2ZW50LmdldE9yaWdpbnMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH0gZXZlbnQgZWxlbWVudCBmcm9tIHF1YWtlbWwgbWVzc2FnZS5cbiAgICovXG4gIF90aGlzLmdldFF1YWtlbWxFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2V2ZW50LmdldEV2ZW50KCk7XG4gIH07XG5cbiAgICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfSBpc284NjAxIHRpbWVzdGFtcCB3aGVuIHF1YWtlbWwgbWVzc2FnZSB3YXMgdXBkYXRlZC5cbiAgICovXG4gIF90aGlzLmdldFVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91cGRhdGVkO1xuICB9O1xuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zPW51bGw7XG4gIHJldHVybiBfdGhpcztcblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1YWtlbWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgdG8gYW4gYXJyYXkgaWYgbmVlZGVkLlxuICpcbiAqIEBwYXJhbSBvYmoge0FueX1cbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBpZiBvYmogaXMgYW4gT2JqZWN0LCBlaXRoZXJcbiAqICAgICAgICAgICBvYmosIGlmIG9iaiBpcyBhbHJlYWR5IGFuIGFycmF5LFxuICogICAgICAgICAgIG90aGVyd2lzZSwgW29ial1cbiAqICAgICAgICAgb3RoZXJ3aXNlLCBbXS5cbiAqL1xudmFyIF9hcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtvYmpdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBzb3VyY2Ugb2JqZWN0cyBvbnRvIGRlc3QuXG4gKlxuICogQHBhcmFtIGRlc3Qge09iamVjdH1cbiAqICAgICAgICBkZXN0aW5hdGlvbiBmb3IgY29waWVkIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdmFyYXJncyB7T2JqZWN0LCAuLi59XG4gKiAgICAgICAgc291cmNlIG9iamVjdHMsIHByb2Nlc3NlZCBpbiBhcmd1bWVudCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiAgICAgICAgYWxsIHByb3BlcnRpZXMgYXJlIGNvcGllZCBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0IHRvIGRlc3QuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc3QsIGFmdGVyIGNvcHlpbmcgc291cmNlIG9iamVjdCBwcm9wZXJ0aWVzLlxuICovXG52YXIgX2V4dGVuZCA9IGZ1bmN0aW9uIChkZXN0IC8qLCB2YXJhcmdzICovKSB7XG4gIHZhciBzcmMsXG4gICAgICBpLFxuICAgICAga2V5O1xuICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3JjID0gYXJndW1lbnRzW2ldO1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwpIHtcbiAgICAgIGZvciAoa2V5IGluIHNyYykge1xuICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG4vKipcbiAqIEJ1aWxkIGEgbG9va3VwIGluZGV4IGZvciBvYmplY3RzLCBiYXNlZCBvbiAodW5pcXVlKSBwcm9wZXJ0eSB2YWx1ZS5cbiAqXG4gKiBGb3IgRXhhbXBsZTpcbiAqICAgICBfaW5kZXgoW3tpZDogJ2EnfSwge2lkOiAnYid9XSwgJ2lkJylcbiAqIHdvdWxkIHJldHVyblxuICogICAge1xuICogICAgICAnYSc6IHtpZDogJ2EnfSxcbiAqICAgICAgJ2InOiB7aWQ6ICdiJ31cbiAqICAgIH1cbiAqXG4gKiBAcGFyYW0gb2JqcyB7QXJyYXk8T2JqZWN0Pn1cbiAqICAgICAgICBvYmplY3RzIHRvIGluZGV4XG4gKiBAcGFyYW0ga2V5IHtTdHJpbmd9XG4gKiAgICAgICAgcHJvcGVydHkgdG8gaW5kZXguXG4gKiBAcGFyYW0gaW5kZXgge09iamVjdH1cbiAqICAgICAgICBvcHRpb25hbCwgZXhpc3RpbmcgaW5kZXggdG8gZXh0ZW5kLlxuICogQHJldHVybiB7T2JqZWN0fSBpbmRleGVkIGRhdGEuXG4gKi9cbnZhciBfaW5kZXggPSBmdW5jdGlvbiAob2Jqcywga2V5LCBpbmRleCkge1xuICB2YXIgaSxcbiAgICAgIGxlbixcbiAgICAgIG9iajtcbiAgaW5kZXggPSBpbmRleCB8fCB7fTtcbiAgaWYgKG9ianMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqcykpIHtcbiAgICAgIG9ianMgPSBbb2Jqc107XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGxlbiA9IG9ianMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICBpbmRleFtvYmpba2V5XV0gPSBvYmo7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBuZXcgUXVha2VtbCBFdmVudC5cbiAqXG4gKiBAcGFyYW0gZXYge0VsZW1lbnR9XG4gKiAgICAgICAgUXVha2VtbCBldmVudChsaWtlKSBlbGVtZW50XG4gKi9cbnZhciBRdWFrZW1sRXZlbnQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9hbXBsaXR1ZGVJbmRleCxcbiAgICAgIF9jYXRhbG9nLFxuICAgICAgX2V2LFxuICAgICAgX21hZ25pdHVkZXMsXG4gICAgICBfb3JpZ2lucyxcbiAgICAgIF9waWNrSW5kZXgsXG4gICAgICBfcHJlZmVycmVkTWFnbml0dWRlSUQsXG4gICAgICBfcHJlZmVycmVkT3JpZ2luSUQsXG4gICAgICBfc3RhdGlvbk1hZ25pdHVkZUluZGV4LFxuXG4gICAgICBfcGFyc2VBcnJpdmFscyxcbiAgICAgIF9wYXJzZU9yaWdpbnMsXG4gICAgICBfcGFyc2VNYWduaXR1ZGVDb250cmlidXRpb25zLFxuICAgICAgX3BhcnNlTWFnbml0dWRlcztcblxuXG4gIF90aGlzID0gT2JqZWN0LmNyZWF0ZSh7fSk7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhpcyBldmVudCwgYnkgcGFyc2luZyBvcmlnaW5zIGFuZCBtYWduaXR1ZGVzLlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICBfZXYgPSBldjtcbiAgICBfY2F0YWxvZyA9IF9ldlsnY2F0YWxvZzpldmVudFNvdXJjZSddO1xuICAgIF9wcmVmZXJyZWRPcmlnaW5JRCA9IF9ldi5wcmVmZXJyZWRPcmlnaW5JRCB8fCBudWxsO1xuICAgIF9wcmVmZXJyZWRNYWduaXR1ZGVJRCA9IF9ldi5wcmVmZXJyZWRNYWduaXR1ZGVJRCB8fCBudWxsO1xuXG4gICAgX3BpY2tJbmRleCA9IF9pbmRleChfZXYucGljaywgJ3B1YmxpY0lEJyk7XG4gICAgX2FtcGxpdHVkZUluZGV4ID0gX2luZGV4KF9ldi5hbXBsaXR1ZGUsICdwdWJsaWNJRCcpO1xuICAgIF9zdGF0aW9uTWFnbml0dWRlSW5kZXggPSBfaW5kZXgoX2V2LnN0YXRpb25NYWduaXR1ZGUsICdwdWJsaWNJRCcpO1xuXG4gICAgX29yaWdpbnMgPSBfcGFyc2VPcmlnaW5zKF9hcnJheShfZXYub3JpZ2luKSk7XG4gICAgX21hZ25pdHVkZXMgPSBfcGFyc2VNYWduaXR1ZGVzKF9hcnJheShfZXYubWFnbml0dWRlKSk7XG4gICAgZXYgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBhcnJheSBvZiBhcnJpdmFsIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gYXJyaXZhbHMge0FycmF5PEVsZW1lbnQ+fVxuICAgKiAgICAgICAgYXJyYXkgb2YgcXVha2VtbCBhcnJpdmFsIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSBwYXJzZWQgYXJyaXZhbCBvYmplY3RzLlxuICAgKi9cbiAgX3BhcnNlQXJyaXZhbHMgPSBmdW5jdGlvbiAoYXJyaXZhbHMpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgYXJyaXZhbCxcbiAgICAgICAgcGFyc2VkID0gW10sXG4gICAgICAgIHBpY2tJbmRleCA9IF9waWNrSW5kZXg7XG5cbiAgICBmb3IgKGEgPSAwOyBhIDwgYXJyaXZhbHMubGVuZ3RoOyBhKyspIHtcbiAgICAgIGFycml2YWwgPSBfZXh0ZW5kKHt9LCBhcnJpdmFsc1thXSk7XG4gICAgICBpZiAodHlwZW9mIGFycml2YWwucGlja0lEID09PSAnc3RyaW5nJykge1xuICAgICAgICBhcnJpdmFsLnBpY2sgPSBwaWNrSW5kZXhbYXJyaXZhbC5waWNrSURdIHx8IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJpdmFsLnBpY2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgcGFyc2VkLnB1c2goYXJyaXZhbCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGFycmF5IG9mIHN0YXRpb25NYWduaXR1ZGVDb250cmlidXRpb24gZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBjb250cmlidXRpb25zIHtBcnJheTxFbGVtZW50Pn1cbiAgICogICAgICAgIGFycmF5IG9mIHF1YWtlbWwgc3RhdGlvbk1hZ25pdHVkZUNvbnRyaWJ1dGlvbiBlbGVtZW50cy5cbiAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gcGFyc2VkIHN0YXRpb25NYWduaXR1ZGVDb250cmlidXRpb24gb2JqZWN0cy5cbiAgICovXG4gIF9wYXJzZU1hZ25pdHVkZUNvbnRyaWJ1dGlvbnMgPSBmdW5jdGlvbiAoY29udHJpYnV0aW9ucykge1xuICAgIHZhciBhbXBsaXR1ZGVJbmRleCA9IF9hbXBsaXR1ZGVJbmRleCxcbiAgICAgICAgYyxcbiAgICAgICAgY29udHJpYnV0aW9uLFxuICAgICAgICBwYXJzZWQgPSBbXSxcbiAgICAgICAgc3RhdGlvbk1hZ25pdHVkZSxcbiAgICAgICAgc3RhdGlvbk1hZ25pdHVkZUluZGV4ID0gX3N0YXRpb25NYWduaXR1ZGVJbmRleDtcblxuICAgIGZvciAoYyA9IDA7IGMgPCBjb250cmlidXRpb25zLmxlbmd0aDsgYysrKSB7XG4gICAgICBjb250cmlidXRpb24gPSBfZXh0ZW5kKHt9LCBjb250cmlidXRpb25zW2NdKTtcbiAgICAgIHN0YXRpb25NYWduaXR1ZGUgPSBfZXh0ZW5kKHt9LFxuICAgICAgICAgIHN0YXRpb25NYWduaXR1ZGVJbmRleFtjb250cmlidXRpb24uc3RhdGlvbk1hZ25pdHVkZUlEXSk7XG4gICAgICBjb250cmlidXRpb24uc3RhdGlvbk1hZ25pdHVkZSA9IHN0YXRpb25NYWduaXR1ZGU7XG4gICAgICBpZiAodHlwZW9mIHN0YXRpb25NYWduaXR1ZGUuYW1wbGl0dWRlSUQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0YXRpb25NYWduaXR1ZGUuYW1wbGl0dWRlID0gX2V4dGVuZCh7fSxcbiAgICAgICAgICAgIGFtcGxpdHVkZUluZGV4W3N0YXRpb25NYWduaXR1ZGUuYW1wbGl0dWRlSURdKTtcbiAgICAgIH1cbiAgICAgIHBhcnNlZC5wdXNoKGNvbnRyaWJ1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuZCBhcnJheSBvZiBtYWduaXR1ZGUgZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBtYWduaXR1ZGVzIHtBcnJheTxFbGVtZW50Pn1cbiAgICogICAgICAgIGFycmF5IG9mIHF1YWtlbWwgbWFnbml0dWRlIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSBwYXJzZWQgbWFnbml0dWRlIG9iamVjdHMuXG4gICAqL1xuICBfcGFyc2VNYWduaXR1ZGVzID0gZnVuY3Rpb24gKG1hZ25pdHVkZXMpIHtcbiAgICB2YXIgbSxcbiAgICAgICAgbWFnbml0dWRlLFxuICAgICAgICBwYXJzZWQgPSBbXSxcbiAgICAgICAgcHJlZmVycmVkTWFnbml0dWRlSUQgPSBfcHJlZmVycmVkTWFnbml0dWRlSUQ7XG5cbiAgICBmb3IgKG0gPSAwOyBtIDwgbWFnbml0dWRlcy5sZW5ndGg7IG0rKykge1xuICAgICAgbWFnbml0dWRlID0gX2V4dGVuZCh7fSwgbWFnbml0dWRlc1ttXSk7XG4gICAgICBtYWduaXR1ZGUuaXNQcmVmZXJyZWQgPSAocHJlZmVycmVkTWFnbml0dWRlSUQgPT09IG1hZ25pdHVkZS5wdWJsaWNJRCk7XG4gICAgICBtYWduaXR1ZGUuY29udHJpYnV0aW9ucyA9IF9wYXJzZU1hZ25pdHVkZUNvbnRyaWJ1dGlvbnMoXG4gICAgICAgICAgX2FycmF5KG1hZ25pdHVkZS5zdGF0aW9uTWFnbml0dWRlQ29udHJpYnV0aW9uKSk7XG4gICAgICBkZWxldGUgbWFnbml0dWRlLnN0YXRpb25NYWduaXR1ZGVDb250cmlidXRpb247XG4gICAgICBpZiAobWFnbml0dWRlLmlzUHJlZmVycmVkKSB7XG4gICAgICAgIHBhcnNlZC51bnNoaWZ0KG1hZ25pdHVkZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQucHVzaChtYWduaXR1ZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBhcnJheSBvZiBvcmlnaW4gZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBvcmlnaW5zIHtBcnJheTxFbGVtZW50Pn1cbiAgICogICAgICAgIGFycmF5IG9mIHF1YWtlbWwgb3JpZ2luIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSBwYXJzZWQgb3JpZ2luIG9iamVjdHMuXG4gICAqL1xuICBfcGFyc2VPcmlnaW5zID0gZnVuY3Rpb24gKG9yaWdpbnMpIHtcbiAgICB2YXIgbyxcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBwYXJzZWQgPSBbXSxcbiAgICAgICAgcHJlZmVycmVkT3JpZ2luSUQgPSBfcHJlZmVycmVkT3JpZ2luSUQ7XG5cbiAgICBmb3IgKG8gPSAwOyBvIDwgb3JpZ2lucy5sZW5ndGg7IG8rKykge1xuICAgICAgb3JpZ2luID0gX2V4dGVuZCh7fSwgb3JpZ2luc1tvXSk7XG4gICAgICBvcmlnaW4uaXNQcmVmZXJyZWQgPSAocHJlZmVycmVkT3JpZ2luSUQgPT09IG9yaWdpbi5wdWJsaWNJRCk7XG4gICAgICBvcmlnaW4uYXJyaXZhbHMgPSBfcGFyc2VBcnJpdmFscyhfYXJyYXkob3JpZ2luLmFycml2YWwpKTtcbiAgICAgIGRlbGV0ZSBvcmlnaW4uYXJyaXZhbDtcbiAgICAgIGlmIChvcmlnaW4uaXNQcmVmZXJyZWQpIHtcbiAgICAgICAgcGFyc2VkLnVuc2hpZnQob3JpZ2luKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5wdXNoKG9yaWdpbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdH0gcXVha2VtbCBldmVudCBlbGVtZW50IGFzIGpzb24gb2JqZWN0LlxuICAgKi9cbiAgX3RoaXMuZ2V0RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9ldjtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gbWFnbml0dWRlcyBwYXJzZWQgZnJvbSBldmVudC5cbiAgICovXG4gIF90aGlzLmdldE1hZ25pdHVkZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9tYWduaXR1ZGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSBvcmlnaW5zIHBhcnNlZCBmcm9tIGV2ZW50LlxuICAgKi9cbiAgX3RoaXMuZ2V0T3JpZ2lucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29yaWdpbnM7XG4gIH07XG5cbiAgX2luaXRpYWxpemUoZXYpO1xuICBldiA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWFrZW1sRXZlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFhtbFV0aWwgPSB7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgc2ltcGxlIHhtbCB0byBhIGpzb24gb2JqZWN0LlxuICAgKiBEb2VzIG5vdCB3b3JrIHdlbGwgZm9yIG1peGVkIGNvbnRlbnQgKHRleHQvZWxlbWVudHMpLlxuICAgKi9cbiAgeG1sVG9Kc29uOiBmdW5jdGlvbiAoeG1sKSB7XG4gICAgLy8gYmFzZWQgb24gaHR0cDovL2Rhdmlkd2Fsc2gubmFtZS9jb252ZXJ0LXhtbC1qc29uXG4gICAgdmFyIG9iaiA9IHt9LFxuICAgICAgICBjaGlsZHJlbiA9IFtdLFxuICAgICAgICBhdHRycyxcbiAgICAgICAgYXR0cixcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGVOYW1lLFxuICAgICAgICBub2RlVmFsdWUsXG4gICAgICAgIGksXG4gICAgICAgIGxlbjtcblxuICAgIGlmICh0eXBlb2YgeG1sID09PSAnc3RyaW5nJykge1xuICAgICAgeG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4bWwsICd0ZXh0L3htbCcpO1xuICAgIH1cblxuICAgIGlmICh4bWwubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIHJldHVybiB4bWwubm9kZVZhbHVlO1xuICAgIH1cblxuICAgIGlmICh4bWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGF0dHJzID0geG1sLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhdHRyID0gYXR0cnMuaXRlbShpKTtcbiAgICAgICAgb2JqW2F0dHIubm9kZU5hbWVdID0gYXR0ci5ub2RlVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHhtbC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIG5vZGVzID0geG1sLmNoaWxkTm9kZXM7XG4gICAgICBmb3IoaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlcy5pdGVtKGkpO1xuICAgICAgICBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWU7XG4gICAgICAgIG5vZGVWYWx1ZSA9IFhtbFV0aWwueG1sVG9Kc29uKG5vZGUpO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGVWYWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2Yob2JqW25vZGVOYW1lXSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgb2JqW25vZGVOYW1lXSA9IG5vZGVWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mKG9ialtub2RlTmFtZV0ucHVzaCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvYmpbbm9kZU5hbWVdID0gW29ialtub2RlTmFtZV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpbbm9kZU5hbWVdLnB1c2gobm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFuIHVwICcjdGV4dCcgbm9kZXNcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIG9ialsnI3RleHQnXSAmJlxuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIG9ialsnI3RleHQnXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBYbWxVdGlsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWNjb3JkaW9uID0gcmVxdWlyZSgnYWNjb3JkaW9uL0FjY29yZGlvbicpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKSxcbiAgICBWaWV3ID0gcmVxdWlyZSgnbXZjL1ZpZXcnKTtcblxuXG52YXIgX0RFRkFVTFRTID0ge1xuICBjbGFzc2VzOiAnYWNjb3JkaW9uLXN0YW5kYXJkJyxcbiAgZGVzdHJveVZpZXc6IHRydWUsXG4gIGV4cGFuZGVkOiBmYWxzZSxcbiAgdG9nZ2xlRWxlbWVudDogJ2gzJyxcbiAgdG9nZ2xlVGV4dDogJ1Nob3cgbW9yZSdcbn07XG5cblxuLyoqXG4gKiBXcmFwIGEgdmlldyBpbiBhbiBhY2NvcmRpb24uXG4gKlxuICogQW55IG9mIHRoZXNlIG9wdGlvbnMgY2FuIGJlIGNoYW5nZWQgbGF0ZXIgYnkgdXBkYXRpbmcgdGhpcyB2aWV3J3MgbW9kZWwuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqIEBwYXJhbSBvcHRpb25zLmNsYXNzZXMge1N0cmluZ31cbiAqICAgICBwYXNzZWQgdG8gQWNjb3JkaW9uIGFzIGNsYXNzZXMgb3B0aW9uLlxuICogQHBhcmFtIG9wdGlvbnMuZGVzdHJveVZpZXcge0Jvb2xlYW59XG4gKiAgICAgd2hldGhlciB0byBkZXN0cm95IHdyYXBwZWQgdmlldyB3aGVuIHRoaXMgdmlldyBpcyBkZXN0cm95ZWQuXG4gKiAgICAgZGVmYXVsdCB0cnVlLlxuICogQHBhcmFtIG9wdGlvbnMuZXhwYW5kZWQge0Jvb2xlYW59XG4gKiAgICAgd2hldGhlciBhY2NvcmRpb24gc2hvdWxkIGJlIGV4cGFuZGVkIGJ5IGRlZmF1bHQuXG4gKiAgICAgZGVmYXVsdCBmYWxzZS5cbiAqIEBwYXJhbSBvcHRpb25zLnRvZ2dsZUVsZW1lbnQge1N0cmluZ31cbiAqICAgICBwYXNzZWQgdG8gQWNjb3JkaW9uIGFzIHRvZ2dsZUVsZW1lbnQgb3B0aW9uLlxuICogICAgIGRlZmF1bHQgJ2gzJy5cbiAqIEBwYXJhbSBvcHRpb25zLnRvZ2dsZVRleHQge1N0cmluZ31cbiAqICAgICBwYXNzZWQgdG8gQWNjb3JkaW9uIGFzIHRvZ2dsZVRleHQgb3B0aW9uLlxuICogICAgIGRlZmF1bHQgJ1Nob3cgbW9yZScuXG4gKi9cbnZhciBBY2NvcmRpb25WaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9hY2NvcmRpb247XG5cblxuICBfdGhpcyA9IFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcblxuICAgIF90aGlzLm1vZGVsLnNldCh7XG4gICAgICBjbGFzc2VzOiBvcHRpb25zLmNsYXNzZXMsXG4gICAgICBkZXN0cm95Vmlldzogb3B0aW9ucy5kZXN0cm95VmlldyxcbiAgICAgIGV4cGFuZGVkOiBvcHRpb25zLmV4cGFuZGVkLFxuICAgICAgdG9nZ2xlRWxlbWVudDogb3B0aW9ucy50b2dnbGVFbGVtZW50LFxuICAgICAgdG9nZ2xlVGV4dDogb3B0aW9ucy50b2dnbGVUZXh0LFxuICAgICAgdmlldzogb3B0aW9ucy52aWV3XG4gICAgfSwge3NpbGVudDogdHJ1ZX0pO1xuICB9O1xuXG5cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF90aGlzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKF9hY2NvcmRpb24pIHtcbiAgICAgIC8vIGNsZWFuIHVwIHByZXZpb3VzIHJlbmRlclxuICAgICAgX2FjY29yZGlvbi5kZXN0cm95KCk7XG4gICAgICBfYWNjb3JkaW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMubW9kZWwuZ2V0KCdkZXN0cm95VmlldycpKSB7XG4gICAgICBfdGhpcy5tb2RlbC5nZXQoJ3ZpZXcnKS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgX3RoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5vbkNsaWNrKTtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBDbGljayBoYW5kbGVyIGNhbGxlZCB3aGVuIGFjY29yZGlvbiBpcyBjbGlja2VkLlxuICAgKi9cbiAgX3RoaXMub25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlldztcblxuICAgIC8vIHJlbmRlciB2aWV3XG4gICAgdmlldyA9IF90aGlzLm1vZGVsLmdldCgndmlldycpO1xuICAgIHZpZXcucmVuZGVyKCk7XG5cbiAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICBfdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzLm9uQ2xpY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYWNjb3JkaW9uLCBhbmQgc2V0IHVwIGNsaWNrIGhhbmRsZXIgdG8gcmVuZGVyIHdyYXBwZWQgdmlldy5cbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xhc3NlcyxcbiAgICAgICAgZXhwYW5kZWQsXG4gICAgICAgIG1vZGVsLFxuICAgICAgICB0b2dnbGVFbGVtZW50LFxuICAgICAgICB0b2dnbGVUZXh0LFxuICAgICAgICB2aWV3O1xuXG4gICAgaWYgKF9hY2NvcmRpb24pIHtcbiAgICAgIC8vIGNsZWFuIHVwIHByZXZpb3VzIHJlbmRlclxuICAgICAgX2FjY29yZGlvbi5kZXN0cm95KCk7XG4gICAgICBfYWNjb3JkaW9uID0gbnVsbDtcbiAgICAgIF90aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMub25DbGljayk7XG4gICAgfVxuXG4gICAgbW9kZWwgPSBfdGhpcy5tb2RlbC5nZXQoKTtcbiAgICBjbGFzc2VzID0gbW9kZWwuY2xhc3NlcztcbiAgICBleHBhbmRlZCA9IG1vZGVsLmV4cGFuZGVkO1xuICAgIHRvZ2dsZUVsZW1lbnQgPSBtb2RlbC50b2dnbGVFbGVtZW50O1xuICAgIHRvZ2dsZVRleHQgPSBtb2RlbC50b2dnbGVUZXh0O1xuICAgIHZpZXcgPSBtb2RlbC52aWV3O1xuXG4gICAgaWYgKCFleHBhbmRlZCkge1xuICAgICAgY2xhc3NlcyA9IGNsYXNzZXMgKyAnIGFjY29yZGlvbi1jbG9zZWQnO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhY2NvcmRpb25cbiAgICBfYWNjb3JkaW9uID0gQWNjb3JkaW9uKHtcbiAgICAgIGVsOiBfdGhpcy5lbCxcbiAgICAgIGFjY29yZGlvbnM6IFt7XG4gICAgICAgIGNsYXNzZXM6IGNsYXNzZXMsXG4gICAgICAgIGNvbnRlbnQ6IHZpZXcuZWwsXG4gICAgICAgIHRvZ2dsZUVsZW1lbnQ6IHRvZ2dsZUVsZW1lbnQsXG4gICAgICAgIHRvZ2dsZVRleHQ6IHRvZ2dsZVRleHRcbiAgICAgIH1dXG4gICAgfSk7XG5cbiAgICBpZiAoZXhwYW5kZWQpIHtcbiAgICAgIHZpZXcucmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMub25DbGljayk7XG4gICAgfVxuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQWNjb3JkaW9uVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ212Yy9Db2xsZWN0aW9uJyksXG4gICAgUHJvZHVjdCA9IHJlcXVpcmUoJ3BkbC9Qcm9kdWN0JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIFhociA9IHJlcXVpcmUoJ3V0aWwvWGhyJyk7XG5cblxudmFyIF9DT05UUklCVVRPUl9MSU5LX0NMQVNTID0gJ2NvbnRyaWJ1dG9yLWxpbmsnO1xudmFyIF9DT05UUklCVVRPUl9MSVNUX0NMQVNTID0gJ2NvbnRyaWJ1dG9yLWxpc3QnO1xudmFyIF9DT05UUklCVVRPUl9SRUZFUkVOQ0VfQ0xBU1MgPSAnY29udHJpYnV0b3ItcmVmZXJlbmNlJztcbnZhciBfQ09OVFJJQlVUT1JfREFUQV9BVFRSSUJVVEUgPSAnZGF0YS1pZCc7XG5cbnZhciBfREVGQVVMVFMgPSB7fTtcblxuXG52YXIgQXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcbiAgICAgIC8vIHZhcmlhYmxlc1xuICAgICAgX2NvbnRyaWJ1dG9ycyxcbiAgICAgIF9zb3VyY2VNYXAsXG4gICAgICBfd2hlblJlYWR5LFxuICAgICAgLy8gbWV0aG9kc1xuICAgICAgX2Zvcm1hdENvbnRyaWJ1dG9yTGluayxcbiAgICAgIF9mb3JtYXRDb250cmlidXRvckxpc3QsXG4gICAgICBfZm9ybWF0Q29udHJpYnV0b3JSZWZlcmVuY2UsXG4gICAgICBfb25FcnJvcixcbiAgICAgIF9vblN1Y2Nlc3MsXG4gICAgICBfb25SZWFkeSxcbiAgICAgIF9zb3J0QnlOYW1lO1xuXG5cbiAgX3RoaXMgPSB7fTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuXG4gICAgX2NvbnRyaWJ1dG9ycyA9IFtdO1xuICAgIF9zb3VyY2VNYXAgPSBudWxsO1xuICAgIF93aGVuUmVhZHkgPSBbXTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXQgY29udHJpYnV0b3IgbGluay5cbiAgICpcbiAgICogQHBhcmFtIGlkIHtTdHJpbmd9XG4gICAqICAgICAgICBjb250cmlidXRvciBjb2RlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCBsaW5rIHRvIGNvbnRyaWJ1dG9yLCBvciB0aXRsZSBpZiBjb250cmlidXRvclxuICAgKiAgICAgICAgIGRvZXMgbm90IGhhdmUgYSB1cmwuXG4gICAqL1xuICBfZm9ybWF0Q29udHJpYnV0b3JMaW5rID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbnRyaWJ1dG9yLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgdXJsO1xuXG4gICAgdGl0bGUgPSBudWxsO1xuICAgIHVybCA9IG51bGw7XG5cbiAgICBpZiAoaWQgIT09IG51bGwpIHtcbiAgICAgIGlkID0gaWQudG9VcHBlckNhc2UoKTtcbiAgICAgIGNvbnRyaWJ1dG9yID0gX3RoaXMuZ2V0Q29udHJpYnV0b3IoaWQpO1xuXG4gICAgICBpZiAoY29udHJpYnV0b3IpIHtcbiAgICAgICAgdGl0bGUgPSBjb250cmlidXRvci50aXRsZTtcbiAgICAgICAgdXJsID0gY29udHJpYnV0b3IudXJsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRpdGxlKSB7XG4gICAgICAgIHRpdGxlID0gaWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVybCkge1xuICAgICAgcmV0dXJuICc8YSBocmVmPVwiJyArIHVybCArICdcIj4nICsgdGl0bGUgKyAnPC9hPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgbGlzdCBvZiBjb250cmlidXRvcnMuXG4gICAqL1xuICBfZm9ybWF0Q29udHJpYnV0b3JMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaXN0TWFya3VwID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9jb250cmlidXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RNYXJrdXAucHVzaCgnPGxpPicgK1xuICAgICAgICAgIF90aGlzLmdldENvbnRyaWJ1dG9yTGluayhfY29udHJpYnV0b3JzW2ldKSArXG4gICAgICAgICAgJzwvbGk+Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RNYXJrdXAuam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBjb250cmlidXRvciByZWZlcmVuY2UuXG4gICAqXG4gICAqIFVzZXMgYWJicmV2aWF0aW9uIGlmIGNvbnRyaWJ1dG9yIGhhcyB0aXRsZS5cbiAgICogQWRkcyBzdXBlcnNjcmlwdCB3aXRoIHBvc2l0aW9uIG9mIGNvbnRyaWJ1dG9yIGluIGNvbnRyaWJ1dG9ycyBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQge1N0cmluZ31cbiAgICogICAgICAgIGNvbnRyaWJ1dG9yIGlkLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCBjb250cmlidXRvciByZWZlcmVuY2UuXG4gICAqL1xuICBfZm9ybWF0Q29udHJpYnV0b3JSZWZlcmVuY2UgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgYnVmLFxuICAgICAgICBjb250cmlidXRvcixcbiAgICAgICAgbGlzdFBvc2l0aW9uLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgdXJsO1xuXG4gICAgYnVmID0gW107XG4gICAgdGl0bGUgPSBudWxsO1xuICAgIHVybCA9IG51bGw7XG5cbiAgICBpZiAoaWQgIT09IG51bGwpIHtcbiAgICAgIGlkID0gaWQudG9VcHBlckNhc2UoKTtcbiAgICAgIGNvbnRyaWJ1dG9yID0gX3RoaXMuZ2V0Q29udHJpYnV0b3IoaWQpO1xuXG4gICAgICBpZiAoY29udHJpYnV0b3IpIHtcbiAgICAgICAgdGl0bGUgPSBjb250cmlidXRvci50aXRsZTtcbiAgICAgICAgdXJsID0gY29udHJpYnV0b3IudXJsO1xuICAgICAgfVxuXG4gICAgICBsaXN0UG9zaXRpb24gPSBfY29udHJpYnV0b3JzLmluZGV4T2YoaWQudG9Mb3dlckNhc2UoKSkgKyAxO1xuXG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgYnVmLnB1c2goJzxhYmJyIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiPicpO1xuICAgICAgfVxuXG4gICAgICBidWYucHVzaChpZCk7XG5cbiAgICAgIGlmIChsaXN0UG9zaXRpb24gPiAwKSB7XG4gICAgICAgIC8vIGZvdW5kIGluIGxpc3RcbiAgICAgICAgYnVmLnB1c2goJzxzdXA+JyArIGxpc3RQb3NpdGlvbiArICc8L3N1cD4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIGJ1Zi5wdXNoKCc8L2FiYnI+Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQXR0cmlidXRpb24gbG9hZCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgX29uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3NvdXJjZU1hcCA9IENvbGxlY3Rpb24oW10pO1xuICAgIF9vblJlYWR5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgYW55IHJlZ2lzdGVyZWQgY2FsbGJhY2tzIGFmdGVyIGRhdGEgbG9hZHMuXG4gICAqL1xuICBfb25SZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfd2hlblJlYWR5LmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIF93aGVuUmVhZHkgPSBbXTtcbiAgfTtcblxuICAvKipcbiAgICogQXR0cmlidXRpb24gbG9hZCBzdWNjZXNzIGhhbmRsZXIuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHtBcnJheTxPYmplY3Q+fVxuICAgKi9cbiAgX29uU3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgX3NvdXJjZU1hcCA9IENvbGxlY3Rpb24oZGF0YSk7XG4gICAgX3RoaXMucmVuZGVyKCk7XG4gICAgX29uUmVhZHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogU29ydCBmdW5jdGlvbiBmb3IgY29udHJpYnV0b3JzLlxuICAgKlxuICAgKiBAcGFyYW0gYSB7U3RyaW5nfVxuICAgKiAgICAgICAgZmlyc3QgY29udHJpYnV0b3IgY29kZS5cbiAgICogQHBhcmFtIGIge1N0cmluZ31cbiAgICogICAgICAgIHNlY29uZCBjb250cmlidXRvciBjb2RlLlxuICAgKiBAcmV0dXJuIC0xLCB3aGVuIGEgYmVmb3JlIGI7XG4gICAqICAgICAgICAgMCwgd2hlbiBlcXVhbDtcbiAgICogICAgICAgICAxLCB3aGVuIGEgYWZ0ZXIgYi5cbiAgICovXG4gIF9zb3J0QnlOYW1lID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYU5hbWUsXG4gICAgICAgIGJOYW1lO1xuXG4gICAgYU5hbWUgPSBfdGhpcy5nZXROYW1lKGEpO1xuICAgIGJOYW1lID0gX3RoaXMuZ2V0TmFtZShiKTtcblxuICAgIGlmIChhTmFtZSA8IGJOYW1lKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChhTmFtZSA+IGJOYW1lKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBjb250cmlidXRvciBieSBpZC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIGNvbnRyaWJ1dG9yIG9iamVjdCwgd2l0aCBhdCBsZWFzdCBwcm9wZXJ0aWVzIFwiaWRcIiwgXCJ0aXRsZVwiLCBcInVybFwiLlxuICAgKiAgICAgICAgIHRpdGxlIGFuZCB1cmwgYXJlIG51bGwgd2hlbiBjb250cmlidXRvciBub3QgZm91bmQuXG4gICAqL1xuICBfdGhpcy5nZXRDb250cmlidXRvciA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBjb250cmlidXRvcjtcblxuICAgIGNvbnRyaWJ1dG9yID0gbnVsbDtcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoX3NvdXJjZU1hcCAhPT0gbnVsbCkge1xuICAgICAgY29udHJpYnV0b3IgPSBfc291cmNlTWFwLmdldChpZCk7XG5cbiAgICAgIC8vIFRPRE86IGNvbnRyaWJ1dG9yIGFsaWFzZXNcbiAgICAgIC8vIHRoaXMgcmVxdWlyZXMgc29tZSBhZGRpdGlvbmFsIHRob3VnaHQsXG4gICAgICAvLyBiZWNhdXNlIHNvdXJjZU1hcCBpc24ndCBuZWNlc3NhcmlseSBzZXQgdG8gZGV0ZWN0IGR1cGxpY2F0ZXNcbiAgICB9XG5cbiAgICByZXR1cm4gY29udHJpYnV0b3I7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8U3RyaW5nPn1cbiAgICogICAgICAgICBsaXN0IG9mIGNvbnRyaWJ1dG9yIGNvZGVzLlxuICAgKi9cbiAgX3RoaXMuZ2V0Q29udHJpYnV0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY29udHJpYnV0b3JzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gZm9ybWF0dGVkIGh0bWwgbGlzdCBvZiBjb250cmlidXRvcnNcbiAgICogKGFzIHNldCBieSAjc2V0Q29udHJpYnV0b3JzKEFycmF5KSkuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gaHRtbCBtYXJrdXAgZm9yIGxpc3QuXG4gICAqL1xuICBfdGhpcy5nZXRDb250cmlidXRvckxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc8b2wgY2xhc3M9XCJjb250cmlidXRvcnMgJyArIF9DT05UUklCVVRPUl9MSVNUX0NMQVNTICsgJ1wiPicgK1xuICAgICAgICBfZm9ybWF0Q29udHJpYnV0b3JMaXN0KCkgK1xuICAgICAgICAnPC9vbD4nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgZm9ybWF0dGVkIGh0bWwgZm9yIGxpbmsgdG8gY29udHJpYnV0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBpZCB7U3RyaW5nfVxuICAgKiAgICAgICAgY29udHJpYnV0b3IgY29kZS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBodG1sLlxuICAgKi9cbiAgX3RoaXMuZ2V0Q29udHJpYnV0b3JMaW5rID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cIicgKyBfQ09OVFJJQlVUT1JfTElOS19DTEFTUyArICdcIicgK1xuICAgICAgICAnICcgKyBfQ09OVFJJQlVUT1JfREFUQV9BVFRSSUJVVEUgKyAnPVwiJyArIGlkICsgJ1wiPicgK1xuICAgICAgICBfZm9ybWF0Q29udHJpYnV0b3JMaW5rKGlkKSArXG4gICAgICAgICc8L3NwYW4+JztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGZvcm1hdHRlZCBodG1sIGZvciByZWZlcmVuY2UgdG8gY29udHJpYnV0b3IuXG4gICAqIFJlZmVyZW5jZXMgcG9zaXRpb24gYXMgcmV0dXJuZWQgYnkgZ2V0Q29udHJpYnV0b3JMaXN0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQge1N0cmluZ31cbiAgICogICAgICAgIGNvbnRyaWJ1dG9yIGNvZGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gaHRtbCBtYXJrdXAgZm9yIHJlZmVyZW5jZSB0byBjb250cmlidXRvci5cbiAgICovXG4gIF90aGlzLmdldENvbnRyaWJ1dG9yUmVmZXJlbmNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cIicgKyBfQ09OVFJJQlVUT1JfUkVGRVJFTkNFX0NMQVNTICsgJ1wiJyArXG4gICAgICAgICcgJyArIF9DT05UUklCVVRPUl9EQVRBX0FUVFJJQlVURSArICc9XCInICsgaWQgKyAnXCI+JyArXG4gICAgICAgIF9mb3JtYXRDb250cmlidXRvclJlZmVyZW5jZShpZCkgK1xuICAgICAgICAnPC9zcGFuPic7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZm9ybWF0dGVkIG5hbWUgZm9yIGEgY29udHJpYnV0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBpZCB7U3RyaW5nfVxuICAgKiAgICAgICAgY29udHJpYnV0b3IgY29kZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICAgICAgbmFtZSBmb3IgY29udHJpYnV0b3IuXG4gICAqL1xuICBfdGhpcy5nZXROYW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbnRyaWJ1dG9yLFxuICAgICAgICB0aXRsZTtcblxuICAgIGNvbnRyaWJ1dG9yID0gX3RoaXMuZ2V0Q29udHJpYnV0b3IoaWQpO1xuICAgIGlkID0gaWQudG9VcHBlckNhc2UoKTtcbiAgICB0aXRsZSA9IG51bGw7XG4gICAgaWYgKGNvbnRyaWJ1dG9yKSB7XG4gICAgICB0aXRsZSA9IGNvbnRyaWJ1dG9yLnRpdGxlO1xuICAgIH1cblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgcmV0dXJuIHRpdGxlICsgJyAoJyArIGlkICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgdGhlIHJlbGV2YW50IGF0dHJpYnV0aW9uIHRvIHByb3ZpZGUgZm9yIGEgZ2l2ZW4gcHJvZHVjdC5cbiAgICpcbiAgICogQHBhcmFtIHByb2R1Y3Qge1Byb2R1Y3R9XG4gICAqICAgICBUaGUgcHJvZHVjdCBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgYXR0cmlidXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgIEF0dHJpYnV0aW9uIG1hcmt1cCBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gICAqL1xuICBfdGhpcy5nZXRQcm9kdWN0QXR0cmlidXRpb24gPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIHZhciBzb3VyY2UsXG4gICAgICAgIHNvdXJjZXMsXG4gICAgICAgIHR5cGU7XG5cbiAgICBzb3VyY2VzID0ge307IC8vIEtlZXAgYSB1bmlxdWUgbGlzdFxuXG4gICAgdHlwZSA9IFByb2R1Y3QuZ2V0QmFzZVR5cGUocHJvZHVjdC5nZXQoJ3R5cGUnKSk7XG5cbiAgICAvLyBQdXQgcHJvZHVjdC5zb3VyY2Ugb24gZmlyc3RcbiAgICBzb3VyY2UgPSBwcm9kdWN0LmdldCgnc291cmNlJyk7XG4gICAgc291cmNlc1tzb3VyY2VdID0gX3RoaXMuZ2V0Q29udHJpYnV0b3JSZWZlcmVuY2Uoc291cmNlKTtcblxuICAgIC8vIEFkZCBpbiBhZGRpdGlvbmFsIHNvdXJjZXMgYmFzZWQgb24gcHJvZHVjdCB0eXBlXG5cbiAgICBpZiAodHlwZSA9PT0gJ29yaWdpbicgfHwgdHlwZSA9PT0gJ3BoYXNlLWRhdGEnKSB7XG4gICAgICAvLyBMb29rIGZvciBvcmlnaW4tc291cmNlIHByb3BlcnR5IGFuZCBtYWduaXR1ZGUtc291cmNlIHByb3BlcnR5IGFuZFxuICAgICAgLy8gYWRkIHRoZW0gYXMgY29udHJpYnV0b3JzIGlmIG5ldyBpZHNcbiAgICAgIHNvdXJjZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ29yaWdpbi1zb3VyY2UnKTtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZSA/IHNvdXJjZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICAgIGlmIChzb3VyY2UgJiYgIXNvdXJjZXMuaGFzT3duUHJvcGVydHkoc291cmNlKSkge1xuICAgICAgICBzb3VyY2VzW3NvdXJjZV0gPSBfdGhpcy5nZXRDb250cmlidXRvclJlZmVyZW5jZShzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdtYWduaXR1ZGUtc291cmNlJyk7XG4gICAgICBzb3VyY2UgPSBzb3VyY2UgPyBzb3VyY2UudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICBpZiAoc291cmNlICYmICFzb3VyY2VzLmhhc093blByb3BlcnR5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlc1tzb3VyY2VdID0gX3RoaXMuZ2V0Q29udHJpYnV0b3JSZWZlcmVuY2Uoc291cmNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmb2NhbC1tZWNoYW5pc20nIHx8IHR5cGUgPT09ICdtb21lbnQtdGVuc29yJykge1xuICAgICAgLy8gTG9vayBmb3IgYmVhY2hiYWxsLXNvdXJjZSBwcm9wZXJ0eSBhbmQgYWRkIGl0IGFzIGNvbnRyaWJ1dG9yIGlmIG5ldyBpZFxuICAgICAgc291cmNlID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnYmVhY2hiYWxsLXNvdXJjZScpO1xuICAgICAgc291cmNlID0gc291cmNlID8gc291cmNlLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgaWYgKHNvdXJjZSAmJiAhc291cmNlcy5oYXNPd25Qcm9wZXJ0eShzb3VyY2UpKSB7XG4gICAgICAgIHNvdXJjZXNbc291cmNlXSA9IF90aGlzLmdldENvbnRyaWJ1dG9yUmVmZXJlbmNlKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZXMpLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBzb3VyY2VzW2N1cnJlbnRdO1xuICAgICAgICB9LCAnJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAgICpcbiAgICogQHBhcmFtIGNvbnRyaWJ1dG9ycyB7QXJyYXk8U3RyaW5nPn1cbiAgICogICAgICAgIGxpc3Qgb2YgY29udHJpYnV0b3JzLlxuICAgKi9cbiAgX3RoaXMuc2V0Q29udHJpYnV0b3JzID0gZnVuY3Rpb24gKGNvbnRyaWJ1dG9ycykge1xuICAgIHZhciBlbDtcblxuICAgIC8vIGNvcHlcbiAgICBfY29udHJpYnV0b3JzID0gY29udHJpYnV0b3JzLnNsaWNlKDApO1xuICAgIC8vIGNvbnZlcnQgdG8gbG93ZXIgY2FzZVxuICAgIF9jb250cmlidXRvcnMgPSBjb250cmlidXRvcnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICAgIC8vIHNvcnRcbiAgICBfY29udHJpYnV0b3JzLnNvcnQoX3NvcnRCeU5hbWUpO1xuXG4gICAgLy8gdXBkYXRlIGNvbnRyaWJ1dG9yIGxpc3QgKGlmIGl0IGV4aXN0cylcbiAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgX0NPTlRSSUJVVE9SX0xJU1RfQ0xBU1MpO1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuaW5uZXJIVE1MID0gX2Zvcm1hdENvbnRyaWJ1dG9yTGlzdCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTG9hZCBhIGNvbnRyaWJ1dG9yIGxpc3QuXG4gICAqL1xuICBfdGhpcy5sb2FkID0gZnVuY3Rpb24gKHVybCkge1xuICAgIFhoci5hamF4KHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgZXJyb3I6IF9vbkVycm9yLFxuICAgICAgc3VjY2VzczogX29uU3VjY2Vzc1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZS1yZW5kZXIgY29udHJpYnV0b3IgbGlua3MgYW5kIHJlZmVyZW5jZXMuXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVscztcblxuICAgIGVscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIF9DT05UUklCVVRPUl9MSU5LX0NMQVNTKSwgMCk7XG4gICAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgIHZhciBpZDtcbiAgICAgIGlkID0gbGluay5nZXRBdHRyaWJ1dGUoX0NPTlRSSUJVVE9SX0RBVEFfQVRUUklCVVRFKTtcbiAgICAgIGlmIChpZCkge1xuICAgICAgICBsaW5rLmlubmVySFRNTCA9IF9mb3JtYXRDb250cmlidXRvckxpbmsoaWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgX0NPTlRSSUJVVE9SX1JFRkVSRU5DRV9DTEFTUyksIDApO1xuICAgIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBpZDtcbiAgICAgIGlkID0gcmVmLmdldEF0dHJpYnV0ZShfQ09OVFJJQlVUT1JfREFUQV9BVFRSSUJVVEUpO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIHJlZi5pbm5lckhUTUwgPSBfZm9ybWF0Q29udHJpYnV0b3JSZWZlcmVuY2UoaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIGEgY2FsbGJhY2ssIHBvc3NpYmx5IHdhaXRpbmcgZm9yIGF0dHJpYnV0aW9uIGRhdGEgdG8gbG9hZC5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn1cbiAgICogICAgICAgIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkICh3aXRoIG5vIGFyZ3VtZW50cykgb25jZSBhdHRyaWJ1dGlvbiBkYXRhXG4gICAqICAgICAgICBoYXMgbG9hZGVkIChvciBmYWlsZWQgdG8gbG9hZCkuXG4gICAqL1xuICBfdGhpcy53aGVuUmVhZHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAoX3NvdXJjZU1hcCA9PT0gbnVsbCkge1xuICAgICAgLy8gc2F2ZSBjYWxsYmFjayBmb3Igd2hlbiByZWFkeVxuICAgICAgX3doZW5SZWFkeS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhZHkgbm93XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0aW9uKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIEF0dHJpYnV0aW9uID0gcmVxdWlyZSgnY29yZS9BdHRyaWJ1dGlvbicpLFxuICAgIE1vZHVsZSA9IHJlcXVpcmUoJ2NvcmUvTW9kdWxlJyksXG4gICAgUHJvZHVjdFZpZXcgPSByZXF1aXJlKCdjb3JlL1Byb2R1Y3RWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIG1vZHVsZToge0lEOiAnJywgVElUTEU6ICdNb2R1bGUgVGl0bGUnfVxufTtcblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSBiYXNlIGNsYXNzIGZyb20gd2hpY2ggb3RoZXJzIGNhbiBpbmhlcml0LiBJdFxuICogZGVmaW5lcyBhIHNpbXBsZSBBUEkgZm9yIGNyZWF0aW5nIGN1c3RvbSBcInBpbnNcIiBmb3IgdGhlIGV4ZWN1dGl2ZSBzdW1tYXJ5XG4gKiBzZWN0aW9uIG9mIHRoZSBldmVudCBwYWdlcy4gVGhpcyBjbGFzcyBleHRlbmRzIGEgUHJvZHVjdFZpZXcuXG4gKlxuICogRWFjaCBwaW4gaXMgY29tcG9zZWQgb2YgYSBoZWFkZXIsIGNvbnRlbnQsIGFuZCBmb290ZXIgc2VjdGlvbi4gVGhlXG4gKiBoZWFkZXIgY29udGFpbnMsIGJ5IGNvbnZlbnRpb24sIHRoZSBwcm9kdWN0IHRpdGxlIHRoYXQgbGlua3MgdG8gdGhlIHByb2R1Y3RcbiAqIGRldGFpbHMuIFRoZSBmb290ZXIgY29udGFpbnMsIGJ5IGNvbnZlbnRpb24sIGNvbnRyaWJ1dG9yIGluZm9ybWF0aW9uIGZvclxuICogdGhlIHByb2R1Y3QuIFRoZSBjb250ZW50IGlzIG11Y2ggbW9yZSBmcmVlLWZvcm0gYW5kIGlzIHR5cGljYWxseSB0aGVcbiAqIHBhcnQgdGhhdCBpcyBvdmVycmlkZGVuIGJ5IGltcGxlbWVudGluZyBzdWItY2xhc3Nlcy5cbiAqXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICBTZWUgY29uc3RydWN0b3IgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cbiAqXG4gKlxuICogQHNlZSBCYXNpY1BpblZpZXcjcmVuZGVyUGluQ29udGVudFxuICogQHNlZSBCYXNpY1BpblZpZXcjcmVuZGVyUGluRm9vdGVyXG4gKiBAc2VlIEJhc2ljUGluVmlldyNyZW5kZXJQaW5IZWFkZXJcbiAqXG4gKi9cbnZhciBCYXNpY1BpblZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX29uQ2xpY2s7XG5cblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gUHJvZHVjdFZpZXcob3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBza2VsZXRvbiBsYXlvdXQgYW5kIHN0b3JlcyByZWZlcmVuY2VzIHRvIERPTSBjb250YWluZXJzXG4gICAqIGZvciBzdWJzZXF1ZW50IHJlbmRyaW5nLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICAgKiAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGlzIHZpZXcsIGluIGFkZGl0aW9uIHRvIHdoYXQgaXMgc3VwcG9ydGVkXG4gICAqICAgICBpbiBhIHN0YW5kYXJkIFByb2R1Y3RWaWV3LCB5b3UgbWF5IHByb3ZpZGUuLi5cbiAgICogQHBhcmFtIG9wdGlvbnMubW9kdWxlIHtNb2R1bGV9XG4gICAqICAgICBBbiBvYmplY3QgY29udGFpbmluZyBhbiBcIklEXCIgYW5kIFwiVElUTEVcIiBwcm9wZXJ0eS4gVGhlIElEIHByb3BlcnR5IGlzXG4gICAqICAgICB1c2VkIHRvIGNyZWF0ZSBhIGxpbmsgdG8gdGhlIHByb2R1Y3QgcGFnZSBhbmQgdGhlIFRJVExFIHByb3BlcnR5IGlzXG4gICAqICAgICB1c2VkIGFzIHRoZSBsaW5rIHRleHQuXG4gICAqXG4gICAqL1xuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgX3RoaXMubW9kdWxlID0gb3B0aW9ucy5tb2R1bGUgfHwgTW9kdWxlO1xuXG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gW1xuICAgICAgJzxhcnRpY2xlIGNsYXNzPVwicGluLXZpZXdcIj4nLFxuICAgICAgICAnPGhlYWRlciBjbGFzcz1cInBpbi1oZWFkZXJcIj48L2hlYWRlcj4nLFxuICAgICAgICAnPHNlY3Rpb24gY2xhc3M9XCJwaW4tY29udGVudFwiPjwvc2VjdGlvbj4nLFxuICAgICAgICAnPGZvb3RlciBjbGFzcz1cInBpbi1mb290ZXJcIj48L2Zvb3Rlcj4nLFxuICAgICAgJzwvYXJ0aWNsZT4nXG4gICAgXS5qb2luKCcnKTtcblxuICAgIF90aGlzLmhlYWRlciA9IF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5waW4taGVhZGVyJyk7XG4gICAgX3RoaXMuY29udGVudCA9IF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5waW4tY29udGVudCcpO1xuICAgIF90aGlzLmZvb3RlciA9IF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5waW4tZm9vdGVyJyk7XG5cbiAgICBfdGhpcy5oZWFkZXIuY2xhc3NMaXN0LmFkZChfdGhpcy5tb2R1bGUuSUQgKyAnLXBpbi1oZWFkZXInKTtcbiAgICBfdGhpcy5jb250ZW50LmNsYXNzTGlzdC5hZGQoX3RoaXMubW9kdWxlLklEICsgJy1waW4tY29udGVudCcpO1xuICAgIF90aGlzLmZvb3Rlci5jbGFzc0xpc3QuYWRkKF90aGlzLm1vZHVsZS5JRCArICctcGluLWZvb3RlcicpO1xuXG4gICAgX3RoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfb25DbGljayk7XG4gIH07XG5cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gX3RoaXMuZWwgaXMgY2xpY2tlZFxuICAgKlxuICAgKi9cbiAgX29uQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIF90aGlzLm9uQ2xpY2soZSk7XG4gIH07XG5cblxuICBfdGhpcy5nZXRMaW5rVXJsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnIycgKyBfdGhpcy5tb2R1bGUuSUQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIF90aGlzLmVsXG4gICAqXG4gICAqIEBwYXJhbSBlIHtNb3VzZUV2ZW50fVxuICAgKiAgICAgQSBNb3VzZUV2ZW50IG9iamVjdFxuICAgKi9cbiAgX3RoaXMub25DbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgX3RoaXMucmVkaXJlY3QoX3RoaXMuZ2V0TGlua1VybCgpKTtcbiAgICBpZiAoZSAmJiB0eXBlb2YgZS5wcmV2ZW50RGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHdpbmRvdy5sb2NhdGlvblxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVkaXJlY3QgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgd2luZG93LmxvY2F0aW9uID0gdXJsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGcmVlcyByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdmlldy5cbiAgICpcbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfdGhpcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF90aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX29uQ2xpY2spO1xuXG4gICAgX29uQ2xpY2sgPSBudWxsO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgaGVhZGVyLCBjb250ZW50LCBhbmQgZm9vdGVyIHNlY3Rpb25zIG9mIHRoaXMgcGluLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCYXNpY1BpblZpZXd9XG4gICAqICAgICBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgdmlldyBmb3IgbWV0aG9kIGNoYWluaW5nLi4uXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMucmVuZGVyUGluSGVhZGVyKCk7XG4gICAgX3RoaXMucmVuZGVyUGluQ29udGVudCgpO1xuICAgIF90aGlzLnJlbmRlclBpbkZvb3RlcigpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAQVBJTWV0aG9kXG4gICAqXG4gICAqIFJlbmRlciB0aGUgY29udGVudCBzZWN0aW9uIG9mIHRoZSBwaW4uIEltcGxlbWVudGluZyBzdWItY2xhc3NlcyB3aWxsXG4gICAqIGxpa2VseSB3YW50IHRvIG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVuZGVyUGluQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5jb250ZW50LmlubmVySFRNTCA9ICdQaW4gQ29udGVudCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBBUElNZXRob2RcbiAgICpcbiAgICogUmVuZGVyIHRoZSBmb290ZXIgc2VjdGlvbiBvZiB0aGUgcGluLlxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVuZGVyUGluRm9vdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmZvb3Rlci5pbm5lckhUTUwgPSAnQ29udHJpYnV0ZWQgYnkgJyArXG4gICAgICAgIEF0dHJpYnV0aW9uLmdldFByb2R1Y3RBdHRyaWJ1dGlvbihfdGhpcy5tb2RlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBBUElNZXRob2RcbiAgICpcbiAgICogUmVuZGVyIHRoZSBoZWFkZXIgc2VjdGlvbiBvZiB0aGUgcGluLlxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVuZGVyUGluSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXNwbGF5O1xuXG4gICAgLy8gVXNlIG1vZHVsZSBJRCBhbmQgVElUTEUgdG8gY3JlYXRlIGEgbGlua1xuICAgIGRpc3BsYXkgPSBfdGhpcy5tb2R1bGUuVElUTEU7XG5cbiAgICBfdGhpcy5oZWFkZXIuaW5uZXJIVE1MID0gW1xuICAgICAgJzxhIGhyZWY9XCInLCBfdGhpcy5nZXRMaW5rVXJsKCksICdcIj4nLCBkaXNwbGF5LCAnPC9hPidcbiAgICBdLmpvaW4oJycpO1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFzaWNQaW5WaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIFZpZXcgPSByZXF1aXJlKCdtdmMvVmlldycpLFxuICAgIFhociA9IHJlcXVpcmUoJ3V0aWwvWGhyJyk7XG5cblxuLyoqXG4gKiBWaWV3IGZvciBhIHNwZWNpZmljIENvbnRlbnQuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICBhbGwgb3B0aW9ucyBhcmUgcGFzc2VkIHRvIG12Yy9WaWV3LlxuICovXG52YXIgQ29udGVudFZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG5cbiAgICAgIF94aHI7XG5cbiAgX3RoaXMgPSBWaWV3KG9wdGlvbnMpO1xuXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfeGhyKSB7XG4gICAgICBfeGhyLmFib3J0KCk7XG4gICAgICBfeGhyID0gbnVsbDtcbiAgICB9XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIG1ldGhvZCB0byBmZXRjaCB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggX3RoaXMubW9kZWwge0NvbnRlbnR9XG4gICAqIG9iamVjdC4gVGhpcyBtZXRob2QgcHJvY2VlZHMgYXN5bmNocm9ub3VzbHkgcmVnYXJkbGVzcyBvZiB3aGV0aGVyXG4gICAqIF90aGlzLm1vZGVsIHVzZXJzIGBieXRlc2Agb3IgYHVybGAgZGF0YS4gT24gc3VjY2VzcyB0aGUgX3RoaXMub25TdWNjZXNzXG4gICAqIGNhbGxiYWNrIGlzIGludm9rZWQsIG9uIGVycm9yLCB0aGUgX3RoaXMub25FcnJvciBjYWxsYmFjayBpcyBpbnZva2VkLlxuICAgKlxuICAgKi9cbiAgX3RoaXMuZmV0Y2hEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhO1xuXG4gICAgZGF0YSA9IF90aGlzLm1vZGVsLmdldCgnYnl0ZXMnKTtcbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgLy8gZm9yY2UgYXN5bmNcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzKSB7XG4gICAgICAgICAgLy8gdmlldyB3YXMgZGVzdHJveWVkIGJlZm9yZSBuZXh0IHRpY2tcbiAgICAgICAgICAvLyBzaW11bGF0ZSBhc3luYyBhYm9ydFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5vblN1Y2Nlc3MoZGF0YSwgbnVsbCk7XG4gICAgICB9LCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3hociA9IFhoci5hamF4KHtcbiAgICAgICAgdXJsOiBfdGhpcy5tb2RlbC5nZXQoJ3VybCcpLFxuICAgICAgICBzdWNjZXNzOiBfdGhpcy5vblN1Y2Nlc3MsXG4gICAgICAgIGVycm9yOiBfdGhpcy5vbkVycm9yLFxuICAgICAgICBkb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3hociA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHN0YXR1cyB7U3RyaW5nfVxuICAgKiAgICAgIEEgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yIHRoYXQgb2NjdXJyZWQuXG4gICAqIEBwYXJhbSB4aHIge1hNTEh0dHBSZXF1ZXN0fSBPcHRpb25hbC4gRGVmYXVsdCB1bmRlZmluZWQuXG4gICAqICAgICAgVGhlIG9yaWdpbmFsIHJlcXVlc3QgdGhhdCBsZWFkIHRvIHRoZSBlcnJvci5cbiAgICovXG4gIF90aGlzLm9uRXJyb3IgPSBmdW5jdGlvbiAoc3RhdHVzLyosIHhociovKSB7XG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gc3RhdHVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAQVBJTWV0aG9kXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGRhdGEgaXMgc3VjY2Vzc2Z1bGx5IGZldGNoZWQgZnJvbSBfdGhpcy5tb2RlbFxuICAgKiB7Q29udGVudH0gb2JqZWN0LiBJdCBzaG91bGQgY29tcGxldGUgdGhlIHJlbmRlciBvZiB0aGUgZmV0Y2hlZCBkYXRhXG4gICAqIGludG8gX3RoaXMuZWwgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB7U3RyaW5nfEpTT059XG4gICAqICAgICBUaGUgZGF0YSBmb3IgX3RoaXMubW9kZWwge0NvbnRlbnR9IG9iamVjdC5cbiAgICogQHBhcmFtIHhociB7WE1MSHR0cFJlcXVlc3R9IE9wdGlvbmFsLlxuICAgKiAgICAgVGhlIFhNTEh0dHBSZXF1ZXN0IG9iamVjdCB1c2VkIHRvIGZldGNoIHRoZSBkYXRhLiBJZiBfdGhpcy5tb2RlbFxuICAgKiAgICAgdXNlcyBgYnl0ZXNgIGRhdGEsIHRoaXMgcGFyYW1ldGVyIGlzIGBudWxsYC5cbiAgICovXG4gIF90aGlzLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLyosIHhociovKSB7XG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gZGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIG1vZGVsIGNoYW5nZXMuIEluaXRpYWxseSBzZXRzIGEgbG9hZGluZyBtZXNzYWdlIHRoZW4gc3RhcnRzXG4gICAqIHRoZSBkYXRhIGZldGNoIHByb2Nlc3MgdG8gcmVuZGVyIHRoZSBhY3R1YWwgY29udGVudC4gUmVsaWVzIG9uIGJyb3dzZXJcbiAgICogY2FjaGVzIHRvIGF2b2lkIGR1cGxpY2F0ZSBIVFRQIG92ZXJoZWFkLlxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmVsLmlubmVySFRNTCA9ICc8cD5Mb2FkaW5nIGNvbnRlbnQmaGVsbGlwOzwvcD4nO1xuICAgIF90aGlzLmZldGNoRGF0YSgpO1xuICB9O1xuXG5cbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb250ZW50VmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0RFRkFVTFRTID0ge1xuICBjb29wZXJhdG9yOiBudWxsLFxuICBlbDogbnVsbFxufTtcblxuXG4vKipcbiAqIENsYXNzIHRvIG1hbmFnZSBjb29wZXJhdG9yIGxvZ28uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqIEBwYXJhbSBvcHRpb25zLmNvb3BlcmF0b3Ige09iamVjdH1cbiAqICAgICAgICBvcHRpb25hbCwgZGVmYXVsdCBudWxsLlxuICogICAgICAgIHNlZSAjc2V0Q29vcGVyYXRvcihjb29wZXJhdG9yKVxuICogQHBhcmFtIG9wdGlvbnMuZWwge0VsZW1lbnR9XG4gKiAgICAgICAgb3B0aW9uYWwsIGRlZmF1bHQgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvb3BlcmF0b3JzJykuXG4gKiAgICAgICAgaWYgbm8gZWxlbWVudCBmb3VuZCwgY3JlYXRlcyBhbmQgYXR0ZW1wdHMgdG8gYWRkIHRvIFwic2l0ZS1oZWFkZXJcIi5cbiAqL1xudmFyIENvb3BlcmF0b3JMb2dvID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemU7XG5cblxuICBfdGhpcyA9IHt9O1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgZWw7XG5cbiAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG5cbiAgICAvLyB1c2UgY29uZmlndXJlZCBlbGVtZW50LCBvciBmYWxsIGJhY2sgdG8gdGVtcGxhdGUgZWxlbWVudC5cbiAgICBlbCA9IG9wdGlvbnMuZWwgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvb3BlcmF0b3JzJyk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgLy8gaWYgdGVtcGxhdGUgZWxlbWVudCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgYW5kIGFkZCB0byBzaXRlLWhlYWRlclxuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2Nvb3BlcmF0b3JzJyk7XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2l0ZS1oZWFkZXInKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlnbm9yZSwgbWF5YmUgbm90IGluIHRlbXBsYXRlXG4gICAgICB9XG4gICAgfVxuICAgIF90aGlzLmVsID0gZWw7XG5cbiAgICBfdGhpcy5zZXRDb29wZXJhdG9yKG9wdGlvbnMuY29vcGVyYXRvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGV4aXN0aW5nIGNvb3BlcmF0b3IgbGlzdCwgYW5kIHJlcGxhY2Ugd2l0aCBzcGVjaWZpZWQgIGNvb3BlcmF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBjb29wZXJhdG9yIHtPYmplY3R9XG4gICAqICAgICAgICB3aGVuIG51bGwsIGNsZWFycyBjb29wZXJhdG9yIGxpc3QgYW5kIHJldHVybnMuXG4gICAqIEBwYXJhbSBjb29wZXJhdG9yLmxvZ28ge1N0cmluZ31cbiAgICogICAgICAgIHVybCBmb3IgY29vcGVyYXRvciBsb2dvLlxuICAgKiBAcGFyYW0gY29vcGVyYXRvci50aXRsZSB7U3RyaW5nfVxuICAgKiAgICAgICAgdGl0bGUgZm9yIGNvb3BlcmF0b3IuXG4gICAqIEBwYXJhbSBjb29wZXJhdG9yLnVybCB7U3RyaW5nfVxuICAgKiAgICAgICAgT3B0aW9uYWwsIHdoZW4gb21pdHRlZCBsb2dvIHdpbGwgbm90IGJlIGxpbmtlZC5cbiAgICogICAgICAgIHVybCBmb3IgbGluayB0byBjb29wZXJhdG9yLlxuICAgKi9cbiAgX3RoaXMuc2V0Q29vcGVyYXRvciA9IGZ1bmN0aW9uIChjb29wZXJhdG9yKSB7XG4gICAgdmFyIGVsLFxuICAgICAgICBpbWcsXG4gICAgICAgIGxvZ28sXG4gICAgICAgIHRpdGxlLFxuICAgICAgICB1cmw7XG5cbiAgICAvLyByZW1vdmUgZXhpc3RpbmcgY29udHJpYnV0b3JcbiAgICBVdGlsLmVtcHR5KF90aGlzLmVsKTtcblxuICAgIC8vIHZhbGlkYXRlIG5ldyBjb250cmlidXRvclxuICAgIGlmICghY29vcGVyYXRvciB8fCAhY29vcGVyYXRvci5sb2dvIHx8ICFjb29wZXJhdG9yLnRpdGxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nbyA9IGNvb3BlcmF0b3IubG9nbztcbiAgICB0aXRsZSA9IGNvb3BlcmF0b3IudGl0bGU7XG4gICAgdXJsID0gY29vcGVyYXRvci51cmw7XG5cbiAgICAvLyBjcmVhdGUgbG9nb1xuICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGltZy5zZXRBdHRyaWJ1dGUoJ3NyYycsIGxvZ28pO1xuICAgIGltZy5zZXRBdHRyaWJ1dGUoJ2FsdCcsICdpbiBjb29wZXJhdGlvbiB3aXRoICcgKyB0aXRsZSk7XG4gICAgZWwgPSBpbWc7XG5cbiAgICAvLyB3cmFwIGluIGxpbmsgaWYgYXBwbGljYWJsZVxuICAgIGlmICh1cmwpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsKTtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGltZyk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGNvb3BlcmF0b3IgY2xhc3NcbiAgICBlbC5jbGFzc0xpc3QuYWRkKCdjb29wZXJhdG9yJyk7XG5cbiAgICAvLyBhZGQgdG8gY29vcGVyYXRvcnMgc2VjdGlvblxuICAgIF90aGlzLmVsLmFwcGVuZENoaWxkKGVsKTtcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvb3BlcmF0b3JMb2dvOyIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgQ29udGVudFZpZXcgPSByZXF1aXJlKCdjb3JlL0NvbnRlbnRWaWV3JyksXG4gICAgRm9ybWF0dGVyID0gcmVxdWlyZSgnY29yZS9Gb3JtYXR0ZXInKSxcbiAgICBQcm9kdWN0ID0gcmVxdWlyZSgncGRsL1Byb2R1Y3QnKTtcblxuXG52YXIgX05PX0NPTlRFTlRfTUVTU0FHRSA9ICdObyBkb3dubG9hZCBjb250ZW50IGF2YWlsYWJsZS4nO1xuXG5cbi8qKlxuICogVGhpcyBjbGFzcyBleHRlbmRzIHRoZSB7Q29udGVudFZpZXd9IGNsYXNzIGFuZCBpcyBzcGVjaWZpY2FsbHkgdXNlZFxuICogZm9yIHJlbmRlcmluZyBcImNvbnRlbnRzLnhtbFwiIGZvciBhIGdpdmVuIHByb2R1Y3QuIFRoZSBgb3B0aW9ucy5tb2RlbGAgc2hvdWxkXG4gKiBiZSBvZiB0eXBlIHtDb250ZW50fS5cbiAqXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgdmlldy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucy5wcm9kdWN0IHtQcm9kdWN0fVxuICogICAgIFRoZSBwcm9kdWN0IGZvciB3aGljaCB0byByZW5kZXIgY29udGVudHMueG1sLlxuICogQHBhcmFtIG9wdGlvbnMuZm9ybWF0dGVyIHtGb3JtYXR0ZXJ9XG4gKiAgICAgVGhlIGZvcm1hdHRlciBvYmplY3QgdG8gdXNlIGZvciBmb3JtYXR0aW5nIGludHJpbnNpYyB2YWx1ZXMuXG4gKi9cbnZhciBEb3dubG9hZFZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2Zvcm1hdHRlcixcbiAgICAgIF9wcm9kdWN0O1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBfdGhpcyA9IENvbnRlbnRWaWV3KG9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBAQ29uc3RydWN0b3JcbiAgICpcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHZpZXcuIFNlZSBjbGFzcyBsZXZlbCBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF9wcm9kdWN0ID0gb3B0aW9ucy5wcm9kdWN0IHx8IFByb2R1Y3QoKTtcblxuICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2Rvd25sb2FkLXZpZXcnKTtcbiAgICBfZm9ybWF0dGVyID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgRm9ybWF0dGVyKCk7XG4gIH07XG5cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZGVmYXVsdCBlcnJvciBtZXNzYWdlLiBDYWxsZWQgaWYgYW4gZXJyb3Igb2NjdXJzIGR1cmluZyB0aGVcbiAgICogZGF0YSBmZXRjaC5cbiAgICpcbiAgICovXG4gIF90aGlzLm9uRXJyb3IgPSBmdW5jdGlvbiAoLypzdGF0dXMsIHhociovKSB7XG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gX05PX0NPTlRFTlRfTUVTU0FHRTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBvZiBkb3dubG9hZHMuIENhbGxlZCB3aGVuIGRhdGEgaXMgc3VjY2Vzc2Z1bGx5IGZldGNoZWQuXG4gICAqXG4gICAqL1xuICBfdGhpcy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcG9uc2VUZXh0LCB4aHIpIHtcbiAgICB0cnkge1xuICAgICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gJzx1bCBjbGFzcz1cIm5vLXN0eWxlXCI+JyArXG4gICAgICAgIF90aGlzLnBhcnNlKHhoci5yZXNwb25zZVhNTCkubWFwKF90aGlzLnJlbmRlckZpbGUpLmpvaW4oJycpICtcbiAgICAgICc8L3VsPic7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgX3RoaXMub25FcnJvcignRmFpbGVkIHRvIHJlbmRlciBjb250ZW50LicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuIFhNTERvY3VtZW50IGBkYXRhYCBpbnRvIGFuIGFycmF5IG9mIGZpbGUgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB7WE1MRG9jdW1lbnR9XG4gICAqICAgICBUaGUgZGF0YSBmZXRjaGVkIGZyb20gdGhlIHNlcnZlciwgaW4gWE1MIGZvcm1hdC5cbiAgICovXG4gIF90aGlzLnBhcnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKFxuICAgICAgICBkYXRhLnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvbnRlbnRzID4gZmlsZScpLCBfdGhpcy5wYXJzZUZpbGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBYTUxFbGVtZW50IGludG8gYSBzdHJ1Y3R1cmVkIGRhdGEgb2JqZWN0IHJlcHJlc2VudGluZyBhIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSBmaWxlIHtYTUxFbGVtZW50fVxuICAgKiAgICAgVGhlIGZpbGUgZWxlbWVudCB0byBwYXJzZS5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgQSBmaWxlIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICogICAgIC0gYGlkYCB7U3RyaW5nfVxuICAgKiAgICAgLSBgdGl0bGVgIHtTdHJpbmd9XG4gICAqICAgICAtIGBjYXB0aW9uYCB7U3RyaW5nfVxuICAgKiAgICAgLSBgZm9ybWF0c2Age0FycmF5fVxuICAgKi9cbiAgX3RoaXMucGFyc2VGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICB2YXIgY2FwdGlvbixcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgZWwsXG4gICAgICAgIGVscyxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICBmb3JtYXRzLFxuICAgICAgICBocmVmLFxuICAgICAgICBpLFxuICAgICAgICBpZCxcbiAgICAgICAgbGVuLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgdHlwZTtcblxuICAgIGlmIChmaWxlLmdldEF0dHJpYnV0ZSgncmVmaWQnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlIGVsZW1lbnQgd2l0aCByZWZpZCcpO1xuICAgIH1cblxuICAgIGlkID0gZmlsZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgdGl0bGUgPSBmaWxlLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICBjYXB0aW9uID0gZmlsZS5xdWVyeVNlbGVjdG9yKCdjYXB0aW9uJyk7XG4gICAgY2FwdGlvbiA9IChjYXB0aW9uID8gY2FwdGlvbi50ZXh0Q29udGVudCA6IG51bGwpO1xuICAgIGZvcm1hdHMgPSBbXTtcblxuICAgIGVscyA9IGZpbGUucXVlcnlTZWxlY3RvckFsbCgnZm9ybWF0Jyk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBlbCA9IGVsc1tpXTtcbiAgICAgIGhyZWYgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgIHR5cGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9ybWF0ID0ge1xuICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICB1cmw6IG51bGwsXG4gICAgICAgICAgbGVuZ3RoOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgY29udGVudCA9IF9wcm9kdWN0LmdldENvbnRlbnQoaHJlZik7XG5cbiAgICAgICAgZm9ybWF0LnVybCA9IGNvbnRlbnQuZ2V0KCd1cmwnKTtcbiAgICAgICAgZm9ybWF0Lmxlbmd0aCA9IGNvbnRlbnQuZ2V0KCdsZW5ndGgnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZm9ybWF0cy5wdXNoKGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgIGNhcHRpb246IGNhcHRpb24sXG4gICAgICBmb3JtYXRzOiBmb3JtYXRzXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgcmVwcmVzZW50aW5nIHRoZSBnaXZlIGZpbGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gZmlsZSB7T2JqZWN0fVxuICAgKiAgICAgVGhlIGZpbGUgb2JqZWN0IHRvIHJlbmRlci5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiAgICAgVGhlIG1hcmt1cCByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGZpbGUgb2JqZWN0LlxuICAgKi9cbiAgX3RoaXMucmVuZGVyRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICc8bGkgY2xhc3M9XCJkb3dubG9hZC1maWxlXCI+JyxcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiZG93bmxvYWQtdGl0bGVcIj4nLCBmaWxlLnRpdGxlICwnPC9zcGFuPicsXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImRvd25sb2FkLWNhcHRpb25cIj4nLCBmaWxlLmNhcHRpb24sICc8L3NwYW4+JyxcbiAgICAgICAgJzx1bCBjbGFzcz1cImRvd25sb2FkLWZvcm1hdHNcIj4nLFxuICAgICAgICAgIGZpbGUuZm9ybWF0cy5tYXAoX3RoaXMucmVuZGVyRm9ybWF0KS5qb2luKCcnKSxcbiAgICAgICAgJzwvdWw+JyxcbiAgICAgICc8L2xpPidcbiAgICBdLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCByZXByZXNlbnRpbmcgdGhlIGdpdmUgZm9ybWF0IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIGZvcm1hdCB7T2JqZWN0fVxuICAgKiAgICAgVGhlIGZvcm1hdCBvYmplY3QgdG8gcmVuZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICBUaGUgbWFya3VwIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gZm9ybWF0IG9iamVjdC5cbiAgICovXG4gIF90aGlzLnJlbmRlckZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICB2YXIgZXh0ZW5zaW9uLFxuICAgICAgICBzaXplO1xuXG4gICAgZXh0ZW5zaW9uID0gZm9ybWF0LmhyZWYuc3BsaXQoJy4nKS5zbGljZSgtMSkuam9pbignJykudG9VcHBlckNhc2UoKTtcbiAgICBzaXplID0gX2Zvcm1hdHRlci5maWxlU2l6ZShmb3JtYXQubGVuZ3RoKTtcblxuICAgIHJldHVybiBbXG4gICAgICAnPGxpIGNsYXNzPVwiZm9ybWF0XCI+JyxcbiAgICAgICAgJzxhIGhyZWY9XCInLCBmb3JtYXQudXJsLCAnXCIgJyxcbiAgICAgICAgICAgICd0aXRsZT1cIicsIGV4dGVuc2lvbiwgJyAoJywgZm9ybWF0LmhyZWYsICcpXCI+JyxcbiAgICAgICAgICBleHRlbnNpb24sICcgKCcsIHNpemUsICcpJyxcbiAgICAgICAgJzwvYT4nLFxuICAgICAgJzwvbGk+J1xuICAgIF0uam9pbignJyk7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuRG93bmxvYWRWaWV3Lk5PX0NPTlRFTlRfTUVTU0FHRSA9IF9OT19DT05URU5UX01FU1NBR0U7XG5cbm1vZHVsZS5leHBvcnRzID0gRG93bmxvYWRWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBBdHRyaWJ1dGlvbiA9IHJlcXVpcmUoJ2NvcmUvQXR0cmlidXRpb24nKSxcbiAgICBDYXRhbG9nRXZlbnQgPSByZXF1aXJlKCdwZGwvQ2F0YWxvZ0V2ZW50JyksXG4gICAgQ29vcGVyYXRvckxvZ28gPSByZXF1aXJlKCdjb3JlL0Nvb3BlcmF0b3JMb2dvJyksXG4gICAgRFlGSUZvcm1Nb2R1bGUgPSByZXF1aXJlKCdkeWZpL0RZRklGb3JtTW9kdWxlJyksXG4gICAgRFlGSU1vZHVsZSA9IHJlcXVpcmUoJ2R5ZmkvRFlGSU1vZHVsZScpLFxuICAgIEV2ZW50cyA9IHJlcXVpcmUoJ3V0aWwvRXZlbnRzJyksXG4gICAgRXhlY3V0aXZlU3VtbWFyeU1vZHVsZSA9IHJlcXVpcmUoJ2dlbmVyYWwvRXhlY3V0aXZlU3VtbWFyeU1vZHVsZScpLFxuICAgIEZpbml0ZUZhdWx0TW9kdWxlID0gcmVxdWlyZSgnZmluaXRlLWZhdWx0L0Zpbml0ZUZhdWx0TW9kdWxlJyksXG4gICAgRm9jYWxNZWNoYW5pc21Nb2R1bGUgPSByZXF1aXJlKCdmb2NhbC1tZWNoYW5pc20vRm9jYWxNZWNoYW5pc21Nb2R1bGUnKSxcbiAgICBGb3JtYXR0ZXIgPSByZXF1aXJlKCdjb3JlL0Zvcm1hdHRlcicpLFxuICAgIEltcGFjdFN1bW1hcnlNb2R1bGUgPSByZXF1aXJlKCdpbXBhY3QvSW1wYWN0U3VtbWFyeU1vZHVsZScpLFxuICAgIEludGVyYWN0aXZlTWFwTW9kdWxlID0gcmVxdWlyZSgnbWFwL0ludGVyYWN0aXZlTWFwTW9kdWxlJyksXG4gICAgTW9kZWwgPSByZXF1aXJlKCdtdmMvTW9kZWwnKSxcbiAgICBNb21lbnRUZW5zb3JNb2R1bGUgPSByZXF1aXJlKCdtb21lbnQtdGVuc29yL01vbWVudFRlbnNvck1vZHVsZScpLFxuICAgIE5lYXJieVNlaXNtaWNpdHkgPSByZXF1aXJlKCdjb3JlL05lYXJieVNlaXNtaWNpdHknKSxcbiAgICBPYWZNb2R1bGUgPSByZXF1aXJlKCdvYWYvT2FmTW9kdWxlJyksXG4gICAgT3JpZ2luTW9kdWxlID0gcmVxdWlyZSgnb3JpZ2luL09yaWdpbk1vZHVsZScpLFxuICAgIFBBR0VSTW9kdWxlID0gcmVxdWlyZSgnbG9zc3BhZ2VyL1BBR0VSTW9kdWxlJyksXG4gICAgUmVnaW9uYWxJbmZvTW9kdWxlID0gcmVxdWlyZSgnZ2VuZXJhbC9SZWdpb25hbEluZm9Nb2R1bGUnKSxcbiAgICBTY2llbnRpZmljU3VtbWFyeU1vZHVsZSA9IHJlcXVpcmUoJ3NjaWVudGlmaWMvU2NpZW50aWZpY1N1bW1hcnlNb2R1bGUnKSxcbiAgICBTaGFrZU1hcE1vZHVsZSA9IHJlcXVpcmUoJ3NoYWtlbWFwL1NoYWtlTWFwTW9kdWxlJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIFdhdmVmb3JtTW9kdWxlID0gcmVxdWlyZSgnd2F2ZWZvcm0vV2F2ZWZvcm1Nb2R1bGUnKTtcblxuXG52YXIgX0RFRkFVTFRTID0ge1xuICAnZXZlbnQnOiBudWxsLCAvLyBDYXRhbG9nRXZlbnRcbiAgJ2NvbmZpZyc6IHtcbiAgfSxcbiAgJ2RlZmF1bHRNb2R1bGUnOiBFeGVjdXRpdmVTdW1tYXJ5TW9kdWxlLklELFxuICAnbW9kdWxlcyc6IFtcbiAgICAvLyBPdmVydmlld1xuICAgIFtcbiAgICAgIEV4ZWN1dGl2ZVN1bW1hcnlNb2R1bGUsXG4gICAgICBJbnRlcmFjdGl2ZU1hcE1vZHVsZSxcbiAgICAgIFJlZ2lvbmFsSW5mb01vZHVsZVxuICAgIF0sXG4gICAgLy8gSW1wYWN0XG4gICAgW1xuICAgICAgSW1wYWN0U3VtbWFyeU1vZHVsZSxcbiAgICAgIERZRklGb3JtTW9kdWxlLFxuICAgICAgRFlGSU1vZHVsZSxcbiAgICAgIFNoYWtlTWFwTW9kdWxlLFxuICAgICAgUEFHRVJNb2R1bGVcbiAgICBdLFxuICAgIC8vIFRlY2huaWNhbFxuICAgIFtcbiAgICAgIFNjaWVudGlmaWNTdW1tYXJ5TW9kdWxlLFxuICAgICAgT3JpZ2luTW9kdWxlLFxuICAgICAgTW9tZW50VGVuc29yTW9kdWxlLFxuICAgICAgRm9jYWxNZWNoYW5pc21Nb2R1bGUsXG4gICAgICBGaW5pdGVGYXVsdE1vZHVsZSxcbiAgICAgIFdhdmVmb3JtTW9kdWxlLFxuICAgICAgT2FmTW9kdWxlXG4gICAgXVxuICBdLFxuICAncmVkaXJlY3RzJzoge1xuICAgIC8vIE92ZXJ2aWV3XG4gICAgJ2dlbmVyYWxfc3VtbWFyeSc6IEV4ZWN1dGl2ZVN1bW1hcnlNb2R1bGUuSUQsXG4gICAgJ2dlbmVyYWxfbWFwJzogSW50ZXJhY3RpdmVNYXBNb2R1bGUuSUQsXG4gICAgLy8gSW1wYWN0XG4gICAgJ2ltcGFjdF9zdW1tYXJ5JzogSW1wYWN0U3VtbWFyeU1vZHVsZS5JRCxcbiAgICAnaW1wYWN0X3RlbGx1cyc6IERZRklGb3JtTW9kdWxlLklELFxuICAgICdpbXBhY3RfZHlmaSc6IERZRklNb2R1bGUuSUQsXG4gICAgJ2ltcGFjdF9zaGFrZW1hcCc6IFNoYWtlTWFwTW9kdWxlLklELFxuICAgICdpbXBhY3RfcGFnZXInOiBQQUdFUk1vZHVsZS5JRCxcbiAgICAvLyBUZWNobmljYWxcbiAgICAnc2NpZW50aWZpY19zdW1tYXJ5JzogU2NpZW50aWZpY1N1bW1hcnlNb2R1bGUuSUQsXG4gICAgJ3NjaWVudGlmaWNfb3JpZ2luJzogT3JpZ2luTW9kdWxlLklELFxuICAgICdzY2llbnRpZmljX21vbWVudC10ZW5zb3InOiBNb21lbnRUZW5zb3JNb2R1bGUuSUQsXG4gICAgJ3NjaWVudGlmaWNfZm9jYWwtbWVjaGFuaXNtJzogRm9jYWxNZWNoYW5pc21Nb2R1bGUuSUQsXG4gICAgJ3NjaWVudGlmaWNfZmluaXRlLWZhdWx0JzogRmluaXRlRmF1bHRNb2R1bGUuSUQsXG4gICAgJ3NjaWVudGlmaWNfd2F2ZWZvcm1zJzogV2F2ZWZvcm1Nb2R1bGUuSURcbiAgfVxufTtcblxudmFyIEV2ZW50UGFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfY29uZmlnLFxuICAgICAgX2N1cnJlbnRNb2R1bGUsXG4gICAgICBfZWwsXG4gICAgICBfZXZlbnQsXG4gICAgICBfZm9ybWF0dGVyLFxuICAgICAgX2hhc1ByZXZpb3VzLFxuICAgICAgX21vZGVsLFxuICAgICAgX21vZHVsZXMsXG4gICAgICBfbmF2RWwsXG4gICAgICBfcmVkaXJlY3RzLFxuXG4gICAgICBfY3JlYXRlTmF2SXRlbSxcbiAgICAgIF9pbml0aWFsaXplTW9kdWxlcyxcbiAgICAgIF9vbkhhc2hDaGFuZ2UsXG4gICAgICBfcGFyc2VIYXNoLFxuICAgICAgX3BhcnNlTGVnYWN5SGFzaDtcblxuXG4gIF90aGlzID0gRXZlbnRzKCk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgICBfcmVkaXJlY3RzID0gb3B0aW9ucy5yZWRpcmVjdHM7XG5cbiAgICBfZXZlbnQgPSBvcHRpb25zLmV2ZW50IHx8IENhdGFsb2dFdmVudCgpO1xuICAgIF9jb25maWcgPSBvcHRpb25zLmNvbmZpZyB8fCB7fTtcbiAgICBfY29uZmlnLmRlZmF1bHRNb2R1bGUgPSBfY29uZmlnLmRlZmF1bHRNb2R1bGUgfHwgb3B0aW9ucy5kZWZhdWx0TW9kdWxlO1xuICAgIF9jb25maWcubW9kdWxlcyA9IG9wdGlvbnMubW9kdWxlcyB8fCBbXTtcblxuICAgIF9mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBGb3JtYXR0ZXIoKTtcbiAgICAvLyB3aGV0aGVyIGV2ZW50IHBhZ2UgaGFzIHByZXZpb3VzbHkgcmVuZGVyZWQgYW55IGNvbnRlbnRcbiAgICBfaGFzUHJldmlvdXMgPSBmYWxzZTtcblxuICAgIF90aGlzLnVwZGF0ZUNvbnRyaWJ1dG9ycygpO1xuICAgIGlmIChfY29uZmlnLmhhc093blByb3BlcnR5KCdBVFRSSUJVVElPTl9VUkwnKSkge1xuICAgICAgQXR0cmlidXRpb24ubG9hZChfY29uZmlnLkFUVFJJQlVUSU9OX1VSTCk7XG4gICAgfVxuXG4gICAgX2VsID0gb3B0aW9ucy5lbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfbmF2RWwgPSBvcHRpb25zLm5hdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCduYXYnKTtcblxuICAgIF90aGlzLmhlYWRlciA9IF9lbC5xdWVyeVNlbGVjdG9yKCcuZXZlbnQtaGVhZGVyJykgfHxcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMuY29udGVudCA9IF9lbC5xdWVyeVNlbGVjdG9yKCcuZXZlbnQtY29udGVudCcpIHx8XG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzLmZvb3RlciA9IF9lbC5xdWVyeVNlbGVjdG9yKCcuZXZlbnQtZm9vdGVyJykgfHxcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBfbW9kZWwgPSBNb2RlbCh7XG4gICAgICAnZXZlbnQnOiBfZXZlbnQsXG4gICAgICAnY29uZmlnJzogX2NvbmZpZ1xuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlcyB0aGUgbWFwcGluZyBmb3IgbGF0ZXJcbiAgICBfaW5pdGlhbGl6ZU1vZHVsZXMoKTtcbiAgICBfdGhpcy5yZW5kZXJIZWFkZXIoKTtcbiAgICBBdHRyaWJ1dGlvbi53aGVuUmVhZHkoX3RoaXMub25BdHRyaWJ1dGlvblJlYWR5KTtcblxuICAgIC8vIHJlbmRlciBtb2R1bGVcbiAgICBFdmVudHMub24oJ2JhY2snLCAnb25CYWNrJywgX3RoaXMpO1xuICAgIEV2ZW50cy5vbignaGFzaGNoYW5nZScsIF9vbkhhc2hDaGFuZ2UpO1xuICAgIF9vbkhhc2hDaGFuZ2UoKTtcbiAgfTtcblxuICBfY3JlYXRlTmF2SXRlbSA9IGZ1bmN0aW9uIChtb2R1bGUsIGlzSGVhZGVyKSB7XG4gICAgdmFyIGxpbmssXG4gICAgICAgIG5hdkl0ZW07XG5cbiAgICBpZiAoaXNIZWFkZXIpIHtcbiAgICAgIG5hdkl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoZWFkZXInKTtcbiAgICAgIGxpbmsgPSBuYXZJdGVtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hdkl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBsaW5rID0gbmF2SXRlbTtcbiAgICB9XG5cbiAgICBsaW5rLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbW9kdWxlLScgKyBtb2R1bGUuSUQgKyAnLW5hdicpO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgJyMnICsgbW9kdWxlLklEKTtcbiAgICBsaW5rLmlubmVySFRNTCA9IG1vZHVsZS5USVRMRTtcblxuICAgIHJldHVybiBuYXZJdGVtO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW4gbmF2aWdhdGlvbiBmb3IgY3VycmVudCBfZXZlbnQgYXMgd2VsbCBhcyBhIG1hcCBvZlxuICAgKiBtb2R1bGVJZCA9PiBtb2R1bGUuXG4gICAqXG4gICAqL1xuICBfaW5pdGlhbGl6ZU1vZHVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdyb3VwLFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICBtb2R1bGUsXG4gICAgICAgIG1vZHVsZXMsXG4gICAgICAgIG1vZHVsZUdyb3VwcyxcbiAgICAgICAgbnVtR3JvdXBzLFxuICAgICAgICBudW1Nb2R1bGVzLFxuICAgICAgICB0eXBlcztcblxuICAgIF9tb2R1bGVzID0ge307XG5cbiAgICB0eXBlcyA9IChfZXZlbnQgPyBPYmplY3Qua2V5cyhfZXZlbnQuZ2V0UHJvZHVjdHMoKSkgOiBbXSk7XG4gICAgbW9kdWxlR3JvdXBzID0gX2NvbmZpZy5tb2R1bGVzO1xuICAgIG51bUdyb3VwcyA9IG1vZHVsZUdyb3Vwcy5sZW5ndGg7XG5cbiAgICBVdGlsLmVtcHR5KF9uYXZFbCk7XG5cbiAgICAvLyBBZGQgbmF2aWdhdGlvbiBsaW5rIHRvIHJldHVybiB0byBMYXRlc3QgRWFydGhxdWFrZXNcbiAgICBfdGhpcy5jcmVhdGVNYXBMaW5rKF9uYXZFbCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtR3JvdXBzOyBpKyspIHtcbiAgICAgIG1vZHVsZXMgPSBtb2R1bGVHcm91cHNbaV07XG4gICAgICBncm91cCA9IG51bGw7XG5cbiAgICAgIG51bU1vZHVsZXMgPSBtb2R1bGVzLmxlbmd0aDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBudW1Nb2R1bGVzOyBqKyspIHtcbiAgICAgICAgbW9kdWxlID0gbW9kdWxlc1tqXTtcblxuICAgICAgICBfbW9kdWxlc1ttb2R1bGUuSURdID0gbW9kdWxlO1xuXG4gICAgICAgIGlmIChfdGhpcy5tb2R1bGVIYXNDb250ZW50KG1vZHVsZSwgdHlwZXMpKSB7XG4gICAgICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgICAgICAgICBncm91cC5hcHBlbmRDaGlsZChfY3JlYXRlTmF2SXRlbShtb2R1bGUsIHRydWUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQoX2NyZWF0ZU5hdkl0ZW0obW9kdWxlKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICBfbmF2RWwuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICAgICAgfVxuXG4gICAgICBncm91cCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQWRkIG5hdmlnYXRpb24gbGluayB0byBkb3dubG9hZCBldmVudCBLTUxcbiAgICBfdGhpcy5jcmVhdGVLbWxMaW5rKF9uYXZFbCk7XG5cbiAgICAvLyBBZGQgc2VhcmNoIG5lYXJieSBzZWlzbWljaXR5IGxpbmtcbiAgICBfdGhpcy5jcmVhdGVTZWFyY2hOZWFyYnlTZWlzbWljaXR5TGluayhfbmF2RWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIEtNTCBMaW5rIHRvIHRoZSBib3R0b20gb2YgdGhlIG5hdmlnYXRpb24uXG4gICAqIEBwYXJhbXMgZWwge0RPTUVsZW1lbnR9XG4gICAqICAgIFRoZSBlbGVtZW50IHRvIGFkZCB0aGUgbGlua3MgdG8uXG4gICAqL1xuICBfdGhpcy5jcmVhdGVLbWxMaW5rID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgbGluayxcbiAgICAgICAga21sVVJMO1xuXG4gICAgaWYgKF9ldmVudCAmJiBfY29uZmlnLktNTF9TVFVCKSB7XG4gICAgICBrbWxVUkwgPSBfY29uZmlnLktNTF9TVFVCLnJlcGxhY2UoJyVzJyxcbiAgICAgICAgICBfZXZlbnQuZ2V0RXZlbnRJZCgpKTtcblxuICAgICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdjbGFzcycsICdrbWwtZG93bmxvYWQnKTtcbiAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdocmVmJywga21sVVJMKTtcbiAgICAgIGxpbmsuaW5uZXJIVE1MID0gJ0Rvd25sb2FkIEV2ZW50IEtNTCc7XG4gICAgICBlbC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgTGF0ZXN0IEVhcnRocXVha2VzIExpbmsgdG8gdGhlIHRvcCBvZiB0aGUgbmF2aWdhdGlvbi5cbiAgICogQHBhcmFtcyBlbCB7RE9NRWxlbWVudH1cbiAgICogICAgVGhlIGVsZW1lbnQgdG8gYWRkIHRoZSBsaW5rcyB0by5cbiAgICovXG4gIF90aGlzLmNyZWF0ZU1hcExpbmsgPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciBsaW5rO1xuXG4gICAgaWYgKCFfdGhpcy5pc1NjZW5hcmlvTW9kZSgpKSB7XG4gICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2xhdGVzdC1lYXJ0aHF1YWtlcycpO1xuICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnL2VhcnRocXVha2VzL21hcC8nKTtcbiAgICAgIGxpbmsuaW5uZXJIVE1MID0gJ0xhdGVzdCBFYXJ0aHF1YWtlcyc7XG4gICAgICBsaW5rLmNsYXNzTGlzdC5hZGQoJ3VwLW9uZS1sZXZlbCcpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgc2VhcmNoIG5lYXJieSBzZWlzbWljaXR5IGxpbmsuXG4gICAqXG4gICAqIEBwYXJhbSBlbCB7RE9NRWxlbWVudH1cbiAgICogICAgIGVsZW1lbnQgdG8gYWRkIGxpbmsgdG8uXG4gICAqL1xuICBfdGhpcy5jcmVhdGVTZWFyY2hOZWFyYnlTZWlzbWljaXR5TGluayA9IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBsaW5rLFxuICAgICAgICBuZWFyYnlTZWlzbWljaXR5LFxuICAgICAgICB1cmw7XG5cbiAgICBpZiAoX2V2ZW50ICYmICFfdGhpcy5pc1NjZW5hcmlvTW9kZSgpKSB7XG4gICAgICBuZWFyYnlTZWlzbWljaXR5ID0gTmVhcmJ5U2Vpc21pY2l0eSgpO1xuICAgICAgdXJsID0gbmVhcmJ5U2Vpc21pY2l0eS5nZXROZWFyYnlTZWlzbWljaXR5TGluayhfZXZlbnQuZ2V0U3VtbWFyeSgpKTtcbiAgICAgIG5lYXJieVNlaXNtaWNpdHkuZGVzdHJveSgpO1xuXG4gICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NlYXJjaC1uZWFyYnktc2Vpc21pY2l0eScpO1xuICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB1cmwpO1xuICAgICAgbGluay5pbm5lckhUTUwgPSAnU2VhcmNoIE5lYXJieSBTZWlzbWljaXR5JztcbiAgICAgIGVsLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBVbmJpbmQgZXZlbnQgbGlzdGVuZXJzIGFuZCBmcmVlIHJlZmVyZW5jZXMuXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV90aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVuZGVyIG1vZHVsZVxuICAgIEV2ZW50cy5vZmYoJ2JhY2snLCAnb25CYWNrJywgX3RoaXMpO1xuICAgIEV2ZW50cy5vZmYoJ2hhc2hjaGFuZ2UnLCBfb25IYXNoQ2hhbmdlKTtcblxuICAgIGlmIChfY3VycmVudE1vZHVsZSkge1xuICAgICAgX2N1cnJlbnRNb2R1bGUuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGlmIChfbW9kZWwpIHtcbiAgICAgIF9tb2RlbC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb25zXG4gICAgX2NyZWF0ZU5hdkl0ZW0gPSBudWxsO1xuICAgIF9pbml0aWFsaXplTW9kdWxlcyA9IG51bGw7XG4gICAgX29uSGFzaENoYW5nZSA9IG51bGw7XG4gICAgX3BhcnNlSGFzaCA9IG51bGw7XG4gICAgX3BhcnNlTGVnYWN5SGFzaCA9IG51bGw7XG5cbiAgICAvLyB2YXJpYWJsZXNcbiAgICBfY29uZmlnID0gbnVsbDtcbiAgICBfY3VycmVudE1vZHVsZSA9IG51bGw7XG4gICAgX2VsID0gbnVsbDtcbiAgICBfZXZlbnQgPSBudWxsO1xuICAgIF9mb3JtYXR0ZXIgPSBudWxsO1xuICAgIF9oYXNQcmV2aW91cyA9IGZhbHNlO1xuICAgIF9tb2RlbCA9IG51bGw7XG4gICAgX21vZHVsZXMgPSBudWxsO1xuICAgIF9uYXZFbCA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYXR0cmlidXRpb24gaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkLFxuICAgKiBVcGRhdGVzIHRoZSBjb250cmlidXRvciBsb2dvIGluIHRoZSBoZWFkZXIgYW5kXG4gICAqIHRoZSBjb250cmlidXRvciBsaXN0IGluIHRoZSBiYW5uZXIuXG4gICAqL1xuICBfdGhpcy5vbkF0dHJpYnV0aW9uUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZWZlcnJlZE9yaWdpbjtcblxuICAgIC8vIENvbnRyaWJ1dG9yIGxvZ28gaW4gYmFubmVyXG4gICAgcHJlZmVycmVkT3JpZ2luID0gX2V2ZW50ID8gX2V2ZW50LmdldFByZWZlcnJlZE9yaWdpblByb2R1Y3QoKSA6IG51bGw7XG4gICAgaWYgKHByZWZlcnJlZE9yaWdpbikge1xuICAgICAgQ29vcGVyYXRvckxvZ28oe1xuICAgICAgICBjb29wZXJhdG9yOiBBdHRyaWJ1dGlvbi5nZXRDb250cmlidXRvcihwcmVmZXJyZWRPcmlnaW4uZ2V0KCdzb3VyY2UnKSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCBDb250cmlidXRvciBsaXN0IGluIGZvb3RlclxuICAgIF90aGlzLnJlbmRlckZvb3RlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb29wcyBvdmVyIGVhY2ggcHJvZHVjdCBhbmQgY2hlY2tzIGZvciBzb3VyY2UgaW5mb3JtYXRpb24uIENyZWF0ZXMgYVxuICAgKiB1bmlxdWUgbGlzdCBvZiBjb250cmlidXRvcnMgYW5kIHRoZW4gc2V0cyB0aGlzIGxpc3Qgb24gdGhlXG4gICAqIEF0dHJpYnV0aW9uIHNvIHdlIGhhdmUgYSBjb21wbGV0ZSBsaXN0LlxuICAgKlxuICAgKi9cbiAgX3RoaXMudXBkYXRlQ29udHJpYnV0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhbGxQcm9kdWN0cyxcbiAgICAgICAgcHJvZHVjdHMsXG4gICAgICAgIHByb2R1Y3QsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc291cmNlcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuZ3RoO1xuXG4gICAgYWxsUHJvZHVjdHMgPSBfZXZlbnQgPyBfZXZlbnQuZ2V0UHJvZHVjdHMoKSA6IHt9O1xuICAgIHNvdXJjZXMgPSB7fTtcblxuICAgIGZvciAodHlwZSBpbiBhbGxQcm9kdWN0cykge1xuICAgICAgcHJvZHVjdHMgPSBhbGxQcm9kdWN0c1t0eXBlXTtcbiAgICAgIGxlbmd0aCA9IHByb2R1Y3RzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb2R1Y3QgPSBwcm9kdWN0c1tpXTtcblxuXG4gICAgICAgIC8vIGNoZWNrIHByb2R1Y3Qgc291cmNlXG4gICAgICAgIHNvdXJjZSA9IHByb2R1Y3QuZ2V0KCdzb3VyY2UnKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHNvdXJjZSAhPT0gJ2FkbWluJyAmJiAhc291cmNlcy5oYXNPd25Qcm9wZXJ0eShzb3VyY2UpKSB7XG4gICAgICAgICAgICBzb3VyY2VzW3NvdXJjZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNvdXJjZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ29yaWdpbi1zb3VyY2UnKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmICghc291cmNlcy5oYXNPd25Qcm9wZXJ0eShzb3VyY2UpKSB7XG4gICAgICAgICAgICBzb3VyY2VzW3NvdXJjZV0gPSBzb3VyY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ21hZ25pdHVkZS1zb3VyY2UnKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmICghc291cmNlcy5oYXNPd25Qcm9wZXJ0eShzb3VyY2UpKSB7XG4gICAgICAgICAgICBzb3VyY2VzW3NvdXJjZV0gPSBzb3VyY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2JlYWNoYmFsbC1zb3VyY2UnKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmICghc291cmNlcy5oYXNPd25Qcm9wZXJ0eShzb3VyY2UpKSB7XG4gICAgICAgICAgICBzb3VyY2VzW3NvdXJjZV0gPSBzb3VyY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgQXR0cmlidXRpb24uc2V0Q29udHJpYnV0b3JzKE9iamVjdC5rZXlzKHNvdXJjZXMpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBldmVudCBwYWdlIGlzIGluIHNjZW5hcmlvIG1vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqICAgICB0cnVlLCB3aGVuIGV2ZW50IHBhZ2UgaXMgY29uZmlndXJlZCB0byBiZSBpbiBzY2VuYXJpbyBtb2RlO1xuICAgKiAgICAgZmFsc2UsIG90aGVyd2lzZS5cbiAgICovXG4gIF90aGlzLmlzU2NlbmFyaW9Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoX2NvbmZpZy5TQ0VOQVJJT19NT0RFID09PSB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhIG1vZHVsZSBoYXMgY29udGVudC5cbiAgICpcbiAgICogSWYgYG1vZHVsZWAgZGVmaW5lcyBhIHN0YXRpYyBoYXNDb250ZW50IG1ldGhvZCwgZGVmZXIgdG8gbW9kdWxlLlxuICAgKiBPdGhlcndpc2UsIGBtb2R1bGVgIHNob3VsZCBkZWZpbmUgYSBzdGF0aWMgVFlQRVMgcHJvcGVydHkgd2l0aCBhIGxpc3RcbiAgICogb2YgXCJiYXNlXCIgcHJvZHVjdCB0eXBlczsgaWYgZXZlbnQgcGFnZSBpcyBpbiBzY2VuYXJpbyBtb2RlLCBhdXRvbWF0aWNhbGx5XG4gICAqIGFkZHMgXCItc2NlbmFyaW9cIiBzdWZmaXggdG8gYmFzZSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gbW9kdWxlIHtNb2R1bGV9XG4gICAqICAgICB0aGUgbW9kdWxlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0gcHJvZHVjdFR5cGVzIHtBcnJheTxTdHJpbmc+fVxuICAgKiAgICAgYXJyYXkgb2YgcHJvZHVjdCB0eXBlcyBhc3NvY2lhdGVkIHdpdGggY3VycmVudCBldmVudC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogICAgIHRydWUsIGlmIG1vZHVsZSBzaG91bGQgYmUgaW5jbHVkZWQgaW4gbmF2aWdhdGlvbjtcbiAgICogICAgIGZhbHNlLCBvdGhlcndpc2UuXG4gICAqL1xuICBfdGhpcy5tb2R1bGVIYXNDb250ZW50ID0gZnVuY3Rpb24gKG1vZHVsZSwgcHJvZHVjdFR5cGVzKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGlzU2NlbmFyaW9Nb2RlLFxuICAgICAgICBsZW4sXG4gICAgICAgIHR5cGU7XG5cbiAgICBpZiAobW9kdWxlLmhhc093blByb3BlcnR5KCdoYXNDb250ZW50JykgJiZcbiAgICAgICAgdHlwZW9mIG1vZHVsZS5oYXNDb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLmhhc0NvbnRlbnQoX21vZGVsKTtcbiAgICB9IGVsc2UgaWYgKG1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnVFlQRVMnKSAmJiBBcnJheS5pc0FycmF5KG1vZHVsZS5UWVBFUykpIHtcbiAgICAgIGxlbiA9IG1vZHVsZS5UWVBFUy5sZW5ndGg7XG4gICAgICBpc1NjZW5hcmlvTW9kZSA9IF90aGlzLmlzU2NlbmFyaW9Nb2RlKCk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0eXBlID0gbW9kdWxlLlRZUEVTW2ldO1xuICAgICAgICBpZiAoaXNTY2VuYXJpb01vZGUpIHtcbiAgICAgICAgICB0eXBlICs9ICctc2NlbmFyaW8nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2R1Y3RUeXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCYWNrIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYGJhY2tgIGV2ZW50IG9uIGdsb2JhbCBFdmVudHMgb2JqZWN0LlxuICAgKi9cbiAgX3RoaXMub25CYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfaGFzUHJldmlvdXMpIHtcbiAgICAgIC8vIHRoZXJlIGlzIGEgcHJldmlvdXMgbW9kdWxlIHRvIHJlbmRlclxuICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcjJyArIF9jb25maWcuZGVmYXVsdE1vZHVsZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBtb2RlbCBhbmQgbW9kdWxlIGJhc2VkIG9uIGN1cnJlbnQgdXJsLlxuICAgKlxuICAgKiBJZiBjdXJyZW50IHVybCBpcyB1bmV4cGVjdGVkL3Vua25vd24sIGxvYWRzIGRlZmF1bHQgbW9kdWxlLlxuICAgKiBUcmlnZ2VycyBhIHJlbmRlciBvZiBjdXJyZW50IG1vZHVsZS5cbiAgICovXG4gIF9vbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsZWFyU2V0dGluZ3MsXG4gICAgICAgIGN1cnJlbnROYXYsXG4gICAgICAgIGhhc2gsXG4gICAgICAgIGxhc3ROYXYsXG4gICAgICAgIG1vZGVsUGFyYW1zLFxuICAgICAgICBtb2R1bGUsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVkaXJlY3Q7XG5cbiAgICAvLyBwYXJzZSB1cmxzIG9mIGZvcm1hdCBcIiNtb2R1bGU/cGFyYW1zXCIgd2hlcmUgcGFyYW1zIGlzIGluIHF1ZXJ5IHN0cmluZyBmb3JtYXRcbiAgICBoYXNoID0gX3BhcnNlSGFzaCh3aW5kb3cubG9jYXRpb24uaGFzaCB8fCAnJyk7XG4gICAgbW9kdWxlID0gaGFzaC5tb2R1bGU7XG4gICAgcGFyYW1zID0gaGFzaC5wYXJhbXM7XG5cbiAgICAvLyB2ZXJpZnkgbW9kdWxlIGlzIGtub3duLCBvdGhlcndpc2UgbG9hZCBkZWZhdWx0IChmcm9tIFwiY29uZmlnXCIpXG4gICAgaWYgKCFfbW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShtb2R1bGUpKSB7XG4gICAgICBoYXNoID0gX3BhcnNlTGVnYWN5SGFzaCh3aW5kb3cubG9jYXRpb24uaGFzaCB8fCAnJyk7XG4gICAgICBtb2R1bGUgPSBoYXNoLm1vZHVsZTtcbiAgICAgIHBhcmFtcyA9IGhhc2gucGFyYW1zO1xuXG4gICAgICBpZiAoX21vZHVsZXMuaGFzT3duUHJvcGVydHkobW9kdWxlKSkge1xuICAgICAgICByZWRpcmVjdCA9ICcjJyArIGhhc2gucmVkaXJlY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWRpcmVjdCA9ICcjJyArIF9jb25maWcuZGVmYXVsdE1vZHVsZTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgXCJiYWRcIiB1cmwgc28gdXNlcnMgY2FuIGdvIGJhY2sgYmVmb3JlIHRoZSByZWRpcmVjdFxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShyZWRpcmVjdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHJlZGlyZWN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKF9jdXJyZW50TW9kdWxlKSB7XG4gICAgICAvLyBjYW4gbmF2aWdhdGUgYmFja3dhcmRzIHVzaW5nIHdpbmRvdy5oaXN0b3J5XG4gICAgICBfaGFzUHJldmlvdXMgPSB0cnVlO1xuXG4gICAgICAvLyBpZiBjdXJyZW50IG1vZHVsZSBpcyBkaWZmZXJlbnQgdGhhbiByZXF1ZXN0ZWQsIGRlc3Ryb3kgY3VycmVudCBtb2R1bGVcbiAgICAgIGlmIChfY3VycmVudE1vZHVsZS5JRCAhPT0gbW9kdWxlKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZXNlIHNvIGRlZmF1bHRzIGFyZSBpbnZva2VkXG4gICAgICAgIGNsZWFyU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgY2xlYXJTZXR0aW5nc1tfY3VycmVudE1vZHVsZS5JRF0gPSB7fTtcbiAgICAgICAgX21vZGVsLnNldChjbGVhclNldHRpbmdzLCB7c2lsZW50OiB0cnVlfSk7XG5cbiAgICAgICAgX2N1cnJlbnRNb2R1bGUuZGVzdHJveSgpO1xuICAgICAgICBfY3VycmVudE1vZHVsZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgbm8gY3VycmVudCBtb2R1bGUsIGNyZWF0ZSBtb2R1bGUgd2l0aCBtb2RlbCBhbmQgbW9kdWxlIGNvbnRlbnQgZWxlbWVudFxuICAgIGlmICghX2N1cnJlbnRNb2R1bGUpIHtcbiAgICAgIF9jdXJyZW50TW9kdWxlID0gX21vZHVsZXNbbW9kdWxlXSh7XG4gICAgICAgIGVsOiBfdGhpcy5jb250ZW50LFxuICAgICAgICBmb3JtYXR0ZXI6IF9mb3JtYXR0ZXIsXG4gICAgICAgIG1vZGVsOiBfbW9kZWxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBtb2R1bGUgcGFyYW1zXG4gICAgcGFyYW1zID0gVXRpbC5leHRlbmQoe30sIHBhcmFtcyk7XG4gICAgbW9kZWxQYXJhbXMgPSB7fTtcbiAgICBtb2RlbFBhcmFtc1ttb2R1bGVdID0gcGFyYW1zO1xuICAgIC8vIHRoaXMgdHJpZ2dlcnMgYSByZW5kZXIgb2YgX2N1cnJlbnRNb2R1bGVcbiAgICBfbW9kZWwuc2V0KG1vZGVsUGFyYW1zKTtcblxuICAgIC8vIHVwZGF0ZSBuYXZpZ2F0aW9uXG4gICAgY3VycmVudE5hdiA9IF9uYXZFbC5xdWVyeVNlbGVjdG9yKCcubW9kdWxlLScgKyBfY3VycmVudE1vZHVsZS5JRCArICctbmF2Jyk7XG4gICAgbGFzdE5hdiA9IF9uYXZFbC5xdWVyeVNlbGVjdG9yKCcuY3VycmVudC1tb2R1bGUnKTtcbiAgICBpZiAoY3VycmVudE5hdiAhPT0gbGFzdE5hdikge1xuICAgICAgaWYgKGxhc3ROYXYpIHtcbiAgICAgICAgbGFzdE5hdi5jbGFzc0xpc3QucmVtb3ZlKCdjdXJyZW50LW1vZHVsZScpO1xuICAgICAgfVxuICAgICAgY3VycmVudE5hdi5jbGFzc0xpc3QuYWRkKCdjdXJyZW50LW1vZHVsZScpO1xuICAgIH1cblxuICAgIC8vIG5vdGlmeSB0aGF0IHBhZ2Ugd2FzIHJlbmRlcmVkXG4gICAgX3RoaXMudHJpZ2dlcigncmVuZGVyJyk7XG5cbiAgICAvLyBzY3JvbGwgdG8gdG9wIG9mIHBhZ2VcbiAgICB3aW5kb3cuc2Nyb2xsKDAsMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtb2R1bGUgYW5kIG1vZHVsZSBwYXJhbWV0ZXJzIGZyb20gYSBoYXNoIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gaGFzaCB7U3RyaW5nfVxuICAgKiAgICAgICAgdGhlIGhhc2ggZnJhZ21lbnQgdG8gcGFyc2UuXG4gICAqICAgICAgICBlLmcuIFwiI21vZHVsZT9wYXJhbTE9dmFsdWUxJnBhcmFtMj12YWx1ZTJcIlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgbW9kdWxlIHtTdHJpbmd9IG5hbWUgb2YgbW9kdWxlLlxuICAgKiAgICAgICAgIHBhcmFtcyB7T2JqZWN0fSBtb2R1bGUgcGFyYW1ldGVycy5cbiAgICovXG4gIF9wYXJzZUhhc2ggPSBmdW5jdGlvbiAoaGFzaCkge1xuICAgIHZhciBtb2R1bGUsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcGFydHM7XG5cbiAgICBoYXNoID0gaGFzaC5yZXBsYWNlKCcjJywgJycpO1xuICAgIHBhcnRzID0gaGFzaC5zcGxpdCgnPycpO1xuICAgIG1vZHVsZSA9IHBhcnRzWzBdO1xuICAgIHBhcmFtcyA9IHt9O1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyByZWpvaW4gYW55IHJlbWFpbmluZyBwYXJ0cyB1c2luZyA/LCB0aGVuIHNwbGl0IHBhcmFtZXRlcnMgb24gJlxuICAgICAgcGFydHMgPSBwYXJ0cy5zbGljZSgxKS5qb2luKCc/Jykuc3BsaXQoJyYnKTtcbiAgICAgIC8vIHBhcnNlIGVhY2ggcGFyYW1ldGVyXG4gICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgbmFtZSxcbiAgICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgICAgdmFsdWU7XG4gICAgICAgIC8vIHBhcmFtZXRlciBhbmQgdmFsdWUgYXJlIHNlcGFyYXRlZCBieSA9XG4gICAgICAgIHBhcnRzID0gcGFyYW0uc3BsaXQoJz0nKTtcbiAgICAgICAgbmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1swXSk7XG4gICAgICAgIC8vIHZhbHVlIG1heSBpbmNsdWRlID0sIHNvIHNsaWNlIGFuZCByZWpvaW5cbiAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQocGFydHMuc2xpY2UoMSkuam9pbignPScpKTtcbiAgICAgICAgcGFyYW1zW25hbWVdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICdtb2R1bGUnOiBtb2R1bGUsXG4gICAgICAncGFyYW1zJzogcGFyYW1zXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1vZHVsZSBhbmQgbW9kdWxlIHBhcmFtZXRlcnMgZnJvbSBhIGhhc2ggZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBoYXNoIHtTdHJpbmd9XG4gICAqICAgICAgICB0aGUgaGFzaCBmcmFnbWVudCB0byBwYXJzZS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIG1vZHVsZSB7U3RyaW5nfSBuYW1lIG9mIG1vZHVsZS5cbiAgICogICAgICAgICBwYXJhbXMge09iamVjdH0gbW9kdWxlIHBhcmFtZXRlcnMuXG4gICAqICAgICAgICAgcmVkaXJlY3Qge09iamVjdH0gcmVkaXJlY3QgcGFyYW1ldGVycy5cbiAgICovXG4gIF9wYXJzZUxlZ2FjeUhhc2ggPSBmdW5jdGlvbiAoaGFzaCkge1xuICAgIHZhciBtb2R1bGUsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcGFydHMsXG4gICAgICAgIHJlZGlyZWN0O1xuXG4gICAgaGFzaCA9IGhhc2gucmVwbGFjZSgnIycsICcnKTtcbiAgICBwYXJhbXMgPSB7fTtcbiAgICBwYXJ0cyA9IGhhc2guc3BsaXQoJzonKTtcbiAgICBtb2R1bGUgPSBwYXJ0c1swXTtcblxuICAgIGlmIChfcmVkaXJlY3RzLmhhc093blByb3BlcnR5KG1vZHVsZSkpIHtcbiAgICAgIG1vZHVsZSA9IF9yZWRpcmVjdHNbbW9kdWxlXTtcbiAgICB9XG5cbiAgICByZWRpcmVjdCA9IG1vZHVsZTtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICBwYXJ0cyA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJzonKS5zcGxpdCgnXycpO1xuXG4gICAgICBpZiAocGFydHNbMF0pIHtcbiAgICAgICAgcGFyYW1zLnNvdXJjZSA9IHBhcnRzWzBdO1xuICAgICAgICByZWRpcmVjdCArPSAnP3NvdXJjZT0nICsgcGFydHNbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJ0c1sxXSkge1xuICAgICAgICBwYXJhbXMuY29kZSA9IHBhcnRzWzFdO1xuICAgICAgICByZWRpcmVjdCArPSAnJmNvZGU9JyArIHBhcnRzWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAnbW9kdWxlJzogbW9kdWxlLFxuICAgICAgJ3BhcmFtcyc6IHBhcmFtcyxcbiAgICAgICdyZWRpcmVjdCc6IHJlZGlyZWN0XG4gICAgfTtcbiAgfTtcblxuICBfdGhpcy5yZW5kZXJGb290ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRyaWJ1dG9ycyxcbiAgICAgICAgbWFya3VwO1xuXG4gICAgY29udHJpYnV0b3JzID0gQXR0cmlidXRpb24uZ2V0Q29udHJpYnV0b3JzKCk7XG4gICAgbWFya3VwID0gW107XG5cbiAgICBpZiAoY29udHJpYnV0b3JzICYmIGNvbnRyaWJ1dG9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGgzPkNvbnRyaWJ1dG9yczwvaDM+JyxcbiAgICAgICAgQXR0cmlidXRpb24uZ2V0Q29udHJpYnV0b3JMaXN0KClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbWFya3VwLnB1c2goXG4gICAgICAnPGgzPkFkZGl0aW9uYWwgSW5mb3JtYXRpb248L2gzPicsXG4gICAgICAnPHVsPidcbiAgICApO1xuXG4gICAgaWYgKF90aGlzLmlzU2NlbmFyaW9Nb2RlKCkpIHtcbiAgICAgIG1hcmt1cC5wdXNoKCc8bGk+PGEgaHJlZj1cIi9zY2VuYXJpb3MvXCI+RWFydGhxdWFrZSBTY2VuYXJpb3M8L2E+PC9saT4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8bGk+JyxcbiAgICAgICAgICAnPGEgaHJlZj1cIi9kYXRhL2NvbWNhdC9cIj4nLFxuICAgICAgICAgICAgJ0FOU1MgQ29tcHJlaGVuc2l2ZSBFYXJ0aHF1YWtlIENhdGFsb2cgKENvbUNhdCkgRG9jdW1lbnRhdGlvbicsXG4gICAgICAgICAgJzwvYT4nLFxuICAgICAgICAnPC9saT4nKTtcbiAgICB9XG5cbiAgICBtYXJrdXAucHVzaChcbiAgICAgICc8bGk+JyxcbiAgICAgICAgJzxhIGhyZWY9XCIvZGF0YS9jb21jYXQvZGF0YS1ldmVudHRlcm1zLnBocFwiPicsXG4gICAgICAgICAgJ1RlY2huaWNhbCB0ZXJtcyB1c2VkIG9uIGV2ZW50IHBhZ2VzJyxcbiAgICAgICAgJzwvYT4nLFxuICAgICAgJzwvbGk+JyxcbiAgICAgICc8L3VsPicpO1xuXG4gICAgX3RoaXMuZm9vdGVyLmlubmVySFRNTCA9IG1hcmt1cC5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGV2ZW50IHBhZ2UgaGVhZGVyIGNvbnRlbnQuXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXJIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRXZlbnQgcGFnZSBoZWFkZXIgY29udGVudCBpcyBnZW5lcmF0ZWQgb24gc2VydmVyLiBEbyBub3QgbW9kaWZ5IGl0IGhlcmUuXG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQYWdlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbi8vIGRlZmF1bHQgb3B0aW9uc1xudmFyIF9ERUZBVUxUUyA9IHtcbiAgLy8gZGVjaW1hbCBwbGFjZXMgZm9yIGRlcHRoXG4gIGRlcHRoRGVjaW1hbHM6IDEsXG4gIC8vIGRlY2ltYWwgcGxhY2VzIGZvciBkaXN0YW5jZVxuICBkaXN0YW5jZURlY2ltYWxzOiAxLFxuICAvLyBjb250ZW50IHdoZW4gYSB2YWx1ZSBpcyBtaXNzaW5nXG4gIGVtcHR5OiAnJm5kYXNoOycsXG4gIC8vIHNpemUgYWJicmV2aWF0aW9ucyBmb3IgW2J5dGVzLCBraWxvYnl0ZXMsIG1lZ2FieXRlcywgZ2lnYWJ5dGVzXVxuICBmaWxlU2l6ZXM6IFsnIEInLCAnIEtCJywgJyBNQicsICcgR0InXSxcbiAgLy8gZGVjaW1hbCBwbGFjZXMgZm9yIGxhdGl0dWRlL2xvbmdpdHVkZVxuICBsb2NhdGlvbkRlY2ltYWxzOiAzLFxuICAvLyBkZWNpbWFsIHBsYWNlcyBmb3IgbWFnbml0dWRlXG4gIG1hZ25pdHVkZURlY2ltYWxzOiAxXG59O1xuXG5cbnZhciBfTUlMRVNfUEVSX0tJTE9NRVRFUiA9IDAuNjIxMzcxO1xuXG52YXIgX01NSV9BUlJBWSA9IFsnSScsICdJJywgJ0lJJywgJ0lJSScsICdJVicsICdWJywgJ1ZJJywgJ1ZJSScsICdWSUlJJyxcbiAgICAnSVgnLCAnWCcsICdYSScsICdYSUknXTtcblxudmFyIF9NTUlfQ09MT1JTID0gW1xuICAnI0ZGRkZGRicsICAvLyBJXG4gICcjRkZGRkZGJywgIC8vIElcbiAgJyNBQ0Q4RTknLCAgLy8gSUlcbiAgJyNBQ0Q4RTknLCAgLy8gSUlJXG4gICcjODNEMERBJywgIC8vIElWXG4gICcjN0JDODdGJywgIC8vIFZcbiAgJyNGOUY1MTgnLCAgLy8gVklcbiAgJyNGQUM2MTEnLCAgLy8gVklJXG4gICcjRkE4QTExJywgIC8vIFZJSUlcbiAgJyNGNzEwMEMnLCAgLy8gSVhcbiAgJyNDODBGMEEnLCAgLy8gWFxuICAnI0M4MEYwQScsICAvLyBYSVxuICAnI0M4MEYwQScgICAvLyBYSUlcbl07XG5cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBuZXcgRm9ybWF0dGVyLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gKiAgICAgICAgZm9ybWF0dGVyIG9wdGlvbnMuXG4gKi9cbnZhciBGb3JtYXR0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2RlcHRoRGVjaW1hbHMsXG4gICAgICBfZGlzdGFuY2VEZWNpbWFscyxcbiAgICAgIF9lbXB0eSxcbiAgICAgIF9maWxlU2l6ZXMsXG4gICAgICBfbG9jYXRpb25EZWNpbWFscyxcbiAgICAgIF9tYWduaXR1ZGVEZWNpbWFscztcblxuICBfdGhpcyA9IHt9O1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG5cbiAgICBfZGVwdGhEZWNpbWFscyA9IG9wdGlvbnMuZGVwdGhEZWNpbWFscztcbiAgICBfZGlzdGFuY2VEZWNpbWFscyA9IG9wdGlvbnMuZGlzdGFuY2VEZWNpbWFscztcbiAgICBfZW1wdHkgPSBvcHRpb25zLmVtcHR5O1xuICAgIF9maWxlU2l6ZXMgPSBvcHRpb25zLmZpbGVTaXplcztcbiAgICBfbG9jYXRpb25EZWNpbWFscyA9IG9wdGlvbnMubG9jYXRpb25EZWNpbWFscztcbiAgICBfbWFnbml0dWRlRGVjaW1hbHMgPSBvcHRpb25zLm1hZ25pdHVkZURlY2ltYWxzO1xuICB9O1xuXG5cbiAgX3RoaXMuYW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUsIGRlY2ltYWxzKSB7XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgaWYgKCFhbmdsZSAmJiBhbmdsZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIF9lbXB0eTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlY2ltYWxzID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSBOdW1iZXIoYW5nbGUpLnRvRml4ZWQoZGVjaW1hbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IE1hdGgucm91bmQoYW5nbGUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSArICcmZGVnOyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGF6aW11dGggdG8gYSBiYWNrIGF6aW11dGggKG9wcG9zaXRlIGRpcmVjdGlvbikuXG4gICAqXG4gICAqIEBwYXJhbSBhemltdXRoIHtOdW1iZXJ9XG4gICAqICAgIGF6aW11dGggdG8gZm9ybWF0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogICAgZm9ybWF0dGVkIGF6aW11dGhcbiAgICovXG4gIF90aGlzLmJhY2tBemltdXRoID0gZnVuY3Rpb24oYXppbXV0aCkge1xuICAgIGlmIChhemltdXRoID49IDE4MCkge1xuICAgICAgYXppbXV0aCA9IGF6aW11dGggLSAxODA7XG4gICAgfSBlbHNlIGlmIChhemltdXRoIDwgMTgwKSB7XG4gICAgICBhemltdXRoID0gYXppbXV0aCArIDE4MDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXppbXV0aDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBhemltdXRoIGluIGRlZ3JlZSdzIGludG8gY29tcGFzcyBwb2ludHMuXG4gICAqIEBwYXJhbSBhemltdXRoIHtudW1iZXJ9XG4gICAqICAgIGF6aW11dGggdG8gZm9ybWF0XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgY29tcGFzcyBkaXJlY3Rpb25cbiAgICovXG4gIF90aGlzLmNvbXBhc3NXaW5kcyA9IGZ1bmN0aW9uKGF6aW11dGgpIHtcbiAgICB2YXIgZnVsbHdpbmQgPSAyMi41LFxuICAgICAgICBkaXJlY3Rpb25zID0gWydOJywgJ05ORScsICdORScsICdFTkUnLCAnRScsICdFU0UnLCAnU0UnLCAnU1NFJyxcbiAgICAgICAgICAgICdTJywgJ1NTVycsICdTVycsICdXU1cnLCAnVycsICdXTlcnLCAnTlcnLCAnTk5XJywgJ04nXTtcblxuICAgIC8vIGlmIGRpcmVjdGlvbiBpcyBhbHJlYWR5IGluIGNvbXBhc3MgcG9pbnRzXG4gICAgaWYgKGRpcmVjdGlvbnMuaW5kZXhPZihhemltdXRoKSA+IC0xKSB7XG4gICAgICByZXR1cm4gYXppbXV0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aW9uc1soTWF0aC5yb3VuZCgoYXppbXV0aCUzNjApL2Z1bGx3aW5kKSldO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JtYXQgYSBVVEMgZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIGRhdGUge0RhdGV9XG4gICAqICAgICAgICBkYXRlIHRvIGZvcm1hdC5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiAgICAgICAgIGZvcm1hdHRlZCBkYXRlLlxuICAgKi9cbiAgX3RoaXMuZGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgdmFyIHllYXIsXG4gICAgICAgIG1vbnRoLFxuICAgICAgICBkYXk7XG5cbiAgICBpZiAoIWRhdGUgfHwgdHlwZW9mIGRhdGUuZ2V0VGltZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIF9lbXB0eTtcbiAgICB9XG5cbiAgICB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgIG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpICsgMTtcbiAgICBkYXkgPSBkYXRlLmdldFVUQ0RhdGUoKTtcblxuICAgIGlmIChtb250aCA8IDEwKSB7XG4gICAgICBtb250aCA9ICcwJyArIG1vbnRoO1xuICAgIH1cbiAgICBpZiAoZGF5IDwgMTApIHtcbiAgICAgIGRheSA9ICcwJyArIGRheTtcbiAgICB9XG5cbiAgICByZXR1cm4geWVhciArICctJyArIG1vbnRoICsgJy0nICsgZGF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JtYXQgYSBkYXRlIGFuZCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhbXAge0RhdGV8TnVtYmVyfVxuICAgKiAgICAgICAgRGF0ZSBvciBtaWxsaXNlY29uZCBlcG9jaCB0aW1zdGFtcCB0byBmb3JtYXQuXG4gICAqIEBwYXJhbSBtaW51dGVzT2Zmc2V0IHtOdW1iZXJ9XG4gICAqICAgICAgICBVVEMgb2Zmc2V0IGluIG1pbnV0ZXMuICAwIGZvciBVVEMuXG4gICAqIEBwYXJhbSBpbmNsdWRlTWlsbGlzZWNvbmRzIHtCb29sZWFufVxuICAgKiAgICAgICAgZGVmYXVsdCBmYWxzZS5cbiAgICogICAgICAgIHdoZXRoZXIgdG8gb3V0cHV0IG1pbGxpc2Vjb25kcy5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiAgICAgICAgIGZvcm1hdHRlZCBkYXRlLlxuICAgKi9cbiAgX3RoaXMuZGF0ZXRpbWUgPSBmdW5jdGlvbiAoc3RhbXAsIG1pbnV0ZXNPZmZzZXQsIGluY2x1ZGVNaWxsaXNlY29uZHMpIHtcbiAgICB2YXIgbWlsbGlPZmZzZXQsXG4gICAgICAgIGRhdGU7XG5cbiAgICBpZiAoIXN0YW1wICYmIHN0YW1wICE9PSAwKSB7XG4gICAgICByZXR1cm4gX2VtcHR5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YW1wLmdldFRpbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGFsbG93IERhdGUgb2JqZWN0c1xuICAgICAgc3RhbXAgPSBzdGFtcC5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgbWludXRlc09mZnNldCA9IG1pbnV0ZXNPZmZzZXQgfHwgMDtcbiAgICBtaWxsaU9mZnNldCA9IG1pbnV0ZXNPZmZzZXQgKiA2MCAqIDEwMDA7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKHN0YW1wICsgbWlsbGlPZmZzZXQpO1xuXG4gICAgcmV0dXJuIF90aGlzLmRhdGUoZGF0ZSkgKyAnICcgKyBfdGhpcy50aW1lKGRhdGUsIGluY2x1ZGVNaWxsaXNlY29uZHMpICtcbiAgICAgICAgJyAoVVRDJyArIF90aGlzLnRpbWV6b25lT2Zmc2V0KG1pbnV0ZXNPZmZzZXQpICsgJyknO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JtYXQgYSBkZXB0aC5cbiAgICpcbiAgICogQHBhcmFtIGRlcHRoIHtOdW1iZXJ9XG4gICAqICAgICAgICBkZXB0aCB0byBmb3JtYXRcbiAgICogQHBhcmFtIHVuaXRzIHtTdHJpbmd9XG4gICAqICAgICAgICBPcHRpb25hbC5cbiAgICogICAgICAgIGRlcHRoIHVuaXRzLCBpZiBhbnkuXG4gICAqIEBwYXJhbSBlcnJvciB7TnVtYmVyfVxuICAgKiAgICAgICAgT3B0aW9uYWwuXG4gICAqICAgICAgICBkZXB0aCBlcnJvciwgaWYgYW55LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCBzdHJpbmcuXG4gICAqL1xuICBfdGhpcy5kZXB0aCA9IGZ1bmN0aW9uIChkZXB0aCwgdW5pdHMsIGVycm9yKSB7XG4gICAgaWYgKCFkZXB0aCAmJiBkZXB0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIF9lbXB0eTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzLm51bWJlcihkZXB0aCwgX2RlcHRoRGVjaW1hbHMsIF9lbXB0eSwgdW5pdHMpICtcbiAgICAgICAgX3RoaXMudW5jZXJ0YWludHkoZXJyb3IsIF9kZXB0aERlY2ltYWxzLCAnJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIGRpc3RhbmNlIChsaWtlIGttIG9yIG1pKS5cbiAgICpcbiAgICogQHBhcmFtIGRpc3RhbmNlIHtOdW1iZXJ9XG4gICAqICAgICBUaGUgZGlzdGFuY2UgZm9yIGZvcm1hdC5cbiAgICogQHBhcmFtIHVuaXRzIHtTdHJpbmd9XG4gICAqICAgICBUaGUgdW5pdHMgZm9yIHRoaXMgZGlzdGFuY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgIEEgZm9ybWF0dGVkIGRpc3RhbmNlIHN0cmluZy5cbiAgICovXG4gIF90aGlzLmRpc3RhbmNlID0gZnVuY3Rpb24gKGRpc3RhbmNlLCB1bml0cykge1xuICAgIHJldHVybiBfdGhpcy5udW1iZXIoZGlzdGFuY2UsIF9kaXN0YW5jZURlY2ltYWxzLCBfZW1wdHksIHVuaXRzKTtcbiAgfTtcblxuICAvKipcbiAgICogRm9ybWF0cyBEWUZJIGxvY2F0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7cmVzcG9uc2V9XG4gICAqICAgICAgICBkeWZpIHJlc3BvbnNlXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBmb3JtYXR0ZWQgRFlGSSBsb2NhdGlvblxuICAgKi9cbiAgX3RoaXMuZHlmaUxvY2F0aW9uID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgdmFyIGNvdW50cnksXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICByZWdpb24sXG4gICAgICAgIHppcDtcblxuICAgIGNvdW50cnkgPSByZXNwb25zZS5jb3VudHJ5O1xuICAgIGxvY2F0aW9uID0gcmVzcG9uc2UubmFtZTtcbiAgICByZWdpb24gPSByZXNwb25zZS5zdGF0ZTtcbiAgICB6aXAgPSByZXNwb25zZS56aXA7XG5cbiAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwiZHlmaS1yZXNwb25zZS1sb2NhdGlvblwiPicgKyBsb2NhdGlvbiArICcsICcgK1xuICAgICAgICByZWdpb24gKyAnJm5ic3A7JyArIHppcCArICc8YnIgLz48c21hbGw+JyArIGNvdW50cnkgKyAnPC9zbWFsbD48L3NwYW4+JztcbiAgfTtcblxuICAvKipcbiAgICogRm9ybWF0IGZpbGUgc2l6ZSB1c2luZyBodW1hbiBmcmllbmRseSBzaXplcy5cbiAgICpcbiAgICogQHBhcmFtIGJ5dGVzIHtOdW1iZXJ9XG4gICAqICAgICAgICBieXRlcyB0byBmb3JtYXQuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZm9ybWF0dGVkIHN0cmluZy5cbiAgICovXG4gIF90aGlzLmZpbGVTaXplID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgdmFyIHNpemVJbmRleDtcblxuICAgIGlmICghYnl0ZXMgJiYgYnl0ZXMgIT09IDApIHtcbiAgICAgIHJldHVybiBfZW1wdHk7XG4gICAgfVxuXG4gICAgc2l6ZUluZGV4ID0gMDtcbiAgICBieXRlcyA9IE51bWJlcihieXRlcyk7XG4gICAgd2hpbGUgKGJ5dGVzID49IDEwMjQpIHtcbiAgICAgIGJ5dGVzID0gYnl0ZXMgLyAxMDI0O1xuICAgICAgc2l6ZUluZGV4Kys7XG4gICAgfVxuICAgIGlmIChzaXplSW5kZXggPiAwKSB7XG4gICAgICBieXRlcyA9IGJ5dGVzLnRvRml4ZWQoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVzID0gYnl0ZXMudG9GaXhlZCgwKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzICsgX2ZpbGVTaXplc1tzaXplSW5kZXhdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JtYXQgYW4gaW50ZW5zaXR5IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gaW50ZW5zaXR5IHtOdW1iZXJ9XG4gICAqICAgICBudW1lcmljIGludGVuc2l0eSB2YWx1ZS5cbiAgICogQHBhcmFtIHRleHQge1N0cmluZ31cbiAgICogICAgIGRlZmF1bHQgJycuXG4gICAqICAgICBjb250ZW50IGFkZGVkIGZvbGxvd2luZyB0aGUgZm9ybWF0dGVkIGludGVuc2l0eSB2YWx1ZS5cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiAgICAgZm9ybWF0dGVkIGludGVuc2l0eS5cbiAgICovXG4gIF90aGlzLmludGVuc2l0eSA9IGZ1bmN0aW9uIChpbnRlbnNpdHksIHRleHQpIHtcbiAgICB2YXIgcm9tYW5OdW1lcmFsO1xuXG4gICAgcm9tYW5OdW1lcmFsID0gX3RoaXMubW1pKGludGVuc2l0eSk7XG4gICAgdGV4dCA9IHRleHQgfHwgJyc7XG5cbiAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwibW1pIG1taScgKyByb21hbk51bWVyYWwgKyAnXCI+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cInJvbWFuXCI+PHN0cm9uZz4nICsgcm9tYW5OdW1lcmFsICsgJzwvc3Ryb25nPjwvc3Bhbj4nICtcbiAgICAgICAgdGV4dCArXG4gICAgICAgICc8L3NwYW4+JztcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCBraWxvbWV0ZXJzIHRvIG1pbGVzLlxuICAgKlxuICAgKiBAcGFyYW0ga20ge051bWJlcn1cbiAgICogICAgICAgIGtpbG9tZXRlcnMuXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogICAgICAgICBtaWxlcy5cbiAgICovXG4gIF90aGlzLmttVG9NaSA9IGZ1bmN0aW9uIChrbSkge1xuICAgIGlmICgha20pIHtcbiAgICAgIHJldHVybiBrbTtcbiAgICB9XG4gICAgcmV0dXJuIChrbSAqIF9NSUxFU19QRVJfS0lMT01FVEVSKTtcbiAgfTtcblxuICAvKipcbiAgICogRm9ybWF0IGEgbGF0aXR1ZGVcbiAgICogQHBhcmFtIGxhdGl0dWRlIHtOdW1iZXJ9XG4gICAqICAgICAgICB0aGUgbGF0aXR1ZGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZm9ybWF0dGVkIHN0cmluZy5cbiAgICovXG4gIF90aGlzLmxhdGl0dWRlID0gZnVuY3Rpb24gKGxhdGl0dWRlKSB7XG4gICAgdmFyIGxhdERpcjtcblxuICAgIGlmICghbGF0aXR1ZGUgJiYgbGF0aXR1ZGUgIT09IDApIHtcbiAgICAgIHJldHVybiBfZW1wdHk7XG4gICAgfVxuICAgIGxhdERpciA9IChsYXRpdHVkZSA+PSAwID8gJ04nIDogJ1MnKTtcblxuICAgIC8vIGFscmVhZHkgaGF2ZSBzaWduIGluZm9ybWF0aW9uLCBhYnMgYmVmb3JlIHJvdW5kaW5nXG4gICAgbGF0aXR1ZGUgPSBNYXRoLmFicyhsYXRpdHVkZSk7XG5cbiAgICAvLyByb3VuZCB0byBjb25maWd1cmVkIG51bWJlciBvZiBkZWNpbWFsc1xuICAgIGlmICh0eXBlb2YgX2xvY2F0aW9uRGVjaW1hbHMgPT09ICdudW1iZXInKSB7XG4gICAgICBsYXRpdHVkZSA9IGxhdGl0dWRlLnRvRml4ZWQoX2xvY2F0aW9uRGVjaW1hbHMpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXRpdHVkZSArICcmZGVnOycgKyBsYXREaXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIExlZnQgcGFkcyB0aGUgc291cmNlIHN0cmluZyB3aXRoIHRoZSBwYWQgc3RyaW5nIHVudGlsIHRoZSBzb3VyY2Ugc3RyaW5nXG4gICAqIGlzIGF0IGxlYXN0IGBsZW5ndGhgIGluIGxlbmd0aC4gSWYgdGhlIHNvdXJjZSBsZW5ndGggaXMgYWxyZWFkeSBncmVhdGVyXG4gICAqIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGRlc2lyZWQgbGVuZ3RoLCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlIHtTdHJpbmd9XG4gICAqICAgICBUaGUgc3RyaW5nIHRvIHBhZFxuICAgKiBAcGFyYW0gbGVuZ3RoIHtJbnRlZ2VyfVxuICAgKiAgICAgVGhlIGRlc2lyZWQgbGVuZ3RoXG4gICAqIEBwYXJhbSBwYWQge1N0cmluZ30gT3B0aW9uYWwuIERlZmF1bHQgJyAnIChzaW5nbGUgc3BhY2UpXG4gICAqICAgICBUaGUgcGFkZGluZyB0byBhZGQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgc291cmNlIHN0cmluZyB1bnRpbCB0aGVcbiAgICogICAgIGRlc2lyZWQgbGVuZ3RoIGlzIG1ldC4gU2hvdWxkIGJlIGEgc2luZ2xlIHJlbmRlcmVkIGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiAgICAgQSBzdHJpbmcgcGFkZGVkIG91dCB0byB0aGUgZGVzaXJlZCBsZW5ndGggd2l0aCB0aGUgZ2l2ZW4gcGFkLlxuICAgKi9cbiAgX3RoaXMubGVmdFBhZCA9IGZ1bmN0aW9uIChzb3VyY2UsIGxlbmd0aCwgcGFkKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHBhZExlbmd0aCxcbiAgICAgICAgcGFkZGluZztcblxuICAgIHBhZExlbmd0aCA9IGxlbmd0aCAtIHNvdXJjZS5sZW5ndGg7XG4gICAgcGFkZGluZyA9IFtdO1xuXG4gICAgaWYgKHBhZExlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhZExlbmd0aDsgaSsrKSB7XG4gICAgICBwYWRkaW5nW2ldID0gcGFkO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHBhZGRpbmcuam9pbignJykgKyBzb3VyY2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXG4gICAqXG4gICAqIEBwYXJhbSBsYXRpdHVkZSB7TnVtYmVyfVxuICAgKiAgICAgICAgdGhlIGxhdGl0dWRlLlxuICAgKiBAcGFyYW0gbG9uZ2l0dWRlIHtOdW1iZXJ9XG4gICAqICAgICAgICB0aGUgbG9uZ2l0dWRlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCBzdHJpbmcuXG4gICAqL1xuICBfdGhpcy5sb2NhdGlvbiA9IGZ1bmN0aW9uIChsYXRpdHVkZSwgbG9uZ2l0dWRlKSB7XG4gICAgcmV0dXJuIF90aGlzLmxhdGl0dWRlKGxhdGl0dWRlKSArICcmbmJzcDsnICtcbiAgICAgICAgX3RoaXMubG9uZ2l0dWRlKGxvbmdpdHVkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIGxvbmdpdHVkZVxuICAgKiBAcGFyYW0gbG9uZ2l0dWRlIHtOdW1iZXJ9XG4gICAqICAgICAgICB0aGUgbG9uZ2l0dWRlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCBzdHJpbmcuXG4gICAqL1xuICBfdGhpcy5sb25naXR1ZGUgPSBmdW5jdGlvbiAobG9uZ2l0dWRlKSB7XG4gICAgdmFyIGxvbkRpcjtcblxuICAgIGlmICghbG9uZ2l0dWRlICYmIGxvbmdpdHVkZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIF9lbXB0eTtcbiAgICB9XG4gICAgbG9uRGlyID0gKGxvbmdpdHVkZSA+PSAwID8gJ0UnIDogJ1cnKTtcblxuICAgIC8vIGFscmVhZHkgaGF2ZSBzaWduIGluZm9ybWF0aW9uLCBhYnMgYmVmb3JlIHJvdW5kaW5nXG4gICAgbG9uZ2l0dWRlID0gTWF0aC5hYnMobG9uZ2l0dWRlKTtcblxuICAgIC8vIHJvdW5kIHRvIGNvbmZpZ3VyZWQgbnVtYmVyIG9mIGRlY2ltYWxzXG4gICAgaWYgKHR5cGVvZiBfbG9jYXRpb25EZWNpbWFscyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGxvbmdpdHVkZSA9IGxvbmdpdHVkZS50b0ZpeGVkKF9sb2NhdGlvbkRlY2ltYWxzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9uZ2l0dWRlICsgJyZkZWc7JyArIGxvbkRpcjtcbiAgfTtcblxuICAvKipcbiAgICogRm9ybWF0IGEgbWFnbml0dWRlLlxuICAgKlxuICAgKiBAcGFyYW0gbWFnbml0dWRlIHtOdW1iZXJ9XG4gICAqICAgICAgICBtYWduaXR1ZGUgdG8gZm9ybWF0LlxuICAgKiBAcGFyYW0gdHlwZSB7U3RyaW5nfVxuICAgKiAgICAgICAgT3B0aW9uYWwuXG4gICAqICAgICAgICBtYWduaXR1ZGUgdHlwZS5cbiAgICogQHBhcmFtIGVycm9yIHtOdW1iZXJ9XG4gICAqICAgICAgICBPcHRpb25hbC5cbiAgICogICAgICAgIG1hZ25pdHVkZSBlcnJvci5cbiAgICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgKi9cbiAgX3RoaXMubWFnbml0dWRlID0gZnVuY3Rpb24gKG1hZ25pdHVkZSwgdHlwZSwgZXJyb3IpIHtcbiAgICByZXR1cm4gX3RoaXMubnVtYmVyKG1hZ25pdHVkZSwgX21hZ25pdHVkZURlY2ltYWxzLCBfZW1wdHksIHR5cGUpICtcbiAgICAgICAgX3RoaXMudW5jZXJ0YWludHkoZXJyb3IsIF9tYWduaXR1ZGVEZWNpbWFscywgJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgbW1pIHRvIGEgcm9tYW4gbnVtZXJhbFxuICAgKlxuICAgKiBAcGFyYW1zIG1taSB7bnVtYmVyfVxuICAgKiAgICAgICAgIE1vZGlmaWVkIE1lcmNhbCBJbnRlbnNpdHlcbiAgICogQHBhcmFtcyBlbXB0eSB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBzdHJpbmcgdG8gcmV0dXJuIGlmIG1taSBpcyBvdXQgb2YgcmFuZ2VcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogICAgICAgICAgVGhlIFJvbWFuIE51bWVyYWwgY29vcmVzcG9uZGluZyB0byB0aGUgbW1pLlxuICAgKi9cbiAgX3RoaXMubW1pID0gZnVuY3Rpb24gKG1taSwgZW1wdHkpIHtcbiAgICBtbWkgPSBNYXRoLnJvdW5kKG1taSk7XG5cbiAgICByZXR1cm4gX01NSV9BUlJBWVttbWldIHx8IGVtcHR5IHx8IF9lbXB0eTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb2xvciBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBNTUlcbiAgICpcbiAgICogQHBhcmFtcyBtbWkge251bWJlcn1cbiAgICogICAgTW9kaWZpZWQgTWVyY2FsIEludGVuc2l0eS5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICBDb2xvciBDb2RlLlxuICAgKi9cbiAgX3RoaXMubW1pQ29sb3IgPSBmdW5jdGlvbiAobW1pKSB7XG4gICAgbW1pID0gTWF0aC5yb3VuZChtbWkpO1xuICAgIHJldHVybiBfTU1JX0NPTE9SU1ttbWldIHx8IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIG51bWJlci5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIHtOdW1iZXJ9XG4gICAqICAgICAgICBudW1iZXIgdG8gZm9ybWF0LlxuICAgKiBAcGFyYW0gZGVjaW1hbHMge051bWJlcn1cbiAgICogICAgICAgIE9wdGlvbmFsLCBkZWZhdWx0IGRvZXMgbm90IHJvdW5kLlxuICAgKiAgICAgICAgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHJvdW5kLlxuICAgKiBAcGFyYW0gZW1wdHkge0FueX1cbiAgICogICAgICAgIE9wdGlvbmFsLCBkZWZhdWx0IG5vbmUuXG4gICAqICAgICAgICB2YWx1ZSB0byByZXR1cm4gaWYgdmFsdWUgaXMgZW1wdHkuXG4gICAqIEBwYXJhbSB1bml0cyB7U3RyaW5nfVxuICAgKiAgICAgICAgT3B0aW9uYWwsIGRlZmF1bHQgbm9uZS5cbiAgICogICAgICAgIHVuaXRzIG9mIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCBzdHJpbmcuXG4gICAqL1xuICBfdGhpcy5udW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxzLCBlbXB0eSwgdW5pdHMpIHtcbiAgICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG4gICAgICByZXR1cm4gZW1wdHkgfHwgX2VtcHR5O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlY2ltYWxzID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpLnRvRml4ZWQoZGVjaW1hbHMpO1xuICAgIH1cbiAgICBpZiAodW5pdHMpIHtcbiAgICAgIHZhbHVlICs9ICcgJyArIHVuaXRzO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1dCBjb21tYXMgaW50byBhIG51bWJlciBmb3IgZGlzcGxheS5cbiAgICpcbiAgICogQHBhcmFtIHgge051bWJlcn1cbiAgICogICAgICAgIG51bWJlciB0byBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSBlbXB0eSB7QW55fVxuICAgKiAgICAgICAgT3B0aW9uYWwsIGRlZmF1bHQgbm9uZS5cbiAgICogICAgICAgIHZhbHVlIHRvIHJldHVybiBpZiB2YWx1ZSBpcyBlbXB0eS5cbiAgICovXG4gIF90aGlzLm51bWJlcldpdGhDb21tYXMgPSBmdW5jdGlvbiAoeCwgZW1wdHkpIHtcbiAgICBpZiAoIXggJiYgeCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGVtcHR5IHx8IF9lbXB0eTtcbiAgICB9XG5cbiAgICB2YXIgcGFydHMgPSB4LnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcblxuICAgIHBhcnRzWzBdID0gcGFydHNbMF0ucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgJywnKTtcblxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIFVUQyB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZSB7RGF0ZX1cbiAgICogICAgICAgIGRhdGUgdG8gZm9ybWF0LlxuICAgKiBAcGFyYW0gaW5jbHVkZU1pbGxpc2Vjb25kcyB7Qm9vbGVhbn1cbiAgICogICAgICAgIGRlZmF1bHQgZmFsc2UuXG4gICAqICAgICAgICB3aGV0aGVyIHRvIG91dHB1dCBtaWxsaXNlY29uZHMuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgICAgICBmb3JtYXR0ZWQgdGltZS5cbiAgICovXG4gIF90aGlzLnRpbWUgPSBmdW5jdGlvbiAoZGF0ZSwgaW5jbHVkZU1pbGxpc2Vjb25kcykge1xuICAgIHZhciBob3VycyxcbiAgICAgICAgbWludXRlcyxcbiAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgbWlsbGlzZWNvbmRzO1xuXG4gICAgaWYgKCFkYXRlIHx8IHR5cGVvZiBkYXRlLmdldFRpbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBfZW1wdHk7XG4gICAgfVxuXG4gICAgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgbWludXRlcyA9IGRhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgIHNlY29uZHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKTtcbiAgICBtaWxsaXNlY29uZHMgPSAnJztcblxuICAgIGlmIChob3VycyA8IDEwKSB7XG4gICAgICBob3VycyA9ICcwJyArIGhvdXJzO1xuICAgIH1cbiAgICBpZiAobWludXRlcyA8IDEwKSB7XG4gICAgICBtaW51dGVzID0gJzAnICsgbWludXRlcztcbiAgICB9XG4gICAgaWYgKHNlY29uZHMgPCAxMCkge1xuICAgICAgc2Vjb25kcyA9ICcwJyArIHNlY29uZHM7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlTWlsbGlzZWNvbmRzKSB7XG4gICAgICBtaWxsaXNlY29uZHMgPSBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgaWYgKG1pbGxpc2Vjb25kcyA8IDEwKSB7XG4gICAgICAgIG1pbGxpc2Vjb25kcyA9ICcuMDAnICsgbWlsbGlzZWNvbmRzO1xuICAgICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZHMgPCAxMDApIHtcbiAgICAgICAgbWlsbGlzZWNvbmRzID0gJy4wJyArIG1pbGxpc2Vjb25kcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbGxpc2Vjb25kcyA9ICcuJyArIG1pbGxpc2Vjb25kcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG91cnMgKyAnOicgKyBtaW51dGVzICsgJzonICsgc2Vjb25kcyArIG1pbGxpc2Vjb25kcztcbiAgfTtcblxuICAvKipcbiAgICogRm9ybWF0IGEgVVRDIHRpbWV6b25lIG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIG9mZnNldCB7TnVtYmVyfVxuICAgKiAgICAgICAgVVRDIG9mZnNldCBpbiBtaW51dGVzLiAgMCBmb3IgVVRDLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICAgICAgZm9ybWF0dGVkIHRpbWV6b25lIG9mZnNldCwgb3IgJycgd2hlbiBvZmZzZXQgaXMgMC5cbiAgICovXG4gIF90aGlzLnRpbWV6b25lT2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgIHZhciBob3VycyxcbiAgICAgICAgbWludXRlcyxcbiAgICAgICAgc2lnbjtcblxuICAgIGlmICghb2Zmc2V0IHx8IG9mZnNldCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgc2lnbiA9ICctJztcbiAgICAgIG9mZnNldCAqPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbiA9ICcrJztcbiAgICB9XG5cbiAgICBob3VycyA9IHBhcnNlSW50KG9mZnNldCAvIDYwLCAxMCk7XG4gICAgbWludXRlcyA9IHBhcnNlSW50KG9mZnNldCAlIDYwLCAxMCk7XG5cbiAgICBpZiAoaG91cnMgPCAxMCkge1xuICAgICAgaG91cnMgPSAnMCcgKyBob3VycztcbiAgICB9XG4gICAgaWYgKG1pbnV0ZXMgPCAxMCkge1xuICAgICAgbWludXRlcyA9ICcwJyArIG1pbnV0ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZ24gKyBob3VycyArICc6JyArIG1pbnV0ZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhbiB1bmNlcnRhaW50eS5cbiAgICpcbiAgICogQHBhcmFtIGVycm9yIHtOdW1iZXJ9XG4gICAqICAgICAgICB1bmNlcnRhaW50eSB0byBmb3JtYXQuXG4gICAqIEBwYXJhbSBkZWNpbWFscyB7TnVtYmVyfVxuICAgKiAgICAgICAgT3B0aW9uYWwsIGRlZmF1bHQgZG9lcyBub3Qgcm91bmQuXG4gICAqICAgICAgICBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQuXG4gICAqIEBwYXJhbSBlbXB0eSB7QW55fVxuICAgKiAgICAgICAgT3B0aW9uYWwsIGRlZmF1bHQgbm9uZS5cbiAgICogICAgICAgIHZhbHVlIHRvIHJldHVybiBpZiBlcnJvciBpcyBlbXB0eS5cbiAgICogQHBhcmFtIHVuaXRzIHtTdHJpbmd9XG4gICAqICAgICAgICBPcHRpb25hbCwgZGVmYXVsdCBub25lLlxuICAgKiAgICAgICAgdW5pdHMgb2YgZXJyb3IuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZm9ybWF0dGVkIHN0cmluZy5cbiAgICovXG4gIF90aGlzLnVuY2VydGFpbnR5ID0gZnVuY3Rpb24gKGVycm9yLCBkZWNpbWFscywgZW1wdHksIHVuaXRzKSB7XG4gICAgaWYgKCFlcnJvciAmJiBlcnJvciAhPT0gMCkge1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cbiAgICBlcnJvciA9IF90aGlzLm51bWJlcihlcnJvciwgZGVjaW1hbHMsIG51bGwsIHVuaXRzKTtcbiAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwidW5jZXJ0YWludHlcIj4mcGx1c21uOyAnICsgZXJyb3IgKyAnPC9zcGFuPic7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuRm9ybWF0dGVyLk1JTEVTX1BFUl9LSUxPTUVURVIgPSBfTUlMRVNfUEVSX0tJTE9NRVRFUjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1hdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb2R1Y3RWaWV3ID0gcmVxdWlyZSgnY29yZS9Qcm9kdWN0VmlldycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG4vKipcbiAqIFZpZXcgdG8gZGlzcGxheSBhIGxpbmsgcHJvZHVjdC5cbiAqXG4gKiBVc2VzIHByb2R1Y3QgcHJvcGVydGllcyBgdGV4dGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gKiAgICAgcGFzc2VkIHRvIFByb2R1Y3RWaWV3LlxuICovXG52YXIgTGlua1Byb2R1Y3RWaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzO1xuXG4gIF90aGlzID0gUHJvZHVjdFZpZXcob3B0aW9ucyk7XG5cblxuICAvKipcbiAgICogUmVuZGVyIGxpbmsgaW50byB0aGlzIHZpZXcncyBlbGVtZW50LlxuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCxcbiAgICAgICAgcHJvZHVjdCxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgdXJsO1xuXG4gICAgcHJvZHVjdCA9IF90aGlzLm1vZGVsO1xuICAgIHRleHQgPSBwcm9kdWN0LmdldFByb3BlcnR5KCd0ZXh0Jyk7XG4gICAgdXJsID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgndXJsJyk7XG5cbiAgICBpZiAodXJsKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIH1cbiAgICBlbC5jbGFzc0xpc3QuYWRkKHByb2R1Y3QuZ2V0KCd0eXBlJykpO1xuXG4gICAgaWYgKHRleHQpIHtcbiAgICAgIGVsLmlubmVySFRNTCA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmlubmVySFRNTCA9ICdObyBsaW5rIHRleHQgYXZhaWxhYmxlJztcbiAgICB9XG5cbiAgICBVdGlsLmVtcHR5KF90aGlzLmVsKTtcbiAgICBfdGhpcy5lbC5hcHBlbmRDaGlsZChlbCk7XG4gIH07XG5cblxuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTGlua1Byb2R1Y3RWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWNjb3JkaW9uVmlldyA9IHJlcXVpcmUoJ2NvcmUvQWNjb3JkaW9uVmlldycpLFxuICAgIEF0dHJpYnV0aW9uID0gcmVxdWlyZSgnY29yZS9BdHRyaWJ1dGlvbicpLFxuICAgIERvd25sb2FkVmlldyA9IHJlcXVpcmUoJ2NvcmUvRG93bmxvYWRWaWV3JyksXG4gICAgRm9ybWF0dGVyID0gcmVxdWlyZSgnY29yZS9Gb3JtYXR0ZXInKSxcbiAgICBQcm9kdWN0ID0gcmVxdWlyZSgncGRsL1Byb2R1Y3QnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyksXG4gICAgVmlldyA9IHJlcXVpcmUoJ212Yy9WaWV3Jyk7XG5cbnZhciBfSUQsXG4gICAgX1RJVExFLFxuICAgIF9UWVBFUyxcblxuICAgIF9oYXNDb250ZW50O1xuXG5cbi8vIE5vdGU6IFRoZXNlIHNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IGVhY2ggaW1wbGVtZW50aW5nIHN1Yi1jbGFzcy5cbl9JRCA9ICdtb2R1bGUnO1xuX1RJVExFID0gJ0RlZmF1bHQgTW9kdWxlJztcbl9UWVBFUyA9IFtdO1xuXG5faGFzQ29udGVudCA9IGZ1bmN0aW9uICgvKmV2ZW50UGFnZU1vZGVsKi8pIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgX0RFRkFVTFRTID0ge1xuXG59O1xuXG5cbnZhciBNb2R1bGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2FjY29yZGlvblZpZXcsXG4gICAgICBfZm9ybWF0dGVyO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBlbDtcblxuICAgIF90aGlzLklEID0gX0lEO1xuICAgIF90aGlzLlRJVExFID0gX1RJVExFO1xuICAgIF9mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBGb3JtYXR0ZXIoKTtcblxuICAgIGVsID0gX3RoaXMuZWw7XG4gICAgZWwuaW5uZXJIVE1MID1cbiAgICAgICc8ZGl2IGNsYXNzPVwibW9kdWxlLWhlYWRlclwiPjwvZGl2PicgK1xuICAgICAgJzxkaXYgY2xhc3M9XCJtb2R1bGUtY29udGVudFwiPjwvZGl2PicgK1xuICAgICAgJzxkaXYgY2xhc3M9XCJtb2R1bGUtZm9vdGVyXCI+PC9kaXY+JztcblxuICAgIC8vIHJlZmVyZW5jZXMgdG8gc2VjdGlvbnMgZm9yIHN1YmNsYXNzIGFjY2Vzc1xuICAgIF90aGlzLmhlYWRlciA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5tb2R1bGUtaGVhZGVyJyk7XG4gICAgX3RoaXMuY29udGVudCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5tb2R1bGUtY29udGVudCcpO1xuICAgIF90aGlzLmZvb3RlciA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5tb2R1bGUtZm9vdGVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZyZWUgcmVmZXJlbmNlcy5cbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfYWNjb3JkaW9uVmlldykge1xuICAgICAgLy8gY2xlYW4gdXAgYW55IHByZXZpb3VzIGZvb3RlclxuICAgICAgX2FjY29yZGlvblZpZXcuZGVzdHJveSgpO1xuICAgICAgX2FjY29yZGlvblZpZXcgPSBudWxsO1xuICAgIH1cblxuICAgIF9mb3JtYXR0ZXIgPSBudWxsO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIEdldCBhIHByb2R1Y3QgZnJvbSB0aGUgZXZlbnQgYmFzZWQgb24gbW9kdWxlIHBhcmFtZXRlcnMgYW5kIGV2ZW50IGNvbmZpZy5cbiAgICpcbiAgICogVXNlcyBtb2R1bGUgcGFyYW1ldGVycyBcInNvdXJjZVwiLCBcImNvZGVcIiwgYW5kIG9wdGlvbmFsbHkgXCJ1cGRhdGVUaW1lXCIuXG4gICAqIElmIFwidXBkYXRlVGltZVwiIGlzIG9taXR0ZWQsIHRoZSBsYXRlc3QgdmVyc2lvbiBmcm9tIFwic291cmNlXCIgYW5kIFwiY29kZVwiIGlzXG4gICAqIHJldHVybmVkLiAgSWYgbm8gcHJvZHVjdCBtYXRjaGluZyBcInNvdXJjZVwiIGFuZCBcImNvZGVcIiBpcyBmb3VuZCwgcmV0dXJuc1xuICAgKiBwcmVmZXJyZWQgcHJvZHVjdC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUge1N0cmluZ31cbiAgICogICAgIHByb2R1Y3QgYmFzZSB0eXBlLlxuICAgKiAgICAgZXZlbnQgY29uZmlndXJhdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGFkZCBhIHNjZW5hcmlvIHN1ZmZpeC5cbiAgICogQHJldHVybiB7UHJvZHVjdH1cbiAgICogICAgIG1hdGNoaW5nIHByb2R1Y3QsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgX3RoaXMuZ2V0UHJvZHVjdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGNvZGUsXG4gICAgICAgIGV2LFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHByb2R1Y3QsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdXBkYXRlVGltZTtcblxuICAgIGV2ID0gX3RoaXMubW9kZWwuZ2V0KCdldmVudCcpO1xuICAgIHBhcmFtcyA9IF90aGlzLm1vZGVsLmdldChfdGhpcy5JRCkgfHwge307XG4gICAgdHlwZSA9IFByb2R1Y3QuZ2V0RnVsbFR5cGUodHlwZSwgX3RoaXMubW9kZWwuZ2V0KCdjb25maWcnKSk7XG4gICAgc291cmNlID0gcGFyYW1zLnNvdXJjZSB8fCBudWxsO1xuICAgIGNvZGUgPSBwYXJhbXMuY29kZSB8fCBudWxsO1xuICAgIHVwZGF0ZVRpbWUgPSBwYXJhbXMudXBkYXRlVGltZSB8fCBudWxsO1xuICAgIHByb2R1Y3QgPSBudWxsO1xuXG4gICAgaWYgKGV2ICYmIHNvdXJjZSAhPT0gbnVsbCAmJiBjb2RlICE9PSBudWxsKSB7XG4gICAgICBwcm9kdWN0ID0gZXYuZ2V0UHJvZHVjdEJ5SWQodHlwZSwgc291cmNlLCBjb2RlLCB1cGRhdGVUaW1lKTtcbiAgICB9XG4gICAgaWYgKGV2ICYmIHByb2R1Y3QgPT09IG51bGwpIHtcbiAgICAgIHByb2R1Y3QgPSBldi5nZXRQcmVmZXJyZWRQcm9kdWN0KHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZHVjdDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFsbCBwcm9kdWN0cyBvZiBhIHNwZWNpZmljIHR5cGUuIElmIHRoZSBjb25maWcuU0NFTkFSSU9fTU9ERSwgdGhlblxuICAgKiBnZXQgdGhlIC1zY2VuYXJpbyB2YXJpYW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUge1N0cmluZ31cbiAgICogICAgIFRoZSBiYXNlIHR5cGUgb2YgcHJvZHVjdHMgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgIEFuIGFycmF5IG9mIHRoZSBtYXRjaGluZyB0eXBlIG9mIHByb2R1Y3QuIFRoaXMgbWlnaHQgYmUgYW4gZW1wdHkgYXJyYXkuXG4gICAqL1xuICBfdGhpcy5nZXRQcm9kdWN0cyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGNhdGFsb2dFdmVudDtcblxuICAgIGNhdGFsb2dFdmVudCA9IF90aGlzLm1vZGVsLmdldCgnZXZlbnQnKTtcbiAgICB0eXBlID0gUHJvZHVjdC5nZXRGdWxsVHlwZSh0eXBlLCBfdGhpcy5tb2RlbC5nZXQoJ2NvbmZpZycpKTtcblxuICAgIGlmIChjYXRhbG9nRXZlbnQpIHtcbiAgICAgIHJldHVybiBjYXRhbG9nRXZlbnQuZ2V0UHJvZHVjdHModHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHByb2R1Y3QgZm9vdGVyLiBHZW5lcmFsaXplZCBmb290ZXIgaW5jbHVkZXMgb25seSB0aGUgRG93bmxvYWRzLlxuICAgKlxuICAgKi9cbiAgX3RoaXMuZ2V0UHJvZHVjdEZvb3RlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRlbnQsXG4gICAgICAgIGVsO1xuXG4gICAgaWYgKF9hY2NvcmRpb25WaWV3KSB7XG4gICAgICAvLyBjbGVhbiB1cCBhbnkgcHJldmlvdXMgZm9vdGVyXG4gICAgICBfYWNjb3JkaW9uVmlldy5kZXN0cm95KCk7XG4gICAgICBfYWNjb3JkaW9uVmlldyA9IG51bGw7XG4gICAgfVxuXG4gICAgY29udGVudCA9IG9wdGlvbnMucHJvZHVjdC5nZXRDb250ZW50KCdjb250ZW50cy54bWwnKTtcbiAgICBpZiAoY29udGVudCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgX3RoaXMuZG93bmxvYWRWaWV3ID0gRG93bmxvYWRWaWV3KHtcbiAgICAgICAgbW9kZWw6IGNvbnRlbnQsXG4gICAgICAgIHByb2R1Y3Q6IG9wdGlvbnMucHJvZHVjdCxcbiAgICAgICAgZm9ybWF0dGVyOiBfZm9ybWF0dGVyXG4gICAgICB9KTtcblxuICAgICAgX2FjY29yZGlvblZpZXcgPSBBY2NvcmRpb25WaWV3KHtcbiAgICAgICAgY2xhc3NlczogJ2FjY29yZGlvbi1zdGFuZGFyZCBhY2NvcmRpb24tcGFnZS1kb3dubG9hZHMnLFxuICAgICAgICBlbDogZWwsXG4gICAgICAgIHRvZ2dsZUVsZW1lbnQ6ICdoMycsXG4gICAgICAgIHRvZ2dsZVRleHQ6ICdEb3dubG9hZHMnLFxuICAgICAgICB2aWV3OiBfdGhpcy5kb3dubG9hZFZpZXdcbiAgICAgIH0pO1xuICAgICAgX2FjY29yZGlvblZpZXcucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBwcm9kdWN0IGhlYWRlci5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogQHBhcmFtIG9wdGlvbnMucHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIHByb2R1Y3QgdG8gc3VtbWFyaXplLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zdW1tYXJ5TW9kdWxlIHtNb2R1bGV9XG4gICAqICAgICBkZWZhdWx0IG51bGwuXG4gICAqICAgICBpbmNsdWRlIGxpbmsgdG8gbW9kdWxlIHdpdGggYWxsIHZlcnNpb25zIG9mIGBwcm9kdWN0YC5cbiAgICovXG4gIF90aGlzLmdldFByb2R1Y3RIZWFkZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBidWYsXG4gICAgICAgIGVsLFxuICAgICAgICBldixcbiAgICAgICAgbnVtUHJvZHVjdHMsXG4gICAgICAgIHByZWZlcnJlZCxcbiAgICAgICAgcHJvZHVjdCxcbiAgICAgICAgcmV2aWV3ZWQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHN1bW1hcnlNb2R1bGU7XG5cbiAgICBwcm9kdWN0ID0gb3B0aW9ucy5wcm9kdWN0O1xuICAgIHN1bW1hcnlNb2R1bGUgPSBvcHRpb25zLnN1bW1hcnlNb2R1bGU7XG5cbiAgICBidWYgPSBbXTtcbiAgICBldiA9IF90aGlzLm1vZGVsLmdldCgnZXZlbnQnKTtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlIHx8IHByb2R1Y3QuZ2V0KCd0eXBlJyk7XG4gICAgLy8gY2FuJ3QgdXNlIHZhciB0eXBlIGJlY2F1c2UgaXQgYnJlYWtzIHRoZSBwcmVmZXJlZCBzZXR0aW5nIHdoZW4gaXQgdXNlc1xuICAgIC8vIG9wdGlvbnMudHlwZVxuICAgIHByZWZlcnJlZCA9IChldi5nZXRQcmVmZXJyZWRQcm9kdWN0KHByb2R1Y3QuZ2V0KCd0eXBlJykpID09PSBwcm9kdWN0KTtcbiAgICByZXZpZXdlZCA9IHByb2R1Y3QuaXNSZXZpZXdlZCgpO1xuXG4gICAgaWYgKHN1bW1hcnlNb2R1bGUpIHtcbiAgICAgIG51bVByb2R1Y3RzID0gZXYuZ2V0UHJvZHVjdHModHlwZSkubGVuZ3RoO1xuICAgICAgYnVmLnB1c2goJzxhIGNsYXNzPVwiYmFjay10by1zdW1tYXJ5LWxpbmtcIicgK1xuICAgICAgICAgICcgaHJlZj1cIiMnICArIHN1bW1hcnlNb2R1bGUuSUQgKyAnXCI+Jyk7XG4gICAgICBpZiAobnVtUHJvZHVjdHMgPiAxKSB7XG4gICAgICAgIGJ1Zi5wdXNoKCdWaWV3IGFsdGVybmF0aXZlICcgKyBfdGhpcy5USVRMRS50b0xvd2VyQ2FzZSgpICsgJ3MnICtcbiAgICAgICAgICAgICcgKCcgKyBudW1Qcm9kdWN0cyArICcgdG90YWwpJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYucHVzaCgnQmFjayB0byAnICsgc3VtbWFyeU1vZHVsZS5USVRMRSk7XG4gICAgICB9XG4gICAgICBidWYucHVzaCgnPC9hPicpO1xuICAgIH1cblxuICAgIGJ1Zi5wdXNoKCc8c21hbGwgY2xhc3M9XCJhdHRyaWJ1dGlvblwiPicgK1xuICAgICAgICAnQ29udHJpYnV0ZWQgYnkgJyArIEF0dHJpYnV0aW9uLmdldFByb2R1Y3RBdHRyaWJ1dGlvbihwcm9kdWN0KSArXG4gICAgICAgICcgbGFzdCB1cGRhdGVkICcgKyBfZm9ybWF0dGVyLmRhdGV0aW1lKHByb2R1Y3QuZ2V0KCd1cGRhdGVUaW1lJykpICtcbiAgICAgICAgJzwvc21hbGw+Jyk7XG5cbiAgICBidWYucHVzaCgnPHVsIGNsYXNzPVwicXVhbGl0eS1zdGF0ZW1lbnRzIG5vLXN0eWxlXCI+Jyk7XG4gICAgaWYgKHByZWZlcnJlZCkge1xuICAgICAgYnVmLnB1c2goJzxsaSBjbGFzcz1cInByZWZlcnJlZFwiPicgK1xuICAgICAgICAgICdUaGUgZGF0YSBiZWxvdyBhcmUgdGhlIG1vc3QgcHJlZmVycmVkIGRhdGEgYXZhaWxhYmxlJyArXG4gICAgICAgICAgJzwvbGk+Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5wdXNoKCc8bGkgY2xhc3M9XCJ1bnByZWZlcnJlZFwiPicgK1xuICAgICAgICAgICdUaGUgZGF0YSBiZWxvdyBhcmUgPHN0cm9uZz5OT1Q8L3N0cm9uZz4nICtcbiAgICAgICAgICAnIHRoZSBtb3N0IHByZWZlcnJlZCBkYXRhIGF2YWlsYWJsZScgK1xuICAgICAgICAgICc8L2xpPicpO1xuICAgIH1cbiAgICBpZiAocmV2aWV3ZWQgPT09IHRydWUpIHtcbiAgICAgIGJ1Zi5wdXNoKCc8bGkgY2xhc3M9XCJyZXZpZXdlZFwiPicgK1xuICAgICAgICAgICdUaGUgZGF0YSBiZWxvdyBoYXZlIGJlZW4gcmV2aWV3ZWQgYnkgYSBzY2llbnRpc3QnICtcbiAgICAgICAgICAnPC9saT4nKTtcbiAgICB9IGVsc2UgaWYgKHJldmlld2VkID09PSBmYWxzZSkge1xuICAgICAgLy8gb25seSBjbGFpbSBwcm9kdWN0IGlzIHVucmV2aWV3ZWQgaWYgcmV2aWV3LXN0YXR1cyBwcm9wZXJ0eSB3YXMgc2V0LlxuICAgICAgYnVmLnB1c2goJzxsaSBjbGFzcz1cInVucmV2aWV3ZWRcIj4nICtcbiAgICAgICAgICAnVGhlIGRhdGEgYmVsb3cgaGF2ZSA8c3Ryb25nPk5PVDwvc3Ryb25nPicgK1xuICAgICAgICAgICcgYmVlbiByZXZpZXdlZCBieSBhIHNjaWVudGlzdC4nICtcbiAgICAgICAgICAnPC9saT4nKTtcbiAgICB9XG4gICAgYnVmLnB1c2goJzwvdWw+Jyk7XG5cbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3Byb2R1Y3QtaGVhZGVyJyk7XG4gICAgZWwuaW5uZXJIVE1MID0gYnVmLmpvaW4oJycpO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIG1vZHVsZSBjb250ZW50LlxuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmhlYWRlci5pbm5lckhUTUwgPSAnPGgzPk1vZHVsZSBIZWFkZXI8L2gzPic7XG4gICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPSAnPGgzPk1vZHVsZSBDb250ZW50PC9oMz4nO1xuICAgIF90aGlzLmZvb3Rlci5pbm5lckhUTUwgPSAnPGgzPk1vZHVsZSBGb290ZXI8L2gzPic7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuTW9kdWxlLklEID0gX0lEO1xuTW9kdWxlLlRJVExFID0gX1RJVExFO1xuTW9kdWxlLlRZUEVTID0gX1RZUEVTO1xuXG5Nb2R1bGUuaGFzQ29udGVudCA9IF9oYXNDb250ZW50O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcbiAgbWFwVXJsOiAnL2VhcnRocXVha2VzL21hcC8nLFxuICByYWRpdXM6IDI1MFxufTtcblxudmFyIF9LTV9QRVJfREVHUkVFID0gMTExLjEyO1xuXG5cbnZhciBOZWFyYnlTZWlzbWljaXR5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9tYXBVcmwsXG4gICAgICBfcmFkaXVzO1xuXG5cbiAgX3RoaXMgPSB7fTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuXG4gICAgX21hcFVybCA9IG9wdGlvbnMubWFwVXJsO1xuICAgIF9yYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgfTtcblxuXG4gIF90aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgX21hcFVybCA9IG51bGw7XG4gICAgX3JhZGl1cyA9IG51bGw7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIGxpbmsgdG8gbWFwL2xpc3QgYmFzZWQgb24gc2VhcmNoIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqIEBwYXJhbSBvcHRpb25zLmV2ZW50aWQge1N0cmluZ31cbiAgICogICAgIGV2ZW50IHRvIHNlbGVjdCBpbiBtYXAvbGlzdCBpbnRlcmZhY2UuXG4gICAqICAgICBkZWZhdWx0IG51bGwuXG4gICAqIEBwYXJhbSBvcHRpb25zLnBhcmFtcyB7T2JqZWN0fVxuICAgKiAgICAgYXBpIHBhcmFtZXRlcnMgYXMgb2JqZWN0IHByb3BlcnRpZXMgYW5kIHZhbHVlcy5cbiAgICovXG4gIF90aGlzLmdldExhdGVzdEVhcnRocXVha2VzTGluayA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGV2ZW50aWQsXG4gICAgICAgIGlkLFxuICAgICAgICBtYXBQb3NpdGlvbixcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBzZXR0aW5ncyxcbiAgICAgICAgdXJsO1xuXG4gICAgZXZlbnRpZCA9IG9wdGlvbnMuZXZlbnRpZCB8fCBudWxsO1xuICAgIHBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuXG4gICAgaWQgPSBldmVudGlkIHx8ICgnJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICBtYXBQb3NpdGlvbiA9IF90aGlzLmdldE1hcFBvc2l0aW9uKHBhcmFtcyk7XG5cbiAgICAvLyBtYXAvbGlzdCB1cmwgc2V0dGluZ3NcbiAgICBzZXR0aW5ncyA9IHtcbiAgICAgIC8vIGRvIG5vdCBhdXRvIHVwZGF0ZSBzZWFyY2hlc1xuICAgICAgYXV0b1VwZGF0ZTogZmFsc2UsXG4gICAgICAvLyB0ZXJyYWluIGJhc2VtYXBcbiAgICAgIGJhc2VtYXA6ICd0ZXJyYWluJyxcbiAgICAgIC8vIHNlbGVjdGVkIGV2ZW50XG4gICAgICBldmVudDogZXZlbnRpZCxcbiAgICAgIC8vIGZlZWQgbmVlZHMgdG8gbWF0Y2ggc2VhcmNoIGlkXG4gICAgICBmZWVkOiBpZCxcbiAgICAgIC8vIGNlbnRlciB2aWV3IGJhc2VkIG9uIHBvaW50IGFuZCByYWRpdXNcbiAgICAgIG1hcHBvc2l0aW9uOiBtYXBQb3NpdGlvbixcbiAgICAgIC8vIHNlYXJjaCBvcHRpb25zXG4gICAgICBzZWFyY2g6IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBpc1NlYXJjaDogdHJ1ZSxcbiAgICAgICAgLy8gVE9ETzogdXNlIGEgZGlmZmVyZW50IG5hbWU/XG4gICAgICAgIG5hbWU6ICdTZWFyY2ggUmVzdWx0cycsXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICB9XG4gICAgfTtcblxuICAgIHVybCA9IF9tYXBVcmwgKyAnIycgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcblxuICAgIHJldHVybiB1cmw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgbWFwIHBvc2l0aW9uIGJhc2VkIG9uIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMge09iamVjdH1cbiAgICogICAgIHNlYXJjaCBhcGkgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7QXJyYXk8QXJyYXk+fVxuICAgKiAgICAgYXJyYXkgcmVwcmVzZW50aW5nIG1hcCBleHRlbnQuXG4gICAqL1xuICBfdGhpcy5nZXRNYXBQb3NpdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgbGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZSxcbiAgICAgICAgbWFwUG9zaXRpb24sXG4gICAgICAgIG1heExhdGl0dWRlLFxuICAgICAgICBtYXhMb25naXR1ZGUsXG4gICAgICAgIG1heFJhZGl1c0ttLFxuICAgICAgICBtaW5MYXRpdHVkZSxcbiAgICAgICAgbWluTG9uZ2l0dWRlLFxuICAgICAgICByYWRpdXNEZWdyZWVzO1xuXG4gICAgLy8gc2V0IGRlZmF1bHRzXG4gICAgbWF4TGF0aXR1ZGUgPSBwYXJhbXMubWF4bGF0aXR1ZGUgfHwgODU7XG4gICAgbWF4TG9uZ2l0dWRlID0gcGFyYW1zLm1heGxvbmdpdHVkZSB8fCAxODA7XG4gICAgbWluTGF0aXR1ZGUgPSBwYXJhbXMubWlubGF0aXR1ZGUgfHwgLTg1O1xuICAgIG1pbkxvbmdpdHVkZSA9IHBhcmFtcy5taW5sb25naXR1ZGUgfHwgLTE4MDtcblxuICAgIC8vIGNvbXB1dGUgYmFzZWQgb24gcmFkaXVzIHNlYXJjaFxuICAgIGxhdGl0dWRlID0gcGFyYW1zLmxhdGl0dWRlO1xuICAgIGxvbmdpdHVkZSA9IHBhcmFtcy5sb25naXR1ZGU7XG4gICAgbWF4UmFkaXVzS20gPSBwYXJhbXMubWF4cmFkaXVza207XG4gICAgaWYgKChsYXRpdHVkZSB8fCBsYXRpdHVkZSA9PT0gMCkgJiZcbiAgICAgICAgKGxvbmdpdHVkZSB8fCBsb25naXR1ZGUgPT09IDApICYmXG4gICAgICAgIChtYXhSYWRpdXNLbSB8fCBtYXhSYWRpdXNLbSA9PT0gMCkpIHtcbiAgICAgIHJhZGl1c0RlZ3JlZXMgPSBtYXhSYWRpdXNLbSAvIF9LTV9QRVJfREVHUkVFO1xuICAgICAgbWF4TGF0aXR1ZGUgPSBsYXRpdHVkZSArIHJhZGl1c0RlZ3JlZXM7XG4gICAgICBtYXhMb25naXR1ZGUgPSBsb25naXR1ZGUgKyByYWRpdXNEZWdyZWVzO1xuICAgICAgbWluTGF0aXR1ZGUgPSBsYXRpdHVkZSAtIHJhZGl1c0RlZ3JlZXM7XG4gICAgICBtaW5Mb25naXR1ZGUgPSBsb25naXR1ZGUgLSByYWRpdXNEZWdyZWVzO1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBleHRlbnRcbiAgICBtYXBQb3NpdGlvbiA9IFtcbiAgICAgIFttaW5MYXRpdHVkZSwgbWluTG9uZ2l0dWRlXSxcbiAgICAgIFttYXhMYXRpdHVkZSwgbWF4TG9uZ2l0dWRlXVxuICAgIF07XG5cbiAgICByZXR1cm4gbWFwUG9zaXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNoYWluc1xuICAgKiBnZXRMYXRlc3RFYXJ0aHF1YWtlc0xpbmsgd2l0aCBnZXROZWFyYnlTZWlzbWljaXR5UGFyYW1zLlxuICAgKlxuICAgKiBAcGFyYW0gc3VtbWFyeSB7T2JqZWN0fVxuICAgKiAgICAgZXZlbnQgc3VtbWFyeSBvYmplY3QsIGFzIHJldHVybmVkIGJ5IENhdGFsb2dFdmVudCNnZXRTdW1tYXJ5KCkuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgIHVybCB0byBkaXNwbGF5IG5lYXJieSBzZWlzbWljaXR5IGluIG1hcC9saXN0LlxuICAgKi9cbiAgX3RoaXMuZ2V0TmVhcmJ5U2Vpc21pY2l0eUxpbmsgPSBmdW5jdGlvbiAoc3VtbWFyeSkge1xuICAgIHZhciBwYXJhbXM7XG5cbiAgICBwYXJhbXMgPSBfdGhpcy5nZXROZWFyYnlTZWlzbWljaXR5UGFyYW1zKHN1bW1hcnkpO1xuICAgIHJldHVybiBfdGhpcy5nZXRMYXRlc3RFYXJ0aHF1YWtlc0xpbmsoe1xuICAgICAgZXZlbnRpZDogc3VtbWFyeS5pZCxcbiAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBuZWFyYnkgc2Vpc21pY2l0eSBBUEkgc2VhcmNoIHBhcmFtZXRlcnMgZm9yIGFuIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gc3VtbWFyeSB7T2JqZWN0fVxuICAgKiAgICAgZXZlbnQgc3VtbWFyeSBvYmplY3QsIGFzIHJldHVybmVkIGJ5IENhdGFsb2dFdmVudCNnZXRTdW1tYXJ5KCkuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgIG9iamVjdCB3aXRoIHNlYXJjaCBwYXJhbWV0ZXJzXG4gICAqL1xuICBfdGhpcy5nZXROZWFyYnlTZWlzbWljaXR5UGFyYW1zID0gZnVuY3Rpb24gKHN1bW1hcnkpIHtcbiAgICB2YXIgZW5kdGltZSxcbiAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZSxcbiAgICAgICAgbWFnbml0dWRlLFxuICAgICAgICBtaW5tYWduaXR1ZGUsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgdGhyZWVXZWVrcyxcbiAgICAgICAgc3RhcnR0aW1lLFxuICAgICAgICB0aW1lO1xuXG4gICAgbGF0aXR1ZGUgPSBzdW1tYXJ5LmxhdGl0dWRlO1xuICAgIGxvbmdpdHVkZSA9IHN1bW1hcnkubG9uZ2l0dWRlO1xuICAgIG1hZ25pdHVkZSA9IHN1bW1hcnkubWFnbml0dWRlO1xuICAgIHRpbWUgPSBzdW1tYXJ5LnRpbWU7XG5cbiAgICBpZiAoIWxhdGl0dWRlIHx8ICFsb25naXR1ZGUgfHwgIXRpbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBtaW5tYWduaXR1ZGUgPSAxO1xuICAgIGlmIChtYWduaXR1ZGUgIT09IG51bGwpIHtcbiAgICAgIG1pbm1hZ25pdHVkZSA9IE1hdGgubWF4KE1hdGguZmxvb3IobWFnbml0dWRlKSAtIDMsIDEpO1xuICAgIH1cblxuICAgIHRocmVlV2Vla3MgPSAzICogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG4gICAgdGltZSA9IG5ldyBEYXRlKHRpbWUpLmdldFRpbWUoKTtcbiAgICBzdGFydHRpbWUgPSBuZXcgRGF0ZSh0aW1lIC0gdGhyZWVXZWVrcykudG9JU09TdHJpbmcoKTtcbiAgICBlbmR0aW1lID0gbmV3IERhdGUodGltZSArIHRocmVlV2Vla3MpLnRvSVNPU3RyaW5nKCk7XG5cbiAgICBwYXJhbXMgPSB7XG4gICAgICBlbmR0aW1lOiBlbmR0aW1lLFxuICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlOiBsb25naXR1ZGUsXG4gICAgICBtYXhyYWRpdXNrbTogX3JhZGl1cyxcbiAgICAgIG1pbm1hZ25pdHVkZTogbWlubWFnbml0dWRlLFxuICAgICAgc3RhcnR0aW1lOiBzdGFydHRpbWVcbiAgICB9O1xuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5OZWFyYnlTZWlzbWljaXR5LktNX1BFUl9ERUdSRUUgPSBfS01fUEVSX0RFR1JFRTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE5lYXJieVNlaXNtaWNpdHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9kdWN0ID0gcmVxdWlyZSgncGRsL1Byb2R1Y3QnKSxcbiAgICBWaWV3ID0gcmVxdWlyZSgnbXZjL1ZpZXcnKTtcblxuXG4vKipcbiAqIFZpZXcgZm9yIGEgc3BlY2lmaWMgUHJvZHVjdC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgIGFsbCBvcHRpb25zIGFyZSBwYXNzZWQgdG8gbXZjL1ZpZXcuXG4gKi9cbnZhciBQcm9kdWN0VmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcztcblxuICAvLyBNYWtlIHN1cmUgdGhlIG1vZGVsIHVzZWQgZm9yIHRoaXMgdmlldyBpcyBhIHBkbC9Qcm9kdWN0XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLm1vZGVsID0gb3B0aW9ucy5tb2RlbCB8fCBQcm9kdWN0KCk7XG5cbiAgX3RoaXMgPSBWaWV3KG9wdGlvbnMpO1xuXG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZHVjdFZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIExpbmtQcm9kdWN0VmlldyA9IHJlcXVpcmUoJ2NvcmUvTGlua1Byb2R1Y3RWaWV3JyksXG4gICAgTW9kdWxlID0gcmVxdWlyZSgnY29yZS9Nb2R1bGUnKSxcbiAgICBQcm9kdWN0ID0gcmVxdWlyZSgncGRsL1Byb2R1Y3QnKSxcbiAgICBUZXh0UHJvZHVjdFZpZXcgPSByZXF1aXJlKCdjb3JlL1RleHRQcm9kdWN0VmlldycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0RFRkFVTFRTID0ge1xuXG59O1xuXG5cbi8qKlxuICogQWJzdHJhY3QgbW9kdWxlIHRvIHNlcnZlIGFzIGFuIGV4dGVuc2lvbiBwb2ludCBmb3Igc3VtbWFyeS1sZXZlbCBtb2R1bGVzLlxuICpcbiAqL1xudmFyIFN1bW1hcnlNb2R1bGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZTtcblxuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgX3RoaXMgPSBNb2R1bGUob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoLypvcHRpb25zKi8pIHtcbiAgICBfdGhpcy5jbGVhckxpbmtzKHRydWUpO1xuICAgIF90aGlzLmNsZWFyVGV4dHModHJ1ZSk7XG4gIH07XG5cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIHZpZXdzIGluIHRoZSBnaXZlbiB2aWV3cyBhcnJheSBhbmQgcG90ZW50aWFsbHkgcmUtaW5pdGlhbGl6ZXNcbiAgICogdGhlIHZpZXdzIGFycmF5IHRvIGFuIGVtcHR5IGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gdmlld3Mge0FycmF5fVxuICAgKiAgICAgQW4gYXJyYXkgb2Ygdmlld3MgdG8gY2xlYXIuXG4gICAqL1xuICBfdGhpcy5jbGVhclZpZXdzID0gZnVuY3Rpb24gKHZpZXdzKSB7XG4gICAgaWYgKHZpZXdzKSB7XG4gICAgICB2aWV3cy5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHZpZXdzIGFzc29jaWF0ZWQgd2l0aCBsaW5rIHByb2R1Y3RzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5pdCB7Qm9vbGVhbn0gT3B0aW9uYWwuIERlZmF1bHQgZmFsc2UuXG4gICAqICAgICBGbGFnIHdoZXRoZXIgdG8gcmUtaW5pdGlhbGl6ZSB0aGUgdmlld3MgYXJyYXkuIEJ5IGRlZmF1bHQgdGhlIHZpZXdzXG4gICAqICAgICBhcnJheSBpcyBzZXQgdG8gbnVsbCwgaWYgdHJ1ZSwgaW5pdGlhbGl6ZXMgdmlld3MgYXJyYXkgdG8gZW1wdHkgYXJyYXkuXG4gICAqXG4gICAqIEBzZWUgI190aGlzLmNsZWFyVmlld3NcbiAgICovXG4gIF90aGlzLmNsZWFyTGlua3MgPSBmdW5jdGlvbiAoaW5pdCkge1xuICAgIF90aGlzLmNsZWFyVmlld3MoX3RoaXMubGlua1ZpZXdzKTtcblxuICAgIGlmIChpbml0KSB7XG4gICAgICBfdGhpcy5saW5rVmlld3MgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMubGlua1ZpZXdzID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgdmlld3MgYXNzb2NpYXRlZCB3aXRoIHRleHQgcHJvZHVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBpbml0IHtCb29sZWFufSBPcHRpb25hbC4gRGVmYXVsdCBmYWxzZS5cbiAgICogICAgIEZsYWcgd2hldGhlciB0byByZS1pbml0aWFsaXplIHRoZSB2aWV3cyBhcnJheS4gQnkgZGVmYXVsdCB0aGUgdmlld3NcbiAgICogICAgIGFycmF5IGlzIHNldCB0byBudWxsLCBpZiB0cnVlLCBpbml0aWFsaXplcyB2aWV3cyBhcnJheSB0byBlbXB0eSBhcnJheS5cbiAgICpcbiAgICogQHNlZSAjX3RoaXMuY2xlYXJWaWV3c1xuICAgKi9cbiAgX3RoaXMuY2xlYXJUZXh0cyA9IGZ1bmN0aW9uIChpbml0KSB7XG4gICAgX3RoaXMuY2xlYXJWaWV3cyhfdGhpcy50ZXh0Vmlld3MsIGluaXQpO1xuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIF90aGlzLnRleHRWaWV3cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy50ZXh0Vmlld3MgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgVFIgRE9NIGVsZW1lbnQgcG90ZW50aWFsbHkgd2l0aCBhXG4gICAqIFwicHJlZmVycmVkXCIgY2xhc3Mgb24gaXQuXG4gICAqXG4gICAqIEBwYXJhbSBwcmVmZXJyZWQge0Jvb2xlYW59XG4gICAqICAgICBUcnVlIGlmIHRoZSBcInByZWZlcnJlZFwiIGNsYXNzIHNob3VsZCBiZSBhZGRlZC4gRmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fVxuICAgKiAgICAgQSBUUiBET00gRWxlbWVudC5cbiAgICovXG4gIF90aGlzLmNyZWF0ZVJvdyA9IGZ1bmN0aW9uIChwcmVmZXJyZWQpIHtcbiAgICB2YXIgcm93O1xuXG4gICAgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcblxuICAgIGlmIChwcmVmZXJyZWQpIHtcbiAgICAgIHJvdy5jbGFzc0xpc3QuYWRkKCdwcmVmZXJyZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93O1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIGZvciBjcmVhdGluZyBhIHN1bW1hcnkgc2VjdGlvbiBmb3IgYSB0eXBlIG9mIHByb2R1Y3QuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9kdWN0cyB7QXJyYXl9XG4gICAqICAgICBBbiBhcnJheSBvZiB7UHJvZHVjdH1zIHRvIHN1bW1hcml6ZS5cbiAgICogQHBhcmFtIHRpdGxlIHtTdHJpbmd9XG4gICAqICAgICBUaGUgaGVhZGVyIHRleHQgdG8gbGFiZWwgdGhpcyBzdW1tYXJ5IHNlY3Rpb24uXG4gICAqIEBwYXJhbSBsYWJlbHMge0FycmF5fVxuICAgKiAgICAgQW4gYXJyYXkgb2Yge1N0cmluZ31zIHRvIHVzZSBhIGNvbHVtbiBoZWFkZXIgdGV4dC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn1cbiAgICogICAgIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBmb3IgZWFjaCBwcm9kdWN0LiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqICAgICBzaG91bGQgcmV0dXJuIGEgVFIgRE9NIGVsZW1lbnQuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBleHBlY3RzIGFcbiAgICogICAgIHtQcm9kdWN0fSBhcyBpdHMgZmlyc3QgcGFyYW1ldGVyIGFuZCBhbiBpbmRleCB7TnVtYmVyfSBhcyBpdCdzIHNlY29uZFxuICAgKiAgICAgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICAgKiAgICAgQSBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHRoZSBzZWN0aW9uIHN1bW1hcnksIHRoaXMgY291bGQgYmVcbiAgICogICAgIGVtcHR5IGlmIG5vIHByb2R1Y3RzIG9yIGxhYmVscyBhcmUgcHJvdmlkZWQuXG4gICAqL1xuICBfdGhpcy5jcmVhdGVTdW1tYXJ5ID0gZnVuY3Rpb24gKHByb2R1Y3RzLCB0aXRsZSwgbGFiZWxzLCBjYWxsYmFjaykge1xuICAgIHZhciBmcmFnbWVudCxcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgdGJvZHksXG4gICAgICAgIHRoZWFkLFxuICAgICAgICB3cmFwcGVyO1xuXG4gICAgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBpZiAocHJvZHVjdHMubGVuZ3RoICYmIGxhYmVscy5sZW5ndGgpIHtcbiAgICAgIGhlYWRlciA9IGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJykpO1xuICAgICAgd3JhcHBlciA9IGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgIHRhYmxlID0gd3JhcHBlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpKTtcbiAgICAgIHRoZWFkID0gdGFibGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGhlYWQnKSk7XG4gICAgICB0Ym9keSA9IHRhYmxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5JykpO1xuXG4gICAgICBoZWFkZXIuaW5uZXJIVE1MID0gdGl0bGU7XG5cbiAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnaG9yaXpvbnRhbC1zY3JvbGxpbmcnKTtcbiAgICAgIHRhYmxlLmNsYXNzTGlzdC5hZGQoJ3RhYmxlLXN1bW1hcnknKTtcblxuICAgICAgdGhlYWQuaW5uZXJIVE1MID0gJzx0cj48dGggc2NvcGU9XCJjb2xcIj4nICtcbiAgICAgICAgICBsYWJlbHMuam9pbignPC90aD48dGggc2NvcGU9XCJjb2xcIj4nKSArICc8L3RoPjwvdHI+JztcblxuICAgICAgdGJvZHkuYXBwZW5kQ2hpbGQocHJvZHVjdHMucmVkdWNlKGZ1bmN0aW9uIChmcmFnbWVudCwgcHJvZHVjdCwgaW5kZXgpIHtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2FsbGJhY2socHJvZHVjdCwgaW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgfSwgZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBGcmVlIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtb2R1bGUuXG4gICAqXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3RoaXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjsgLy8gQWxyZWFkeSBkZXN0cm95ZWRcbiAgICB9XG5cbiAgICBfdGhpcy5jbGVhckxpbmtzKCk7XG4gICAgX3RoaXMuY2xlYXJUZXh0cygpO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBtYXJrdXAgZm9yIGEgY2F0YWxvZyBjb2x1bW4gaW4gdGhlIHN1bW1hcnkgdGFibGUuIFRoaXMgaW5jbHVkZXNcbiAgICogYSBsaW5rIHRvIHRoZSBwcm9kdWN0IGRldGFpbHMgcGFnZSBhcyB3ZWxsIGFzIGEgcHJlZmVycmVkIGNoZWNrYm94IGlmXG4gICAqIGFwcHJvcHJpYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gbW9kdWxlIHtNb2R1bGV9XG4gICAqICAgICBUaGUgbW9kdWxlIGZvciB3aGljaCB0byBnZW5lcmF0ZSB0aGUgbGluay5cbiAgICogQHBhcmFtIHByb2R1Y3Qge1Byb2R1Y3R9XG4gICAqICAgICBUaGUgcHJvZHVjdCBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgdGhlIGxpbmsuXG4gICAqIEBwYXJhbSBwcmVmZXJyZWQge0Jvb2xlYW59XG4gICAqICAgICBUcnVlIGlmIHRoZSBjdXJyZW50IHByb2R1Y3QgaXMgcHJlZmVycmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgIFRoZSBtYXJrdXAgZm9yIHRoZSBsaW5rIHRvIHRoZSBwcm9kdWN0IGRldGFpbHMgcGFnZS5cbiAgICovXG4gIF90aGlzLmdldENhdGFsb2dNYXJrdXAgPSBmdW5jdGlvbiAobW9kdWxlLCBwcm9kdWN0LCBwcmVmZXJyZWQpIHtcbiAgICB2YXIgbWFya3VwLFxuICAgICAgICB0eXBlO1xuXG4gICAgbWFya3VwID0gW107XG4gICAgdHlwZSA9IFByb2R1Y3QuZ2V0QmFzZVR5cGUocHJvZHVjdC5nZXQoJ3R5cGUnKSk7XG5cbiAgICBpZiAocHJlZmVycmVkKSB7XG4gICAgICBtYXJrdXAucHVzaCgnPGFiYnIgdGl0bGU9XCJQcmVmZXJyZWQgJyArIHR5cGUgK1xuICAgICAgICAnXCIgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmNoZWNrPC9hYmJyPicpO1xuICAgIH1cblxuICAgIG1hcmt1cC5wdXNoKCc8YSBocmVmPVwiIycgKyBtb2R1bGUuSUQgKyAnP3NvdXJjZT0nICsgcHJvZHVjdC5nZXQoJ3NvdXJjZScpICtcbiAgICAgICAgJyZhbXA7Y29kZT0nICsgcHJvZHVjdC5nZXQoJ2NvZGUnKSArICdcIj4nICtcbiAgICAgIChwcm9kdWN0LmdldFByb3BlcnR5KCdldmVudHNvdXJjZScpIHx8ICdOL0EnKS50b1VwcGVyQ2FzZSgpICtcbiAgICAnPC9hPicpO1xuXG4gICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB2aXN1YWxpemF0aW9uIGZvciBsaW5rIHByb2R1Y3RzLiBEZWxlZ2F0ZXMgdG8gdGhlXG4gICAqIHtMaW5rUHJvZHVjdFZpZXd9LlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdHMge0FycmF5fVxuICAgKiAgICAgQW4gYXJyYXkgb2YgcHJvZHVjdHMgdG8gZ2VuZXJhdGUgdmlzdWFsaXphdGlvbnMgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICAgKiAgICAgQSBmcmFnbWVudCBjb250YWluaW5nIHRoZSBtYXJrdXAgZm9yIGVhY2ggdGV4dCBwcm9kdWN0LlxuICAgKi9cbiAgX3RoaXMuZ2V0TGlua3MgPSBmdW5jdGlvbiAocHJvZHVjdHMpIHtcbiAgICB2YXIgZnJhZ21lbnQsXG4gICAgICAgIGxpc3Q7XG5cbiAgICBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGlmIChwcm9kdWN0cy5sZW5ndGgpIHtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKF90aGlzLmdldExpbmtzSGVhZGVyKCkpO1xuICAgICAgbGlzdCA9IGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJykpO1xuXG4gICAgICBwcm9kdWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9kdWN0KSB7XG4gICAgICAgIHZhciB2aWV3O1xuXG4gICAgICAgIHZpZXcgPSBMaW5rUHJvZHVjdFZpZXcoe1xuICAgICAgICAgIGVsOiBsaXN0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJykpLFxuICAgICAgICAgIG1vZGVsOiBwcm9kdWN0XG4gICAgICAgIH0pO1xuICAgICAgICB2aWV3LnJlbmRlcigpO1xuXG4gICAgICAgIF90aGlzLmxpbmtWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBUElNZXRob2QuXG4gICAqXG4gICAqIEltcGxlbWVudGluZyBjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH1cbiAgICogICAgIEEgaGVhZGVyIHRvIGxhYmVsIHRoZSBsaW5rcyBzZWN0aW9uIGZvciB0aGlzIHtTdW1tYXJ5TW9kdWxlfS4gSWYgbm9cbiAgICogICAgIGhlYWRlciBpcyBkZXNpcmVkLCByZXR1cm4gYW4gZW1wdHkge0RvY3VtZW50RnJhZ21lbnR9LlxuICAgKi9cbiAgX3RoaXMuZ2V0TGlua3NIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhlYWRlcjtcblxuICAgIGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgaGVhZGVyLmlubmVySFRNTCA9ICdSZWxhdGVkIExpbmtzJztcblxuICAgIHJldHVybiBoZWFkZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdmlzdWFsaXphdGlvbiBmb3IgdGV4dCBwcm9kdWN0cy4gRGVsZWdhdGVzIHRvIHRoZVxuICAgKiB7VGV4dFByb2R1Y3RWaWV3fS5cbiAgICpcbiAgICogQHBhcmFtIHByb2R1Y3RzIHtBcnJheX1cbiAgICogICAgIEFuIGFycmF5IG9mIHByb2R1Y3RzIHRvIGdlbmVyYXRlIHZpc3VhbGl6YXRpb25zIGZvci5cbiAgICpcbiAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICogICAgIEEgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgbWFya3VwIGZvciBlYWNoIHRleHQgcHJvZHVjdC5cbiAgICovXG4gIF90aGlzLmdldFRleHRzID0gZnVuY3Rpb24gKHByb2R1Y3RzKSB7XG4gICAgdmFyIGZyYWdtZW50O1xuXG4gICAgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBwcm9kdWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9kdWN0KSB7XG4gICAgICB2YXIgdmlldztcblxuICAgICAgdmlldyA9IFRleHRQcm9kdWN0Vmlldyh7XG4gICAgICAgIGVsOiBmcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSksXG4gICAgICAgIG1vZGVsOiBwcm9kdWN0XG4gICAgICB9KTtcbiAgICAgIHZpZXcucmVuZGVyKCk7XG5cbiAgICAgIF90aGlzLnRleHRWaWV3cy5wdXNoKHZpZXcpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3VtbWFyeU1vZHVsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbnRlbnRWaWV3ID0gcmVxdWlyZSgnY29yZS9Db250ZW50VmlldycpLFxuICAgIFByb2R1Y3RWaWV3ID0gcmVxdWlyZSgnY29yZS9Qcm9kdWN0VmlldycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0RFRkFVTFRTID0ge1xuICBjb250ZW50UGF0aDogJydcbn07XG5cblxudmFyIFRleHRQcm9kdWN0VmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfY29udGVudCxcbiAgICAgIF9jb250ZW50VmlldztcblxuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgX3RoaXMgPSBQcm9kdWN0VmlldyhvcHRpb25zKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHZpZXcuIENoZWNrcyB0aGUgY29uZmlndXJlZCBgY29udGVudFBhdGhgIChlbXB0eSBzdHJpbmdcbiAgICogYnkgZGVmYXVsdCkuIElmIGl0IGV4aXN0cywgY3JlYXRlcyBhIHtDb250ZW50Vmlld30gdG8gd2hpY2ggZnV0dXJlXG4gICAqIHJlbmRlcmluZyBpcyBkZWxlZ2F0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqICAgICBDb25maXVndXJhdGlvbiBvcHRpb25zIGZvciB0aGlzIHZpZXcuIEluIGFkZGl0aW9uIHRvIG9wdGlvbnMgc3BlY2lmaWVkXG4gICAqICAgICBpbiB7UHJvZHVjdFZpZXd9LCB0aGlzIG1heSBpbmNsdWRlIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmNvbnRlbnRQYXRoIHtTdHJpbmd9IE9wdGlvbmFsLiBEZWZhdWx0ICcnLlxuICAgKiAgICAgVGhlIHBhdGggZm9yIHRoZSBjb250ZW50IHRvIHJlbmRlciBmb3IgdGhpcyBUZXh0UHJvZHVjdFZpZXcuXG4gICAqXG4gICAqIEBzZWUgbXZjL1ZpZXdcbiAgICovXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBfdGhpcy5lbC5jbGFzc0xpc3QuYWRkKF90aGlzLm1vZGVsLmdldCgndHlwZScpKTtcbiAgICBfdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCd0ZXh0LXByb2R1Y3QnKTtcblxuICAgIF9jb250ZW50ID0gX3RoaXMubW9kZWwuZ2V0Q29udGVudChvcHRpb25zLmNvbnRlbnRQYXRoKTtcblxuICAgIGlmIChfY29udGVudCkge1xuICAgICAgX2NvbnRlbnRWaWV3ID0gQ29udGVudFZpZXcoe1xuICAgICAgICBlbDogX3RoaXMuZWwsXG4gICAgICAgIG1vZGVsOiBfY29udGVudFxuICAgICAgfSk7XG5cbiAgICAgIF9jb250ZW50Vmlldy5vblN1Y2Nlc3MgPSBfdGhpcy5vblN1Y2Nlc3M7XG4gICAgICBfY29udGVudFZpZXcub25FcnJvciA9IF90aGlzLm9uRXJyb3I7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEZyZWVzIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyB2aWV3LiBJbiBwYXJ0aWN1bGFyLCBpZiBhXG4gICAqIHtDb250ZW50Vmlld30gd2FzIGNyZWF0ZWQsIGl0IGlzIGRlc3Ryb3llZC5cbiAgICpcbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfY29udGVudFZpZXcpIHtcbiAgICAgIF9jb250ZW50Vmlldy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgX2NvbnRlbnQgPSBudWxsO1xuICAgIF9jb250ZW50VmlldyA9IG51bGw7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgbWV0aG9kIGlmIHRoZSBjb250ZW50IGZhaWxzIHRvIGZldGNoIGl0cyBkYXRhLiBEaXNwbGF5cyBhXG4gICAqIGJhc2ljIGVycm9yIG1lc3NhZ2UuXG4gICAqXG4gICAqL1xuICBfdGhpcy5vbkVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmVsLmlubmVySFRNTCA9XG4gICAgICAgICc8cCBjbGFzcz1cImFsZXJ0IGVycm9yXCI+Tm8gdGV4dCBjb250ZW50IHRvIHJlbmRlci48L3A+JztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgbWV0aG9kIHdoZW4gdGhlIGNvbnRlbnQgc3VjY2Vzc2Z1bGx5IGZldGNoZXMgaXRzIGRhdGEuIERpc3BsYXlzXG4gICAqIHRoZSByZXN1bHQgaW4gYF90aGlzLmVsYCBidXQgcmVwbGFjZXMgcGF0aHMgdG8gcmVsYXRpdmUgcmVzb3VyY2VzIGJhc2VkXG4gICAqIG9uIG90aGVyIGNvbnRlbnQgaW4gYF90aGlzLm1vZGVsYC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEge1N0cmluZ31cbiAgICogICAgIFRoZSBkYXRhIHRvIHJlbmRlci5cbiAgICovXG4gIF90aGlzLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gX3RoaXMucmVwbGFjZVJlbGF0aXZlUGF0aHMoZGF0YSxcbiAgICAgICAgX3RoaXMubW9kZWwuZ2V0KCdjb250ZW50cycpLmRhdGEoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIHtDb250ZW50fSB3YXMgZm91bmQgZHVyaW5nIGluaXRpYWxpemF0aW9uLCBkZWxlZ2F0ZXMgdG8gdGhlIGNyZWF0ZWRcbiAgICoge0NvbnRlbnRWaWV3fSwgb3RoZXJ3aXNlIGRpc3BsYXlzIHRoZSBzdG9jayBlcnJvciBtZXNzYWdlLlxuICAgKlxuICAgKiBAc2VlIENvbnRlbnRWaWV3I3JlbmRlclxuICAgKiBAc2VlIFRleHRQcm9kdWN0VmlldyNvbkVycm9yXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gJzxwIGNsYXNzPVwiYWxlcnQgaW5mb1wiPkxvYWRpbmcgY29udGVudCZoZWxsaXA7PC9wPic7XG4gICAgaWYgKF9jb250ZW50Vmlldykge1xuICAgICAgX2NvbnRlbnRWaWV3LnJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5vbkVycm9yKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHJlbGF0aXZlIHBhdGhzIGluIHRleHQgcHJvZHVjdHMgd2l0aCBmdWxseSBxdWFsaWZpZWQgVVJMc1xuICAgKiBiYXNlZCBvbiB0aGUgVVJMcyBmb3VuZCBpbiB0aGUgcHJvZHVjdCdzIGNvbnRlbnQgY29sbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMge1N0cmluZ31cbiAgICogICAgYnl0ZSBkYXRhIGZyb20gdGhlIHRleHQgcHJvZHVjdCBjb250ZW50c1xuICAgKlxuICAgKiBAcGFyYW0gY29udGVudHMge0FycmF5fVxuICAgKiAgICBhcnJheSBvZiBjb250ZW50IG9iamVjdHMgdG8gY2hlY2sgZm9yIHJlbGF0aXZlIHBhdGhzIHRoYXQgZXhpc3RcbiAgICogICAgaW4gdGhlIGJ5dGVzIGRhdGFcbiAgICovXG4gIF90aGlzLnJlcGxhY2VSZWxhdGl2ZVBhdGhzID0gZnVuY3Rpb24gKGJ5dGVzLCBjb250ZW50cykge1xuICAgIHZhciBjb250ZW50LFxuICAgICAgICBpLFxuICAgICAgICBsZW47XG5cbiAgICBsZW4gPSBjb250ZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnRlbnQgPSBjb250ZW50c1tpXS5nZXQoKTtcbiAgICAgIGlmIChjb250ZW50LmlkICE9PSAnJykge1xuICAgICAgICBieXRlcyA9IGJ5dGVzLnJlcGxhY2UobmV3IFJlZ0V4cCgnXCInICsgY29udGVudC5pZCArICdcIicsICdnJyksXG4gICAgICAgICAgICAnXCInICsgY29udGVudC51cmwgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0UHJvZHVjdFZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIERZRklGb3JtVmlldyA9IHJlcXVpcmUoJ2R5ZmkvRFlGSUZvcm1WaWV3JyksXG4gICAgRXZlbnRzID0gcmVxdWlyZSgndXRpbC9FdmVudHMnKSxcbiAgICBNb2RhbFZpZXcgPSByZXF1aXJlKCdtdmMvTW9kYWxWaWV3JyksXG4gICAgTW9kZWwgPSByZXF1aXJlKCdtdmMvTW9kZWwnKSxcbiAgICBNb2R1bGUgPSByZXF1aXJlKCdjb3JlL01vZHVsZScpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKSxcbiAgICBYaHIgPSByZXF1aXJlKCd1dGlsL1hocicpO1xuXG5cbnZhciBfSUQsXG4gICAgX1RJVExFLFxuICAgIF9oYXNDb250ZW50LFxuICAgIF9wYXJzZU1lc3NhZ2VBc0h0bWwsXG4gICAgX3BhcnNlTWVzc2FnZUFzU3RyaW5nO1xuXG5fSUQgPSAndGVsbHVzJztcbl9USVRMRSA9ICdGZWx0IFJlcG9ydCAtIFRlbGwgVXMhJztcblxuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gcGFyc2UgYSByYXcgcmVzcG9uc2UgdXNpbmcgSFRNTCBET00gbWFuaXB1bGF0aW9uLiBUaGlzXG4gKiBpcyB0aGUgbW9zdCByZWxpYWJsZSBwYXJzaW5nIG1ldGhvZCwgYnV0IG1heSBub3QgYmUgYXMgc3VwcG9ydGVkIGFjcm9zc1xuICogYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIHtTdHJpbmd9XG4gKiAgICAgQW4gSFRNTCBzdHJpbmcgZnJvbSB3aGljaCB0byBwYXJzZSBhIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqICAgICBUaGUgcGFyc2VkIG1lc3NhZ2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgSWYgdGhlIHJlc3BvbnNlIGRvZXMgbm90IHJlcHJlc2VudCB2YWxpZCBIVE1MLiBPZiBpZiB0aGUgcmVzcG9uc2UgZG9lc1xuICogICAgIG5vdCBpbmNsdWRlIGEgZGVzY3JpcHRpb24gbGlzdCB0YWcgKDxkbD4pLlxuICovXG5fcGFyc2VNZXNzYWdlQXNIdG1sID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBoO1xuXG4gIGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gIGguaW5uZXJIVE1MID0gcmVzcG9uc2U7XG5cbiAgcmV0dXJuIGgucXVlcnlTZWxlY3RvcignZGwnKS5vdXRlckhUTUw7XG59O1xuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gcGFyc2UgYSByYXcgcmVzcG9uc2UgdXNpbmcgU3RyaW5nIG1hbmlwdWxhdGlvbi4gVGhpcyBpcyBhXG4gKiBmYWxsYmFjayBhcHByb2FjaCB3aGVuIERPTSBwYXJzaW5nIGZhaWxzLlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSB7U3RyaW5nfVxuICogICAgIEFuIEhUTUwgc3RyaW5nIGZyb20gd2hpY2ggdG8gcGFyc2UgYSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiAgICAgVGhlIHBhcnNlZCBtZXNzYWdlIG9yIG51bGwgaWYgbm8gbWVzc2FnZSBpcyBmb3VuZC5cbiAqL1xuX3BhcnNlTWVzc2FnZUFzU3RyaW5nID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBlbmRJZHgsXG4gICAgICBzdGFydElkeDtcblxuICBzdGFydElkeCA9IHJlc3BvbnNlLmluZGV4T2YoJzxkbD4nKTtcbiAgZW5kSWR4ID0gcmVzcG9uc2UuaW5kZXhPZignPC9kbD4nKTtcblxuICBpZiAoc3RhcnRJZHggPT09IC0xIHx8IGVuZElkeCA9PT0gLTEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5zdWJzdHJpbmcoc3RhcnRJZHgsIGVuZElkeCkgKyAnPC9kbD4nO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoaXMgbW9kdWxlIGhhcyBjb250ZW50LiBTY2VuYXJpbyBldmVudHMgZG8gd2lsbCBub3RcbiAqIGdldCB0aGlzIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gZXZlbnRQYWdlTW9kZWxcbiAqICAgICBUaGUgbW9kZWwgdXNlIGJ5IHRoZSB7RXZlbnRQYWdlfSBjbGFzcy5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICAgIFRydWUgaWYgdGhlIG1vZHVsZSBzaG91bGQgYmUgaW5jbHVkZWQuIEZhbHNlIG90aGVyd2lzZS5cbiAqL1xuX2hhc0NvbnRlbnQgPSBmdW5jdGlvbiAoZXZlbnRQYWdlTW9kZWwpIHtcbiAgdmFyIGNvbmZpZztcblxuICBjb25maWcgPSBldmVudFBhZ2VNb2RlbC5nZXQoJ2NvbmZpZycpO1xuXG4gIHJldHVybiBjb25maWcuaGFzT3duUHJvcGVydHkoJ1NDRU5BUklPX01PREUnKSA/XG4gICAgKCFjb25maWcuU0NFTkFSSU9fTU9ERSkgOiB0cnVlO1xufTtcblxudmFyIF9ERUZBVUxUUyA9IHtcbiAgRFlGSV9SRVNQT05TRV9VUkw6ICcvcHJvZHVjdHMvZHlmaS9yZXNwb25zZS5odG1sJyxcbiAgRk9STV9WRVJTSU9OOiAnMS41J1xufTtcblxuXG4vKipcbiAqIE1vZHVsZSBmb3IgZGlzcGxheWluZyB0aGUge0RZRklGb3JtVmlld30uIFRoaXMgbW9kdWxlIGhhbmRsZXMgdGhlIG1vZGFsXG4gKiBkaWFsb2cgaW4gd2hpY2ggdGhlIHZpZXcgaXMgcmVuZGVyZWQuIEl0IGNvbW11bmljYXRlcyB3aXRoIHRoZSB2aWV3IHRocm91Z2hcbiAqIHRoZSBtb2RlbCBwcm92aWRlZCB0byB0aGUgdmlldyBpbiBvcmRlciB0byBnZXQgdGhlIGZvcm0gdmFsdWVzIHdoZW4gdGhlXG4gKiBzdWJtaXQgYnV0dG9uIGlzIGNsaWNrZWQuIFRoaXMgbW9kdWxlIGRlYWxzIHdpdGggZm9ybSBzdWJtaXNzaW9uIHdoaWxlIHRoZVxuICogdmlldyBpdHNlbGYgZGVhbHMgd2l0aCB1c2VyIGlucHV0cy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyBtb2R1bGUuIFNlZSBfaW5pdGlhbGl6ZSBtZXRob2RcbiAqICAgICBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuICovXG52YXIgRFlGSUZvcm1Nb2R1bGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2Zvcm1Nb2RlbCxcbiAgICAgIF9mb3JtVmVyc2lvbixcbiAgICAgIF9tb2RhbCxcbiAgICAgIF9zdWJtaXRCdXR0b24sXG4gICAgICBfc3VibWl0UmVzdWx0LFxuICAgICAgX3N1Ym1pdFVybCxcbiAgICAgIF92aWV3O1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IE1vZHVsZShvcHRpb25zKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IuIEluaXRpYWxpemVzIGEgbmV3IERZRklNb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgbW9kdWxlLiBJbiBhZGRpdGlvbiB0byB3aGF0IGNhbiBiZVxuICAgKiAgICAgcHJvdmlkZWQgYSBnZW5lcmljIG1vZHVsZSwgdGhlc2UgbWF5IGFsc28gaW5jbHVkZTpcbiAgICogQHBhcmFtIG9wdGlvbnMuRk9STV9WRVJTSU9OIHtTdHJpbmd9XG4gICAqICAgICBBIHZlcnNpb24gc3RyaW5nIGlkZW50aWZpZXIgZm9yIHRoaXMgZm9ybS5cbiAgICovXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgY2F0YWxvZ0V2ZW50LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGV2ZW50VGltZXN0YW1wO1xuXG4gICAgX3RoaXMuSUQgPSBfSUQ7XG4gICAgX3RoaXMuVElUTEUgPSBfVElUTEU7XG5cbiAgICBjb25maWcgPSBfdGhpcy5tb2RlbC5nZXQoJ2NvbmZpZycpO1xuICAgIF9zdWJtaXRVcmwgPSAoY29uZmlnICYmIGNvbmZpZy5EWUZJX1JFU1BPTlNFX1VSTCkgP1xuICAgICAgICBjb25maWcuRFlGSV9SRVNQT05TRV9VUkwgOiBvcHRpb25zLkRZRklfUkVTUE9OU0VfVVJMO1xuICAgIF9zdWJtaXRSZXN1bHQgPSBudWxsO1xuXG4gICAgX2Zvcm1WZXJzaW9uID0gb3B0aW9ucy5GT1JNX1ZFUlNJT047XG5cbiAgICBfdGhpcy5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMub25Db250ZW50Q2xpY2spO1xuXG4gICAgY2F0YWxvZ0V2ZW50ID0gX3RoaXMubW9kZWwuZ2V0KCdldmVudCcpO1xuXG4gICAgaWYgKGNhdGFsb2dFdmVudCkge1xuICAgICAgZXZlbnRUaW1lc3RhbXAgPSBjYXRhbG9nRXZlbnQuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIF9mb3JtTW9kZWwgPSBNb2RlbCh7XG4gICAgICBldmVudFRpbWU6IGV2ZW50VGltZXN0YW1wID8gZXZlbnRUaW1lc3RhbXAudG9VVENTdHJpbmcoKSA6ICcnLFxuICAgICAgbGFuZ3VhZ2U6ICdlbidcbiAgICAgIC8vIFRPRE8gOjogQWxzbyBpbmNsdWRlIGV2ZW50aWQgaW4gc29tZSB3YXk/XG4gICAgfSk7XG5cbiAgICBfZm9ybU1vZGVsLm9uKCdjaGFuZ2UnLCAnb25Gb3JtQ2hhbmdlJywgX3RoaXMpO1xuXG4gICAgX3ZpZXcgPSBEWUZJRm9ybVZpZXcoe1xuICAgICAgbW9kZWw6IF9mb3JtTW9kZWxcbiAgICB9KTtcbiAgICBfdmlldy5yZW5kZXIoKTtcblxuICAgIF9tb2RhbCA9IE1vZGFsVmlldyhfdmlldy5lbCwge1xuICAgICAgYnV0dG9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgY2FsbGJhY2s6IF90aGlzLm9uU3VibWl0LFxuICAgICAgICAgIGNsYXNzZXM6IFsnZ3JlZW4nLCAnZHlmaS1zdWJtaXQtYnV0dG9uJ10sXG4gICAgICAgICAgdGV4dDogJ1N1Ym1pdCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNhbGxiYWNrOiBfdGhpcy5vbkNhbmNlbCxcbiAgICAgICAgICBjbGFzc2VzOiBbJ2R5ZmktY2FuY2VsLWJ1dHRvbiddLFxuICAgICAgICAgIHRleHQ6ICdDYW5jZWwnXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB0aXRsZTogbnVsbCAvLyBObyB0aXRsZS4gVmlldyBzaG91bGQgcmVuZGVyIHRpdGxlIGFuZCBPTUIgbnVtYmVyLlxuICAgIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEZyZWVzIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtb2R1bGUuXG4gICAqXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5jb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMub25Db250ZW50Q2xpY2spO1xuICAgIF9mb3JtTW9kZWwub2ZmKCdjaGFuZ2UnLCAnb25Gb3JtQ2hhbmdlJywgX3RoaXMpO1xuXG4gICAgX21vZGFsLmhpZGUoKTtcbiAgICBfbW9kYWwuZGVzdHJveSgpO1xuICAgIF92aWV3LmRlc3Ryb3koKTsgLy8gTkI6IERlc3Ryb3kgdmlldyBiZWZvcmUgZGVzdHJveWluZyBtb2RlbFxuICAgIF9mb3JtTW9kZWwuZGVzdHJveSgpO1xuXG4gICAgX2Zvcm1Nb2RlbCA9IG51bGw7XG4gICAgX2Zvcm1WZXJzaW9uID0gbnVsbDtcbiAgICBfbW9kYWwgPSBudWxsO1xuICAgIF9zdWJtaXRSZXN1bHQgPSBudWxsO1xuICAgIF9zdWJtaXRVcmwgPSBudWxsO1xuICAgIF92aWV3ID0gbnVsbDtcblxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB3aGVuIHVzZXIgY2xpY2tzIHRoZSBjYW5jZWwgYnV0dG9uLiBGb3JtIGlzIGhpZGRlbiBhbmQgYnJvd3NlclxuICAgKiBpcyBuYXZpZ2F0ZWQgYmFjayB0byBzb21lIG90aGVyIGV2ZW50IHBhZ2UgY29udGVudC5cbiAgICpcbiAgICovXG4gIF90aGlzLm9uQ2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIF9tb2RhbC5oaWRlKCk7XG5cbiAgICAvLyBOb3RpZnkgdGhlIEV2ZW50UGFnZSB0aGlzIHZpZXcgd291bGQgbGlrZSB0byBnbyBiYWNrXG4gICAgRXZlbnRzLnRyaWdnZXIoJ2JhY2snKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gaGFuZGVsIHJlLXNob3dpbmcgdGhlIGZvcm0gd2hlbiBhIGJ1dHRvbiBpcyBjbGlja2VkIG9uIHRoZVxuICAgKiBwYWdlIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gZXZ0IHtFdmVudH1cbiAgICogICAgIFRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGNhbGxiYWNrLlxuICAgKi9cbiAgX3RoaXMub25Db250ZW50Q2xpY2sgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGV2dC50YXJnZXQgJiYgZXZ0LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3ctZm9ybScpKSB7XG4gICAgICBfdGhpcy5zaG93Rm9ybSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgd2hlbiB0aGUgX2Zvcm1Nb2RlbCBpcyBjaGFuZ2VkLiBDaGVja3MgdG8gc2VlIGlmIHJlcXVpcmVkXG4gICAqIGZpZWxkcyBhcmUgY29tcGxldGUgYW5kIGlmIHNvLCBlbmFibGVzIHN1Ym1pdCBidXR0b247IG90aGVyd2lzZSBkaXNhYmxlc1xuICAgKiB0aGUgYnV0dG9uLlxuICAgKlxuICAgKi9cbiAgX3RoaXMub25Gb3JtQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfc3VibWl0QnV0dG9uKSB7XG4gICAgICBpZiAoIV9mb3JtTW9kZWwuZ2V0KCdjaWltX21hcExhdCcpIHx8XG4gICAgICAgICAgIV9mb3JtTW9kZWwuZ2V0KCdjaWltX21hcExvbicpIHx8XG4gICAgICAgICAgIV9mb3JtTW9kZWwuZ2V0KCdjaWltX3RpbWUnKSB8fFxuICAgICAgICAgICFfZm9ybU1vZGVsLmdldCgnZmxkU2l0dWF0aW9uX2ZlbHQnKSkge1xuICAgICAgICAvLyBBIHJlcXVpcmVkIGZpZWxkIGlzIG1pc3NpbmcsIGRpc2FibGUgc3VibWl0IGJ1dHRvblxuICAgICAgICBfc3VibWl0QnV0dG9uLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zdWJtaXRCdXR0b24ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgd2hlbiB0aGUgc3VibWl0IGJ1dHRvbiBpcyBjbGlja2VkIG9uIHRoZSBmb3JtLiBUaGlzIG1ldGhvZFxuICAgKiBhdWdtZW50cyB0aGUgZm9ybSBkYXRhIHdpdGggc29tZSBpbnRlcm5hbGx5IHJlcXVpcmVkIGluZm9ybWF0aW9uLCB0aGVuXG4gICAqIHN1Ym1pdHMgdGhlIHJlcXVlc3QgdXNpbmcgQUpBWCB2aWEgQ09SUy5cbiAgICpcbiAgICovXG4gIF90aGlzLm9uU3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhLFxuICAgICAgICBldjtcblxuICAgIF9zdWJtaXRSZXN1bHQgPSBudWxsO1xuXG4gICAgZXYgPSBfdGhpcy5tb2RlbC5nZXQoJ2V2ZW50Jyk7XG5cbiAgICBkYXRhID0gVXRpbC5leHRlbmQoe1xuICAgICAgZXZlbnRpZDogZXYgPyBldi5nZXRFdmVudElkKCkgOiBudWxsLFxuICAgICAgZm9ybV92ZXJzaW9uOiBfZm9ybVZlcnNpb24sXG4gICAgICBjaWltX3JlcG9ydDogJ1N1Ym1pdCBGb3JtJ1xuICAgIH0sIF9mb3JtTW9kZWwuZ2V0KCkpO1xuXG4gICAgWGhyLmFqYXgoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgZXJyb3I6IF90aGlzLm9uU3VibWl0RXJyb3IsXG4gICAgICB1cmw6IF9zdWJtaXRVcmwsXG4gICAgICBzdWNjZXNzOiBfdGhpcy5vblN1Ym1pdFN1Y2Nlc3NcbiAgICB9KTtcblxuICAgIF9tb2RhbC5oaWRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHdoZW4gdGhlIHN1Ym1pdCBYaHIgZmFpbHMuIE5vdGUsIHRoaXMgaXMgb25seSBleGVjdXRlZCBpZiBhblxuICAgKiBIVFRQIHN0YXR1cyBjb2RlIGFjY29tcGFuaWVzIHRoZSByZXNwb25zZS4gVXBkYXRlcyB0aGUgcmVzdWx0IG9iamVjdCBhbmRcbiAgICogY2FsbHMgdGhlIHJlbmRlciBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSBlcnJvciB7TWl4ZWR9XG4gICAqICAgICBTZWUgWGhyI2FqYXg6ZXJyb3JcbiAgICogQHBhcmFtIHhociB7WE1MSHR0cFJlcXVlc3R9XG4gICAqICAgICBUaGUgWEhSIHRoYXQgY2F1c2VkIHRoZSBlcnJvci5cbiAgICovXG4gIF90aGlzLm9uU3VibWl0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IvKiwgeGhyKi8pIHtcbiAgICBfc3VibWl0UmVzdWx0ID0ge1xuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfTtcblxuICAgIF90aGlzLnJlbmRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB3aGVuIHRoZSBzdWJtaXQgWGhyIHN1Y2NlZWRzLiBOb3RlLCB0aGlzIG1heSBleGVjdXRlIGV2ZW4gaWYgdGhlXG4gICAqIGZvcm0gd2FzIG5vdCBwcm9jZXNzZWQgaWYgdGhlIHJlc3BvbnNlIHJldHVybnMgYW4gSFRUUCAyWFggc3RhdHVzLiBVcGRhdGVzXG4gICAqIHRoZSByZXN1bHQgb2JqZWN0IGFuZCBjYWxscyB0aGUgcmVuZGVyIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHJlc3BvbnNlIHtTdHJpbmd9XG4gICAqICAgICBUaGUgcmVzcG9uc2UgbWVzc2FnZSB0byBwYXJzZS5cbiAgICogQHBhcmFtIHhociB7WE1MSHR0cFJlcXVlc3R9XG4gICAqICAgICBUaGUgWEhSIHRoYXQgc3VibWl0dGVkIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgX3RoaXMub25TdWJtaXRTdWNjZXNzID0gZnVuY3Rpb24gKHJlc3BvbnNlLyosIHhociovKSB7XG4gICAgdmFyIG1lc3NhZ2U7XG5cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZSA9IF9wYXJzZU1lc3NhZ2VBc0h0bWwocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG1lc3NhZ2UgPSBfcGFyc2VNZXNzYWdlQXNTdHJpbmcocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICBfc3VibWl0UmVzdWx0ID0ge1xuICAgICAgICBzdWNjZXNzOiBtZXNzYWdlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfc3VibWl0UmVzdWx0ID0ge1xuICAgICAgICBlcnJvcjogJ1JlcXVpcmVkIGVudHJpZXMgbm90IHByb3ZpZGVkISBQbGVhc2UgcmUtc3VibWl0IHRoZSBmb3JtICcgK1xuICAgICAgICAgICAgJ2FmdGVyIGFuc3dlcmluZyBhbGwgcmVxdWlyZWQgcXVlc3Rpb25zLidcbiAgICAgIH07XG4gICAgfVxuXG4gICAgX3RoaXMucmVuZGVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCBzaG93IHRoZSBmb3JtIG9yIHdoZW4gaXQgaXMgc3VibWl0dGVkLiBEZXBlbmRpbmcgb24gdGhlIGN1cnJlbnRcbiAgICogc3RhdGUgb2YgdGhlIHJlc3VsdCBvYmplY3QsIGRpc3BsYXlzIHRoZSByZXN1bHQgbWVzc2FnZSBvciBzaG93cyB0aGUgZm9ybVxuICAgKiBpdHNlbGYuXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1dHRvbk1hcmt1cDtcblxuICAgIGJ1dHRvbk1hcmt1cCA9ICc8YnV0dG9uIGNsYXNzPVwic2hvdy1mb3JtXCI+U2hvdyBGb3JtPC9idXR0b24+JztcblxuICAgIF90aGlzLmhlYWRlci5pbm5lckhUTUwgPSAnPGgzPicgKyBfdGhpcy5USVRMRSArICc8L2gzPic7XG4gICAgX3RoaXMuZm9vdGVyLmlubmVySFRNTCA9ICcnO1xuXG4gICAgaWYgKF9zdWJtaXRSZXN1bHQgJiYgKF9zdWJtaXRSZXN1bHQuZXJyb3IgfHwgX3N1Ym1pdFJlc3VsdC5zdWNjZXNzKSkge1xuICAgICAgaWYgKF9zdWJtaXRSZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPSAnPHAgY2xhc3M9XCJhbGVydCBlcnJvclwiPicgK1xuICAgICAgICAgICAgX3N1Ym1pdFJlc3VsdC5lcnJvciArICc8L3A+JyArIGJ1dHRvbk1hcmt1cDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gW1xuICAgICAgICAgICc8aDM+UXVlc3Rpb25uYWlyZSBDb21wbGV0ZTwvaDM+JyxcbiAgICAgICAgICAnPHAgY2xhc3M9XCJhbGVydCBzdWNjZXNzXCI+JyxcbiAgICAgICAgICAgICdUaGFuayB5b3UgZm9yIHlvdXIgY29udHJpYnV0aW9uLiAnLFxuICAgICAgICAgICAgJ1lvdXIgaW5mb3JtYXRpb24gd2lsbCBiZSBwcm9jZXNzZWQgc2hvcnRseS4nLFxuICAgICAgICAgICc8L3A+JyxcbiAgICAgICAgICBfc3VibWl0UmVzdWx0LnN1Y2Nlc3NcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPSBidXR0b25NYXJrdXA7XG4gICAgICBfdGhpcy5zaG93Rm9ybSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2hvd3MgdGhlIG1vZGFsIGZvcm0uIE9uY2Ugc2hvd24sIGxldHMgdXBkYXRlcyB0aGUgc3VibWl0IGJ1dHRvbiBzdGF0ZVxuICAgKiAoZGlzYWJsZWQgb3Igbm90KSwgYW5kIHRoZW4gYWxsb3dzIHRoZSBzdWItdmlldyB0byByZW5kZXIuXG4gICAqXG4gICAqL1xuICBfdGhpcy5zaG93Rm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfbW9kYWwuc2hvdygpO1xuICAgIF9zdWJtaXRCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZHlmaS1zdWJtaXQtYnV0dG9uJyk7XG5cbiAgICAvLyBFbnN1cmUgc3VibWl0IGJ1dHRvbiBzdGF0dXMgaXMgY3VycmVudGx5IHVwLXRvLWRhdGVcbiAgICBfdGhpcy5vbkZvcm1DaGFuZ2UoKTtcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5EWUZJRm9ybU1vZHVsZS5JRCA9IF9JRDtcbkRZRklGb3JtTW9kdWxlLlRJVExFID0gX1RJVExFO1xuXG5EWUZJRm9ybU1vZHVsZS5oYXNDb250ZW50ID0gX2hhc0NvbnRlbnQ7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEWUZJRm9ybU1vZHVsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgQmFzaWNQaW5WaWV3ID0gcmVxdWlyZSgnY29yZS9CYXNpY1BpblZpZXcnKSxcbiAgICBEWUZJRm9ybU1vZHVsZSA9IHJlcXVpcmUoJ2R5ZmkvRFlGSUZvcm1Nb2R1bGUnKSxcbiAgICBGb3JtYXR0ZXIgPSByZXF1aXJlKCdjb3JlL0Zvcm1hdHRlcicpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxudmFyIF9ERUZBVUxUUyA9IHtcbiAgbW9kdWxlOiBEWUZJRm9ybU1vZHVsZVxufTtcblxuXG52YXIgRFlGSUZvcm1QaW5WaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9mb3JtYXR0ZXI7XG5cblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gQmFzaWNQaW5WaWV3KG9wdGlvbnMpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBfZm9ybWF0dGVyID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgRm9ybWF0dGVyKCk7XG4gIH07XG5cblxuICAvKipcbiAgICogRnJlZXMgcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHZpZXcuXG4gICAqXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3RoaXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfZm9ybWF0dGVyID0gbnVsbDtcblxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGhpc3RvZ3JhbXMgYXMgRFlGSUZvcm1QaW5WaWV3IGNvbnRlbnRcbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlclBpbkNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcmt1cCxcbiAgICAgICAgbnVtUmVzcG9uc2VzLFxuICAgICAgICByZXNwb25zZXMsXG4gICAgICAgIHN0aWxsWmVybyxcbiAgICAgICAgdmFsdWU7XG5cbiAgICBtYXJrdXAgPSBbXTtcbiAgICByZXNwb25zZXMgPSBfdGhpcy5tb2RlbC5nZXRQcm9wZXJ0eSgnbnVtLXJlc3BvbnNlcycpIHx8XG4gICAgICAgIF90aGlzLm1vZGVsLmdldFByb3BlcnR5KCdudW1SZXNwJykgfHwgJzAnO1xuICAgIG51bVJlc3BvbnNlcyA9IF9mb3JtYXR0ZXIubnVtYmVyV2l0aENvbW1hcyhyZXNwb25zZXMpO1xuICAgIC8vIHBhZCB3aXRoIHplcm9zXG4gICAgcmVzcG9uc2VzID0gX2Zvcm1hdHRlci5sZWZ0UGFkKHJlc3BvbnNlcy50b1N0cmluZygpLCA2LCAnMCcpO1xuICAgIHN0aWxsWmVybyA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVzcG9uc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB2YWx1ZSA9IHJlc3BvbnNlcy5jaGFyQXQoaSk7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gJzAnICYmIHN0aWxsWmVybykge1xuICAgICAgICBtYXJrdXAucHVzaCgnPGRpdiBjbGFzcz1cInJlc3BvbnNlcy1kaWdpdCBlbXB0eS1kaWdpdFwiPjA8L2Rpdj4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0aWxsWmVybyA9IGZhbHNlO1xuICAgICAgICBtYXJrdXAucHVzaCgnPGRpdiBjbGFzcz1cInJlc3BvbnNlcy1kaWdpdFwiPicsIHZhbHVlLCAnPC9kaXY+Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPVxuICAgICAgJzxkaXYgY2xhc3M9XCJkeWZpLXJlc3BvbnNlcy1iYWRnZVwiIHRpdGxlPVwiTnVtYmVyIG9mIERZRkkgUmVzcG9uc2VzXCI+JyArXG4gICAgICAgIG1hcmt1cC5qb2luKCcnKSArXG4gICAgICAnPC9kaXY+JyArXG4gICAgICAnPGRpdiBjbGFzcz1cImR5ZmktcmVzcG9uc2VzLWFiYnJcIj4nICtcbiAgICAgICAgJzxhYmJyIHRpdGxlPVwiJyArIG51bVJlc3BvbnNlcyArICcgRFlGSSBSZXNwb25zZXNcIj5SZXNwb25zZXM8L2FiYnI+JyArXG4gICAgICAnPC9kaXY+JyArXG4gICAgICAnPHNtYWxsIGNsYXNzPVwiZGlzY2xhaW1lclwiPicgK1xuICAgICAgICAnQ29udHJpYnV0ZSB0byBjaXRpemVuIHNjaWVuY2UuIFBsZWFzZSA8YSBocmVmPVwiI3RlbGx1c1wiPnRlbGwgdXM8L2E+ICcgK1xuICAgICAgICAnYWJvdXQgeW91ciBleHBlcmllbmNlLicgK1xuICAgICAgJzwvc21hbGw+JztcbiAgfTtcblxuICAvKipcbiAgICogVXNlIGN1c3RvbSBhdHRyaWJ1dGlvbiBhcyB0aGlzIGNvbnRlbnQgaXMgZ2VuZXJhdGVkIGJ5IHVzZXItc3VibWl0dGVkXG4gICAqIGZlbHQgcmVwb3J0cyBmcm9tIHRoZSBcIlRlbGwgVXMhXCIgbGluay5cbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlclBpbkZvb3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5mb290ZXIuaW5uZXJIVE1MID0gJ0NpdGl6ZW4gU2NpZW50aXN0IENvbnRyaWJ1dGlvbnMnO1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERZRklGb3JtUGluVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgRXZlbnRzID0gcmVxdWlyZSgndXRpbC9FdmVudHMnKSxcbiAgICBGb3JtYXR0ZXIgPSByZXF1aXJlKCdjb3JlL0Zvcm1hdHRlcicpLFxuICAgIExvY2F0aW9uVmlldyA9IHJlcXVpcmUoJ2xvY2F0aW9udmlldy9Mb2NhdGlvblZpZXcnKSxcbiAgICBNb2RlbCA9IHJlcXVpcmUoJ212Yy9Nb2RlbCcpLFxuICAgIE1vZGFsVmlldyA9IHJlcXVpcmUoJ212Yy9Nb2RhbFZpZXcnKSxcbiAgICBRdWVzdGlvblZpZXcgPSByZXF1aXJlKCdxdWVzdGlvbnZpZXcvUXVlc3Rpb25WaWV3JyksXG4gICAgVGV4dFF1ZXN0aW9uVmlldyA9IHJlcXVpcmUoJ2R5ZmkvVGV4dFF1ZXN0aW9uVmlldycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKSxcbiAgICBWaWV3ID0gcmVxdWlyZSgnbXZjL1ZpZXcnKSxcbiAgICBYaHIgPSByZXF1aXJlKCd1dGlsL1hocicpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIGV2ZW50VGltZTogbnVsbCxcbiAgbGFuZ3VhZ2U6ICdlbicsXG4gIHVybDogJ2pzL2xhbmd1YWdlcy8nXG59O1xuXG52YXIgX0RZRklfRElTQ0xBSU1FUiA9XG4gICc8cCBjbGFzcz1cImFsZXJ0IGluZm9cIj4nICtcbiAgICAnVGhpcyBmb3JtIGlzIHN1YmplY3QgdG8gdGhlIFByaXZhY3kgQWN0IG9mIDE5NzQuJyArXG4gICc8L3A+JyArXG4gICc8cD4nICtcbiAgICAnPHN0cm9uZz5BdXRob3JpdHk8L3N0cm9uZz48YnIvPicgK1xuICAgICdUaGUgTmF0aW9uYWwgRWFydGhxdWFrZSBIYXphcmRzIFJlZHVjdGlvbiBQcm9ncmFtIChORUhSUCksIHdoaWNoICcgK1xuICAgICd3YXMgZmlyc3QgYXV0aG9yaXplZCBpbiAxOTc3LCBQdWJsaWMgTGF3IChQTCkgOTXigJMxMjQpLCBhbmQgbW9zdCAnICtcbiAgICAncmVjZW50bHkgcmVhdXRob3JpemVkIGluIDIwMDQgKE5FSFJQIFJlYXV0aG9yaXphdGlvbiBBY3Qgb2YgMjAwNCwgJyArXG4gICAgJ1BMIDEwOOKAkzM2MCcgK1xuICAnPC9wPicgK1xuICAnPHA+JyArXG4gICAgJzxzdHJvbmc+UHJpbmNpcGFsIFB1cnBvc2U8L3N0cm9uZz48YnIvPicgK1xuICAgICdUaGUgRWFydGhxdWFrZSBIYXphcmRzIFByb2dyYW0gcHJvdmlkZXMgcmFwaWQsIGF1dGhvcml0YXRpdmUgJyArXG4gICAgJ2luZm9ybWF0aW9uIG9uIGVhcnRocXVha2VzIGFuZCB0aGVpciBpbXBhY3QgdG8gZW1lcmdlbmN5IHJlc3BvbmRlcnMsICcgK1xuICAgICdnb3Zlcm5tZW50cywgZmFjaWxpdGllcyBtYW5hZ2VycyBhbmQgcmVzZWFyY2hlcnMgYWNyb3NzIHRoZSBjb3VudHJ5LicgK1xuICAnPC9wPicgK1xuICAnPHA+JyArXG4gICAgJzxzdHJvbmc+Um91dGluZSBVc2U8L3N0cm9uZz48YnIvPicgK1xuICAgICdVc2VkIHRvIGFsbG93IHVzZXJzIHRvIHJlcG9ydCBzaGFraW5nIGludGVuc2l0eSBvZiBlYXJ0aHF1YWtlIGV2ZW50cywgJyArXG4gICAgJ3RvIGFsbG93IHVzZXJzIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiBlYXJ0aHF1YWtlIGV2ZW50cywgYW5kIHRvICcgK1xuICAgICdhbGxvdyB1c2VycyB0byB2b2x1bnRlZXIgdG8gaGF2ZSBzZWlzbWljIGluc3RydW1lbnRhdGlvbiBpbnN0YWxsZWQgJyArXG4gICAgJ29uIHRoZWlyIHByb3BlcnR5LicgK1xuICAnPC9wPicgK1xuICAnPHA+JyArXG4gICAgJzxzdHJvbmc+RGlzY2xvc3VyZSBpcyBWb2x1bnRhcnk8L3N0cm9uZz48YnIvPicgK1xuICAgICdJZiB0aGUgaW5kaXZpZHVhbCBkb2VzIG5vdCBmdXJuaXNoIHRoZSBpbmZvcm1hdGlvbiByZXF1ZXN0ZWQsIHRoZXJlICcgK1xuICAgICd3aWxsIGJlIG5vIGFkdmVyc2UgY29uc2VxdWVuY2VzLiBIb3dldmVyLCBpZiB5b3UgZG8gbm90IHByb3ZpZGUgJyArXG4gICAgJ2NvbnRhY3QgaW5mb3JtYXRpb24gd2UgbWF5IGJlIHVuYWJsZSB0byBjb250YWN0IHlvdSBmb3IgYWRkaXRpb25hbCAnICtcbiAgICAnaW5mb3JtYXRpb24gdG8gdmVyaWZ5IHlvdXIgcmVzcG9uc2VzLicgK1xuICAnPC9wPicgK1xuICAnPHA+JyArXG4gICAgJzxzdHJvbmc+UHJpdmFjeSBBY3QgU3RhdGVtZW50PC9zdHJvbmc+PGJyLz4nICtcbiAgICAnWW91IGFyZSBub3QgcmVxdWlyZWQgdG8gcHJvdmlkZSB5b3VyIHBlcnNvbmFsIGNvbnRhY3QgaW5mb3JtYXRpb24gaW4nICtcbiAgICAnb3JkZXIgdG8gc3VibWl0IHlvdXIgc3VydmV5LiBIb3dldmVyLCBpZiB5b3UgZG8gbm90IHByb3ZpZGUgY29udGFjdCcgK1xuICAgICdpbmZvcm1hdGlvbiwgd2UgbWF5IGJlIHVuYWJsZSB0byBjb250YWN0IHlvdSBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbicgK1xuICAgICd0byB2ZXJpZnkgeW91ciByZXNwb25zZXMuIElmIHlvdSBkbyBwcm92aWRlIGNvbnRhY3QgaW5mb3JtYXRpb24sIHRoaXMnICtcbiAgICAnaW5mb3JtYXRpb24gd2lsbCBvbmx5IGJlIHVzZWQgdG8gaW5pdGlhdGUgZm9sbG93LXVwIGNvbW11bmljYXRpb25zIHdpdGgnICtcbiAgICAneW91LiBUaGUgcmVjb3JkcyBmb3IgdGhpcyBjb2xsZWN0aW9uIHdpbGwgYmUgbWFpbnRhaW5lZCBpbiB0aGUnICtcbiAgICAnYXBwcm9wcmlhdGUgUHJpdmFjeSBBY3QgU3lzdGVtIG9mIFJlY29yZHMgaWRlbnRpZmllZCBhcyBFYXJ0aHF1YWtlJyArXG4gICAgJ0hhemFyZHMgUHJvZ3JhbSBFYXJ0aHF1YWtlIEluZm9ybWF0aW9uLiAoSU5URVJJT1IvVVNHUy0yKSBwdWJsaXNoZWQnICtcbiAgICAnYXQgNzQgRlIgMzQwMzMgKEp1bHkgMTQsMjAwOSkuJyArXG4gICc8L3A+JyArXG4gICc8cD4nICtcbiAgICAnPHN0cm9uZz5QYXBlcndvcmsgUmVkdWN0aW9uIEFjdCBTdGF0ZW1lbnQ8L3N0cm9uZz48YnIvPicgK1xuICAgICdUaGUgUGFwZXJ3b3JrIFJlZHVjdGlvbiBBY3Qgb2YgMTk5NSAoNDQgVS5TLkMuIDM1MDEgZXQuIHNlcS4pIHJlcXVpcmVzICcgK1xuICAgICd1cyB0byBpbmZvcm0geW91IHRoYXQgdGhpcyBpbmZvcm1hdGlvbiBpcyBiZWluZyBjb2xsZWN0ZWQgdG8gc3VwcGxlbWVudCAnICtcbiAgICAnaW5zdHJ1bWVudGFsIGRhdGEgYW5kIHRvIHByb21vdGUgcHVibGljIHNhZmV0eSB0aHJvdWdoIGJldHRlciAnICtcbiAgICAndW5kZXJzdGFuZGluZyBvZiBlYXJ0aHF1YWtlcy4gUmVzcG9uc2UgdG8gdGhpcyByZXF1ZXN0IGlzIHZvbHVudGFyeS4gJyArXG4gICAgJ1B1YmxpYyByZXBvcnRpbmcgZm9yIHRoaXMgZm9ybSBpcyBlc3RpbWF0ZWQgdG8gYXZlcmFnZSA2IG1pbnV0ZXMgcGVyICcgK1xuICAgICdyZXNwb25zZSwgaW5jbHVkaW5nIHRoZSB0aW1lIGZvciByZXZpZXdpbmcgaW5zdHJ1Y3Rpb25zIGFuZCBjb21wbGV0aW5nICcgK1xuICAgICd0aGUgZm9ybS4gQSBGZWRlcmFsIGFnZW5jeSBtYXkgbm90IGNvbmR1Y3Qgb3Igc3BvbnNvciwgYW5kIGEgcGVyc29uIGlzICcgK1xuICAgICdub3QgcmVxdWlyZWQgdG8gcmVzcG9uZCB0bywgYSBjb2xsZWN0aW9uIG9mIGluZm9ybWF0aW9uIHVubGVzcyBpdCAnICtcbiAgICAnZGlzcGxheXMgYSBjdXJyZW50bHkgdmFsaWQgT01CIENvbnRyb2wgTnVtYmVyLiBDb21tZW50cyByZWdhcmRpbmcgdGhpcyAnICtcbiAgICAnY29sbGVjdGlvbiBvZiBpbmZvcm1hdGlvbiBzaG91bGQgYmUgZGlyZWN0ZWQgdG86IEJ1cmVhdSBDbGVhcmFuY2UgJyArXG4gICAgJ29mZmljZXIsIFUuUy4gR2VvbG9naWNhbCBTdXJ2ZXksIDgwNyBOYXRpb25hbCBDZW50ZXIsIFJlc3RvbiwgVkEgMjAxOTIuJyArXG4gICc8L3A+JztcblxuXG4vKipcbiAqIFZpZXcgZm9yIHRoZSBEWUZJIEZvcm0uIFRoaXMgdmlldyByZXRyaWV2ZXMgdGhlIHF1ZXN0aW9ucy9hbnN3ZXJzIGZyb20gdGhlXG4gKiBhcHByb3ByaWF0ZSBsYW5ndWFnZSBvYmplY3QsIGJ1aWxkcyB0aGUgZm9ybSwgYW5kIGJpbmRzIHRoZSBxdWVzdGlvbnMgdG9cbiAqIHRoZSBtb2RlbCB1c2luZyB0aGUgdXBkYXRlTW9kZWwgbWV0aG9kLlxuKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyBtb2R1bGUuIFNlZSBfaW5pdGlhbGl6ZSBtZXRob2RcbiAqICAgICBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuICpcbiAqIENsYXNzIHZhcmlhYmxlcy5cbiAqICBfZGF0YToge29iamVjdH0gQ29udGFpbnMgdGhlIHF1ZXN0aW9ucy9hbnN3ZXJzIGZyb20gdGhlIGxhbmd1YWdlIG9iamVjdC5cbiAqICBfcXVlc3Rpb25zOiB7b2piZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcXVlc3Rpb24gdmlld3MuXG4gKi9cbnZhciBEWUZJRm9ybVZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2N1ckxvYyxcbiAgICAgIF9kYXRhLFxuICAgICAgX2Zvcm1hdHRlcixcbiAgICAgIF9sb2NhdGlvbkJ1dHRvbixcbiAgICAgIF9sb2NhdGlvbkRpc3BsYXksXG4gICAgICBfbG9jYXRpb25WaWV3LFxuICAgICAgX3F1ZXN0aW9ucyxcbiAgICAgIF91cmw7XG5cblxuICBfdGhpcyA9IFZpZXcob3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLiBJbml0aWFsaXplcyBhIG5ldyBEWUZJVmlldy5cbiAgICpcbiAgICogQHBhcmFtcyBsYW5ndWFnZSB7c3RyaW5nfVxuICAgKiAgICBUaGUgbGFuZ3VhZ2UgdG8gZmV0Y2ggdGhlIHF1ZXN0aW9ucyBmb3IuXG4gICAqIEBwYXJhbXMgZXZlbnRUaW1lIHtzdHJpbmd9XG4gICAqICAgIFRoZSB0aW1lIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtcyB1cmwge3N0cmluZ31cbiAgICogICAgVGhlIHVybCBsb2NhdGlvbiBmb3IgdGhlIGxhbmd1YWdlL3F1ZXN0aW9ucyBvYmplY3QuXG4gICAqL1xuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgX2N1ckxvYyA9IHt9O1xuICAgIF9kYXRhID0gbnVsbDtcbiAgICBfZm9ybWF0dGVyID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgRm9ybWF0dGVyKCk7XG4gICAgX2xvY2F0aW9uVmlldyA9IG51bGw7XG4gICAgX3F1ZXN0aW9ucyA9IHt9O1xuICAgIF91cmwgPSBvcHRpb25zLnVybDtcblxuICAgIGlmICghX3RoaXMubW9kZWwuZ2V0KCdsYW5ndWFnZScpKSB7XG4gICAgICBfdGhpcy5tb2RlbC5zZXQoe2xhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlfSwge3NpbGVudDogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGlmICghX3RoaXMubW9kZWwuZ2V0KCdldmVudFRpbWUnKSkge1xuICAgICAgX3RoaXMubW9kZWwuc2V0KHtldmVudFRpbWU6IG9wdGlvbnMuZXZlbnRUaW1lfSwge3NpbGVudDogdHJ1ZX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5tb2RlbC5zZXQoe2NpaW1fdGltZTogX3RoaXMubW9kZWwuZ2V0KCdldmVudFRpbWUnKX0sXG4gICAgICAgICAge3NpbGVudDogdHJ1ZX0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBMaXN0ZW5lcnMgdG8gYWxsIHF1ZXN0aW9ucyBpbiB0aGUgcXVlc3Rpb25zIG9iamVjdC5cbiAgICovXG4gIF90aGlzLmFkZFF1ZXN0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGZpZWxkIGluIF9xdWVzdGlvbnMpIHtcbiAgICAgIF9xdWVzdGlvbnNbZmllbGRdLm9uKCdjaGFuZ2UnLCBfdGhpcy51cGRhdGVNb2RlbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgREZZSSBGb3JtXG4gICAqICBTcGlucyB0aHJvdWdoIHRoZSBxdWVzdGlvbnMgb2JqZWN0LCBhbmQgYnVpbGRzIHRoZSBhcHByb3ByaWF0ZSBzZWN0aW9ucy5cbiAgICovXG4gIF90aGlzLmNyZWF0ZUZvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsLFxuICAgICAgICAvLyBGb3JtIEVsZW1lbnRzXG4gICAgICAgIGJhc2VRdWVzdGlvbnNFbCxcbiAgICAgICAgY29udGFjdENvbnRhaW5lcixcbiAgICAgICAgZGlzY2xhaW1lckVsLFxuICAgICAgICBoZWFkZXIsXG4gICAgICAgIG1vcmVRdWVzdGlvbnNFbCxcbiAgICAgICAgdG9nZ2xlQ29udGFpbmVyLFxuICAgICAgICAvLyBkYXRhIGluZm9ybWF0aW9uXG4gICAgICAgIGJhc2VRdWVzdGlvbnMsXG4gICAgICAgIGNvbnRhY3RJbmZvLFxuICAgICAgICBldmVudFRpbWUsXG4gICAgICAgIG1vcmVRdWVzdGlvbnMsXG4gICAgICAgIGxvY2F0aW9uSW5mbyxcbiAgICAgICAgdG9nZ2xlSW5mbztcblxuICAgIGVsID0gX3RoaXMuZWw7XG5cbiAgICBiYXNlUXVlc3Rpb25zID0gX2RhdGEuYmFzZVF1ZXN0aW9ucztcbiAgICBjb250YWN0SW5mbyA9IF9kYXRhLmNvbnRhY3RJbmZvO1xuICAgIGV2ZW50VGltZSA9IF9kYXRhLmV2ZW50VGltZTtcbiAgICBtb3JlUXVlc3Rpb25zID0gX2RhdGEubW9yZVF1ZXN0aW9ucztcbiAgICBsb2NhdGlvbkluZm8gPSBfZGF0YS5sb2NhdGlvbkluZm87XG4gICAgdG9nZ2xlSW5mbyA9IF9kYXRhLnRvZ2dsZUluZm87XG5cbiAgICBoZWFkZXIgPSBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoZWFkZXInKSk7XG4gICAgaGVhZGVyLmNsYXNzTGlzdC5hZGQoJ2R5ZmktZm9ybS1oZWFkZXInKTtcblxuICAgIGJhc2VRdWVzdGlvbnNFbCA9IGVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICBiYXNlUXVlc3Rpb25zRWwuY2xhc3NMaXN0LmFkZCgnZHlmaS1yZXF1aXJlZC1xdWVzdGlvbnMnKTtcblxuICAgIHRvZ2dsZUNvbnRhaW5lciA9IGVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICB0b2dnbGVDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZHlmaS1vcHRpb25hbC1jYWxsb3V0Jyk7XG4gICAgdG9nZ2xlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0Jyk7XG4gICAgdG9nZ2xlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2luZm8nKTtcblxuICAgIG1vcmVRdWVzdGlvbnNFbCA9IGVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICBtb3JlUXVlc3Rpb25zRWwuY2xhc3NMaXN0LmFkZCgnZHlmaS1vcHRpb25hbC1xdWVzdGlvbnMnKTtcblxuICAgIGNvbnRhY3RDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWN0Q29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2R5ZmktY29udGFjdC1xdWVzdGlvbnMnKTtcbiAgICBjb250YWN0Q29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0Jyk7XG5cbiAgICBkaXNjbGFpbWVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgICBoZWFkZXIuaW5uZXJIVE1MID0gJzxoMiBjbGFzcz1cImZlbHQtaGVhZGVyXCI+RmVsdCBSZXBvcnQgLSBUZWxsIFVzITwvaDI+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwib21iLW51bWJlclwiPicgK1xuICAgICAgICAgICdPTUIgTm8uIDEwMjgtMDA0OCcgK1xuICAgICAgICAgICc8YnIvPicgK1xuICAgICAgICAgICdFeHBpcmVzIDA1LzMxLzIwMTgnICtcbiAgICAgICAgJzwvZGl2Pic7XG5cbiAgICAvLyBIYW5kbGUgbG9jYXRpb24gcXVlc3Rpb25cbiAgICBfdGhpcy5jcmVhdGVMb2NhdGlvblF1ZXN0aW9ucyhsb2NhdGlvbkluZm8sIGJhc2VRdWVzdGlvbnNFbCk7XG5cbiAgICBpZiAoX3RoaXMubW9kZWwuZ2V0KCdldmVudFRpbWUnKSA9PT0gbnVsbCkge1xuICAgICAgICBfdGhpcy5jcmVhdGVUZXh0UXVlc3Rpb24oZXZlbnRUaW1lLCBiYXNlUXVlc3Rpb25zRWwpO1xuICAgIH1cblxuICAgIC8vIExvb3Agb3ZlciBlYWNoIGJhc2UgcXVlc3Rpb24gYW5kIGNyZWF0ZSBhIFF1ZXN0aW9uVmlld1xuICAgIF90aGlzLmNyZWF0ZVF1ZXN0aW9ucyhiYXNlUXVlc3Rpb25zLCBiYXNlUXVlc3Rpb25zRWwpO1xuXG4gICAgICAvLyBWaXN1YWwgY29udHJvbCB0byBzaG93L2hpZGUgbW9yZVF1ZXN0aW9uc0VsXG4gICAgX3RoaXMuY3JlYXRlVG9nZ2xlQ29udHJvbCh0b2dnbGVJbmZvLCB0b2dnbGVDb250YWluZXIpO1xuXG4gICAgLy8gTG9vcCBvdmVyIGVhY2ggYWRkaXRpb25hbCBxdWVzdGlvbiBhbmQgY3JlYXRlIGEgUXVlc3Rpb25WaWV3XG4gICAgX3RoaXMuY3JlYXRlUXVlc3Rpb25zKG1vcmVRdWVzdGlvbnMsIG1vcmVRdWVzdGlvbnNFbCk7XG5cbiAgICAvLyBIYW5kbGUgYWRkaXRpb25hbCBjb21tZW50c1xuICAgIF90aGlzLmNyZWF0ZVRleHRRdWVzdGlvbihfZGF0YS5jb21tZW50cywgbW9yZVF1ZXN0aW9uc0VsKTtcblxuICAgIC8vIEhhbmRsZSBjb250YWN0IGluZm9ybWF0aW9uXG4gICAgY29udGFjdENvbnRhaW5lci5pbm5lckhUTUwgPSAnPGxlZ2VuZD5Db250YWN0IEluZm9ybWF0aW9uJyArXG4gICAgICAgICcgPHNtYWxsPihvcHRpb25hbCk8L3NtYWxsPjwvbGVnZW5kPic7XG4gICAgX3RoaXMuY3JlYXRlVGV4dFF1ZXN0aW9uKGNvbnRhY3RJbmZvLCBjb250YWN0Q29udGFpbmVyKTtcbiAgICBtb3JlUXVlc3Rpb25zRWwuYXBwZW5kQ2hpbGQoY29udGFjdENvbnRhaW5lcik7XG5cbiAgICAvLyBBZGQgZGlzY2xhaW1lciBsaW5rXG4gICAgZGlzY2xhaW1lckVsLmNsYXNzTmFtZSA9ICdkeWZpLWRpc2NsYWltZXInO1xuICAgIGRpc2NsYWltZXJFbC5ocmVmID0gJy9yZXNlYXJjaC9keWZpL2Rpc2NsYWltZXIucGhwI0RZRklGb3JtRGlzY2xhaW1lcic7XG4gICAgZGlzY2xhaW1lckVsLmlubmVySFRNTCA9ICdQUkEgLSBQcml2YWN5IFN0YXRlbWVudCc7XG4gICAgZGlzY2xhaW1lckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBkaWFsb2cgPSBNb2RhbFZpZXcoX0RZRklfRElTQ0xBSU1FUiwge1xuICAgICAgICB0aXRsZTogJ1BSQSAtIFByaXZhY3kgU3RhdGVtZW50JyxcbiAgICAgICAgY2xvc2FibGU6IGZhbHNlLFxuICAgICAgICBidXR0b25zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dDogJ09LJyxcbiAgICAgICAgICAgIGNsYXNzZXM6IFsnZ3JlZW4nXSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRpYWxvZy5oaWRlKCk7XG4gICAgICAgICAgICAgIGRpYWxvZy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgIGRpYWxvZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcblxuICAgICAgZGlhbG9nLnNob3coKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcblxuICAgIGNvbnRhY3RDb250YWluZXIuYXBwZW5kQ2hpbGQoZGlzY2xhaW1lckVsKTtcblxuICAgIF90aGlzLnN5bmNoUXVlc3Rpb25BbnN3ZXJzKCk7XG4gICAgX3RoaXMuYWRkUXVlc3Rpb25MaXN0ZW5lcnMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBMb2NhdGlvbiBRdWVzdGlvbnMuXG4gICAqICAgIExvY2F0aW9uIHF1ZXN0aW9ucyBhcmUgbm90IHZpc2libGUgdG8gdXNlcnMsIGluc3RlYWQgYSBidXR0b24gaXNcbiAgICogICAgdmlzaWJsZSB0aGF0IGNhbGxzIGEgTG9jYXRpb25WaWV3LiBXaGljaCB0aGVuIGZpbGxzIGluIHRoZVxuICAgKiAgICBsb2NhdGlvbiBxdWVzdGlvbnMuIFRoZSBsb2NhdGlvbiBxdWVzdGlvbnMgYXJlIGEgbWluaW11bSBzdWJzZXQgb2ZcbiAgICogICAgdGhlIFF1ZXN0aW9uVmlldyBBUEkuXG4gICAqXG4gICAqIEBwYXJhbXMgcXVlc3Rpb25JbmZvIHtvYmplY3R9XG4gICAqICAgIGxvY2F0aW9uSW5mbzoge29iamVjdH1cbiAgICogICAgICBsYWJlbDoge3N0cmluZ31cbiAgICogICAgICBidXR0b246IHtzdHJpbmd9XG4gICAqICAgICAgYnV0dG9uVXBkYXRlOiB7c3RyaW5nfVxuICAgKiBAcGFyYW1zIGNvbnRhaW5lciB7ZG9tIGVsZW1lbnR9XG4gICAqL1xuICBfdGhpcy5jcmVhdGVMb2NhdGlvblF1ZXN0aW9ucyA9IGZ1bmN0aW9uIChxdWVzdGlvbkluZm8sIGNvbnRhaW5lcikge1xuICAgIHZhciBmaWVsZHNldCxcbiAgICAgICAgbGVnZW5kLFxuICAgICAgICBzZWN0aW9uO1xuXG4gICAgc2VjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlY3Rpb24nKTtcbiAgICBmaWVsZHNldCA9IHNlY3Rpb24uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmllbGRzZXQnKSk7XG4gICAgbGVnZW5kID0gZmllbGRzZXQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGVnZW5kJykpO1xuICAgIF9sb2NhdGlvbkRpc3BsYXkgPSBmaWVsZHNldC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgX2xvY2F0aW9uQnV0dG9uID0gZmllbGRzZXQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJykpO1xuXG4gICAgc2VjdGlvbi5jbGFzc0xpc3QuYWRkKCdxdWVzdGlvbicpO1xuICAgIGxlZ2VuZC5pbm5lckhUTUwgPSBxdWVzdGlvbkluZm8ubGFiZWw7XG4gICAgX2xvY2F0aW9uQnV0dG9uLmlubmVySFRNTCA9IHF1ZXN0aW9uSW5mby5idXR0b247XG4gICAgX2xvY2F0aW9uQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2xvY2F0aW9uLWJ1dHRvbicpO1xuXG4gICAgLy8gQWRkIFF1ZXN0aW9uVmlldy1saWtlIG9iamVjdHMgdG8gdGhlIGxpc3Qgb2YgcXVlc3Rpb25zXG4gICAgX3F1ZXN0aW9ucy5jaWltX21hcExhdCA9IEV2ZW50cygpO1xuICAgIF9xdWVzdGlvbnMuY2lpbV9tYXBMYXQubW9kZWwgPSBNb2RlbCh7ZmllbGQ6J2NpaW1fbWFwTGF0J30pO1xuICAgIF9xdWVzdGlvbnMuY2lpbV9tYXBMYXQuZ2V0QW5zd2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7dmFsdWU6IF9jdXJMb2MubGF0aXR1ZGV9O1xuICAgIH07XG4gICAgX3F1ZXN0aW9ucy5jaWltX21hcExhdC5zZXRBbnN3ZXJzID0gZnVuY3Rpb24gKGxhdGl0dWRlKSB7XG4gICAgICBfY3VyTG9jLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgfTtcblxuICAgIF9xdWVzdGlvbnMuY2lpbV9tYXBMb24gPSBFdmVudHMoKTtcbiAgICBfcXVlc3Rpb25zLmNpaW1fbWFwTG9uLm1vZGVsID0gTW9kZWwoe2ZpZWxkOidjaWltX21hcExvbid9KTtcbiAgICBfcXVlc3Rpb25zLmNpaW1fbWFwTG9uLmdldEFuc3dlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge3ZhbHVlOiBfY3VyTG9jLmxvbmdpdHVkZX07XG4gICAgfTtcbiAgICBfcXVlc3Rpb25zLmNpaW1fbWFwTG9uLnNldEFuc3dlcnMgPSBmdW5jdGlvbiAobG9uZ2l0dWRlKSB7XG4gICAgICBfY3VyTG9jLmxvbmdpdHVkZSA9IGxvbmdpdHVkZTtcbiAgICB9O1xuXG4gICAgX3F1ZXN0aW9ucy5jaWltX21hcENvbmZpZGVuY2UgPSBFdmVudHMoKTtcbiAgICBfcXVlc3Rpb25zLmNpaW1fbWFwQ29uZmlkZW5jZS5tb2RlbCA9IE1vZGVsKHtmaWVsZDonY2lpbV9tYXBDb25maWRlbmNlJ30pO1xuICAgIF9xdWVzdGlvbnMuY2lpbV9tYXBDb25maWRlbmNlLmdldEFuc3dlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7dmFsdWU6IF9jdXJMb2MuY29uZmlkZW5jZX07XG4gICAgfTtcbiAgICBfcXVlc3Rpb25zLmNpaW1fbWFwQ29uZmlkZW5jZS5zZXRBbnN3ZXJzID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBfcXVlc3Rpb25zLmNpaW1fbWFwQWRkcmVzcyA9IEV2ZW50cygpO1xuICAgIF9xdWVzdGlvbnMuY2lpbV9tYXBBZGRyZXNzLm1vZGVsID0gTW9kZWwoe2ZpZWxkOidjaWltX21hcEFkZHJlc3MnfSk7XG4gICAgX3F1ZXN0aW9ucy5jaWltX21hcEFkZHJlc3MuZ2V0QW5zd2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt2YWx1ZTogX2N1ckxvYy5wbGFjZX07XG4gICAgfTtcbiAgICBfcXVlc3Rpb25zLmNpaW1fbWFwQWRkcmVzcy5zZXRBbnN3ZXJzID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBfbG9jYXRpb25WaWV3ID0gTG9jYXRpb25WaWV3KCk7XG5cbiAgICBfbG9jYXRpb25WaWV3Lm9uKCdsb2NhdGlvbicsIF90aGlzLmxvY2F0aW9uQ2FsbGJhY2spO1xuXG4gICAgX2xvY2F0aW9uQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX2xvY2F0aW9uVmlldy5zaG93KHtpbml0aWFsTG9jYXRpb246IF9jdXJMb2N9KTtcbiAgICB9KTtcblxuICAgIC8vIEFwcGVuZCBjb250ZW50IHRvIGNvbnRhaW5lclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBpdGVyYXRlIG92ZXIgYSBoYXNoIG9mIHF1ZXN0aW9uSW5mbyBjcmVhdGluZyBhIHZpZXdcbiAgICogZm9yIGVhY2ggcXVlc3Rpb24sIGFwcGVuZGluZyB0aGUgdmlld3MgY29udGVudCB0byB0aGUgY29udGFpbmVyLCBhbmRcbiAgICogaG9sZGluZyBvbiB0byBhIHJlZmVyZW5jZSB0byB0aGF0IHZpZXcgb24gdGhlIHF1ZXN0aW9uIGhhc2ggKGtleWVkIGJ5IHRoZVxuICAgKiBzYW1lIGZpZWxkIGFzIGluIHRoZSBxdWVzdGlvbkluZm8gaGFzaCkuXG4gICAqXG4gICAqIEBwYXJhbSBxdWVzdGlvbkluZm8ge09iamVjdH1cbiAgICogICAgICBBbiBvYmplY3Qgb2YgcXVlc3Rpb24gaW5mb3JtYXRpb24ga2V5ZWQgYnkgdGhlIGZpZWxkIG5hbWVcbiAgICogICAgICBjb3JyZXNwb25kaW5nIHRvIHRoYXQgaW5mb3JtYXRpb24gYXMgZXhwZWN0ZWQgYnkgdGhlIERZRkkgZm9ybVxuICAgKiAgICAgIHByb2Nlc3NpbmcgY29kZS5cbiAgICogQHBhcmFtIGNvbnRhaW5lciB7RE9NRWxlbWVudH0gcGFzcy1ieS1yZWZlcmVuY2VcbiAgICogICAgICBUaGUgY29udGFpbmVyIGludG8gd2hpY2ggdGhlIHZpZXcuZWwgc2hvdWxkIGJlIGFwcGVuZGVkLlxuICAgKi9cbiAgX3RoaXMuY3JlYXRlUXVlc3Rpb25zID0gZnVuY3Rpb24gKHF1ZXN0aW9uSW5mbywgY29udGFpbmVyKSB7XG4gICAgdmFyIGZpZWxkID0gbnVsbCxcbiAgICAgICAgdmlldyA9IG51bGw7XG5cbiAgICBmb3IgKGZpZWxkIGluIHF1ZXN0aW9uSW5mbykge1xuICAgICAgdmlldyA9IFF1ZXN0aW9uVmlldyhVdGlsLmV4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbDogZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBxdWVzdGlvbkluZm9bZmllbGRdLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZGVsOiBNb2RlbCh7ZmllbGQ6IGZpZWxkfSlcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIF9xdWVzdGlvbnNbZmllbGRdID0gdmlldztcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2aWV3LmVsKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzZXQgb2YgdGV4dCBxdWVzdGlvbnMuXG4gICAqICAgIHNlZSBjcmVhdGVRdWVzdGlvbnMgZm9yIGdlbmVyYWwgb3ZlcnZpZXcuXG4gICAqICAgIFRoZSBtYWluIGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIGNhbGxzIFRleHRRdWVzdGlvblZpZXdcbiAgICogICAgdG8gaGFuZGxlIHF1ZXN0aW9ucyB0aGF0IHVzZSBpbnB1dC9UZXh0LUFyZWEgYXMgaXQncyB0eXBlLlxuICAgKi9cbiAgX3RoaXMuY3JlYXRlVGV4dFF1ZXN0aW9uID0gZnVuY3Rpb24gKHF1ZXN0aW9uSW5mbywgY29udGFpbmVyKSB7XG4gICAgdmFyIGZpZWxkID0gbnVsbCxcbiAgICAgICAgdmlldyA9IG51bGw7XG5cbiAgICBmb3IgKGZpZWxkIGluIHF1ZXN0aW9uSW5mbykge1xuICAgICAgdmlldyA9IFRleHRRdWVzdGlvblZpZXcoVXRpbC5leHRlbmQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZWw6IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcXVlc3Rpb25JbmZvW2ZpZWxkXSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2RlbDogTW9kZWwoe2ZpZWxkOiBmaWVsZH0pXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICBfcXVlc3Rpb25zW2ZpZWxkXSA9IHZpZXc7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodmlldy5lbCk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIHNldHMgdGhlIHRleHQgb2YgdGhlIHRvZ2dsZSBjb250cm9sLCB3aGljaCBpbmZvcm1zIHRoZSB1c2VyIHdoZXRoZXJcbiAgICogdGhleSBuZWVkIHRvIGNvbnRpbnVlIGZpbGxpbmcgdGhlIGZvcm0gb3Igbm90LlxuICAgKi9cbiAgX3RoaXMuY3JlYXRlVG9nZ2xlQ29udHJvbCA9IGZ1bmN0aW9uIChpbmZvLCBjb250cm9sKSB7XG4gICAgY29udHJvbC5pbm5lckhUTUwgPSBpbmZvLmRlc2NyaXB0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGcmVlIHJlZmVyZW5jZXMuXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3F1ZXN0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgX3RoaXMuZGVzdHJveUZvcm0oKTtcbiAgICAgIF9xdWVzdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChfbG9jYXRpb25WaWV3KSB7XG4gICAgICBfbG9jYXRpb25WaWV3LmRlc3Ryb3koKTtcbiAgICAgIF9sb2NhdGlvblZpZXcgPSBudWxsO1xuICAgIH1cblxuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBxdWVzdGlvbnMgaW4gdGhlIEZvcm0uXG4gICAqL1xuICBfdGhpcy5kZXN0cm95Rm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBmaWVsZCBpbiBfcXVlc3Rpb25zKSB7XG4gICAgICBfcXVlc3Rpb25zW2ZpZWxkXS5vZmYoJ2NoYW5nZScpO1xuICAgICAgX3F1ZXN0aW9uc1tmaWVsZF0uZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGxpc3Qgb2YgcXVlc3Rpb25zLlxuICAgKiAgIFRoaXMgZXhpc3RzIGZvciB0ZXN0aW5nLCBfcXVlc3Rpb25zIHNob3VsZCBiZSBjb25zaWRlcmVkIHByaXZhdGUuXG4gICAqL1xuICBfdGhpcy5nZXRRdWVzdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9xdWVzdGlvbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIGNoYW5nZWQge29iamVjdH1cbiAgICogICAgQ29udGFpbnMgYSBrZXk6dmFsdWUgcGFpciBvZiBhbnkgcXVlc3Rpb24gdGhhdCBoYXMgY2hhbmdlZC5cbiAgICogICAgSWYgdGhlIG9iamVjdCBpcyBudWxsLCBvciBpZiB0aGUga2V5IGlzIGxhbmd1YWdlLCB0aGVuIHRoZVxuICAgKiAgICBlbnRpcmUgZm9ybSBpcyByZW5kZXJlZCwgYWZ0ZXIgZmV0Y2hpbmcgdGhlIGxhbmd1YWdlIG9iamVjdC5cbiAgICogICAgSWYgaXQgY29udGFpbnMgYW55IG90aGVyIGtleSwgaXQgdXBkYXRlcyB0aGUgc3BlY2lmaWMgYW5zd2VyLlxuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKGNoYW5nZWQpIHtcbiAgICBpZiAoIWNoYW5nZWQgfHwgY2hhbmdlZC5oYXNPd25Qcm9wZXJ0eSgnbGFuZ3VhZ2UnKSkge1xuICAgICAgX3RoaXMucmVuZGVyUXVlc3Rpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMudXBkYXRlQW5zd2VyKGNoYW5nZWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY2FsbGJhY2sgZm9yIHRoZSBMb2NhdGlvblZpZXcuXG4gICAqICBXaGVuIExvY2F0aW9uVmlldyBpcyBkb25lLCBpdCBjYWxscyB0aGlzIGZ1bmN0aW9uLCB3aGljaCB0aGVuIHNldHMgdGhlXG4gICAqICBsb2NhdGlvbiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbXMgbG9jYXRpb25PYmplY3Qge2xvY2F0aW9uT2JqZWN0fVxuICAgKiAgICBzZWUgbG9jYXRpb25WaWV3XG4gICAqXG4gICAqIE5vdGVzOiBUcmlnZ2VycyBjaGFuZ2Ugb24gdGhlIGxhdGl0dWRlLCBhbmQgbG9uZ2l0dWRlIFwicXVlc3Rpb25zXCJcbiAgICovXG4gIF90aGlzLmxvY2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiAobG9jYXRpb25PYmplY3QpIHtcbiAgICB2YXIgY29uZmlkZW5jZSxcbiAgICAgICAgbWFya3VwID0gW10sXG4gICAgICAgIHByZXR0eUxhdCA9IG51bGwsXG4gICAgICAgIHByZXR0eUxuZyA9IG51bGw7XG5cbiAgICBfY3VyTG9jID0gbG9jYXRpb25PYmplY3Q7XG4gICAgY29uZmlkZW5jZSA9IChfY3VyTG9jLmNvbmZpZGVuY2UgPT09IC0xID8gMCA6IF9jdXJMb2MuY29uZmlkZW5jZSk7XG5cbiAgICBwcmV0dHlMYXQgPSBfY3VyTG9jLmxhdGl0dWRlO1xuICAgIGlmIChwcmV0dHlMYXQgPCAwLjApIHtcbiAgICAgIHByZXR0eUxhdCA9ICgtMS4wKnByZXR0eUxhdCkudG9GaXhlZChjb25maWRlbmNlKSArICcmZGVnO1MnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV0dHlMYXQgPSBwcmV0dHlMYXQudG9GaXhlZChjb25maWRlbmNlKSArICcmZGVnO04nO1xuICAgIH1cblxuICAgIHByZXR0eUxuZyA9IF9jdXJMb2MubG9uZ2l0dWRlO1xuICAgIGlmIChwcmV0dHlMbmcgPCAwLjApIHtcbiAgICAgIHByZXR0eUxuZyA9ICgtMS4wKnByZXR0eUxuZykudG9GaXhlZChjb25maWRlbmNlKSArICcmZGVnO1cnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV0dHlMbmcgPSBwcmV0dHlMbmcudG9GaXhlZChjb25maWRlbmNlKSArICcmZGVnO0UnO1xuICAgIH1cblxuICAgIGlmIChfY3VyTG9jLnBsYWNlICE9PSBudWxsKSB7XG4gICAgICBtYXJrdXAucHVzaChfY3VyTG9jLnBsYWNlICsgJzxici8+Jyk7XG4gICAgfVxuXG4gICAgX2xvY2F0aW9uRGlzcGxheS5jbGFzc0xpc3QuYWRkKCdsb2NhdGlvbi1yZXN1bHQnLCAnYWxlcnQnLCAnc3VjY2VzcycpO1xuXG4gICAgX2xvY2F0aW9uRGlzcGxheS5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJhZGRyZXNzXCI+JyArXG4gICAgICAgICgoX2N1ckxvYy5wbGFjZSkgPyAoX2N1ckxvYy5wbGFjZSArICc8L3NwYW4+JykgOiAnJykgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJjb29yZGluYXRlc1wiPicgK1xuICAgICAgICBwcmV0dHlMYXQgKyAnLCAnICsgcHJldHR5TG5nICtcbiAgICAgICAgKChfY3VyTG9jLnBsYWNlKSA/ICcnIDogJzwvc3Bhbj4nKTtcblxuXG4gICAgX2xvY2F0aW9uQnV0dG9uLmlubmVySFRNTCA9IF9kYXRhLmxvY2F0aW9uSW5mby5idXR0b25VcGRhdGU7XG5cbiAgICBfcXVlc3Rpb25zLmNpaW1fbWFwTGF0LnRyaWdnZXIoJ2NoYW5nZScsIF9xdWVzdGlvbnMuY2lpbV9tYXBMYXQpO1xuICAgIF9xdWVzdGlvbnMuY2lpbV9tYXBMb24udHJpZ2dlcignY2hhbmdlJywgX3F1ZXN0aW9ucy5jaWltX21hcExvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIFF1ZXN0aW9uIGZvcm0gYWZ0ZXIgZmV0Y2hpbmcgdGhlIGxhbmd1YWdlIG9iamVjdC5cbiAgICovXG4gIF90aGlzLnJlbmRlclF1ZXN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFuZ3VhZ2U7XG5cbiAgICBsYW5ndWFnZSA9IF90aGlzLm1vZGVsLmdldCgnbGFuZ3VhZ2UnKTtcblxuICAgIFhoci5hamF4KHtcbiAgICAgIHVybDogX3VybCArIGxhbmd1YWdlICsgJy5qc29uJyxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChfZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLmRlc3Ryb3lGb3JtKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfZGF0YSA9IGRhdGE7XG4gICAgICAgIF90aGlzLmNyZWF0ZUZvcm0oKTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIE1vZGVsIHdoZW4gYSBxdWVzdGlvbiBpcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW1zIHF1ZXN0aW9uIHtRdWVzdGlvblZpZXd9XG4gICAqICAgIFRoZSBxdWVzdGlvbiB0aGF0IGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgX3RoaXMudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAocXVlc3Rpb24pIHtcbiAgICB2YXIgYW5zd2VyLFxuICAgICAgICBmaWVsZDtcblxuICAgIGZpZWxkID0gcXVlc3Rpb24ubW9kZWwuZ2V0KCdmaWVsZCcpO1xuICAgIGFuc3dlciA9IHF1ZXN0aW9uLmdldEFuc3dlcnMoKTtcblxuICAgIF90aGlzLm1vZGVsLnNldChfdGhpcy5zdHJpcEFuc3dlcihmaWVsZCwgYW5zd2VyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBBbnN3ZXIgZm9yIGEgcXVlc3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbXMgY2hhbmdlZCB7b2JqZWN0fVxuICAgKiAgICAgaG9sZHMgYSBrZXkvdmFsdWUgcGFpciBvZiB0aGUgcXVlc3Rpb25pZC9hbnN3ZXIgdGhhdCBoYXMgY2hhbmdlZC5cbiAgICovXG4gIF90aGlzLnVwZGF0ZUFuc3dlciA9IGZ1bmN0aW9uIChjaGFuZ2VkKSB7XG4gICAgdmFyIGZpZWxkO1xuXG4gICAgZm9yIChmaWVsZCBpbiBjaGFuZ2VkKSB7XG4gICAgICBfcXVlc3Rpb25zW2ZpZWxkXS5zZXRBbnN3ZXJzKGNoYW5nZWRbZmllbGRdKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN5bmNoJ3MgcXVlc3Rpb25zIHdpdGggdGhlIG1vZGVsIGFuc3dlcnMuXG4gICAqL1xuICBfdGhpcy5zeW5jaFF1ZXN0aW9uQW5zd2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmllbGQ7XG5cbiAgICBmb3IgKGZpZWxkIGluIF9xdWVzdGlvbnMpIHtcbiAgICAgIGlmIChfdGhpcy5tb2RlbC5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgX3F1ZXN0aW9uc1tmaWVsZF0uc2V0KF90aGlzLm1vZGVsLmdldChmaWVsZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RyaXBzIGFuIEFuc3dlciBmcm9tIHRoZSBvYmplY3QgYSBxdWVzdGlvbiBwYXNzZXMgYmFjay4gQW5kIHBhY2thZ2VzIGl0XG4gICAqICAgaW4gYW4gb2JqZWN0IGZvciB0aGUgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbXMgZmllbGQge3N0cmluZ31cbiAgICogICAgVGhlIG5hbWUgb2YgYSBxdWVzdGlvbi5cbiAgICogQHBhcmFtIGFuc3dlciB7c3RyaW5nfVxuICAgKiAgICBBbiBhbnN3ZXIgZnJvbSBhIHF1ZXN0aW9uVmlld1xuICAgKi9cbiAgX3RoaXMuc3RyaXBBbnN3ZXIgPSBmdW5jdGlvbiAoZmllbGQsIGFuc3dlcnMpIHtcbiAgICB2YXIgYW5zd2VyT2JqZWN0LFxuICAgICAgICBjbnQsXG4gICAgICAgIGZpZWxkT3RoZXI7XG5cbiAgICBhbnN3ZXJPYmplY3QgPSB7fTtcbiAgICBpZiAoYW5zd2VycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBhbnN3ZXJPYmplY3RbZmllbGRdID0gW107XG4gICAgICBmb3IgKGNudCA9IDA7IGNudCA8IGFuc3dlcnMubGVuZ3RoOyBjbnQrKykge1xuICAgICAgICBhbnN3ZXJPYmplY3RbZmllbGRdLnB1c2goYW5zd2Vyc1tjbnRdLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFuc3dlcnMgaW5zdGFuY2VvZiBPYmplY3QgJiYgYW5zd2Vycy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbnN3ZXJPYmplY3RbZmllbGRdID0gYW5zd2Vycy52YWx1ZTtcbiAgICAgIGlmKGFuc3dlcnMudmFsdWUgPT09ICdfT3RoZXInKSB7XG4gICAgICAgIGZpZWxkT3RoZXIgPSBmaWVsZCArICdfT3RoZXInO1xuICAgICAgICBhbnN3ZXJPYmplY3RbZmllbGRPdGhlcl0gPSBhbnN3ZXJzLm90aGVyVmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuc3dlck9iamVjdFtmaWVsZF0gPSAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5zd2VyT2JqZWN0O1xuICB9O1xuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEWUZJRm9ybVZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIENvbnRlbnRWaWV3ID0gcmVxdWlyZSgnY29yZS9Db250ZW50VmlldycpLFxuICAgIGQzID0gcmVxdWlyZSgnZDMnKSxcbiAgICBEM0xpbmVWaWV3ID0gcmVxdWlyZSgnZDMvRDNMaW5lVmlldycpLFxuICAgIEQzVmlldyA9IHJlcXVpcmUoJ2QzL0QzVmlldycpLFxuICAgIFN0YW5kYXJkRGV2YXRpb25MaW5lVmlldyA9IHJlcXVpcmUoJ2R5ZmkvU3RhbmRhcmREZXZpYXRpb25MaW5lVmlldycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgZXh0ZW5kcyB0aGUge0NvbnRlbnRWaWV3fSBjbGFzcyBhbmQgaXMgc3BlY2lmaWNhbGx5IHVzZWRcbiAqIGZvciByZW5kZXJpbmcgXCJkeWZpX3Bsb3RfYXR0ZW4uanNvblwiIGZvciB0aGUgZHlmaSBwcm9kdWN0LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gKiAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGlzIHZpZXcuXG4gKlxuICovXG52YXIgRFlGSUludGVuc2l0eUdyYXBoVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcblxuICAgICAgX2dyYXBoO1xuXG4gICAgX3RoaXMgPSBDb250ZW50VmlldyhvcHRpb25zKTtcblxuICAvKipcbiAgICogQWRkcyBhIGxpbmUgdmlldyB0byB0aGUgRDNWaWV3ICh3LyBjb25uZWN0aW5nIGxpbmVzLCB0aGlzIGZ1bmN0aW9uIGlzXG4gICAqIGNhbGxlZCB0byBidWlsZCB0aGUgbGluZSB2aWV3IHdoZW4sIGRhdGFzZXQuY2xhc3M6IFwiZXN0aW1hdGVkMVwiIG9yXG4gICAqIGNsYXNzOiBcImVzdGltYXRlZDJcIi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFzZXRcbiAgICogICAgYW4gb2JqZWN0IHVzZWQgdG8gZGVzY3JpYmUgYSBzZXQgb2YgZGF0YVxuICAgKlxuICAgKiAgICBkYXRhc2V0LmNsYXNzID0gaWRlbnRpZmllciBmb3IgdHlwZSBvZiBkYXRhXG4gICAqICAgIGRhdGFzZXQubGVnZW5kID0gdGhlIGRhdGFzZXQgbmFtZSwgdXNlZCBieSB0aGUgbGVnZW5kXG4gICAqICAgIGRhdGFzZXQuZGF0YSA9IHRoZSBwb2ludCBkYXRhIHRvIHBsb3RcbiAgICovXG4gIF90aGlzLmJ1aWxkTGluZVZpZXcgPSBmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgIHZhciBsaW5lID0gRDNMaW5lVmlldyh7XG4gICAgICB2aWV3OiBfZ3JhcGgsXG4gICAgICBzaG93UG9pbnRzOiAoZGF0YXNldC5zaG93UG9pbnRzID8gZGF0YXNldC5zaG93UG9pbnRzIDogZmFsc2UpLFxuICAgICAgZGF0YTogX3RoaXMucGFyc2VEYXRhSW50b0FycmF5KGRhdGFzZXQuZGF0YSksXG4gICAgICBjbGFzc05hbWU6IGRhdGFzZXQuY2xhc3MsXG4gICAgICBsYWJlbDogZGF0YXNldC5sZWdlbmQsXG4gICAgICBzaG93TGVnZW5kUG9pbnQ6IGZhbHNlXG4gICAgfSk7XG4gICAgX2dyYXBoLnZpZXdzLmFkZChsaW5lKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIGxpbmUgdmlldyB0byB0aGUgRDNWaWV3ICh3L28gY29ubmVjdGluZyBsaW5lcyksIHRoaXMgZnVuY3Rpb24gaXNcbiAgICogY2FsbGVkIHRvIGJ1aWxkIHRoZSBsaW5lIHZpZXcgd2hlbiwgZGF0YXNldC5jbGFzczogXCJtZWRpYW5cIi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFzZXRcbiAgICogICAgYW4gb2JqZWN0IHVzZWQgdG8gZGVzY3JpYmUgYSBzZXQgb2YgZGF0YVxuICAgKlxuICAgKiAgICBkYXRhc2V0LmNsYXNzID0gaWRlbnRpZmllciBmb3IgdHlwZSBvZiBkYXRhXG4gICAqICAgIGRhdGFzZXQubGVnZW5kID0gdGhlIGRhdGFzZXQgbmFtZSwgdXNlZCBieSB0aGUgbGVnZW5kXG4gICAqICAgIGRhdGFzZXQuZGF0YSA9IHRoZSBwb2ludCBkYXRhIHRvIHBsb3RcbiAgICovXG4gIF90aGlzLmJ1aWxkTWVkaWFuRGF0YVZpZXcgPSBmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgIHZhciBtZWRpYW5EYXRhID0gRDNMaW5lVmlldyh7XG4gICAgICB2aWV3OiBfZ3JhcGgsXG4gICAgICBzaG93TGluZTogZmFsc2UsXG4gICAgICBkYXRhOiBfdGhpcy5wYXJzZURhdGFJbnRvQXJyYXkoZGF0YXNldC5kYXRhKSxcbiAgICAgIGNsYXNzTmFtZTogZGF0YXNldC5jbGFzcyxcbiAgICAgIGxhYmVsOiBkYXRhc2V0LmxlZ2VuZCxcbiAgICAgIHBvaW50UmFkaXVzOiAzXG4gICAgfSk7XG4gICAgX2dyYXBoLnZpZXdzLmFkZChtZWRpYW5EYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIHNjYXR0ZXIgcGxvdCBEM1ZpZXcsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGJ1aWxkXG4gICAqIHRoZSBsaW5lIHZpZXcgd2hlbiwgZGF0YXNldC5jbGFzczogXCJzY2F0dGVycGxvdDFcIi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFzZXRcbiAgICogICAgYW4gb2JqZWN0IHVzZWQgdG8gZGVzY3JpYmUgYSBzZXQgb2YgZGF0YVxuICAgKlxuICAgKiAgICBkYXRhc2V0LmNsYXNzID0gaWRlbnRpZmllciBmb3IgdHlwZSBvZiBkYXRhXG4gICAqICAgIGRhdGFzZXQubGVnZW5kID0gdGhlIGRhdGFzZXQgbmFtZSwgdXNlZCBieSB0aGUgbGVnZW5kXG4gICAqICAgIGRhdGFzZXQuZGF0YSA9IHRoZSBwb2ludCBkYXRhIHRvIHBsb3RcbiAgICovXG4gIF90aGlzLmJ1aWxkU2NhdHRlclBsb3RWaWV3ID0gZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgICB2YXIgc2NhdHRlcnBsb3QgPSBEM0xpbmVWaWV3KHtcbiAgICAgIHZpZXc6IF9ncmFwaCxcbiAgICAgIHNob3dMaW5lOiBmYWxzZSxcbiAgICAgIGRhdGE6IF90aGlzLnBhcnNlRGF0YUludG9BcnJheShkYXRhc2V0LmRhdGEpLFxuICAgICAgY2xhc3NOYW1lOiBkYXRhc2V0LmNsYXNzLFxuICAgICAgbGFiZWw6IGRhdGFzZXQubGVnZW5kLFxuICAgICAgcG9pbnRSYWRpdXM6IDJcbiAgICB9KTtcbiAgICBfZ3JhcGgudmlld3MuYWRkKHNjYXR0ZXJwbG90KTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIFN0YW5kYXJkRGV2aWF0aW9uTGluZVZpZXcgdG8gdGhlIEQzVmlldywgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcbiAgICogdG8gZ3JhcGggdGhlIHN0YW5kYXJkIGRldmFpYXRpb24gYmlubmVkIGRhdGEgd2hlbiwgZGF0YXNldC5jbGFzczogXCJiaW5uZWRcIlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YXNldFxuICAgKiAgICBhbiBvYmplY3QgdXNlZCB0byBkZXNjcmliZSBhIHNldCBvZiBkYXRhXG4gICAqXG4gICAqICAgIGRhdGFzZXQuY2xhc3MgPSBpZGVudGlmaWVyIGZvciB0eXBlIG9mIGRhdGFcbiAgICogICAgZGF0YXNldC5sZWdlbmQgPSB0aGUgZGF0YXNldCBuYW1lLCB1c2VkIGJ5IHRoZSBsZWdlbmRcbiAgICogICAgZGF0YXNldC5kYXRhID0gdGhlIHBvaW50IGRhdGEgdG8gcGxvdFxuICAgKi9cbiAgX3RoaXMuYnVpbGRTdGFuZGFyZERldmlhdGlvbkxpbmVWaWV3ID0gZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgICB2YXIgc3RhbmRhcmREZXZhdGlvbkxpbmVWaWV3ID0gU3RhbmRhcmREZXZhdGlvbkxpbmVWaWV3KHtcbiAgICAgIHZpZXc6IF9ncmFwaCxcbiAgICAgIGRhdGE6IF90aGlzLnBhcnNlRGF0YUludG9BcnJheShkYXRhc2V0LmRhdGEpLFxuICAgICAgaGlzdG9ncmFtOiBkYXRhc2V0LmRhdGEsXG4gICAgICBjbGFzc05hbWU6IGRhdGFzZXQuY2xhc3MsXG4gICAgICBsYWJlbDogZGF0YXNldC5sZWdlbmQsXG4gICAgICBwb2ludFJhZGl1czogNSxcbiAgICAgIHNob3dMaW5lOiBmYWxzZVxuICAgIH0pO1xuICAgIF9ncmFwaC52aWV3cy5hZGQoc3RhbmRhcmREZXZhdGlvbkxpbmVWaWV3KTtcbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50IGxpc3RlbmVycyBhbmQgZnJlZSByZWZlcmVuY2VzLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpZXdzO1xuXG4gICAgaWYgKF90aGlzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKF9ncmFwaCkge1xuICAgICAgdmlld3MgPSBfZ3JhcGgudmlld3MuZGF0YSgpO1xuICAgICAgX2dyYXBoLnZpZXdzLnJlc2V0KFtdLCB7J3NpbGVudCc6IHRydWV9KTtcbiAgICAgIHZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIF9ncmFwaC5kZXN0cm95KCk7XG4gICAgICBfZ3JhcGggPSBudWxsO1xuICAgIH1cbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFyYml0cmFyeSBzZXQgb2YgbG9ncml0aG1pYyB2YWx1ZXMgZm9yIGdyYXBocyB3aG9zZSB0aWNrIHZhbHVlc1xuICAgKiAgd291bGQgb3RoZXJ3aXNlIHJ1biBpbnRvIGVhY2ggb3RoZXIuXG4gICAqXG4gICAqIEBwYXJhbXMge2FycmF5fSBleHRlbnRcbiAgICogICAgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgbWluIGFuZCBtYXggb2YgdGhlIHggYXhpcyBkYXRhIHJhbmdlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YXJyYXl9IHRpY2tzXG4gICAqICAgIEFuIGFycmF5IG9mIHRpY2sgdmFsdWVzLlxuICAgKi9cbiAgX3RoaXMuZ2V0TG9nVGlja3MgPSBmdW5jdGlvbiAoZXh0ZW50KSB7XG4gICAgdmFyIG1pbixcbiAgICAgICAgbWF4LFxuICAgICAgICB0aWNrcztcblxuICAgIG1pbiA9IGV4dGVudFswXTtcbiAgICBtYXggPSBleHRlbnRbMV07XG5cbiAgICBpZiAobWF4ID4gNTAwMCkge1xuICAgICAgdGlja3MgPSBbNTAsIDEwMCwgNTAwLCAxMDAwLCAyMDAwLCA1MDAwLCAxMDAwMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzID0gWzEwLCAyMCwgMzAsIDQwLCA1MCwgMTAwLCAyMDAsIDMwMCwgNDAwLCA1MDAsIDEwMDAsIDIwMDAsIDUwMDBdO1xuICAgIH1cblxuICAgIGlmIChtaW4gPiB0aWNrc1swXSApIHtcbiAgICAgIHRpY2tzID0gdGlja3MuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+IG1pbjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXggPCB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSkge1xuICAgICAgdGlja3MgPSB0aWNrcy5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgbWF4O1xuICAgICAgfSk7XG4gICAgfVxuXG4gIHJldHVybiB0aWNrcztcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBEM1ZpZXcgdGhhdCB3aWxsIGRpc3BsYXkgYWxsIG9mIHRoZSBkYXRhc2V0cyByZXR1cm5lZCBieSB0aGVcbiAgICogQ29udGVudFZpZXcuZmV0Y2hEYXRhIFhociByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICAgKiAgICBEYXRhIHJldHVybmVkIGJ5IHRoZSBYaHIgcmVxdWVzdCBmb3IgZHlmaV9wbG90X2F0dGVuLmpzb25cbiAgICovXG4gIF90aGlzLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGRhdGFzZXRzO1xuXG4gICAgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXG4gICAgaWYgKGRhdGFzZXRzICYmIGRhdGFzZXRzLmxlbmd0aCAmJiBkYXRhc2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICBfZ3JhcGggPSBEM1ZpZXcoVXRpbC5leHRlbmQoe1xuICAgICAgICB0aXRsZTogJ0ludGVuc2l0eSB2cy4gRGlzdGFuY2UgUGxvdCcsXG4gICAgICAgIHhMYWJlbDogJ0h5cG9jZW50cmFsIERpc3RhbmNlIChrbSknLFxuICAgICAgICB5TGFiZWw6ICdJbnRlbnNpdHkgKG1taSknLFxuICAgICAgICB4QXhpc1NjYWxlOiBkMy5zY2FsZS5sb2coKSxcbiAgICAgICAgeEF4aXNGb3JtYXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgeEF4aXNUaWNrczogX3RoaXMueEF4aXNUaWNrcyxcbiAgICAgICAgeUF4aXNUaWNrczogWzEsMiwzLDQsNSw2LDcsOCw5LDEwXSxcbiAgICAgICAgeUV4dGVudDogWzEsMTBdLFxuICAgICAgICBtYXJnaW5Ub3A6IDEwLFxuICAgICAgICBtYXJnaW5MZWZ0OiAxMCxcbiAgICAgICAgcGFkZGluZ0xlZnQ6NzBcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgIF90aGlzLmVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnSW50ZW5zaXR5R3JhcGhWaWV3Jyk7XG4gICAgICBfdGhpcy5lbC5hcHBlbmRDaGlsZChfZ3JhcGguZWwpO1xuICAgICAgX3RoaXMucGFyc2VEYXRhKGRhdGFzZXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gJzxwIGNsYXNzPVwiYWxlcnQgd2FybmluZ1wiPkludGVuc2l0eSB2cy4gRGlzdGFuY2UgJyArXG4gICAgICAgICAgJ2RhdGEgZG9lcyBub3QgZXhpc3QuPC9wPic7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTY2FucyBhbGwgZGF0YXNldHMgcmV0dXJuZWQgaW4gdGhlIFhIUiByZXNwb25zZSBhbmQgZGV0ZXJtaW5lc1xuICAgKiB3aGljaCB0eXBlIG9mIHZpZXcgd2lsbCBiZSBhZGRlZCB0byB0aGUgRDNWaWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBkYXRhXG4gICAqICAgIEFuIGFycmF5IG9mIGRhdGFzZXRzIHRvIGJlIHBsb3R0ZWQgaW4gdGhlIEQzVmlld1xuICAgKi9cbiAgX3RoaXMucGFyc2VEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgICAgIGlmIChkYXRhc2V0LmNsYXNzID09PSAnZXN0aW1hdGVkMScgfHxcbiAgICAgICAgICBkYXRhc2V0LmNsYXNzID09PSAnZXN0aW1hdGVkMicpIHtcbiAgICAgICAgX3RoaXMuYnVpbGRMaW5lVmlldyhkYXRhc2V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhc2V0LmNsYXNzID09PSAnc2NhdHRlcnBsb3QxJykge1xuICAgICAgICBfdGhpcy5idWlsZFNjYXR0ZXJQbG90VmlldyhkYXRhc2V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhc2V0LmNsYXNzID09PSAnbWVkaWFuJykge1xuICAgICAgICBfdGhpcy5idWlsZE1lZGlhbkRhdGFWaWV3KGRhdGFzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGFzZXQuY2xhc3MgPT09ICdiaW5uZWQnKSB7XG4gICAgICAgIF90aGlzLmJ1aWxkU3RhbmRhcmREZXZpYXRpb25MaW5lVmlldyhkYXRhc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogTWFzc2FnZXMgdGhlIHBvaW50IGRhdGEgaW50byBhIG5ldyBmb3JtYXQgdGhhdCBpcyBleHBlY3RlZCBieSB0aGVcbiAgICogRDNMaW5lVmlldyBhbmQgU3RhbmRhcmREZXZhdGlvbkxpbmVWaWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBkYXRhUG9pbnRzXG4gICAqICAgIEFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCBjb250YWluIFwieFwiIGFuZCBcInlcIiBhdHRyaWJ1dGVzIHRoYXQgcmVwcmVzZW50XG4gICAqICAgIHBvaW50IGRhdGEuXG4gICAqL1xuICBfdGhpcy5wYXJzZURhdGFJbnRvQXJyYXkgPSBmdW5jdGlvbiAoZGF0YVBvaW50cykge1xuICAgIHZhciBkYXRhO1xuXG4gICAgZGF0YSA9IFtdO1xuICAgIGRhdGFQb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIGRhdGEucHVzaChbcG9pbnQueCwgcG9pbnQueV0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2VzIGNlcnRhaW4gdGhhdCB4IEF4aXMgdGlja3MgYXJlIHZpc2libGUgZm9yIHNtYWxsIGF4aXMgZXh0ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gZXh0ZW50XG4gICAqICAgIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG1pbiBhbmQgbWF4IG9mIHRoZSB4IGF4aXMgZGF0YSByYW5nZS5cbiAgICpcbiAgICogQHJldHVybnMge2FycmF5fSB0aWNrc1xuICAgKiAgICBBbiBhcnJheSBvZiB0aWNrIHZhbHVlcywgb3IgbnVsbCBpZiB0aGUgZDMgZGVmYXVsdCB3aWxsIHN1ZmZpY2UuXG4gICAqL1xuICBfdGhpcy54QXhpc1RpY2tzID0gZnVuY3Rpb24gKGV4dGVudCkge1xuICAgIHZhciBsb2dtaW4sXG4gICAgICAgIGxvZ21heCxcbiAgICAgICAgbWluLFxuICAgICAgICBtYXgsXG4gICAgICAgIHRpY2tzO1xuXG4gICAgLy8gTm8gZXh0ZW50cywgcmV0dXJuIG51bGwuXG4gICAgaWYgKGV4dGVudC5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBtaW4gPSBleHRlbnRbMF07XG4gICAgbWF4ID0gZXh0ZW50W2V4dGVudC5sZW5ndGggLTFdO1xuXG4gICAgbG9nbWluID0gTWF0aC5sb2cobWluKSAvIE1hdGguTE4xMDtcbiAgICBsb2dtYXggPSBNYXRoLmxvZyhtYXgpIC8gTWF0aC5MTjEwO1xuXG4gICAgLy8gcmFuZ2UgaXMgY29tcGxldGVseSB3aXRoaW4gMiB0aWNrcyBvbiB0aGUgbG9nIDEwIHNjYWxlLlxuICAgIC8vIENyZWF0ZSAyIHRpY2tzLCByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IDEwMDAncy5cbiAgICBpZiAobG9nbWF4IC0gbG9nbWluIDwgMSkge1xuICAgICAgdGlja3MgPSBbTWF0aC5yb3VuZChtaW4gKiAxMDAwLjApIC8gMTAwMC4wLFxuICAgICAgICAgIE1hdGgucm91bmQobWF4ICogMTAwMC4wKSAvIDEwMDAuMF07XG4gICAgICByZXR1cm4gdGlja3M7XG4gICAgfVxuXG4gICAgaWYgKGxvZ21heCAtIGxvZ21pbiA+IDEuNSkge1xuICAgICAgdGlja3MgPSBfdGhpcy5nZXRMb2dUaWNrcyhleHRlbnQpO1xuICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG5cbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEWUZJSW50ZW5zaXR5R3JhcGhWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBEWUZJRm9ybU1vZHVsZSA9IHJlcXVpcmUoJ2R5ZmkvRFlGSUZvcm1Nb2R1bGUnKSxcbiAgICBEWUZJVmlldyA9IHJlcXVpcmUoJ2R5ZmkvRFlGSVZpZXcnKSxcbiAgICBJbXBhY3RTdW1tYXJ5TW9kdWxlID0gcmVxdWlyZSgnaW1wYWN0L0ltcGFjdFN1bW1hcnlNb2R1bGUnKSxcbiAgICBNb2R1bGUgPSByZXF1aXJlKCdjb3JlL01vZHVsZScpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0lELFxuICAgIF9USVRMRSxcbiAgICBfVFlQRVM7XG5cblxuX0lEID0gJ2R5ZmknO1xuX1RJVExFID0gJ0RpZCBZb3UgRmVlbCBJdD8nO1xuX1RZUEVTID0gWydkeWZpJ107XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcblxufTtcblxuXG52YXIgRFlGSU1vZHVsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfZHlmaVZpZXc7XG5cblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gTW9kdWxlKG9wdGlvbnMpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKC8qb3B0aW9ucyovKSB7XG4gICAgX3RoaXMuSUQgPSBfSUQ7XG4gICAgX3RoaXMuVElUTEUgPSBfVElUTEU7XG4gIH07XG5cblxuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX2R5ZmlWaWV3KSB7XG4gICAgICBfZHlmaVZpZXcuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIF9keWZpVmlldyA9IG51bGw7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMucmVuZGVySGVhZGVyKCk7XG4gICAgX3RoaXMucmVuZGVyQ29udGVudCgpO1xuICAgIF90aGlzLnJlbmRlckZvb3RlcigpO1xuICB9O1xuXG4gIF90aGlzLnJlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb2R1Y3Q7XG5cbiAgICBwcm9kdWN0ID0gX3RoaXMuZ2V0UHJvZHVjdCgnZHlmaScpO1xuXG4gICAgaWYgKCFwcm9kdWN0KSB7XG4gICAgICBfdGhpcy5jb250ZW50LmlubmVySFRNTCA9ICc8cCBjbGFzcz1cImFsZXJ0IGVycm9yXCI+Tm8gRFlGSSBGb3VuZCE8L3A+JztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF9keWZpVmlldyAmJiBfZHlmaVZpZXcuZGVzdHJveSkge1xuICAgICAgICBfZHlmaVZpZXcuZGVzdHJveSgpO1xuICAgICAgICBfZHlmaVZpZXcgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBfZHlmaVZpZXcgPSBEWUZJVmlldyh7XG4gICAgICAgIGVsOiBfdGhpcy5jb250ZW50LFxuICAgICAgICBtb2RlbDogcHJvZHVjdFxuICAgICAgfSk7XG5cbiAgICAgIF9keWZpVmlldy5yZW5kZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgX3RoaXMucmVuZGVyRm9vdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZGRpdGlvbmFsRm9vdGVyLFxuICAgICAgICBwcm9kdWN0O1xuXG4gICAgX3RoaXMuZm9vdGVyLmlubmVySFRNTCA9W1xuICAgICAgJzxoMz5Gb3IgTW9yZSBJbmZvcm1hdGlvbjwvaDM+JyxcbiAgICAgICc8dWw+JyxcbiAgICAgICAgJzxsaT4nLFxuICAgICAgICAgICc8YSBocmVmPVwiL2RhdGEvZHlmaS9cIj4nLFxuICAgICAgICAgICAgJ1NjaWVudGlmaWMgQmFja2dyb3VuZCBmb3IgRGlkIFlvdSBGZWVsIEl0PycsXG4gICAgICAgICAgJzwvYT4nLFxuICAgICAgICAnPC9saT4nLFxuICAgICAgJzwvdWw+J1xuICAgIF0uam9pbignJyk7XG5cbiAgICBwcm9kdWN0ID0gX3RoaXMuZ2V0UHJvZHVjdCgnZHlmaScpO1xuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBhZGRpdGlvbmFsRm9vdGVyID0gX3RoaXMuZ2V0UHJvZHVjdEZvb3Rlcih7XG4gICAgICAgIHByb2R1Y3Q6IHByb2R1Y3RcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYWRkaXRpb25hbEZvb3Rlcikge1xuICAgICAgICBfdGhpcy5mb290ZXIuYXBwZW5kQ2hpbGQoYWRkaXRpb25hbEZvb3Rlcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfdGhpcy5yZW5kZXJIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb2R1Y3Q7XG5cbiAgICBfdGhpcy5oZWFkZXIuaW5uZXJIVE1MID0gJzxoMyBjbGFzcz1cImR5ZmktdGl0bGVcIj4nICsgX3RoaXMuVElUTEUgKyAnPC9oMz4nICtcbiAgICAgICAgJzxhIGNsYXNzPVwidGVsbC11cy1saW5rXCIgaHJlZj1cIiMnICsgRFlGSUZvcm1Nb2R1bGUuSUQgK1xuICAgICAgICAnXCI+JyArIERZRklGb3JtTW9kdWxlLlRJVExFICsgJzwvYT4nO1xuXG4gICAgcHJvZHVjdCA9IF90aGlzLmdldFByb2R1Y3QoJ2R5ZmknKTtcblxuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBfdGhpcy5oZWFkZXIuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0UHJvZHVjdEhlYWRlcih7XG4gICAgICAgIHByb2R1Y3Q6IHByb2R1Y3QsXG4gICAgICAgIHN1bW1hcnlNb2R1bGU6IEltcGFjdFN1bW1hcnlNb2R1bGVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuRFlGSU1vZHVsZS5JRCA9IF9JRDtcbkRZRklNb2R1bGUuVElUTEUgPSBfVElUTEU7XG5EWUZJTW9kdWxlLlRZUEVTID0gX1RZUEVTO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRFlGSU1vZHVsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgQmFzaWNQaW5WaWV3ID0gcmVxdWlyZSgnY29yZS9CYXNpY1BpblZpZXcnKSxcbiAgICBEWUZJTW9kdWxlID0gcmVxdWlyZSgnZHlmaS9EWUZJTW9kdWxlJyksXG4gICAgRm9ybWF0dGVyID0gcmVxdWlyZSgnY29yZS9Gb3JtYXR0ZXInKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcbiAgbW9kdWxlOiBEWUZJTW9kdWxlXG59O1xuXG52YXIgRFlGSVBpblZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2Zvcm1hdHRlcjtcblxuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgX3RoaXMgPSBCYXNpY1BpblZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF9mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBGb3JtYXR0ZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBjb250ZW50IHNlY3Rpb24gb2YgdGhlIHBpbi4gVGhpcyBsb2FkcyBhIERZRkkgaW1hZ2VcbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlclBpbkNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvZGUsXG4gICAgICAgIGltZztcblxuICAgIGNvZGUgPSBfdGhpcy5tb2RlbC5nZXQoJ2NvZGUnKTtcbiAgICBpbWcgPSBfdGhpcy5tb2RlbC5nZXRDb250ZW50KCdwaW4tdGh1bWJuYWlsLnBuZycpO1xuICAgIGlmICghaW1nKSB7XG4gICAgICBpbWcgPSBfdGhpcy5tb2RlbC5nZXRDb250ZW50KGNvZGUgKyAnX2NpaW0uanBnJyk7XG4gICAgfVxuXG4gICAgaWYgKGltZykge1xuICAgICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPSAnPGltZyBzcmM9XCInICsgaW1nLmdldCgndXJsJykgK1xuICAgICAgICAgICdcIiBjbGFzcz1cImR5ZmktaW50ZW5zaXR5LW1hcFwiIGFsdD1cIkRZRkkgSW50ZW5zaXR5IE1hcFwiLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5jb250ZW50LmlubmVySFRNTCA9ICc8cCBjbGFzcz1cImFsZXJ0IHdhcm5pbmdcIj5Db3VsZCBub3QgbG9hZCAnICtcbiAgICAgICAgICAnRFlGSSBpbnRlbnNpdHkgbWFwPC9wPic7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgaGVhZGVyIGZvciBEWUZJUGluVmlldyB3aXRoIGltcGFjdCBidWJibGVcbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlclBpbkhlYWRlciA9IFV0aWwuY29tcG9zZShfdGhpcy5yZW5kZXJQaW5IZWFkZXIsIGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5oZWFkZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLFxuICAgICAgICBfZm9ybWF0dGVyLmludGVuc2l0eShfdGhpcy5tb2RlbC5nZXRQcm9wZXJ0eSgnbWF4bW1pJyksIG51bGwpKTtcbiAgfSk7XG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERZRklQaW5WaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ212Yy9Db2xsZWN0aW9uJyksXG4gICAgQ29udGVudFZpZXcgPSByZXF1aXJlKCdjb3JlL0NvbnRlbnRWaWV3JyksXG4gICAgRGF0YVRhYmxlID0gcmVxdWlyZSgnbXZjL0RhdGFUYWJsZScpLFxuICAgIEZvcm1hdHRlciA9IHJlcXVpcmUoJ2NvcmUvRm9ybWF0dGVyJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfTk9fQ09OVEVOVF9NRVNTQUdFID0gJzxwIGNsYXNzPVwiYWxlcnQgZXJyb3JcIj5ObyBSZXNwb25zZXMgYXZhaWxhYmxlLjwvcD4nO1xuXG4vKiBGb3JtYXR0ZXIgZm9yIF9SRVNQT05TRV9EQVRBX0NPTFVNTlMgKi9cbnZhciBfRk9STUFUVEVSID0gRm9ybWF0dGVyKCk7XG5cbi8qIEFycmF5IG9mIENvbHVtbiBPYmplY3RzIGZvciBSZXNwb25zZXMgRGF0YVRhYmxlICovXG52YXIgX1JFU1BPTlNFX0RBVEFfQ09MVU1OUyA9IFtcbiAge1xuICAgIGNsYXNzTmFtZTogJ2R5ZmktcmVzcG9uc2UtbG9jYXRpb24nLFxuICAgIHRpdGxlOiAnTG9jYXRpb24nLFxuICAgIGRvd25sb2FkVGl0bGU6ICdDaXR5XFx0U3RhdGUvUmVnaW9uXFx0Q291bnRyeVxcdFppcCBDb2RlJyxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIF9GT1JNQVRURVIuZHlmaUxvY2F0aW9uKHJlc3BvbnNlKTtcbiAgICB9LFxuICAgIGRvd25sb2FkRm9ybWF0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHZhciBjb3VudHJ5LFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIHJlZ2lvbixcbiAgICAgICAgICB6aXA7XG5cbiAgICAgIGNvdW50cnkgPSByZXNwb25zZS5jb3VudHJ5O1xuICAgICAgbG9jYXRpb24gPSByZXNwb25zZS5uYW1lO1xuICAgICAgcmVnaW9uID0gcmVzcG9uc2Uuc3RhdGU7XG4gICAgICB6aXAgPSByZXNwb25zZS56aXA7XG5cbiAgICAgIHJldHVybiBbbG9jYXRpb24sIHJlZ2lvbiwgY291bnRyeSwgemlwXS5qb2luKCdcXHQnKTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBjbGFzc05hbWU6ICdkeWZpLXJlc3BvbnNlLW1taScsXG4gICAgdGl0bGU6ICdNTUknLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gX0ZPUk1BVFRFUi5pbnRlbnNpdHkocmVzcG9uc2UuY2RpKTtcbiAgICB9LFxuICAgIGRvd25sb2FkRm9ybWF0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBfRk9STUFUVEVSLm1taShyZXNwb25zZS5jZGkpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGNsYXNzTmFtZTogJ2R5ZmktcmVzcG9uc2UtbnVtUmVzcCcsXG4gICAgdGl0bGU6ICdSZXNwb25zZXMnLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UubnJlc3A7XG4gICAgfVxuICB9LFxuICB7XG4gICAgY2xhc3NOYW1lOiAnZHlmaS1yZXNwb25zZS1kaXN0YW5jZScsXG4gICAgdGl0bGU6ICdEaXN0YW5jZScsXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5kaXN0ICsgJyBrbSc7XG4gICAgfVxuICB9LFxuICB7XG4gICAgY2xhc3NOYW1lOiAnZHlmaS1yZXNwb25zZS1sYXRpdHVkZScsXG4gICAgdGl0bGU6ICdMYXRpdHVkZScsXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBfRk9STUFUVEVSLmxhdGl0dWRlKHJlc3BvbnNlLmxhdCk7XG4gICAgfSxcbiAgICBkb3dubG9hZEZvcm1hdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UubGF0O1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGNsYXNzTmFtZTogJ2R5ZmktcmVzcG9uc2UtbG9uZ2l0dWRlJyxcbiAgICB0aXRsZTogJ0xvbmdpdHVkZScsXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBfRk9STUFUVEVSLmxvbmdpdHVkZShyZXNwb25zZS5sb24pO1xuICAgIH0sXG4gICAgZG93bmxvYWRGb3JtYXQ6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmxvbjtcbiAgICB9XG4gIH1cbl07XG5cbi8qIEFycmF5IG9mIHNvcnQgb2JqZWN0cyBmb3IgdXNlIGJ5IERhdGFUYWJsZSAqL1xudmFyIF9SRVNQT05TRV9EQVRBX1NPUlRTID0gW1xuICB7XG4gICAgaWQ6ICdjaXR5JyxcbiAgICB0aXRsZTogJ0NpdHknLFxuICAgIHNvcnRCeTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UubmFtZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBpZDogJ2NvdW50cnknLFxuICAgIHRpdGxlOiAnQ291bnRyeScsXG4gICAgc29ydEJ5OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5jb3VudHJ5O1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGlkOiAnZGlzdGFuY2UnLFxuICAgIHRpdGxlOiAnRGlzdGFuY2UnLFxuICAgIHNvcnRCeTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGlzdDtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBpZDogJ21taScsXG4gICAgdGl0bGU6ICdNTUknLFxuICAgIHNvcnRCeTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuY2RpO1xuICAgIH0sXG4gICAgZGVzY2VuZGluZzogdHJ1ZVxuICB9LFxuICB7XG4gICAgaWQ6ICdzdGF0ZScsXG4gICAgdGl0bGU6ICdSZWdpb24gLyBTdGF0ZScsXG4gICAgc29ydEJ5OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5zdGF0ZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBpZDogJ251bVJlc3AnLFxuICAgIHRpdGxlOiAnUmVzcG9uc2VzJyxcbiAgICBzb3J0Qnk6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLm5yZXNwO1xuICAgIH0sXG4gICAgZGVzY2VuZGluZzogdHJ1ZVxuICB9LFxuICB7XG4gICAgaWQ6ICd6aXAnLFxuICAgIHRpdGxlOiAnWmlwIENvZGUnLFxuICAgIHNvcnRCeTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAocmVzcG9uc2UuemlwICE9PSAnJykge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuemlwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXTtcblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgZXh0ZW5kcyB0aGUge0NvbnRlbnRWaWV3fSBjbGFzcyBhbmQgaXMgc3BlY2lmaWNhbGx5IHVzZWRcbiAqIGZvciByZW5kZXJpbmcgXCJzdGF0aW9ubGlzdC5qc29uXCIgZm9yIGEgZ2l2ZW4gcHJvZHVjdC4gVGhlIGBvcHRpb25zLm1vZGVsYFxuICogc2hvdWxkIGJlIG9mIHR5cGUge0NvbnRlbnR9LlxuICpcbiAqL1xudmFyIERZRklSZXNwb25zZXNWaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9idXR0b24sXG4gICAgICBfZm9ybWF0dGVyLFxuICAgICAgX3Byb2R1Y3QsXG4gICAgICBfcmVzcG9uc2VzLFxuICAgICAgX3Jlc3BvbnNlVGFibGUsXG4gICAgICBfcmVzcG9uc2VUYWJsZUVsO1xuXG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIF90aGlzID0gQ29udGVudFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2J1dHRvbiA9IG51bGw7XG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuICAgIF9wcm9kdWN0ID0gb3B0aW9ucy5wcm9kdWN0IHx8IG51bGw7XG4gICAgX3Jlc3BvbnNlVGFibGUgPSBudWxsO1xuICAgIF9yZXNwb25zZVRhYmxlRWwgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSB0b2dnbGUgYnV0dG9uIHRvIHRoZSByZXBvbnNlcyBEYXRhVGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSBjb250YWludGVyXG4gICAqICAgICAgICBUaGUgY29udGFpbmVyIGVsZW1lbnQgdGhhdCB0aGUgYnV0dG9uIHNob3VsZCBiZSBhZGRlZCB0by5cbiAgICovXG4gIF90aGlzLmFkZFRvZ2dsZUJ1dHRvbiA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBfYnV0dG9uID0gY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpKTtcbiAgICBfYnV0dG9uLmlubmVySFRNTCA9ICdTZWUgQWxsIFJlc3BvbnNlcyc7XG4gICAgX2J1dHRvbi5jbGFzc05hbWUgPSAndmlldy1hbGwnO1xuICAgIF9idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5vblRvZ2dsZUJ1dHRvbkNsaWNrKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoX2J1dHRvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgcmVzcG9uc2UgY29sbGVjdGlvbiBmcm9tIHRoZSBEWUZJIHhtbERvYy5cbiAgICpcbiAgICogQHBhcmFtIHhtbERvYyB4bWxPYmplY3RcbiAgICogICAgICAgIHRoZSB4bWwgZG9jdW1lbnQgdG8gcGFyc2UuXG4gICAqIEByZXR1cm4gQ29sbGVjdGlvblxuICAgKiAgICAgICAgIEEgY29sbGVjdGlvbiBvZiBEWUZJIHJlc3BvbnNlcy5cbiAgICovXG4gIF90aGlzLmJ1aWxkUmVzcG9uc2VzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uICh4bWxEb2MpIHtcbiAgICB2YXIgZGF0YSA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbG9jYXRpb24nKSxcbiAgICAgICAgcmVzcG9uc2VzQXJyYXkgPSBbXSxcbiAgICAgICAgbG9jYXRpb25OYW1lLCBsb2NhdGlvbnMsIGxvY2F0aW9uLFxuICAgICAgICBub2RlLCBub2RlTmFtZSwgbm9kZVZhbHVlO1xuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBkYXRhLmxlbmd0aDsgeCsrKSB7XG5cbiAgICAgIGxvY2F0aW9uTmFtZSA9IGRhdGFbeF0uZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICBsb2NhdGlvbnMgPSBkYXRhW3hdLmNoaWxkTm9kZXM7XG4gICAgICBsb2NhdGlvbiA9IHtcbiAgICAgICAgaWQ6IHgsICAvLyBBc3NpZ24gYW4gSUQgZm9yIHNvcnRpbmcgY2FjaGluZ1xuICAgICAgICB6aXA6ICcnIC8vIFByb3ZpZGUgZW1wdHkgZGVmYXVsdCB0byBwcmV2ZW50IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICBub2RlID0gbG9jYXRpb25zW2ldO1xuICAgICAgICBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWU7XG4gICAgICAgIG5vZGVWYWx1ZSA9IG5vZGUudGV4dENvbnRlbnQ7XG5cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnbmFtZScgfHxcbiAgICAgICAgICAgIG5vZGVOYW1lID09PSAnc3RhdGUnIHx8XG4gICAgICAgICAgICBub2RlTmFtZSA9PT0gJ2NvdW50cnknIHx8XG4gICAgICAgICAgICBub2RlTmFtZSA9PT0gJ3ppcCcpIHtcbiAgICAgICAgICBsb2NhdGlvbltub2RlTmFtZV0gPSBub2RlVmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBub2RlTmFtZSA9PT0gJ2NkaScgfHxcbiAgICAgICAgICAgIG5vZGVOYW1lID09PSAnZGlzdCcgfHxcbiAgICAgICAgICAgIG5vZGVOYW1lID09PSAnbGF0JyB8fFxuICAgICAgICAgICAgbm9kZU5hbWUgPT09ICdsb24nKSB7XG4gICAgICAgICAgbG9jYXRpb25bbm9kZU5hbWVdID0gcGFyc2VGbG9hdChub2RlVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAnbnJlc3AnKSB7XG4gICAgICAgICAgbG9jYXRpb25bbm9kZU5hbWVdID0gcGFyc2VJbnQobm9kZVZhbHVlLCAxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGV0ZXJtaW5lIGNvdW50cnkvIGFkZCB6aXAgY29kZSB0byBuYW1lXG4gICAgICBpZiAobG9jYXRpb25OYW1lLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICBsb2NhdGlvbi5jb3VudHJ5ID0gJ1VuaXRlZCBTdGF0ZXMgb2YgQW1lcmljYSc7XG4gICAgICAgIGxvY2F0aW9uLnppcCA9IGxvY2F0aW9uTmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2F0aW9uTmFtZSA9IGxvY2F0aW9uTmFtZS5zcGxpdCgnOjonKTtcbiAgICAgICAgbG9jYXRpb24uc3RhdGUgPSBsb2NhdGlvbk5hbWVbMV07XG4gICAgICAgIGxvY2F0aW9uLmNvdW50cnkgPSBsb2NhdGlvbk5hbWVbMl07XG4gICAgICB9XG5cbiAgICAgIHJlc3BvbnNlc0FycmF5LnB1c2gobG9jYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBDb2xsZWN0aW9uKHJlc3BvbnNlc0FycmF5KTtcbiAgfTtcblxuICAvKipcbiAgICogRnJlZSByZWZlcmVuY2VzLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9idXR0b24gIT09IG51bGwpIHtcbiAgICAgIF9idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5vblRvZ2dsZUJ1dHRvbkNsaWNrKTtcbiAgICB9XG4gICAgaWYgKF9yZXNwb25zZVRhYmxlICE9PSBudWxsKSB7XG4gICAgICBfcmVzcG9uc2VUYWJsZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmIChfcmVzcG9uc2VzKSB7XG4gICAgICBfcmVzcG9uc2VzLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBfYnV0dG9uID0gbnVsbDtcbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3Jlc3BvbnNlcyA9IG51bGw7XG4gICAgX3Jlc3BvbnNlVGFibGVFbCA9IG51bGw7XG4gICAgX3Jlc3BvbnNlVGFibGUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGRlZmF1bHQgZXJyb3IgbWVzc2FnZS4gQ2FsbGVkIGlmIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgdGhlXG4gICAqIGRhdGEgZmV0Y2guXG4gICAqXG4gICAqL1xuICBfdGhpcy5vbkVycm9yID0gZnVuY3Rpb24gKC8qc3RhdHVzLCB4aHIqLykge1xuICAgIF90aGlzLmVsLmlubmVySFRNTCA9IF9OT19DT05URU5UX01FU1NBR0U7XG4gIH07XG5cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBvZiByZXNwb25zZXMuIENhbGxlZCB3aGVuIGRhdGEgaXMgc3VjY2Vzc2Z1bGx5IGZldGNoZWQuXG4gICAqXG4gICAqL1xuICBfdGhpcy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcG9uc2VUZXh0LCB4aHIpIHtcbiAgICBfcmVzcG9uc2VzID0gX3RoaXMuYnVpbGRSZXNwb25zZXNDb2xsZWN0aW9uKHhoci5yZXNwb25zZVhNTCk7XG5cbiAgICBfcmVzcG9uc2VUYWJsZSA9IERhdGFUYWJsZSh7XG4gICAgICBlbDogX3RoaXMuZWwsXG4gICAgICBjbGFzc05hbWU6ICdkeWZpLXJlc3BvbnNlLXRhYmxlJyxcbiAgICAgIGNvbGxlY3Rpb246IF9yZXNwb25zZXMsXG4gICAgICBlbXB0eU1hcmt1cDogX05PX0NPTlRFTlRfTUVTU0FHRSxcbiAgICAgIGNvbHVtbnM6IF9SRVNQT05TRV9EQVRBX0NPTFVNTlMsXG4gICAgICBzb3J0czogX1JFU1BPTlNFX0RBVEFfU09SVFMsXG4gICAgICBkZWZhdWx0U29ydDogJ2Rpc3RhbmNlJ1xuICAgIH0pO1xuXG4gICAgX3Jlc3BvbnNlVGFibGVFbCA9IF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5kYXRhdGFibGUtZGF0YScpO1xuICAgIF9yZXNwb25zZVRhYmxlRWwuY2xhc3NMaXN0LmFkZCgnaG9yaXpvbnRhbC1zY3JvbGxpbmcnKTtcbiAgICBpZiAoX3Jlc3BvbnNlcy5kYXRhKCkubGVuZ3RoID4gMTApIHtcbiAgICAgIF90aGlzLmFkZFRvZ2dsZUJ1dHRvbihfdGhpcy5lbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIFJlc3BvbnNlIGxpc3Qgc2l6ZSwgZWl0aGVyIGFsbCByZXNwb25zZXMsIG9yIHRoZSBsYXN0IDEwLlxuICAgKlxuICAgKi9cbiAgX3RoaXMub25Ub2dnbGVCdXR0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3Jlc3BvbnNlVGFibGVFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2Z1bGwtbGlzdCcpKSB7XG4gICAgICBfcmVzcG9uc2VUYWJsZUVsLmNsYXNzTGlzdC5yZW1vdmUoJ2Z1bGwtbGlzdCcpO1xuICAgICAgX2J1dHRvbi5pbm5lckhUTUwgPSAnU2hvdyBBbGwgUmVzcG9uc2VzJztcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3BvbnNlVGFibGVFbC5jbGFzc0xpc3QuYWRkKCdmdWxsLWxpc3QnKTtcbiAgICAgIF9idXR0b24uaW5uZXJIVE1MID0gJ1Nob3cgT25seSAxMCBSZXNwb25zZXMnO1xuICAgIH1cbiAgfTtcblxuICBfaW5pdGlhbGl6ZSgpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5EWUZJUmVzcG9uc2VzVmlldy5OT19DT05URU5UX01FU1NBR0UgPSBfTk9fQ09OVEVOVF9NRVNTQUdFO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRFlGSVJlc3BvbnNlc1ZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIERZRklJbnRlbnNpdHlHcmFwaFZpZXcgPSByZXF1aXJlKCdkeWZpL0RZRklJbnRlbnNpdHlHcmFwaFZpZXcnKSxcbiAgICBEWUZJUmVzcG9uc2VzVmlldyA9IHJlcXVpcmUoJ2R5ZmkvRFlGSVJlc3BvbnNlc1ZpZXcnKSxcbiAgICBJbnRlcmFjdGl2ZU1hcFZpZXcgPSByZXF1aXJlKCdtYXAvSW50ZXJhY3RpdmVNYXBWaWV3JyksXG4gICAgUHJvZHVjdFZpZXcgPSByZXF1aXJlKCdjb3JlL1Byb2R1Y3RWaWV3JyksXG4gICAgU3ZnSW1hZ2VNYXAgPSByZXF1aXJlKCdzdmdpbWFnZW1hcC9TdmdJbWFnZU1hcCcpLFxuICAgIFRhYkxpc3QgPSByZXF1aXJlKCd0YWJsaXN0L1RhYkxpc3QnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcblxufTtcblxuLy8gTWFwIG9mIGluZm9ybWF0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGFic1xudmFyIF9SRVNPVVJDRVMgPSB7XG4gICdpbnRlbnNpdHktbWFwJzoge1xuICAgIHRpdGxlOiAnSW50ZW5zaXR5IE1hcCcsXG4gICAgc3VmZml4OiAnX2NpaW0uanBnJyxcbiAgICB1c2VtYXA6ICdpbWFwX2Jhc2UnLFxuICAgIGhyZWY6ICcjbWFwPycgK1xuICAgICAgICBJbnRlcmFjdGl2ZU1hcFZpZXcuU0hBS0VNQVBfQ09OVE9VUlMgKyAnPSBmYWxzZSYnICtcbiAgICAgICAgSW50ZXJhY3RpdmVNYXBWaWV3LkRZRklfMTBLX09WRVJMQVkgKyAnPXRydWUmJyArXG4gICAgICAgIEludGVyYWN0aXZlTWFwVmlldy5EWUZJX0RFRkFVTFRfT1ZFUkxBWSArICc9dHJ1ZScsXG4gICAgbWFwU3VmZml4OiAnX2NpaW1faW1hcC5odG1sJ1xuICB9LFxuICAnZ2VvY29kZS1tYXAnOiB7XG4gICAgdGl0bGU6J0dlb2NvZGVkIE1hcCcsXG4gICAgc3VmZml4OidfY2lpbV9nZW8uanBnJyxcbiAgICB1c2VtYXA6J2ltYXBfZ2VvJyxcbiAgICBtYXBTdWZmaXg6J19jaWltX2dlb19pbWFwLmh0bWwnXG4gIH0sXG4gICd6b29tLW1hcCc6IHtcbiAgICB0aXRsZTonWm9vbSBNYXAnLFxuICAgIHN1ZmZpeDonX2NpaW1fem9vbS5qcGcnLFxuICAgIHVzZW1hcDonaW1hcF96b29tJyxcbiAgICBtYXBTdWZmaXg6J19jaWltX3pvb21faW1hcC5odG1sJ1xuICB9LFxuICAnem9vbS1vdXQtbWFwJzoge1xuICAgIHRpdGxlOidab29tIE91dCBNYXAnLFxuICAgIHN1ZmZpeDonX2NpaW1fem9vbW91dC5qcGcnLFxuICAgIHVzZW1hcDonaW1hcF96b29tb3V0JyxcbiAgICBtYXBTdWZmaXg6J19jaWltX3pvb21vdXRfaW1hcC5odG1sJ1xuICB9LFxuICAnaW50ZW5zaXR5LWRpc3RhbmNlJzoge1xuICAgIHRpdGxlOidJbnRlbnNpdHkgVnMuIERpc3RhbmNlJyxcbiAgICBzdWZmaXg6J19wbG90X2F0dGVuLmpwZycsXG4gICAgc3VidmlldzogRFlGSUludGVuc2l0eUdyYXBoVmlldyxcbiAgICBzdWJ2aWV3Q29udGVudDogJ2R5ZmlfcGxvdF9hdHRlbi5qc29uJ1xuICB9LFxuICAncmVzcG9uc2UtdGltZSc6IHtcbiAgICB0aXRsZTonUmVzcG9uc2VzIFZzLiBUaW1lJyxcbiAgICBzdWZmaXg6J19wbG90X251bXJlc3AuanBnJ1xuICB9LFxuICAncmVzcG9uc2UtbGlzdCc6IHtcbiAgICB0aXRsZTogJ0RZRkkgUmVzcG9uc2VzJyxcbiAgICBzdWJ2aWV3OiBEWUZJUmVzcG9uc2VzVmlldyxcbiAgICBzdWJ2aWV3Q29udGVudDogJ2NkaV96aXAueG1sJ1xuICB9XG59O1xuXG5cbi8qKlxuICogVGhpcyBjbGFzcyBleHRlbmRzIGEgUHJvZHVjdFZpZXcgYW5kIGlzIHVzZWQgdG8gcmVuZGVyIGEgRFlGSSBwcm9kdWN0LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gKiAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zLiBTZWUgX2luaXRpYWxpemUgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xudmFyIERZRklWaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9yZXNvdXJjZXMsXG4gICAgICBfdGFiTGlzdCxcbiAgICAgIF90YWJzO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IFByb2R1Y3RWaWV3KG9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ldyB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICAgKiAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zLiBOb3RoaW5nIHNwZWNpZmljIHRvIHRoaXMgdmlldyBhdCB0aGlzIHRpbWUuXG4gICAqL1xuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgvKm9wdGlvbnMqLykge1xuICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2R5ZmktdmlldycpO1xuXG4gICAgX3Jlc291cmNlcyA9IFV0aWwuZXh0ZW5kKHt9LCBfUkVTT1VSQ0VTLCBvcHRpb25zLnJlc291cmNlcyk7XG4gIH07XG5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbWFnZS1iYXNlZCB0YWIuIEltYWdlLWJhc2VkIHRhYnMgY29uc2lzdCBvZiBhbiBpbWFnZSB0YWcsXG4gICAqIG9wdGlvbmFsbHkgd3JhcHBlZCBpbiBhIGxpbmssIG9wdGlvbmFsbHkgd2l0aCBhIGNvcnJlc3BvbmRpbmcgaW1hZ2UgbWFwXG4gICAqIGZvciBpbnRlcmF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyB7T2JqZWN0fVxuICAgKiAgICAgSW5mb3JtYXRpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGUgaW1hZ2UtYmFzZWQgdGFiLlxuICAgKiBAcGFyYW0gcGFyYW1zLmFsdCB7U3RyaW5nfVxuICAgKiAgICAgVGhlIHRpdGxlIGZvciB0aGlzIHRhYi4gQWxzbyB1c2VkIGFzIGFsdCB0ZXh0IGZvciB0aGUgaW1hZ2UuXG4gICAqIEBwYXJhbSBwYXJhbXMuaHJlZiB7U3RyaW5nfSBPcHRpb25hbC5cbiAgICogICAgIFRoZSBVUkwgdG8gdXNlIGZvciBhIGxpbmsgd3JhcHBpbmcgdGhlIGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLFxuICAgKiAgICAgbm8gbGluayB3aWxsIHdyYXAgdGhlIGltYWdlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmltYWdlIHtTdHJpbmd9XG4gICAqICAgICBUaGUgVVJMIHRvIHVzZSBmb3IgdGhlIGltYWdlIHNvdXJjZS5cbiAgICogQHBhcmFtIHBhcmFtcy5tYXAge1N0cmluZ30gT3B0aW9uYWwuXG4gICAqICAgICBUaGUgVVJMIHRvIHVzZSBmb3IgdGhlIGltYWdlIG1hcC4gSWYgbm90IHNwZWNpZmllZCwgbm8gY29ycmVzcG9uZGluZ1xuICAgKiAgICAgaW1hZ2UgbWFwIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZW1hcCB7U3RyaW5nfSBPcHRpb25hbC5cbiAgICogICAgIFRoZSBuYW1lL2lkIHRvIHVzZSBmb3Igc2ltcGxlIGltYWdlIG1hcHMuIFN2Z0ltYWdlTWFwICh0aGUgdHlwaWNhbFxuICAgKiAgICAgYmVoYXZpb3IpIHdpbGwgbm90IHVzZSB0aGlzIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgQSB0YWIgb2JqZWN0IGFzIGV4cGVjdGVkIGluIG9yZGVyIHRvIHByb3ZpZGUgdG8gdGhlIFRhYkxpc3QjYWRkVGFiXG4gICAqICAgICBtZXRob2QuXG4gICAqXG4gICAqIEBzZWUgVGFiTGlzdCNhZGRUYWJcbiAgICovXG4gIF90aGlzLmNyZWF0ZUltYWdlVGFiID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBjb250YWluZXIsXG4gICAgICAgIGltYWdlLFxuICAgICAgICBtYXA7XG5cbiAgICBpZiAocGFyYW1zLmhyZWYpIHtcbiAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBwYXJhbXMuaHJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICBjb250YWluZXIuY2xhc3NOYW1lID0gJ2R5ZmktdGFibGlzdC1pbWFnZSc7XG5cbiAgICBpZiAoIXBhcmFtcy5tYXApIHtcbiAgICAgIGltYWdlID0gY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpKTtcbiAgICAgIGltYWdlLnNldEF0dHJpYnV0ZSgnYWx0JywgcGFyYW1zLmFsdCk7XG4gICAgICAvLyBEZWZlciBzZXR0aW5nIGltYWdlIHNyYyBzbyBpbWFnZSBpcyBub3QgZmV0Y2hlZCB1bnRpbCB0YWIgaXMgbG9hZGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRpdGxlOiBwYXJhbXMuYWx0LFxuICAgICAgY29udGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocGFyYW1zLm1hcCkge1xuICAgICAgICAgIG1hcCA9IFN2Z0ltYWdlTWFwKHtcbiAgICAgICAgICAgIGVsOiBjb250YWluZXIsXG4gICAgICAgICAgICBpbWFnZUFsdDogcGFyYW1zLmFsdCxcbiAgICAgICAgICAgIGltYWdlVXJsOiBwYXJhbXMuaW1hZ2UsXG4gICAgICAgICAgICBtYXBVcmw6IHBhcmFtcy5tYXAsXG4gICAgICAgICAgICBtYXBOYW1lOiBwYXJhbXMubWFwTmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgIH0sXG4gICAgICAvLyBDYWxsZWQgd2hlbiB0YWIgbGlzdCBpcyBkZXN0cm95ZWQuIENsZWFucyB1cCBtYXAgaWYgb25lIHdhcyBnZW5lcmF0ZWQuXG4gICAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBtYXAuZGVzdHJveSkge1xuICAgICAgICAgIG1hcC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBDYWxsZWQgd2hlbiB0YWIgaXMgc2VsZWN0ZWQuIEdpdmUgbWFwIGNoYW5jZSB0byByZW5kZXIgaWYgb25lIHdhc1xuICAgICAgLy8gZ2VuZXJhdGVkLCBvdGhlcndpc2UganVzdCBzZXQgaW1hZ2Uuc3JjIHRvIGZldGNoIHRoZSBjb250ZW50LlxuICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBtYXAucmVuZGVyKSB7XG4gICAgICAgICAgbWFwLnJlbmRlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKGltYWdlKSB7XG4gICAgICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlKCdzcmMnLCBwYXJhbXMuaW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN1YnZpZXctYmFzZWQgdGFiLiBTdWJ2aWV3LWJhc2VkIHRhYnMgZGVsZWdhdGUgcmVuZGVyaW5nXG4gICAqIHRvIGEgZGlmZmVyZW50IHZpZXcuIFRoZSBzdWJ2aWV3IGl0c2VsZiBpcyBjcmVhdGVkIGltbWVkaWF0ZWx5LCByZW5kZXJlZFxuICAgKiBkdXJpbmcgdGFiLm9uU2VsZWN0LCBhbmQgZGVzdHJveWVkIGR1cmluZyB0YWJMaXN0Lm9uRGVzdHJveS5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyB7T2JqZWN0fVxuICAgKiAgICAgQ29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyB0aGUgc3Vidmlldy1iYXNlIHRhYi5cbiAgICogQHBhcmFtIHBhcmFtcy5jb25zdHJ1Y3RvciB7RnVuY3Rpb259XG4gICAqICAgICBBIGNvbnN0cnVjdG9yIGZhY3RvcnkgdGhhdCByZXR1cm5zIGEgdmlldyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHBhcmFtcy5jb250ZW50IHtNb2RlbH1cbiAgICogICAgIFRoZSBtb2RlbCB0byBwcm92aWRlIHRoZSBjcmVhdGVkIHZpZXcuIFR5cGljYWxseSBhIHtDb250ZW50fSBtb2RlbC5cbiAgICogQHBhcmFtIHBhcmFtcy50aXRsZSB7U3RyaW5nfVxuICAgKiAgICAgVGhlIHRpdGxlIHRvIHB1dCBvbiB0aGUgdGFiLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICBBIHRhYiBvYmplY3QgYXMgZXhwZWN0ZWQgaW4gb3JkZXIgdG8gcHJvdmlkZSB0byB0aGUgVGFiTGlzdCNhZGRUYWJcbiAgICogICAgIG1ldGhvZC5cbiAgICpcbiAgICogQHNlZSBUYWJMaXN0I2FkZFRhYlxuICAgKi9cbiAgX3RoaXMuY3JlYXRlU3ViVmlld1RhYiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgc3VidmlldztcblxuICAgIHN1YnZpZXcgPSBwYXJhbXMuY29uc3RydWN0b3Ioe1xuICAgICAgbW9kZWw6IHBhcmFtcy5jb250ZW50LFxuICAgICAgcHJvZHVjdDogX3RoaXMubW9kZWxcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICB0aXRsZTogcGFyYW1zLnRpdGxlLFxuICAgICAgY29udGVudDogc3Vidmlldy5lbCxcbiAgICAgIG9uRGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJ2aWV3LmRlc3Ryb3koKTtcbiAgICAgIH0sXG4gICAgICBvblNlbGVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJ2aWV3LnJlbmRlcigpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0YWIgYmFzZWQgb24gaW5mb3JtYXRpb24gZm91bmQgaW4gdGhlIGdpdmVuIHBhcmFtcy4gQmFzZWQgb24gdGhlXG4gICAqIGF2YWlsYWJsZSBpbmZvcm1hdGlvbiBhbmQgY29ycmVzcG9uZGluZyBjb250ZW50IG9uIGBfdGhpcy5tb2RlbGAsIHRoaXNcbiAgICogbWV0aG9kIHdpbGwgZWl0aGVyICgxKSBwcm9kdWNlIGEgc3Vidmlldy1iYXNlZCB0YWIsICgyKSBwcm9kdWNlIGFuXG4gICAqIGltYWdlLWJhc2VkIHRhYiwgb3IgKDMpIG5vdCBwcm9kdWNlIGEgdGFiLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIHtPYmplY3R9XG4gICAqICAgICBDb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIHRoZSB0YWIuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgIEEgdGFiIG9iamVjdCBhcyBleHBlY3RlZCBpbiBvcmRlciB0byBwcm92aWRlIHRvIHRoZSBUYWJMaXN0I2FkZFRhYlxuICAgKiAgICAgbWV0aG9kLlxuICAgKlxuICAgKiBAc2VlIFRhYkxpc3QjYWRkVGFiXG4gICAqIEBzZWUgRFlGSVZpZXcjY3JlYXRlSW1hZ2VUYWJcbiAgICogQHNlZSBEWUZJVmlldyNjcmVhdGVTdWJWaWV3VGFiXG4gICAqL1xuICBfdGhpcy5jcmVhdGVUYWIgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIGNvZGUsXG4gICAgICAgIGltYWdlQ29udGVudCxcbiAgICAgICAgaW1hZ2VNYXBDb250ZW50LFxuICAgICAgICBzdWJ2aWV3Q29udGVudCxcbiAgICAgICAgdGFiO1xuXG4gICAgY29kZSA9IF90aGlzLm1vZGVsLmdldCgnY29kZScpO1xuXG4gICAgaW1hZ2VDb250ZW50ID0gX3RoaXMubW9kZWwuZ2V0Q29udGVudChjb2RlICsgcGFyYW1zLnN1ZmZpeCk7XG4gICAgaW1hZ2VNYXBDb250ZW50ID0gX3RoaXMubW9kZWwuZ2V0Q29udGVudChjb2RlICsgcGFyYW1zLm1hcFN1ZmZpeCk7XG4gICAgc3Vidmlld0NvbnRlbnQgPSBfdGhpcy5tb2RlbC5nZXRDb250ZW50KHBhcmFtcy5zdWJ2aWV3Q29udGVudCk7XG5cbiAgICBpZiAocGFyYW1zLnN1YnZpZXcgJiYgc3Vidmlld0NvbnRlbnQpIHtcbiAgICAgIHRhYiA9IF90aGlzLmNyZWF0ZVN1YlZpZXdUYWIoe1xuICAgICAgICBjb25zdHJ1Y3RvcjogcGFyYW1zLnN1YnZpZXcsXG4gICAgICAgIGNvbnRlbnQ6IHN1YnZpZXdDb250ZW50LFxuICAgICAgICB0aXRsZTogcGFyYW1zLnRpdGxlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGltYWdlQ29udGVudCkge1xuICAgICAgdGFiID0gX3RoaXMuY3JlYXRlSW1hZ2VUYWIoe1xuICAgICAgICBhbHQ6IHBhcmFtcy50aXRsZSxcbiAgICAgICAgaHJlZjogcGFyYW1zLmhyZWYsXG4gICAgICAgIGltYWdlOiBpbWFnZUNvbnRlbnQuZ2V0KCd1cmwnKSxcbiAgICAgICAgbWFwOiBpbWFnZU1hcENvbnRlbnQgPyBpbWFnZU1hcENvbnRlbnQuZ2V0KCd1cmwnKSA6IG51bGwsXG4gICAgICAgIG1hcE5hbWU6IHBhcmFtcy51c2VtYXBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YWI7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHN1Yi12aWV3cyAoVGFiTGlzdCkgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLiBDYWxscyBwYXJlbnRcbiAgICogZGVzdHJveSBtZXRob2QgdmlhIGNvbXBvc2l0aW9uLlxuICAgKlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF90YWJMaXN0ICYmIF90YWJMaXN0LmRlc3Ryb3kpIHtcbiAgICAgIF90YWJMaXN0LmRlc3Ryb3koKTtcbiAgICB9XG5cblxuICAgIF9yZXNvdXJjZXMgPSBudWxsO1xuICAgIF90YWJMaXN0ID0gbnVsbDtcbiAgICBfdGFicyA9IG51bGw7XG5cblxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBgX3RhYkxpc3RgIGFuZCBsb2FkcyB0YWIgY29udGVudHMgYmFzZWQgb24gd2hhdCBpcyBhdmFpbGFibGVcbiAgICogaW4gYF90aGlzLm1vZGVsYC4gSWYgYW4gYF90YWJMaXN0YCB3YXMgcHJldmlvdXNseSBjcmVhdGVkLCBpdCBpcyBkZXN0cm95ZWRcbiAgICogYmVmb3JlIGEgbmV3IGBfdGFiTGlzdGAgaXMgY3JlYXRlZC4gVGhpcyBpcyByZXF1aXJlZCBzaW5jZSB7VGFiTGlzdH0gZG9lc1xuICAgKiBub3QgeWV0IGhhdmUgYSBcInJlbW92ZVRhYlwiIG1ldGhvZC5cbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3RhYkxpc3QgJiYgX3RhYkxpc3QuZGVzdHJveSkge1xuICAgICAgX3RhYkxpc3QuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIF90YWJMaXN0ID0gVGFiTGlzdCh7XG4gICAgICBlbDogX3RoaXMuZWwsXG4gICAgICB0YWJzOiBbXVxuICAgIH0pO1xuXG4gICAgLy8gVGhlIGBhZGRUYWJgIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgc2VsZWN0IG1ldGhvZCBzdWNoXG4gICAgLy8gdGhhdCB0aGlzIHZpZXcgY2FuIHN1YnNlcXVlbnRseSBzZWxlY3QgYW55IHBhcnRpY3VsYXIgdGFiIGFzIGRlc2lyZWQuXG4gICAgX3RhYnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfcmVzb3VyY2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBpbmZvLFxuICAgICAgICAgIHRhYjtcblxuICAgICAgaW5mbyA9IF9yZXNvdXJjZXNba2V5XTtcbiAgICAgIHRhYiA9IF90aGlzLmNyZWF0ZVRhYihpbmZvKTtcbiAgICAgIGlmICh0YWIpIHtcbiAgICAgICAgX3RhYnNba2V5XSA9IF90YWJMaXN0LmFkZFRhYih0YWIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRFlGSVZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkMyA9IHJlcXVpcmUoJ2QzJyksXG4gICAgQ2xhc3NMaXN0ID0gcmVxdWlyZSgnZDMvQ2xhc3NMaXN0JyksXG4gICAgRDNMaW5lVmlldyA9IHJlcXVpcmUoJ2QzL0QzTGluZVZpZXcnKSxcbiAgICBEM1N1YlZpZXcgPSByZXF1aXJlKCdkMy9EM1N1YlZpZXcnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxuLyoqXG4gKiBUaGlzIGNsYXNzIGV4dGVuZHMgdGhlIHtEM1N1YlZpZXd9IGNsYXNzIGFuZCBpcyBzcGVjaWZpY2FsbHkgdXNlZFxuICogZm9yIHJlbmRlcmluZyBiaW5uZWQgc3RhbmRhcmQgZGV2aWF0aW9uIGRhdGEgYXMgcGFydCBvZiBhIEQzTGluZVZpZXdcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBhIEQzTGluZVZpZXdcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucy5oaXN0b2dyYW0ge09iamVjdH1cbiAqICAgIEFuIGFycmF5IG9mIGRhdGFwb2ludHMgd2l0aCBzdGFuZGFyZCBkZXZpYXRpb24gZGF0YVxuICogICAgWyB7eDogeDEsIHk6IHkxLCBzdGRldjogdmFsdWV9LCAuLi5dXG4gKi9cbnZhciBTdGFuZGFyZERldmlhdGlvbkxpbmVWaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9kYXRhLFxuICAgICAgX2VsLFxuICAgICAgX2hpc3RvZ3JhbXMsXG4gICAgICBfbGVnZW5kLFxuICAgICAgX2xlZ2VuZExpbmUsXG4gICAgICBfbGluZVZpZXcsXG4gICAgICBfeCxcbiAgICAgIF95O1xuXG4gIF90aGlzID0gRDNTdWJWaWV3KG9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBAQ29uc3RydWN0b3JcbiAgICpcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHZpZXcuIFNlZSBjbGFzcyBsZXZlbCBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIENsYXNzTGlzdC5wb2x5ZmlsbChfdGhpcy5lbCk7XG4gICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnU3RhbmRhcmREZXZpYXRpb25MaW5lVmlldycpO1xuICAgIF9lbCA9IGQzLnNlbGVjdChfdGhpcy5lbCk7XG5cbiAgICBfaGlzdG9ncmFtcyA9IF9lbC5hcHBlbmQoJ2cnKTtcbiAgICBfbGluZVZpZXcgPSBEM0xpbmVWaWV3KFV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICBlbDogX2VsLmFwcGVuZCgnZycpLm5vZGUoKSxcbiAgICAgIGxlZ2VuZDogX3RoaXMubGVnZW5kXG4gICAgfSkpO1xuXG4gICAgX2RhdGEgPSBvcHRpb25zLmhpc3RvZ3JhbTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyBhIHBvaW50IHdpdGggYSBoaXN0b2dyYW0gKGZvciB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uKVxuICAgKiBvbiB0aGUgRDNMaW5lVmlldy5cbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfeCA9IF90aGlzLnZpZXcubW9kZWwuZ2V0KCd4QXhpc1NjYWxlJyk7XG4gICAgX3kgPSBfdGhpcy52aWV3Lm1vZGVsLmdldCgneUF4aXNTY2FsZScpO1xuXG4gICAgX2xpbmVWaWV3LnJlbmRlcigpO1xuICAgIF9oaXN0b2dyYW1zLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuXG4gICAgaWYgKF9kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBzdGFuZGFyZCBkZXZpYXRpb24gZm9yIGVhY2ggcG9pbnRcbiAgICBfZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIGVsLFxuICAgICAgICAgIHAweSxcbiAgICAgICAgICBwMXksXG4gICAgICAgICAgcHgsXG4gICAgICAgICAgd2lkdGg7XG5cbiAgICAgIGlmIChwb2ludC5zdGRldiA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdpZHRoID0gNjtcbiAgICAgIGVsID0gX2hpc3RvZ3JhbXMuYXBwZW5kKCdwYXRoJykuYXR0cignY2xhc3MnLCAnc3RhbmRhcmQtZGV2aWF0aW9uJyk7XG4gICAgICBweCA9IF94KHBvaW50LngpO1xuICAgICAgcDB5ID0gX3kocG9pbnQueSAtIHBvaW50LnN0ZGV2KTtcbiAgICAgIHAxeSA9IF95KHBvaW50LnkgKyBwb2ludC5zdGRldik7XG4gICAgICBlbC5hdHRyKCdkJyxcbiAgICAgICAgICAnTSAnICsgKHB4IC0gd2lkdGgpICsgJyAnICsgcDB5ICtcbiAgICAgICAgICAnTCAnICsgKHB4ICsgd2lkdGgpICsgJyAnICsgcDB5ICtcbiAgICAgICAgICAnTSAnICsgKHB4IC0gd2lkdGgpICsgJyAnICsgcDF5ICtcbiAgICAgICAgICAnTCAnICsgKHB4ICsgd2lkdGgpICsgJyAnICsgcDF5ICtcbiAgICAgICAgICAnTSAnICsgcHggKyAnICcgKyBwMHkgK1xuICAgICAgICAgICdMICcgKyBweCArICcgJyArIHAxeVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBsZWdlbmRcbiAgICBpZiAoX2xpbmVWaWV3LmxlZ2VuZCkge1xuICAgICAgQ2xhc3NMaXN0LnBvbHlmaWxsKF90aGlzLmxlZ2VuZCk7XG4gICAgICBfbGVnZW5kID0gZDMuc2VsZWN0KF90aGlzLmxlZ2VuZCk7XG4gICAgICBfbGVnZW5kTGluZSA9IF9sZWdlbmQuc2VsZWN0KCdwYXRoJyk7XG4gICAgICBfbGVnZW5kTGluZS5hdHRyKCdkJyxcbiAgICAgICAgICAnTSAxICAtMyBMIDI0IC0zJyArXG4gICAgICAgICAgJ00gMSAgLTkgTCAxICAgMycgK1xuICAgICAgICAgICdNIDI0IC05IEwgMjQgIDMnXG4gICAgICApLmF0dHIoJ2NsYXNzJywgJ3N0YW5kYXJkLWRldmlhdGlvbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kIGV2ZW50IGxpc3RlbmVycyBhbmQgZnJlZSByZWZlcmVuY2VzLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF90aGlzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKF9saW5lVmlldykge1xuICAgICAgX2xpbmVWaWV3LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBfZGF0YSA9IG51bGw7XG4gICAgX2VsID0gbnVsbDtcbiAgICBfaGlzdG9ncmFtcyA9IG51bGw7XG4gICAgX2xlZ2VuZCA9IG51bGw7XG4gICAgX2xlZ2VuZExpbmUgPSBudWxsO1xuICAgIF9saW5lVmlldyA9IG51bGw7XG4gICAgX3ggPSBudWxsO1xuICAgIF95ID0gbnVsbDtcblxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFuZGFyZERldmlhdGlvbkxpbmVWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyksXG4gICAgVmlldyA9IHJlcXVpcmUoJ212Yy9WaWV3Jyk7XG5cblxuLy8gRGVmYXVsdCB2YWx1ZXMgdXNlZCBieSBjb25zdHJ1Y3Rvci5cbnZhciBfREVGQVVMVFMgPSB7XG4gIC8vIGxhYmVsIC0gVGhlIHF1ZXN0aW9uIGJlaW5nIGFza2VkXG4gIHR5cGU6ICdpbnB1dCcsXG4gIGxhYmVsOiBudWxsLFxuICBwbGFjZWhvbGRlcjogJycsXG4gIHZhbHVlOiBudWxsXG59O1xuXG52YXIgX0lEX1NFUVVFTkNFID0gMDtcblxuXG4vKipcbiAqIENsYXNzOiBUZXh0UXVlc3Rpb25WaWV3XG4gKiBDcmVhdGVzIGEgbmV3IFRleHRRdWVzdGlvblZpZXcuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFNlZSBfREVGQVVMVFMgYWJvdmUgZm9yXG4gKiAgICAgZGV0YWlsZWQgZG9jdW1lbnRhdGlvbiBvbiB3aGF0IGNhbiBiZSBzcGVjaWZpZWQuXG4gKi9cblxudmFyIFRleHRRdWVzdGlvblZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2lucHV0LFxuICAgICAgX2xhYmVsO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBpZCxcbiAgICAgICAgc2VjdGlvbjtcblxuICAgIGlkID0gJ3RleHQtaW5wdXQtJyArICgrK19JRF9TRVFVRU5DRSk7XG5cbiAgICBzZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuICAgIF9sYWJlbCA9IHNlY3Rpb24uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSk7XG4gICAgX2lucHV0ID0gc2VjdGlvbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KG9wdGlvbnMudHlwZSkpO1xuXG4gICAgc2VjdGlvbi5jbGFzc0xpc3QuYWRkKCdxdWVzdGlvbicpO1xuICAgIHNlY3Rpb24uY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dCcpO1xuXG4gICAgX2xhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgaWQpO1xuXG4gICAgX2lucHV0LmlkID0gaWQ7XG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2lucHV0Jykge1xuICAgICAgX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICBfaW5wdXQuc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIG9wdGlvbnMucGxhY2Vob2xkZXIpO1xuICAgIH1cblxuICAgIF9sYWJlbC5pbm5lckhUTUwgPSBvcHRpb25zLmxhYmVsO1xuICAgIF9pbnB1dC52YWx1ZSA9IG9wdGlvbnMudmFsdWUgfHwgJyc7XG5cbiAgICBfdGhpcy5lbC5hcHBlbmRDaGlsZChzZWN0aW9uKTtcblxuXG4gICAgX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIF90aGlzLm9uQ2hhbmdlKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBGcmVlIHJlZmVyZW5jZXNcbiAgICpcbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIF9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBfdGhpcy5vbkNoYW5nZSk7XG5cbiAgICBfaW5wdXQgPSBudWxsO1xuICAgIF9sYWJlbCA9IG51bGw7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogR2V0IGFuc3dlcnMgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfdGhpcy5nZXRBbnN3ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7dmFsdWU6IF9pbnB1dC52YWx1ZSB8fCBudWxsLCBsYWJlbDogX2xhYmVsLmlubmVySFRNTH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGFuIGV2ZW50IGNoYW5nZSB3aGVuIGEgdGV4dCBxdWVzdGlvbiBjaGFuZ2VzLlxuICAgKlxuICAgKi9cbiAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMudHJpZ2dlcignY2hhbmdlJywgX3RoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGFuc3dlci5cbiAgICpcbiAgICovXG4gIF90aGlzLnNldEFuc3dlcnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBfaW5wdXQudmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRRdWVzdGlvblZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGaW5pdGVGYXVsdFZpZXcgPSByZXF1aXJlKCdmaW5pdGUtZmF1bHQvRmluaXRlRmF1bHRWaWV3JyksXG4gICAgTW9kdWxlID0gcmVxdWlyZSgnY29yZS9Nb2R1bGUnKSxcbiAgICBTY2llbnRpZmljU3VtbWFyeU1vZHVsZSA9IHJlcXVpcmUoJ3NjaWVudGlmaWMvU2NpZW50aWZpY1N1bW1hcnlNb2R1bGUnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cbnZhciBfSUQsXG4gICAgX1RJVExFLFxuICAgIF9UWVBFUztcblxuX0lEID0gJ2Zpbml0ZS1mYXVsdCc7XG5fVElUTEUgPSAnRmluaXRlIEZhdWx0Jztcbl9UWVBFUyA9IFsnZmluaXRlLWZhdWx0J107XG5cbnZhciBGaW5pdGVGYXVsdE1vZHVsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9maW5pdGVGYXVsdFZpZXc7XG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgX3RoaXMgPSBNb2R1bGUob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuSUQgPSBfSUQ7XG4gICAgX3RoaXMuVElUTEUgPSBfVElUTEU7XG4gIH07XG5cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9maW5pdGVGYXVsdFZpZXcpIHtcbiAgICAgIF9maW5pdGVGYXVsdFZpZXcuZGVzdHJveSgpO1xuICAgICAgX2Zpbml0ZUZhdWx0VmlldyA9IG51bGw7XG4gICAgfVxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGRldGFpbHMgZm9yIHRoaXMgbW9kdWxlLiBEZWZlcnMgYnVsayBvZiBoZWFkZXIgSW5mb3JtYXRpb25cbiAgICogdG8gZ2VuZXJhbGl6ZWQgaGVhZGVyIHJlbmRlcmluZy4gVXNlcyBGaW5pdGVGYXVsdFZpZXcgZm9yIGJ1bGsgb2ZcbiAgICogY29udGVudCByZW5kZXJpbmcuXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvb3RlcixcbiAgICAgICAgcHJvZHVjdDtcblxuICAgIC8vIERlc3Ryb3kgRmluaXRlRmF1bHRWaWV3IGlmIGl0IGFscmVhZHkgZXhpc3RzXG4gICAgaWYgKF9maW5pdGVGYXVsdFZpZXcgJiYgX2Zpbml0ZUZhdWx0Vmlldy5kZXN0cm95KSB7XG4gICAgICBfZmluaXRlRmF1bHRWaWV3LmRlc3Ryb3koKTtcbiAgICAgIF9maW5pdGVGYXVsdFZpZXcgPSBudWxsO1xuICAgIH1cblxuICAgIF90aGlzLmhlYWRlci5pbm5lckhUTUwgPSAnPGgzPkZpbml0ZSBGYXVsdDwvaDM+JztcbiAgICBVdGlsLmVtcHR5KF90aGlzLmNvbnRlbnQpO1xuICAgIFV0aWwuZW1wdHkoX3RoaXMuZm9vdGVyKTtcblxuICAgIHByb2R1Y3QgPSBfdGhpcy5nZXRQcm9kdWN0KCdmaW5pdGUtZmF1bHQnKTtcbiAgICBpZiAoIXByb2R1Y3QpIHtcbiAgICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID1cbiAgICAgICAgICAnPHAgY2xhc3M9XCJhbGVydCB3YXJuaW5nXCI+Tm8gRmluaXRlIEZhdWx0IEZvdW5kPC9wPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERpc3BsYXkgcmV2aWV3L3ByZWZlcnJlZCBzdGF0dXMgaW4gaGVhZGVyIHNlY3Rpb25cbiAgICAgIF90aGlzLmhlYWRlci5hcHBlbmRDaGlsZChfdGhpcy5nZXRQcm9kdWN0SGVhZGVyKHtcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgc3VtbWFyeU1vZHVsZTogU2NpZW50aWZpY1N1bW1hcnlNb2R1bGVcbiAgICAgIH0pKTtcblxuICAgICAgLy8gRGlzcGxheSBGaW5pdGUgRmF1bHQgVmlldyBpbiBjb250ZW50IHNlY3Rpb25cbiAgICAgIF9maW5pdGVGYXVsdFZpZXcgPSBGaW5pdGVGYXVsdFZpZXcoe1xuICAgICAgICBlbDogX3RoaXMuY29udGVudCxcbiAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgIH0pO1xuICAgICAgX2Zpbml0ZUZhdWx0Vmlldy5yZW5kZXIoKTtcblxuICAgICAgLy8gRGlzcGxheSBkb3dubG9hZHMgaW4gZm9vdGVyIHNlY3Rpb25cbiAgICAgIGZvb3RlciA9IF90aGlzLmdldFByb2R1Y3RGb290ZXIoe1xuICAgICAgICBwcm9kdWN0OiBwcm9kdWN0LFxuICAgICAgfSk7XG4gICAgICBpZiAoZm9vdGVyKSB7XG4gICAgICAgIF90aGlzLmZvb3Rlci5hcHBlbmRDaGlsZChmb290ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfaW5pdGlhbGl6ZSgpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5GaW5pdGVGYXVsdE1vZHVsZS5JRCA9IF9JRDtcbkZpbml0ZUZhdWx0TW9kdWxlLlRJVExFID0gX1RJVExFO1xuRmluaXRlRmF1bHRNb2R1bGUuVFlQRVMgPSBfVFlQRVM7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGaW5pdGVGYXVsdE1vZHVsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgQmFzaWNQaW5WaWV3ID0gcmVxdWlyZSgnY29yZS9CYXNpY1BpblZpZXcnKSxcbiAgICBGaW5pdGVGYXVsdE1vZHVsZSA9IHJlcXVpcmUoJ2Zpbml0ZS1mYXVsdC9GaW5pdGVGYXVsdE1vZHVsZScpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0RFRkFVTFRTID0ge1xuICBtb2R1bGU6IEZpbml0ZUZhdWx0TW9kdWxlXG59O1xuXG52YXIgRmluaXRlRmF1bHRQaW5WaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IEJhc2ljUGluVmlldyhvcHRpb25zKTtcblxuXG4gIF90aGlzLmdldFNsaXBJbWFnZSA9IGZ1bmN0aW9uIChwcm9kdWN0KSB7XG4gICAgdmFyIGNvZGUsXG4gICAgICAgIGltYWdlLFxuICAgICAgICBwYXRocztcblxuICAgIGNvZGUgPSBwcm9kdWN0LmdldCgncHJvcGVydGllcycpLmV2ZW50c291cmNlY29kZTtcbiAgICBpbWFnZSA9IHByb2R1Y3QuZ2V0Q29udGVudCgnd2ViLycgKyBjb2RlICsgJ19zbGlwMi5wbmcnKTtcbiAgICBpbWFnZSA9IGltYWdlIHx8IHByb2R1Y3QuZ2V0Q29udGVudCgnd2ViMS8nICsgY29kZSArICdfc2xpcDIucG5nJyk7XG4gICAgaW1hZ2UgPSBpbWFnZSB8fCBwcm9kdWN0LmdldENvbnRlbnQoJ3dlYjIvJyArIGNvZGUgKyAnX3NsaXAyLnBuZycpO1xuXG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcGF0aHMgPSBwcm9kdWN0LmdldCgnY29udGVudHMnKTtcbiAgICAgIHBhdGhzID0gcGF0aHMgPyBwYXRocy5nZXRJZHMoKSA6IHt9O1xuICAgICAgcGF0aHMgPSBPYmplY3Qua2V5cyhwYXRocyk7XG5cbiAgICAgIHBhdGhzLnNvbWUoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguaW5kZXhPZignc2xpcCcpICE9PSAtMSkge1xuICAgICAgICAgIGltYWdlID0gcHJvZHVjdC5nZXRDb250ZW50KHBhdGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgY29udGVudCBzZWN0aW9uIG9mIHRoZSBwaW4uIFRoaXMgbG9hZHMgdGhlIHNtYWxsZXIgdmVyc2lvblxuICAgKiBvZiB0aGUgZmluaXRlLWZhdWx0IGJhc2VtYXAucG5nXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXJQaW5Db250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbWFnZSxcbiAgICAgICAgbWFya3VwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGltYWdlID0gX3RoaXMuZ2V0U2xpcEltYWdlKF90aGlzLm1vZGVsKTtcblxuICAgICAgbWFya3VwID0gJzxzcGFuPkNyb3NzLXNlY3Rpb24gb2Ygc2xpcCBkaXN0cmlidXRpb248L3NwYW4+JyArXG4gICAgICAgICAgJzxpbWcgc3JjPVwiJyArIGltYWdlLmdldCgndXJsJykgKyAnXCInICtcbiAgICAgICAgICAnIGNsYXNzPVwiZmluaXRlLWZhdWx0LWNyb3NzLXNlY3Rpb25cIiAnICtcbiAgICAgICAgICAnIGFsdD1cIkNyb3NzLXNlY3Rpb24gb2Ygc2xpcCBkaXN0cmlidXRpb25cIi8+JztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBtYXJrdXAgPSAnPHAgY2xhc3M9XCJhbGVydCBlcnJvclwiPkNvdWxkIG5vdCBsb2FkIGNyb3NzLXNlY3Rpb24gb2YgJyArXG4gICAgICAgICAgJ3NsaXAgZGlzdHJpYnV0aW9uPC9wPic7XG4gICAgfVxuXG4gICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH07XG5cblxuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbml0ZUZhdWx0UGluVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRleHRQcm9kdWN0VmlldyA9IHJlcXVpcmUoJ2NvcmUvVGV4dFByb2R1Y3RWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG5cbn07XG5cblxudmFyIEZpbml0ZUZhdWx0VmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcztcblxuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7Y29udGVudFBhdGg6IG9wdGlvbnMubW9kZWwgP1xuICAgICAgKG9wdGlvbnMubW9kZWwuZ2V0UHJvcGVydHkoJ2V2ZW50c291cmNlY29kZScpICsgJy5odG1sJykgOiAnJ30sXG4gICAgX0RFRkFVTFRTLCBvcHRpb25zXG4gICk7XG4gIF90aGlzID0gVGV4dFByb2R1Y3RWaWV3KG9wdGlvbnMpO1xuXG5cbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGaW5pdGVGYXVsdFZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIEZvcm1hdHRlciA9IHJlcXVpcmUoJ2NvcmUvRm9ybWF0dGVyJyksXG4gICAgTW9kdWxlID0gcmVxdWlyZSgnY29yZS9Nb2R1bGUnKSxcbiAgICBGb2NhbE1lY2hhbmlzbVZpZXcgPSByZXF1aXJlKCdmb2NhbC1tZWNoYW5pc20vRm9jYWxNZWNoYW5pc21WaWV3JyksXG4gICAgU2NpZW50aWZpY1N1bW1hcnlNb2R1bGUgPSByZXF1aXJlKCdzY2llbnRpZmljL1NjaWVudGlmaWNTdW1tYXJ5TW9kdWxlJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMsXG4gICAgX0lELFxuICAgIF9USVRMRSxcbiAgICBfVFlQRVM7XG5cblxuX0lEID0gJ2ZvY2FsLW1lY2hhbmlzbSc7XG5fVElUTEUgPSAnRm9jYWwgTWVjaGFuaXNtJztcbl9UWVBFUyA9IFsnZm9jYWwtbWVjaGFuaXNtJ107XG5cbl9ERUZBVUxUUyA9IHtcbiAgZm9ybWF0dGVyOiBudWxsXG59O1xuXG5cbi8qKlxuICogTW9kdWxlIHRvIGRpc3BsYXkgYSBmb2NhbC1tZWNoYW5pc20gdHlwZSB7UHJvZHVjdH0uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdHRlciB7Rm9ybWF0dGVyfVxuICogICAgIGZvcm1hdHRlciBvYmplY3QgdG8gcGFzcyB0byBGb2NhbE1lY2hhbmlzbVZpZXcuXG4gKi9cbnZhciBGb2NhbE1lY2hhbmlzbU1vZHVsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfZm9ybWF0dGVyLFxuICAgICAgX2ZvY2FsTWVjaGFuaXNtVmlldztcblxuXG4gIF90aGlzID0gTW9kdWxlKG9wdGlvbnMpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuXG4gICAgX3RoaXMuSUQgPSBfSUQ7XG4gICAgX3RoaXMuVElUTEUgPSBfVElUTEU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZyZWUgcmVmZXJlbmNlcy5cbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfZm9jYWxNZWNoYW5pc21WaWV3KSB7XG4gICAgICBfZm9jYWxNZWNoYW5pc21WaWV3LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgX2ZvY2FsTWVjaGFuaXNtVmlldyA9IG51bGw7XG5cbiAgICBfZm9ybWF0dGVyID0gbnVsbDtcbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogUmVuZGVyIHByb2R1Y3QgY29udGVudCwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBubyBwcm9kdWN0IGF2YWlsYWJsZS5cbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZHVjdDtcblxuICAgIHByb2R1Y3QgPSBfdGhpcy5nZXRQcm9kdWN0KCdmb2NhbC1tZWNoYW5pc20nKTtcblxuICAgIF90aGlzLnJlbmRlckhlYWRlcihwcm9kdWN0KTtcbiAgICBfdGhpcy5yZW5kZXJDb250ZW50KHByb2R1Y3QpO1xuICAgIF90aGlzLnJlbmRlckZvb3Rlcihwcm9kdWN0KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBjb250ZW50IHNlY3Rpb24gb2YgdGhpcyBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9kdWN0IHtQcm9kdWN0fVxuICAgKiAgICAgcHJvZHVjdCB0byByZW5kZXIsIG9yIG51bGwgaWYgbm8gcHJvZHVjdC5cbiAgICovXG4gIF90aGlzLnJlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIGlmIChfZm9jYWxNZWNoYW5pc21WaWV3ICYmIF9mb2NhbE1lY2hhbmlzbVZpZXcuZGVzdHJveSkge1xuICAgICAgX2ZvY2FsTWVjaGFuaXNtVmlldy5kZXN0cm95KCk7XG4gICAgICBfZm9jYWxNZWNoYW5pc21WaWV3ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXByb2R1Y3QpIHtcbiAgICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gJzxwIGNsYXNzPVwiYWxlcnQgZXJyb3JcIj4nICtcbiAgICAgICAgICAnTm8gRm9jYWwgTWVjaGFuaXNtIEZvdW5kIScgK1xuICAgICAgICAgICc8L3A+JztcbiAgICB9IGVsc2Uge1xuICAgICAgX2ZvY2FsTWVjaGFuaXNtVmlldyA9IEZvY2FsTWVjaGFuaXNtVmlldyh7XG4gICAgICAgIGVsOiBfdGhpcy5jb250ZW50LFxuICAgICAgICBmb3JtYXR0ZXI6IF9mb3JtYXR0ZXIsXG4gICAgICAgIG1vZGVsOiBwcm9kdWN0XG4gICAgICB9KTtcbiAgICAgIF9mb2NhbE1lY2hhbmlzbVZpZXcucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGZvb3RlciBzZWN0aW9uIG9mIHRoaXMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIHByb2R1Y3QgdG8gcmVuZGVyLCBvciBudWxsIGlmIG5vIHByb2R1Y3QuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJGb290ZXIgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIHZhciBkb3dubG9hZHM7XG5cbiAgICBVdGlsLmVtcHR5KF90aGlzLmZvb3Rlcik7XG4gICAgaWYgKHByb2R1Y3QpIHtcbiAgICAgIGRvd25sb2FkcyA9IF90aGlzLmdldFByb2R1Y3RGb290ZXIoe1xuICAgICAgICBwcm9kdWN0OiBwcm9kdWN0XG4gICAgICB9KTtcbiAgICAgIGlmIChkb3dubG9hZHMpIHtcbiAgICAgICAgX3RoaXMuZm9vdGVyLmFwcGVuZENoaWxkKGRvd25sb2Fkcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGhlYWRlciBzZWN0aW9uIG9mIHRoaXMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIHByb2R1Y3QgdG8gcmVuZGVyLCBvciBudWxsIGlmIG5vIHByb2R1Y3QuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJIZWFkZXIgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIHZhciBoZWFkZXI7XG5cbiAgICBVdGlsLmVtcHR5KF90aGlzLmhlYWRlcik7XG4gICAgX3RoaXMuaGVhZGVyLmlubmVySFRNTCA9ICc8aDM+JyArIF90aGlzLlRJVExFICsgJzwvaDM+JztcblxuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBoZWFkZXIgPSBfdGhpcy5nZXRQcm9kdWN0SGVhZGVyKHtcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgc3VtbWFyeU1vZHVsZTogU2NpZW50aWZpY1N1bW1hcnlNb2R1bGVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIF90aGlzLmhlYWRlci5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5Gb2NhbE1lY2hhbmlzbU1vZHVsZS5JRCA9IF9JRDtcbkZvY2FsTWVjaGFuaXNtTW9kdWxlLlRJVExFID0gX1RJVExFO1xuRm9jYWxNZWNoYW5pc21Nb2R1bGUuVFlQRVMgPSBfVFlQRVM7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGb2NhbE1lY2hhbmlzbU1vZHVsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgRm9jYWxNZWNoYW5pc21Nb2R1bGUgPSByZXF1aXJlKCdmb2NhbC1tZWNoYW5pc20vRm9jYWxNZWNoYW5pc21Nb2R1bGUnKSxcbiAgICBNb21lbnRUZW5zb3JQaW5WaWV3ID0gcmVxdWlyZSgnbW9tZW50LXRlbnNvci9Nb21lbnRUZW5zb3JQaW5WaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIGNsYXNzTmFtZTogJ2ZvY2FsLW1lY2hhbmlzbS1waW4tYmVhY2hiYWxsJyxcbiAgZmlsbENvbG9yOiAnI2ZmYWE2OScsXG4gIG1vZHVsZTogRm9jYWxNZWNoYW5pc21Nb2R1bGVcbn07XG5cblxuLyoqXG4gKiBUaGlzIHZpZXcgaXMgdXNlZCBmb3IgcmVuZGVyaW5nIGEgZm9jYWwgbWVjaGFuaXNtIHBpbi4gQ3VycmVudGx5IGl0XG4gKiBkb2VzIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSB7TW9tZW50VGVuc29yUGluVmlld30gKGkuZS4gYSBiZWFjaGJhbGwpLCBidXRcbiAqIHVzZXMgYSBkaWZmZXJlbnQgY29sb3IgYW5kIGNsYXNzTmFtZSBieSBkZWZhdWx0LlxuICpcbiAqIEBzZWUge21vbWVudC10ZW5zb3IvTW9tZW50VGVuc29yUGluVmlld31cbiAqL1xudmFyIEZvY2FsTWVjaGFuaXNtUGluVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcztcblxuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgX3RoaXMgPSBNb21lbnRUZW5zb3JQaW5WaWV3KG9wdGlvbnMpO1xuXG5cbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGb2NhbE1lY2hhbmlzbVBpblZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBdHRyaWJ1dGlvbiA9IHJlcXVpcmUoJ2NvcmUvQXR0cmlidXRpb24nKSxcbiAgICBNb21lbnRUZW5zb3JWaWV3ID0gcmVxdWlyZSgnbW9tZW50LXRlbnNvci9Nb21lbnRUZW5zb3JWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIGZpbGxDb2xvcjogJyNmZmFhNjknXG59O1xuXG5cbi8qKlxuICogVmlldyBmb3IgZGlzcGxheWluZyBmb2NhbCBtZWNoYW5pc21zLlxuICpcbiAqIFNhbWUgYXMgTW9tZW50VGVuc29yVmlldyBleGNlcHQgc3VwcHJlc3NlcyBheGVzLCBhbmQgTVQgc3BlY2lmaWMgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICBzZWUgTW9tZW50VGVuc29yVmlldy5cbiAqL1xudmFyIEZvY2FsTWVjaGFuaXNtVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcztcblxuXG4gIF90aGlzID0gTW9tZW50VGVuc29yVmlldyhVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKSk7XG5cblxuICAvKipcbiAgICogT3ZlcnJpZGUgZ2V0QXhlcyB0byBzdXBwcmVzcyBheGlzIGluZm9ybWF0aW9uIGZvciBmb2NhbCBtZWNoYW5pc21zLlxuICAgKi9cbiAgX3RoaXMuZ2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBkb24ndCBzaG93IGFueSBheGVzIGluZm9ybWF0aW9uXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udGVudCBmb3IgdGhlIFwiaW5mb1wiIHNlY3Rpb24gb2YgdGhlIG1vbWVudCB0ZW5zb3Igdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHRlbnNvciB7VGVuc29yfVxuICAgKiAgICAgdGhlIHRlbnNvciBiZWluZyBkaXNwbGF5ZWQuXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG4gICAqICAgICBtYXJrdXAgZm9yIHRoZSBpbmZvIHNlY3Rpb24gb2YgdGhlIG1vbWVudCB0ZW5zb3Igdmlldy5cbiAgICovXG4gIF90aGlzLmdldEluZm8gPSBmdW5jdGlvbiAoLyp0ZW5zb3IqLykge1xuICAgIHZhciBjYXRhbG9nLFxuICAgICAgICBjb250cmlidXRvcixcbiAgICAgICAgZGF0YVNvdXJjZSxcbiAgICAgICAgZWwsXG4gICAgICAgIHByb2R1Y3Q7XG5cbiAgICBwcm9kdWN0ID0gX3RoaXMubW9kZWw7XG5cbiAgICBjYXRhbG9nID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnZXZlbnRzb3VyY2UnKTtcbiAgICBjb250cmlidXRvciA9IHByb2R1Y3QuZ2V0KCdzb3VyY2UnKTtcbiAgICBkYXRhU291cmNlID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnYmVhY2hiYWxsLXNvdXJjZScpIHx8IGNvbnRyaWJ1dG9yO1xuXG4gICAgY2F0YWxvZyA9IGNhdGFsb2cudG9VcHBlckNhc2UoKTtcbiAgICBjb250cmlidXRvciA9IEF0dHJpYnV0aW9uLmdldENvbnRyaWJ1dG9yUmVmZXJlbmNlKGNvbnRyaWJ1dG9yKTtcbiAgICBkYXRhU291cmNlID0gQXR0cmlidXRpb24uZ2V0Q29udHJpYnV0b3JSZWZlcmVuY2UoZGF0YVNvdXJjZSk7XG5cbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ21vbWVudC10ZW5zb3ItaW5mbycpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2hvcml6b250YWwtc2Nyb2xsaW5nJyk7XG4gICAgZWwuaW5uZXJIVE1MID1cbiAgICAgICAgJzx0YWJsZT4nICtcbiAgICAgICAgICAnPHRib2R5PicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkNhdGFsb2c8L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyBjYXRhbG9nICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5EYXRhIFNvdXJjZTwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIGRhdGFTb3VyY2UgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkNvbnRyaWJ1dG9yPC90aD4nICtcbiAgICAgICAgICAgICAgJzx0ZD4nICsgY29udHJpYnV0b3IgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICc8L3Rib2R5PicgK1xuICAgICAgICAnPC90YWJsZT4nO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZm9jYWwgbWVjaGFuaXNtIHZpZXcgdGl0bGUuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW5zb3Ige1RlbnNvcn1cbiAgICogICAgIHRoZSB0ZW5zb3IgYmVpbmcgZGlzcGxheWVkLlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fVxuICAgKiAgICAgbWFya3VwIGZvciB0aGUgaW5mbyBzZWN0aW9uIG9mIHRoZSBtb21lbnQgdGVuc29yIHZpZXcuXG4gICAqL1xuICBfdGhpcy5nZXRUaXRsZSA9IGZ1bmN0aW9uICgvKnRlbnNvciovKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgfTtcblxuXG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGb2NhbE1lY2hhbmlzbVZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIER5ZmlGb3JtUGluVmlldyA9IHJlcXVpcmUoJ2R5ZmkvRFlGSUZvcm1QaW5WaWV3JyksXG4gICAgRHlmaVBpblZpZXcgPSByZXF1aXJlKCdkeWZpL0RZRklQaW5WaWV3JyksXG4gICAgRmluaXRlRmF1bHRQaW5WaWV3ID0gcmVxdWlyZSgnZmluaXRlLWZhdWx0L0Zpbml0ZUZhdWx0UGluVmlldycpLFxuICAgIEZvY2FsTWVjaGFuaXNtUGluVmlldyA9IHJlcXVpcmUoJ2ZvY2FsLW1lY2hhbmlzbS9Gb2NhbE1lY2hhbmlzbVBpblZpZXcnKSxcbiAgICBJbnRlcmFjdGl2ZU1hcFBpblZpZXcgPSByZXF1aXJlKCdtYXAvSW50ZXJhY3RpdmVNYXBQaW5WaWV3JyksXG4gICAgTW9tZW50VGVuc29yUGluVmlldyA9IHJlcXVpcmUoJ21vbWVudC10ZW5zb3IvTW9tZW50VGVuc29yUGluVmlldycpLFxuICAgIE9yaWdpblBpblZpZXcgPSByZXF1aXJlKCdvcmlnaW4vT3JpZ2luUGluVmlldycpLFxuICAgIFBBR0VSUGluVmlldyA9IHJlcXVpcmUoJ2xvc3NwYWdlci9QQUdFUlBpblZpZXcnKSxcbiAgICBQcm9kdWN0ID0gcmVxdWlyZSgncGRsL1Byb2R1Y3QnKSxcbiAgICBSZWdpb25hbEluZm9QaW5WaWV3ID0gcmVxdWlyZSgnZ2VuZXJhbC9SZWdpb25hbEluZm9QaW5WaWV3JyksXG4gICAgU2hha2VNYXBQaW5WaWV3ID0gcmVxdWlyZSgnc2hha2VtYXAvU2hha2VNYXBQaW5WaWV3JyksXG4gICAgU3VtbWFyeU1vZHVsZSA9IHJlcXVpcmUoJ2NvcmUvU3VtbWFyeU1vZHVsZScpLFxuICAgIFRzdW5hbWlQaW5WaWV3ID0gcmVxdWlyZSgnZ2VuZXJhbC9Uc3VuYW1pUGluVmlldycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0lELFxuICAgIF9ERUZBVUxUUyxcbiAgICBfVElUTEUsXG5cbiAgICBfaGFzQ29udGVudDtcblxuXG5fSUQgPSAnZXhlY3V0aXZlJztcbl9USVRMRSA9ICdPdmVydmlldyc7XG5cbl9oYXNDb250ZW50ID0gZnVuY3Rpb24gKGV2ZW50UGFnZU1vZGVsKSB7XG4gIHZhciBldjtcblxuICBldiA9IGV2ZW50UGFnZU1vZGVsLmdldCgnZXZlbnQnKTtcbiAgaWYgKGV2ICE9PSBudWxsKSB7XG4gICAgLy8gb25seSBzaG93IHRoaXMgbW9kdWxlIGlmIHRoZXJlIGlzIGFuIGV2ZW50XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5fREVGQVVMVFMgPSB7XG59O1xuXG5cbi8qKlxuICogVGhlIEV4ZWN1dGl2ZVN1bW1hcnlNb2R1bGUgcHJvdmlkZXMgYSBcIlBpbiBCb2FyZFwiIHZpZXdzIG9mIHByZWZlcnJlZCBwcm9kdWN0XG4gKiBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnQgZXZlbnQuXG4gKlxuICovXG52YXIgRXhlY3V0aXZlU3VtbWFyeU1vZHVsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IFN1bW1hcnlNb2R1bGUob3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRXhlY3V0aXZlU3VtbWFyeU1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMubW9kZWwuZXZlbnQge0NhdGFsb2dFdmVudH1cbiAgICogQHBhcmFtIG9wdGlvbnMubW9kZWwuY29uZmlnIHtPYmplY3R9XG4gICAqXG4gICAqL1xuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgvKm9wdGlvbnMqLykge1xuICAgIHZhciBlbDtcblxuICAgIGVsID0gX3RoaXMuZWw7XG5cbiAgICBfdGhpcy5JRCA9IF9JRDtcbiAgICBfdGhpcy5USVRMRSA9IF9USVRMRTtcblxuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2V4ZWN1dGl2ZS1zdW1tYXJ5Jyk7XG5cbiAgICBfdGhpcy5jbGVhclBpbnModHJ1ZSk7XG4gICAgX3RoaXMuY2xlYXJUZXh0cyh0cnVlKTsgLy8gZ2VuZXJhbC1oZWFkZXIgKyBnZW5lcmFsLXRleHRcbiAgICBfdGhpcy5jbGVhckxpbmtzKHRydWUpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgdmlld3MgYXNzb2NpYXRlZCB3aXRoIHBpbnMuXG4gICAqXG4gICAqIEBwYXJhbSBpbml0IHtCb29sZWFufSBPcHRpb25hbC4gRGVmYXVsdCBmYWxzZS5cbiAgICogICAgIEZsYWcgd2hldGhlciB0byByZS1pbml0aWFsaXplIHRoZSB2aWV3cyBhcnJheS4gQnkgZGVmYXVsdCB0aGUgdmlld3NcbiAgICogICAgIGFycmF5IGlzIHNldCB0byBudWxsLCBpZiB0cnVlLCBpbml0aWFsaXplcyB2aWV3cyBhcnJheSB0byBlbXB0eSBhcnJheS5cbiAgICpcbiAgICogQHNlZSAjX3RoaXMuY2xlYXJWaWV3c1xuICAgKi9cbiAgX3RoaXMuY2xlYXJQaW5zID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgICBfdGhpcy5jbGVhclZpZXdzKF90aGlzLnBpblZpZXdzKTtcblxuICAgIGlmIChpbml0KSB7XG4gICAgICBfdGhpcy5waW5WaWV3cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5waW5WaWV3cyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIExJIGVsZW1lbnQsIGFwcGVuZHMgaXQgdG8gdGhlIGdpdmVuIGBwYXJlbnRgIGFuZCBzZXRzXG4gICAqIGFwcHJvcHJpYXRlIGNsYXNzZXMuIFRoZSBgZXhlY3V0aXZlLXN1bW1hcnktcGluYCBjbGFzcyBpcyBhZGRlZCBieSBkZWZhdWx0XG4gICAqIGJ1dCBvdGhlciBjbGFzc2VzIG15IGJlIGFkZGVkIGJ5IHByb3ZpZGluZyB0aGVtIGluIHRoZSBgY2xhc3Nlc2AgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyZW50IHtET01FbGVtZW50fVxuICAgKiAgICAgVGhlIHBhcmVudCBlbGVtZW50IHRvIHdoaWNoIHRoZSBjcmVhdGVkIGNvbnRhaW5lciBzaG91bGQgYmUgYXBwZW5kZWQuXG4gICAqIEBwYXJhbSBjbGFzc2VzIHtBcnJheX0gT3B0aW9uYWwuXG4gICAqICAgICBBbiBhcnJheSBvZiBjbGFzc2VzIHRvIGFkZCB0byB0aGUgY3JlYXRlZCBjb250YWluZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG4gICAqL1xuICBfdGhpcy5jcmVhdGVQaW5Db250YWluZXIgPSBmdW5jdGlvbiAocGFyZW50LCBjbGFzc2VzKSB7XG4gICAgdmFyIGNvbnRhaW5lcjtcblxuICAgIHBhcmVudCA9IHBhcmVudCB8fCBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG5cbiAgICBjb250YWluZXIgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2V4ZWN1dGl2ZS1zdW1tYXJ5LXBpbicpO1xuXG4gICAgY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9O1xuXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfdGhpcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IGRlc3Ryb3llZFxuICAgIH1cblxuICAgIF90aGlzLmNsZWFyUGlucygpO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIEFQSU1ldGhvZC5cbiAgICpcbiAgICogSW1wbGVtZW50aW5nIGNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fVxuICAgKiAgICAgQSBoZWFkZXIgdG8gbGFiZWwgdGhlIGxpbmtzIHNlY3Rpb24gZm9yIHRoaXMge1N1bW1hcnlNb2R1bGV9LiBJZiBub1xuICAgKiAgICAgaGVhZGVyIGlzIGRlc2lyZWQsIHJldHVybiBhbiBlbXB0eSB7RG9jdW1lbnRGcmFnbWVudH0uXG4gICAqL1xuICBfdGhpcy5nZXRMaW5rc0hlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGVhZGVyO1xuXG4gICAgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICBoZWFkZXIuaW5uZXJIVE1MID0gJ0ZvciBNb3JlIEluZm9ybWF0aW9uJztcblxuICAgIHJldHVybiBoZWFkZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgZWFjaCBvZiB0aGUgcGlucyBpbiBvcmRlciB3aXRoaW4gX3RoaXMucGluTGlzdCBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSBldiB7Q2F0YWxvZ0V2ZW50fVxuICAgKiAgICAgVGhlIGV2ZW50IGRhdGEgdG8gcmVuZGVyLlxuICAgKi9cbiAgX3RoaXMuZ2V0UGlucyA9IGZ1bmN0aW9uIChldikge1xuICAgIHZhciBjb25maWcsXG4gICAgICAgIGV2ZW50UHJvcHMsXG4gICAgICAgIGxpc3QsXG4gICAgICAgIHByb2R1Y3Q7XG5cbiAgICBfdGhpcy5waW5WaWV3cyA9IF90aGlzLnBpblZpZXdzIHx8IFtdO1xuICAgIGNvbmZpZyA9IF90aGlzLm1vZGVsLmdldCgnY29uZmlnJykgfHwge307XG4gICAgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgbGlzdC5jbGFzc0xpc3QuYWRkKCdleGVjdXRpdmUtc3VtbWFyeS1waW5zJyk7XG5cbiAgICBpZiAoIWV2KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBldmVudFByb3BzID0gZXYuZ2V0U3VtbWFyeSgpLnByb3BlcnRpZXMgfHwge307XG5cbiAgICAvLyBJbnRlcmFjdGl2ZSBNYXAgcGluXG4gICAgX3RoaXMucGluVmlld3MucHVzaChJbnRlcmFjdGl2ZU1hcFBpblZpZXcoe1xuICAgICAgZWw6IF90aGlzLmNyZWF0ZVBpbkNvbnRhaW5lcihsaXN0KSxcbiAgICAgIG1vZGVsOiBfdGhpcy5tb2RlbFxuICAgIH0pKTtcblxuICAgIC8vIFJlZ2lvbmFsIEluZm8gcGluXG4gICAgX3RoaXMucGluVmlld3MucHVzaChSZWdpb25hbEluZm9QaW5WaWV3KHtcbiAgICAgIGVsOiBfdGhpcy5jcmVhdGVQaW5Db250YWluZXIobGlzdCksXG4gICAgICBtb2RlbDogZXYuZ2V0UHJlZmVycmVkT3JpZ2luUHJvZHVjdCgpXG4gICAgfSkpO1xuXG4gICAgLy8gRFlGSSBGb3JtIHBpblxuICAgIGlmIChjb25maWcuU0NFTkFSSU9fTU9ERSAhPT0gdHJ1ZSkge1xuICAgICAgcHJvZHVjdCA9IGV2LmdldFByZWZlcnJlZFByb2R1Y3QoUHJvZHVjdC5nZXRGdWxsVHlwZSgnZHlmaScsIGNvbmZpZykpO1xuICAgICAgX3RoaXMucGluVmlld3MucHVzaChEeWZpRm9ybVBpblZpZXcoe1xuICAgICAgICBlbDogX3RoaXMuY3JlYXRlUGluQ29udGFpbmVyKGxpc3QpLFxuICAgICAgICBtb2RlbDogcHJvZHVjdCB8fCBQcm9kdWN0KClcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBEWUZJIHBpblxuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBfdGhpcy5waW5WaWV3cy5wdXNoKER5ZmlQaW5WaWV3KHtcbiAgICAgICAgZWw6IF90aGlzLmNyZWF0ZVBpbkNvbnRhaW5lcihsaXN0KSxcbiAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBTaGFrZU1hcCBwaW5cbiAgICBwcm9kdWN0ID0gZXYuZ2V0UHJlZmVycmVkUHJvZHVjdChQcm9kdWN0LmdldEZ1bGxUeXBlKCdzaGFrZW1hcCcsIGNvbmZpZykpO1xuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBfdGhpcy5waW5WaWV3cy5wdXNoKFNoYWtlTWFwUGluVmlldyh7XG4gICAgICAgIGVsOiBfdGhpcy5jcmVhdGVQaW5Db250YWluZXIobGlzdCksXG4gICAgICAgIG1vZGVsOiBwcm9kdWN0XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gUEFHRVIgcGluXG4gICAgcHJvZHVjdCA9IGV2LmdldFByZWZlcnJlZFByb2R1Y3QoUHJvZHVjdC5nZXRGdWxsVHlwZSgnbG9zc3BhZ2VyJywgY29uZmlnKSk7XG4gICAgaWYgKHByb2R1Y3QpIHtcbiAgICAgIF90aGlzLnBpblZpZXdzLnB1c2goUEFHRVJQaW5WaWV3KHtcbiAgICAgICAgZWw6IF90aGlzLmNyZWF0ZVBpbkNvbnRhaW5lcihsaXN0KSxcbiAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBPcmlnaW4gcGluXG4gICAgcHJvZHVjdCA9IGV2LmdldFByZWZlcnJlZE9yaWdpblByb2R1Y3QoKTtcbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgX3RoaXMucGluVmlld3MucHVzaChPcmlnaW5QaW5WaWV3KHtcbiAgICAgICAgZWw6IF90aGlzLmNyZWF0ZVBpbkNvbnRhaW5lcihsaXN0KSxcbiAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBNb21lbnQgVGVuc29yIHBpblxuICAgIHByb2R1Y3QgPSBldi5nZXRQcmVmZXJyZWRQcm9kdWN0KFByb2R1Y3QuZ2V0RnVsbFR5cGUoJ21vbWVudC10ZW5zb3InLFxuICAgICAgICBjb25maWcpKTtcbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgX3RoaXMucGluVmlld3MucHVzaChNb21lbnRUZW5zb3JQaW5WaWV3KHtcbiAgICAgICAgZWw6IF90aGlzLmNyZWF0ZVBpbkNvbnRhaW5lcihsaXN0KSxcbiAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT25seSBzaG93IGZvY2FsIG1lY2hhbmlzbSBpZiBubyBtb21lbnQgdGVuc29yXG5cbiAgICAgIC8vIEZvY2FsIE1lY2hhbmlzbSBwaW5cbiAgICAgIHByb2R1Y3QgPSBldi5nZXRQcmVmZXJyZWRQcm9kdWN0KFByb2R1Y3QuZ2V0RnVsbFR5cGUoXG4gICAgICAgICAgJ2ZvY2FsLW1lY2hhbmlzbScsIGNvbmZpZykpO1xuICAgICAgaWYgKHByb2R1Y3QpIHtcbiAgICAgICAgX3RoaXMucGluVmlld3MucHVzaChGb2NhbE1lY2hhbmlzbVBpblZpZXcoe1xuICAgICAgICAgIGVsOiBfdGhpcy5jcmVhdGVQaW5Db250YWluZXIobGlzdCksXG4gICAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbml0ZSBGYXVsdCBwaW5cbiAgICBwcm9kdWN0ID0gZXYuZ2V0UHJlZmVycmVkUHJvZHVjdChQcm9kdWN0LmdldEZ1bGxUeXBlKCdmaW5pdGUtZmF1bHQnLFxuICAgICAgICBjb25maWcpKTtcbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgX3RoaXMucGluVmlld3MucHVzaChGaW5pdGVGYXVsdFBpblZpZXcoe1xuICAgICAgICBlbDogX3RoaXMuY3JlYXRlUGluQ29udGFpbmVyKGxpc3QpLFxuICAgICAgICBtb2RlbDogcHJvZHVjdFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8vIFRzdW5hbWkgcGluXG4gICAgaWYgKGV2LmdldFN1bW1hcnkoKS5wcm9wZXJ0aWVzLnRzdW5hbWkgPT09IDEpIHtcbiAgICAgIF90aGlzLnBpblZpZXdzLnB1c2goVHN1bmFtaVBpblZpZXcoe1xuICAgICAgICBlbDogX3RoaXMuY3JlYXRlUGluQ29udGFpbmVyKGxpc3QpLFxuICAgICAgICBtb2RlbDogZXYuZ2V0UHJlZmVycmVkT3JpZ2luUHJvZHVjdCgpXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIERvZXMgYSBjb21wYXJpc29uIG9mIG9uZSBQcm9kdWN0IGFnYWluc3QgYW4gYXJyYXkgb2YgUHJvZHVjdHMgdG8gc2VlIGlmXG4gICAqIHRoZSBzYW1lIFwidXJsXCIgcHJvcGVydHkgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59XG4gICAqICAgICByZXR1cm4gdHJ1ZSBpZiB0aGUgbGluayBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgYXJyYXlcbiAgICpcbiAgICovXG4gIF90aGlzLmlzRHVwbGljYXRlID0gZnVuY3Rpb24gKG5lZWRsZSwgaGF5c3RhY2spIHtcbiAgICB2YXIgaTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhheXN0YWNrW2ldLmdldCgncHJvcGVydGllcycpLnVybCA9PT1cbiAgICAgICAgICAgIG5lZWRsZS5nZXQoJ3Byb3BlcnRpZXMnKS51cmwpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBkdXBsaWNhdGUgaXRlbXMgZnJvbSB0aGUgYXJyYXkgdGhhdCBoYXZlIHRoZSBzYW1lIFwidXJsXCIgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIGxpbmtzIHtBcnJheTxQcm9kdWN0Pn1cbiAgICogICAgIEFuIGFycmF5IG9mIFByb2R1Y3RzXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW1vdmVEdXBsaWNhdGVMaW5rcyA9IGZ1bmN0aW9uIChsaW5rcykge1xuICAgIHZhciBpLFxuICAgICAgICBsaW5rLFxuICAgICAgICBwcm9kdWN0cztcblxuICAgIC8vIGFkZCB0aGUgZmlyc3QgaXRlbSBzaW5jZSBpdCBjYW5ub3QgYmUgYSBkdXBsaWNhdGUgeWV0XG4gICAgcHJvZHVjdHMgPSBbXTtcblxuICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgIHByb2R1Y3RzLnB1c2gobGlua3NbMF0pO1xuXG4gICAgICAvLyBhZGQgYWxsIGFkZGl0aW9uYWwgbGlua3MgdGhhdCBkbyBub3QgYWxyZWFkeSBleGlzdCBpbiBwcm9kdWN0cyBhcnJheVxuICAgICAgZm9yIChpID0gMTsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rc1tpXTtcbiAgICAgICAgaWYgKCFfdGhpcy5pc0R1cGxpY2F0ZShsaW5rLCBwcm9kdWN0cykpIHtcbiAgICAgICAgICBwcm9kdWN0cy5wdXNoKGxpbmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2R1Y3RzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBtb2R1bGUgYnkgZGVsZWdhdGluZyB0byB0aHJlZSBzdWItcmVuZGVyIG1ldGhvZHMuXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbmZpZyxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgZXYsXG4gICAgICAgIGZvb3RlckVsLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBsaW5rcyxcbiAgICAgICAgcG9zdGVycyxcbiAgICAgICAgdGV4dHM7XG5cbiAgICBldiA9IF90aGlzLm1vZGVsLmdldCgnZXZlbnQnKTtcblxuICAgIF90aGlzLmNsZWFyVGV4dHModHJ1ZSk7XG4gICAgX3RoaXMuY2xlYXJMaW5rcyh0cnVlKTtcbiAgICBfdGhpcy5jbGVhclBpbnModHJ1ZSk7XG5cbiAgICBVdGlsLmVtcHR5KF90aGlzLmhlYWRlcik7XG4gICAgVXRpbC5lbXB0eShfdGhpcy5jb250ZW50KTtcbiAgICBVdGlsLmVtcHR5KF90aGlzLmZvb3Rlcik7XG5cbiAgICBpZiAoIWV2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnID0gX3RoaXMubW9kZWwuZ2V0KCdjb25maWcnKTtcbiAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGhlYWRlcnMgPSBldi5nZXRQcm9kdWN0cyhQcm9kdWN0LmdldEZ1bGxUeXBlKCdnZW5lcmFsLWhlYWRlcicpLCBjb25maWcpO1xuICAgIHBvc3RlcnMgPSBldi5nZXRQcm9kdWN0cyhQcm9kdWN0LmdldEZ1bGxUeXBlKCdwb3N0ZXInKSwgY29uZmlnKTtcbiAgICB0ZXh0cyA9IGV2LmdldFByb2R1Y3RzKFByb2R1Y3QuZ2V0RnVsbFR5cGUoJ2dlbmVyYWwtdGV4dCcpLCBjb25maWcpO1xuICAgIGxpbmtzID0gX3RoaXMucmVtb3ZlRHVwbGljYXRlTGlua3MoZXYuZ2V0UHJvZHVjdHMoXG4gICAgICAgIFByb2R1Y3QuZ2V0RnVsbFR5cGUoJ2dlbmVyYWwtbGluaycpLCBjb25maWcpKTtcblxuXG4gICAgX3RoaXMuaGVhZGVyLmFwcGVuZENoaWxkKF90aGlzLmdldFRleHRzKGhlYWRlcnMpKTtcblxuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0UGlucyhldikpO1xuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0VGV4dHModGV4dHMpKTtcbiAgICBjb250ZW50LmFwcGVuZENoaWxkKF90aGlzLmdldExpbmtzKGxpbmtzKSk7XG4gICAgX3RoaXMuY29udGVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIC8vIENyZWF0ZXMgYSBkb3dubG9hZCBhY2NvcmRpb24gaWYgcG9zdGVyIGRhdGEgaXMgYXZhaWxhYmxlLiBUaGlzIGFjY29yZGlvblxuICAgIC8vIGhhcyBwb3N0ZXIgZGF0YS5cbiAgICBpZiAocG9zdGVycyAmJiBwb3N0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvb3RlckVsID0gX3RoaXMuZ2V0UHJvZHVjdEZvb3Rlcih7XG4gICAgICAgIHByb2R1Y3Q6IHBvc3RlcnNbMF1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxscyByZW5kZXIgdG8gbWFrZSBkYXRhIGF2YWlsYWJsZSBhbmQgcmVtb3ZlcyB0aGUgYWNjb3JkaW9uLWNsb3NlZFxuICAgICAgLy8gY2xhc3Mgc28gdGhhdCB0aGUgYWNjb3JkaW9uIGlzIG9wZW4gYnkgZGVmYXVsdC5cbiAgICAgIGlmIChmb290ZXJFbCAmJiBmb290ZXJFbC5xdWVyeVNlbGVjdG9yKCcuYWNjb3JkaW9uLWNsb3NlZCcpKSB7XG4gICAgICAgIF90aGlzLmRvd25sb2FkVmlldy5yZW5kZXIoKTtcbiAgICAgICAgZm9vdGVyRWwucXVlcnlTZWxlY3RvcignLmFjY29yZGlvbi1jbG9zZWQnKS5jbGFzc0xpc3QuXG4gICAgICAgICAgICByZW1vdmUoJ2FjY29yZGlvbi1jbG9zZWQnKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuZm9vdGVyLmFwcGVuZENoaWxkKGZvb3RlckVsKTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgdGhlIHBpbiB2aWV3cyBhZnRlciB0aGV5IGFyZSBpbiB0aGUgRE9NIHNvIHRoZXkgaGF2ZSBleHRlbnRzXG4gICAgX3RoaXMucGluVmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgdmlldy5yZW5kZXIoKTtcbiAgICB9KTtcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5FeGVjdXRpdmVTdW1tYXJ5TW9kdWxlLklEID0gX0lEO1xuRXhlY3V0aXZlU3VtbWFyeU1vZHVsZS5USVRMRSA9IF9USVRMRTtcblxuRXhlY3V0aXZlU3VtbWFyeU1vZHVsZS5oYXNDb250ZW50ID0gX2hhc0NvbnRlbnQ7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpdmVTdW1tYXJ5TW9kdWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRm9ybWF0dGVyID0gcmVxdWlyZSgnY29yZS9Gb3JtYXR0ZXInKSxcbiAgICBOZWFyYnlQbGFjZXNWaWV3ID0gcmVxdWlyZSgnZ2VuZXJhbC9OZWFyYnlQbGFjZXNWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIFhociA9IHJlcXVpcmUoJ3V0aWwvWGhyJyk7XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcbiAgdXJsOiAnaHR0cHM6Ly9lYXJ0aHF1YWtlLnVzZ3MuZ292L3dzL2dlb3NlcnZlLydcbn07XG5cblxuLyoqXG4gKiBWaWV3IGZvciBhIGdlb3NlcnZlIG5lYXJieS1jaXRpZXMgUHJvZHVjdC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgYWxsIG9wdGlvbnMgYXJlIHBhc3NlZCB0byBQcm9kdWN0Vmlldy5cbiAqL1xudmFyIEdlb3NlcnZlTmVhcmJ5UGxhY2VzVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfZm9ybWF0dGVyLFxuICAgICAgX3VybCxcbiAgICAgIF94aHI7XG5cblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gTmVhcmJ5UGxhY2VzVmlldyhvcHRpb25zKTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuICAgIF91cmwgPSBvcHRpb25zLnVybCB8fCBudWxsO1xuICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2dlb3NlcnZlLW5lYXJieS1wbGFjZXMnKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXRzIGRhdGFcbiAgICovXG4gIF90aGlzLmZldGNoRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfeGhyID0gWGhyLmFqYXgoe1xuICAgICAgdXJsOiBfdXJsICsgJ3BsYWNlcy5qc29uJyxcbiAgICAgIHN1Y2Nlc3M6IF90aGlzLm9uU3VjY2VzcyxcbiAgICAgIGVycm9yOiBfdGhpcy5vbkVycm9yLFxuICAgICAgZGF0YToge1xuICAgICAgICBsYXRpdHVkZTogX3RoaXMubW9kZWwuZ2V0UHJvcGVydHkoJ2xhdGl0dWRlJyksXG4gICAgICAgIGxvbmdpdHVkZTogX3RoaXMubW9kZWwuZ2V0UHJvcGVydHkoJ2xvbmdpdHVkZScpLFxuICAgICAgICB0eXBlOiAnZXZlbnQnXG4gICAgICB9LFxuICAgICAgZG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfeGhyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzcGxheXMgbWVzc2FnZSBmb2xsb3dlZCBieSB0aGUgdXJsIHJlcXVlc3RlZCBvbiBlcnJvclxuICAgKi9cbiAgX3RoaXMub25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSAnVW5hYmxlIHRvIGxvYWQgZ2Vvc2VydmUgd2ViIHNlcnZpY2UsIFVSTDogJyArIF91cmw7XG4gICAgX3RoaXMudHJpZ2dlcigncGxhY2VzLWVycm9yJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGRhdGEgaXMgc3VjY2Vzc2Z1bGx5IGZldGNoZWQgZnJvbSBfdGhpcy5tb2RlbFxuICAgKiB7Q29udGVudH0gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB7U3RyaW5nfEpTT059XG4gICAqICAgICBUaGUgZGF0YSBmb3IgX3RoaXMubW9kZWwge0NvbnRlbnR9IG9iamVjdC5cbiAgICovXG4gIF90aGlzLm9uU3VjY2VzcyA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLmV2ZW50LmZlYXR1cmVzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGF6aW11dGgsXG4gICAgICAgICAgY291bnRyeU9yU3RhdGU7XG5cbiAgICAgIGF6aW11dGggPSBfZm9ybWF0dGVyLmJhY2tBemltdXRoKGl0ZW0ucHJvcGVydGllcy5hemltdXRoKTtcblxuICAgICAgLy8gQ2hlY2tzIHRvIHNlZSBpZiBsb2NhdGlvbiBpcyBpbnNpZGUgdGhlIFVTIG9yIG5vdCBpZiBpdCBpcyBpbiB0aGUgVVNcbiAgICAgIC8vIHRoZSBzdGF0ZSBuYW1lIGlzIHVzZWQgaWYgdGhlIGxvY2F0aW9uIGlzIG91dHNpZGUgdGhlIFVTXG4gICAgICAvLyB0aGUgY291bnRyeSBuYW1lIGlzIHVzZWQuXG4gICAgICBpZiAoaXRlbS5wcm9wZXJ0aWVzLmNvdW50cnlfY29kZSA9PT0gJ1VTJykge1xuICAgICAgICBjb3VudHJ5T3JTdGF0ZSA9IGl0ZW0ucHJvcGVydGllcy5hZG1pbjFfbmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50cnlPclN0YXRlID0gaXRlbS5wcm9wZXJ0aWVzLmNvdW50cnlfbmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzdGFuY2U6IGl0ZW0ucHJvcGVydGllcy5kaXN0YW5jZSxcbiAgICAgICAgZGlyZWN0aW9uOiBfZm9ybWF0dGVyLmNvbXBhc3NXaW5kcyhhemltdXRoKSxcbiAgICAgICAgbmFtZTogaXRlbS5wcm9wZXJ0aWVzLm5hbWUgKyAnLCAnICsgY291bnRyeU9yU3RhdGUsXG4gICAgICAgIHBvcHVsYXRpb246IGl0ZW0ucHJvcGVydGllcy5wb3B1bGF0aW9uXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBfdGhpcy5vblN1Y2Nlc3MpO1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgbW9kZWwgY2hhbmdlcy4gSW5pdGlhbGx5IHNldHMgYSBsb2FkaW5nIG1lc3NhZ2UgdGhlbiBzdGFydHNcbiAgICogdGhlIGRhdGEgZmV0Y2ggcHJvY2VzcyB0byByZW5kZXIgdGhlIGFjdHVhbCBjb250ZW50LiBSZWxpZXMgb24gYnJvd3NlclxuICAgKiBjYWNoZXMgdG8gYXZvaWQgZHVwbGljYXRlIEhUVFAgb3ZlcmhlYWQuXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gJ0xvYWRpbmcgY29udGVudCZoZWxsaXA7JztcbiAgICBfdGhpcy5mZXRjaERhdGEoKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveSBhbGwgdGhlIHRoaW5ncy5cbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfeGhyKSB7XG4gICAgICBfeGhyLmFib3J0KCk7XG4gICAgICBfeGhyID0gbnVsbDtcbiAgICB9XG4gICAgX3VybCA9IG51bGw7XG4gICAgX2Zvcm1hdHRlciA9IG51bGw7XG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2Vvc2VydmVOZWFyYnlQbGFjZXNWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvZHVjdFZpZXcgPSByZXF1aXJlKCdjb3JlL1Byb2R1Y3RWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIFhociA9IHJlcXVpcmUoJ3V0aWwvWGhyJyk7XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcbiAgdXJsOiAnaHR0cHM6Ly9lYXJ0aHF1YWtlLnVzZ3MuZ292L3dzL2dlb3NlcnZlL3JlZ2lvbnMuanNvbidcbn07XG5cblxuLyoqXG4gKiBWaWV3IGZvciBhIGdlb3NlcnZlIHRlY3RvbmljIHN1bW1hcnkgUHJvZHVjdC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgYWxsIG9wdGlvbnMgYXJlIHBhc3NlZCB0byBQcm9kdWN0Vmlldy5cbiAqL1xudmFyIEdlb3NlcnZlUmVnaW9uU3VtbWFyeVZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX3VybCxcbiAgICAgIF94aHI7XG5cblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gUHJvZHVjdFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ2dlb3NlcnZlLXJlZ2lvbi1zdW1tYXJ5Jyk7XG4gICAgX3VybCA9IG9wdGlvbnMudXJsO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldHMgZGF0YVxuICAgKi9cbiAgX3RoaXMuZmV0Y2hEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIF94aHIgPSBYaHIuYWpheCh7XG4gICAgICB1cmw6IF91cmwsXG4gICAgICBzdWNjZXNzOiBfdGhpcy5vblN1Y2Nlc3MsXG4gICAgICBlcnJvcjogX3RoaXMub25FcnJvcixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGF0aXR1ZGU6IF90aGlzLm1vZGVsLmdldFByb3BlcnR5KCdsYXRpdHVkZScpLFxuICAgICAgICBsb25naXR1ZGU6IF90aGlzLm1vZGVsLmdldFByb3BlcnR5KCdsb25naXR1ZGUnKSxcbiAgICAgICAgdHlwZTogJ3RlY3RvbmljJ1xuICAgICAgfSxcbiAgICAgIGRvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3hociA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3BsYXlzIG1lc3NhZ2UgZm9sbG93ZWQgYnkgdGhlIHVybCByZXF1ZXN0ZWQgb24gZXJyb3JcbiAgICovXG4gIF90aGlzLm9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gJzxwIGNsYXNzPVwiYWxlcnQgZXJyb3JcIj4nICtcbiAgICAgICAgJ0Vycm9yIGxvYWRpbmcgcmVnaW9uIHRlY3RvbmljIHN1bW1hcnknICtcbiAgICAgICAgJzwvcD4nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiBkYXRhIGlzIHN1Y2Nlc3NmdWxseSBmZXRjaGVkIGZyb20gX3RoaXMubW9kZWxcbiAgICoge0NvbnRlbnR9IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEge1N0cmluZ3xKU09OfVxuICAgKiAgICAgVGhlIGRhdGEgZm9yIF90aGlzLm1vZGVsIHtDb250ZW50fSBvYmplY3QuXG4gICAqL1xuICBfdGhpcy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBmZWF0dXJlcztcblxuICAgIGZlYXR1cmVzID0gZGF0YS50ZWN0b25pYy5mZWF0dXJlcztcbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gZmVhdHVyZXNbMF0ucHJvcGVydGllcy5zdW1tYXJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSAnPHAgY2xhc3M9XCJhbGVydCBpbmZvXCI+JyArXG4gICAgICAgICAgJ05vIHJlZ2lvbiBzdW1tYXJ5IGF2YWlsYWJsZSBmb3IgdGhpcyBsb2NhdGlvbicgK1xuICAgICAgICAgICc8L3A+JztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBtb2RlbCBjaGFuZ2VzLiBJbml0aWFsbHkgc2V0cyBhIGxvYWRpbmcgbWVzc2FnZSB0aGVuIHN0YXJ0c1xuICAgKiB0aGUgZGF0YSBmZXRjaCBwcm9jZXNzIHRvIHJlbmRlciB0aGUgYWN0dWFsIGNvbnRlbnQuIFJlbGllcyBvbiBicm93c2VyXG4gICAqIGNhY2hlcyB0byBhdm9pZCBkdXBsaWNhdGUgSFRUUCBvdmVyaGVhZC5cbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSAnPHA+TG9hZGluZyBjb250ZW50JmhlbGxpcDs8L3A+JztcbiAgICBfdGhpcy5mZXRjaERhdGEoKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveSBhbGwgdGhlIHRoaW5ncy5cbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfeGhyKSB7XG4gICAgICBfeGhyLmFib3J0KCk7XG4gICAgICBfeGhyID0gbnVsbDtcbiAgICB9XG4gICAgX3VybCA9IG51bGw7XG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2Vvc2VydmVSZWdpb25TdW1tYXJ5VmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEF0dHJpYnV0aW9uID0gcmVxdWlyZSgnY29yZS9BdHRyaWJ1dGlvbicpLFxuICAgIEZvcm1hdHRlciA9IHJlcXVpcmUoJ2NvcmUvRm9ybWF0dGVyJyksXG4gICAgSW50ZXJhY3RpdmVNYXBWaWV3ID0gcmVxdWlyZSgnbWFwL0ludGVyYWN0aXZlTWFwVmlldycpLFxuICAgIE1vZHVsZSA9IHJlcXVpcmUoJ2NvcmUvTW9kdWxlJyksXG4gICAgVmlldyA9IHJlcXVpcmUoJ212Yy9WaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7fTtcblxuXG4vKipcbiAqIFZpZXcgdG8gZGlzcGxheSBsb2NhdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgIHBhZGRlZCB0byBWaWV3LlxuICogQHBhcmFtIG9wdGlvbnMuZm9ybWF0dGVyIHtGb3JtYXR0ZXJ9XG4gKiAgICAgZm9ybWF0dGluZyBvYmplY3QuXG4gKiAgICAgZGVmYXVsdCBgRm9ybWF0dGVyKClgLlxuICovXG52YXIgTG9jYXRpb25WaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9hdHRyaWJ1dGlvbixcbiAgICAgIF9jYXB0aW9uLFxuICAgICAgX2Zvcm1hdHRlcixcbiAgICAgIF9tYXBWaWV3O1xuXG5cbiAgX3RoaXMgPSBWaWV3KG9wdGlvbnMpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgZWw7XG5cbiAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuXG4gICAgZWwgPSBfdGhpcy5lbDtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKCdsb2NhdGlvbnZpZXcnKTtcbiAgICBlbC5pbm5lckhUTUwgPVxuICAgICAgICAnPGgzPkxvY2F0aW9uPC9oMz4nICtcbiAgICAgICAgJzxzbWFsbCBjbGFzcz1cImF0dHJpYnV0aW9uXCI+PC9zbWFsbD4nICtcbiAgICAgICAgJzxmaWd1cmU+JyArXG4gICAgICAgICAgJzxhIGhyZWY9XCIjbWFwXCIgY2xhc3M9XCJsb2NhdGlvbnZpZXctbWFwXCI+JyArXG4gICAgICAgICAgICAnPGRpdj48L2Rpdj4nICtcbiAgICAgICAgICAnPC9hPicgK1xuICAgICAgICAgICc8ZmlnY2FwdGlvbiBjbGFzcz1cImxvY2F0aW9udmlldy1jYXB0aW9uXCI+PC9maWdjYXB0aW9uPicgK1xuICAgICAgICAnPC9maWd1cmU+JztcblxuICAgIF9hdHRyaWJ1dGlvbiA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5hdHRyaWJ1dGlvbicpO1xuICAgIF9jYXB0aW9uID0gZWwucXVlcnlTZWxlY3RvcignLmxvY2F0aW9udmlldy1jYXB0aW9uJyk7XG4gICAgX21hcFZpZXcgPSBJbnRlcmFjdGl2ZU1hcFZpZXcoe1xuICAgICAgZWw6IGVsLnF1ZXJ5U2VsZWN0b3IoJy5sb2NhdGlvbnZpZXctbWFwID4gZGl2JyksXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBtb2RlbDogX3RoaXMubW9kZWwsXG4gICAgICBtb2R1bGU6IG9wdGlvbnMubW9kdWxlIHx8IE1vZHVsZSgpXG4gICAgfSk7XG4gICAgX21hcFZpZXcuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5vbkNsaWNrKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBVbmJpbmQgZXZlbnRzIGFuZCBmcmVlIHJlZmVyZW5jZXMuXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3RoaXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX21hcFZpZXcuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5vbkNsaWNrKTtcbiAgICBfbWFwVmlldy5kZXN0cm95KCk7XG5cbiAgICBfYXR0cmlidXRpb24gPSBudWxsO1xuICAgIF9jYXB0aW9uID0gbnVsbDtcbiAgICBfZm9ybWF0dGVyID0gbnVsbDtcbiAgICBfbWFwVmlldyA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogR2V0IGF0dHJpYnV0aW9uIGZvciBwcm9kdWN0LlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIHRoZSBwcm9kdWN0LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICBhdHRyaWJ1dGlvbiBtYXJrdXAuXG4gICAqL1xuICBfdGhpcy5nZXRBdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChwcm9kdWN0KSB7XG4gICAgaWYgKCFwcm9kdWN0KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdDb250cmlidXRlZCBieSAnICtcbiAgICAgICAgQXR0cmlidXRpb24uZ2V0UHJvZHVjdEF0dHJpYnV0aW9uKHByb2R1Y3QpICtcbiAgICAgICAgJyBsYXN0IHVwZGF0ZWQgJyArXG4gICAgICAgIF9mb3JtYXR0ZXIuZGF0ZXRpbWUocHJvZHVjdC5nZXQoJ3VwZGF0ZVRpbWUnKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBsb2NhdGlvbiBjYXB0aW9uIGZvciBwcm9kdWN0LlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIHRoZSBwcm9kdWN0LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICBjYXB0aW9uIG1hcmt1cC5cbiAgICovXG4gIF90aGlzLmdldENhcHRpb24gPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIHZhciBkZXB0aCxcbiAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZTtcblxuICAgIGlmICghcHJvZHVjdCkge1xuICAgICAgcmV0dXJuICc8cCBjbGFzcz1cImFsZXJ0IGluZm9cIj5ObyBsb2NhdGlvbiB0byBkaXNwbGF5LjwvcD4nO1xuICAgIH1cblxuICAgIGRlcHRoID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnZGVwdGgnKSB8fCAnJztcbiAgICBsYXRpdHVkZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2xhdGl0dWRlJykgfHwgbnVsbDtcbiAgICBsb25naXR1ZGUgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdsb25naXR1ZGUnKSB8fCBudWxsO1xuXG4gICAgaWYgKGRlcHRoKSB7XG4gICAgICBkZXB0aCA9ICcgZGVwdGg9JyArIF9mb3JtYXR0ZXIuZGVwdGgoZGVwdGgsICdrbScpICtcbiAgICAgICAgICAnICgnICsgX2Zvcm1hdHRlci5kZXB0aChfZm9ybWF0dGVyLmttVG9NaShkZXB0aCksICdtaScpICsgJyknO1xuICAgIH1cblxuICAgIHJldHVybiBfZm9ybWF0dGVyLmxvY2F0aW9uKGxhdGl0dWRlLCBsb25naXR1ZGUpICsgZGVwdGggK1xuICAgICAgICAnPGJyLz48YSBocmVmPVwiI21hcFwiPlZpZXcgaW50ZXJhY3RpdmUgbWFwPC9hPic7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsaWNrIGhhbmRsZXIgZm9yIG1hcC5cbiAgICovXG4gIF90aGlzLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LmxvY2F0aW9uID0gJyNtYXAnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgbG9jYXRpb24gdmlldy5cbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwsXG4gICAgICAgIGV2LFxuICAgICAgICBwcm9kdWN0O1xuXG4gICAgZWwgPSBfdGhpcy5lbDtcbiAgICBldiA9IF90aGlzLm1vZGVsLmdldCgnZXZlbnQnKTtcbiAgICBpZiAoZXYgPT09IG51bGwpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xvY2F0aW9udmlldy1lbXB0eScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2xvY2F0aW9udmlldy1lbXB0eScpO1xuICAgIHByb2R1Y3QgPSBldi5nZXRQcmVmZXJyZWRPcmlnaW5Qcm9kdWN0KCk7XG4gICAgX2F0dHJpYnV0aW9uLmlubmVySFRNTCA9IF90aGlzLmdldEF0dHJpYnV0aW9uKHByb2R1Y3QpO1xuICAgIF9jYXB0aW9uLmlubmVySFRNTCA9IF90aGlzLmdldENhcHRpb24ocHJvZHVjdCk7XG4gICAgX21hcFZpZXcucmVuZGVyKCk7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhdGlvblZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9kdWN0VmlldyA9IHJlcXVpcmUoJ2NvcmUvUHJvZHVjdFZpZXcnKSxcbiAgICBGb3JtYXR0ZXIgPSByZXF1aXJlKCdjb3JlL0Zvcm1hdHRlcicpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKSxcbiAgICBYaHIgPSByZXF1aXJlKCd1dGlsL1hocicpO1xuXG52YXIgX0RFRkFVTFRTO1xuXG5fREVGQVVMVFMgPSB7XG4gIGVycm9yTWVzc2FnZTogJ0Vycm9yIGxvYWRpbmcgbmVhcmJ5IHBsYWNlcy4nLFxuICByZW5kZXJOZXdMYXlvdXQ6IGZhbHNlXG59O1xuXG5cbi8qKlxuICogVmlldyBmb3IgYSBuZWFyYnktY2l0aWVzIFByb2R1Y3QuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgIGFsbCBvcHRpb25zIGFyZSBwYXNzZWQgdG8gUHJvZHVjdFZpZXcuXG4gKi9cbnZhciBOZWFyYnlQbGFjZXNWaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9lcnJvck1lc3NhZ2UsXG4gICAgICBfZm9ybWF0dGVyLFxuICAgICAgX3JlbmRlck5ld0xheW91dCxcbiAgICAgIF94aHI7XG5cbiAgX3RoaXMgPSBQcm9kdWN0VmlldyhvcHRpb25zKTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuXG4gICAgX2Vycm9yTWVzc2FnZSA9IG9wdGlvbnMuZXJyb3JNZXNzYWdlO1xuICAgIF9mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBGb3JtYXR0ZXIoKTtcbiAgICBfcmVuZGVyTmV3TGF5b3V0ID0gb3B0aW9ucy5yZW5kZXJOZXdMYXlvdXQ7XG5cbiAgICBfdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCduZWFyYnktcGxhY2VzJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgYWxsIHRoZSB0aGluZ3MuXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3hocikge1xuICAgICAgX3hoci5hYm9ydCgpO1xuICAgICAgX3hociA9IG51bGw7XG4gICAgfVxuICAgIF9lcnJvck1lc3NhZ2UgPSBudWxsO1xuICAgIF9mb3JtYXR0ZXIgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkYXRhXG4gICAqL1xuICBfdGhpcy5mZXRjaERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRlbnQ7XG5cbiAgICBjb250ZW50ID0gX3RoaXMubW9kZWwuZ2V0Q29udGVudCgnbmVhcmJ5LWNpdGllcy5qc29uJyk7XG5cbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIF90aGlzLm9uRXJyb3IoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfeGhyID0gWGhyLmFqYXgoe1xuICAgICAgdXJsOiBjb250ZW50LmdldCgndXJsJyksXG4gICAgICBzdWNjZXNzOiBfdGhpcy5vblN1Y2Nlc3MsXG4gICAgICBlcnJvcjogX3RoaXMub25FcnJvcixcbiAgICAgIGRvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3hociA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdHMgYSBwbGFjZS5cbiAgICpcbiAgICogQHBhcmFtIHBsYWNlIHtPYmplY3R9XG4gICAqICAgICBBbiBvYmplY3QgY29udGFpbmluZyBwbGFjZSBpbmZvcm1hdGlvbi4gTmFtZWx5OlxuICAgKiAgICAgICAgIFwiZGlzdGFuY2VcIiB7TnVtYmVyfSAoa20pXG4gICAqICAgICAgICAgXCJkaXJlY3Rpb25cIiB7U3RyaW5nfSAoQ29tcGFzc1dpbmRzKVxuICAgKiAgICAgICAgIFwibmFtZVwiIHtTdHJpbmd9IChEZXNjcmlwdGlvbilcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiAgICAgVGhlIGZvcm1hdHRlZCBwbGFjZSBtYXJrdXAuXG4gICAqL1xuICBfdGhpcy5mb3JtYXRQbGFjZSA9IGZ1bmN0aW9uIChwbGFjZSkge1xuICAgIHZhciBtYXJrdXA7XG5cbiAgICBpZiAoX3JlbmRlck5ld0xheW91dCkge1xuICAgICAgbWFya3VwID0gW1xuICAgICAgICAnPGxpIGNsYXNzPVwibmVhcmJ5LXBsYWNlcy1wbGFjZVwiPicsXG4gICAgICAgICAgJzxzcGFuIGNsYXNzPVwibmVhcmJ5LXBsYWNlcy1uYW1lXCI+JyxcbiAgICAgICAgICAgIHBsYWNlLm5hbWUsXG4gICAgICAgICAgJzwvc3Bhbj4nLFxuICAgICAgICAgICc8YXNpZGUgY2xhc3M9XCJuZWFyYnktcGxhY2VzLWRpc3RhbmNlXCI+JyxcbiAgICAgICAgICAgIF9mb3JtYXR0ZXIuZGlzdGFuY2UocGxhY2UuZGlzdGFuY2UsICdrbScpLFxuICAgICAgICAgICAgJyAoJyxcbiAgICAgICAgICAgICAgX2Zvcm1hdHRlci5kaXN0YW5jZShfZm9ybWF0dGVyLmttVG9NaShwbGFjZS5kaXN0YW5jZSksICdtaScpLFxuICAgICAgICAgICAgJykgJyxcbiAgICAgICAgICAgIHBsYWNlLmRpcmVjdGlvbixcbiAgICAgICAgICAnPC9hc2lkZT4nLFxuICAgICAgICAgICc8YXNpZGUgY2xhc3M9XCJuZWFyYnktcGxhY2VzLXBvcHVsYXRpb25cIj5Qb3B1bGF0aW9uOiAnLFxuICAgICAgICAgICAgX2Zvcm1hdHRlci5udW1iZXJXaXRoQ29tbWFzKHBsYWNlLnBvcHVsYXRpb24pLFxuICAgICAgICAgICc8L2FzaWRlPicsXG4gICAgICAgICc8L2xpPidcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgJzxsaT4nLFxuICAgICAgICAgIF9mb3JtYXR0ZXIuZGlzdGFuY2UocGxhY2UuZGlzdGFuY2UsICdrbScpLFxuICAgICAgICAgICcgKCcsXG4gICAgICAgICAgICBfZm9ybWF0dGVyLmRpc3RhbmNlKF9mb3JtYXR0ZXIua21Ub01pKHBsYWNlLmRpc3RhbmNlKSwgJ21pJyksXG4gICAgICAgICAgJykgJyxcbiAgICAgICAgICBwbGFjZS5kaXJlY3Rpb24sICcgb2YgJywgcGxhY2UubmFtZSxcbiAgICAgICAgJzwvbGk+J1xuICAgICAgXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBhIHByb2JsZW0uXG4gICAqXG4gICAqIEBwYXJhbSBlcnJvck1lc3NhZ2Uge1N0cmluZ31cbiAgICogICAgICBBIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvciB0aGF0IG9jY3VycmVkLlxuICAgKi9cbiAgX3RoaXMub25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSBfZXJyb3JNZXNzYWdlO1xuICAgIF90aGlzLnRyaWdnZXIoJ3BsYWNlcy1lcnJvcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gcmVuZGVyIG5lYXJieS1jaXRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHtPYmplY3R9XG4gICAqICAgIFRoZSBkYXRhIGZvciBuZWFyYnktY2l0aWVzIEpTT04uXG4gICAqL1xuICBfdGhpcy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBtYXJrdXA7XG5cbiAgICAvLyBGb3JtYXRzIG5lYXJieSBwbGFjZXNcbiAgICBtYXJrdXAgPSBkYXRhLnJlZHVjZShmdW5jdGlvbiAocHJldiwgaXRlbS8qLCBpZHgsIGFyciovKSB7XG4gICAgICByZXR1cm4gcHJldiArIF90aGlzLmZvcm1hdFBsYWNlKGl0ZW0pO1xuICAgIH0sICcnKTtcblxuXG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gJzx1bCBjbGFzcz1cIm5vLXN0eWxlXCI+JyArIG1hcmt1cCArICc8L3VsPic7XG4gICAgX3RoaXMudHJpZ2dlcigncGxhY2VzJywgZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBtb2RlbCBjaGFuZ2VzLiBJbml0aWFsbHkgc2V0cyBhIGxvYWRpbmcgbWVzc2FnZSB0aGVuIHN0YXJ0c1xuICAgKiB0aGUgZGF0YSBmZXRjaCBwcm9jZXNzIHRvIHJlbmRlciB0aGUgYWN0dWFsIGNvbnRlbnQuIFJlbGllcyBvbiBicm93c2VyXG4gICAqIGNhY2hlcyB0byBhdm9pZCBkdXBsaWNhdGUgSFRUUCBvdmVyaGVhZC5cbiAgICovXG4gICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgIF90aGlzLmVsLmlubmVySFRNTCA9ICdMb2FkaW5nIGNvbnRlbnQmaGVsbGlwOyc7XG4gICAgIF90aGlzLmZldGNoRGF0YSgpO1xuICAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE5lYXJieVBsYWNlc1ZpZXc7XG4iLCIvKiBnbG9iYWwgTCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGVycmFpbiA9IHJlcXVpcmUoJ2xlYWZsZXQvbGF5ZXIvVGVycmFpbicpLFxuICAgIEdlb3NlcnZlTmVhcmJ5UGxhY2VzVmlldyA9IHJlcXVpcmUoJ2dlbmVyYWwvR2Vvc2VydmVOZWFyYnlQbGFjZXNWaWV3JyksXG4gICAgR2Vvc2VydmVSZWdpb25TdW1tYXJ5VmlldyA9IHJlcXVpcmUoJ2dlbmVyYWwvR2Vvc2VydmVSZWdpb25TdW1tYXJ5VmlldycpLFxuICAgIEhpc3RvcmljU2Vpc21pY2l0eSA9IHJlcXVpcmUoJ2xlYWZsZXQvbGF5ZXIvSGlzdG9yaWNTZWlzbWljaXR5JyksXG4gICAgSW50ZXJhY3RpdmVNYXBNb2R1bGUgPSByZXF1aXJlKCdtYXAvSW50ZXJhY3RpdmVNYXBNb2R1bGUnKSxcbiAgICBJbnRlcmFjdGl2ZU1hcFZpZXcgPSByZXF1aXJlKCdtYXAvSW50ZXJhY3RpdmVNYXBWaWV3JyksXG4gICAgTW9kdWxlID0gcmVxdWlyZSgnY29yZS9Nb2R1bGUnKSxcbiAgICBOZWFyYnlQbGFjZXNWaWV3ID0gcmVxdWlyZSgnZ2VuZXJhbC9OZWFyYnlQbGFjZXNWaWV3JyksXG4gICAgUHJvZHVjdCA9IHJlcXVpcmUoJ3BkbC9Qcm9kdWN0JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIFhociA9IHJlcXVpcmUoJ3V0aWwvWGhyJyk7XG5cblxudmFyIF9JRCxcbiAgICBfVElUTEUsXG5cbiAgICBfaGFzQ29udGVudDtcblxuXG5fSUQgPSAncmVnaW9uLWluZm8nO1xuX1RJVExFID0gJ1JlZ2lvbmFsIEluZm9ybWF0aW9uJztcblxuX2hhc0NvbnRlbnQgPSBmdW5jdGlvbiAoZXZlbnRQYWdlTW9kZWwpIHtcbiAgdmFyIGV2O1xuXG4gIGV2ID0gZXZlbnRQYWdlTW9kZWwuZ2V0KCdldmVudCcpO1xuICBpZiAoZXYgIT09IG51bGwpIHtcbiAgICAvLyBvbmx5IHNob3cgdGhpcyBtb2R1bGUgaWYgdGhlcmUgaXMgYW4gZXZlbnRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIGZvcm1hdHRlcjogbnVsbCxcbiAgbWFwUmFkaXVzOiA1LjBcbn07XG5cblxuLyoqXG4gKiBBIG1vZHVsZSBmb3IgcmVuZGVyaW5nIG5vbi1ldmVudCBzcGVjaWZpYywgcmVnaW9uYWwgaW5mb3JtYXRpb24uXG4gKlxuICovXG52YXIgUmVnaW9uYWxJbmZvTW9kdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9tYXBFbCxcbiAgICAgIF9tYXBSYWRpdXMsXG4gICAgICBfbmVhcmJ5UGxhY2VzRWwsXG4gICAgICBfbmVhcmJ5UGxhY2VzVmlldyxcbiAgICAgIF9vdGhlclJlZ2lvbkluZm9FbCxcbiAgICAgIF90ZWN0b25pY1N1bW1hcnlFbCxcbiAgICAgIF90ZWN0b25pY1N1bW1hcnlWaWV3O1xuXG5cbiAgX3RoaXMgPSBNb2R1bGUob3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZvciB0aGlzIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtcyBvcHRpb25zLmZvcm1hdHRlciB7Rm9ybWF0dGVyfVxuICAgKiAgICAgQSBmb3JtYXR0ZXIgdG8gdXNlIG9uIHRoaXMgbW9kdWxlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5tYXBSYWRpdXMge051bWJlcn1cbiAgICogICAgIFRoZSBkZWZhdWx0IG1hcCByYWRpdXMgaW4gZGVjaW1hbCBkZWdyZWVzLiBOb3RlOiBUaGlzIHZhbHVlIGlzXG4gICAqICAgICBub3QgdXNlZCB1bmxlc3MgbmVhcmJ5IGNpdGllcyBmYWlscy5cbiAgICovXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgZWwsXG4gICAgICAgIG1hcExpbms7XG5cbiAgICBfdGhpcy5JRCA9IF9JRDtcbiAgICBfdGhpcy5USVRMRSA9IF9USVRMRTtcblxuICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcblxuICAgIF9tYXBSYWRpdXMgPSBvcHRpb25zLm1hcFJhZGl1cztcblxuICAgIG1hcExpbmsgPSBbXG4gICAgICAnIycsIEludGVyYWN0aXZlTWFwTW9kdWxlLklELCAnPycsXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChJbnRlcmFjdGl2ZU1hcFZpZXcuSElTVF9TRUlTX09WRVJMQVkpLCAnPXRydWUmYW1wOycsXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChJbnRlcmFjdGl2ZU1hcFZpZXcuUE9QVUxBVElPTl9PVkVSTEFZKSwgJz10cnVlJmFtcDsnLFxuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoSW50ZXJhY3RpdmVNYXBWaWV3LlNIQUtFTUFQX0NPTlRPVVJTKSwgJz1mYWxzZSdcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgZWwgPSBfdGhpcy5jb250ZW50O1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3JlZ2lvbmFsLWluZm8tbW9kdWxlJyk7XG4gICAgZWwuaW5uZXJIVE1MID0gW1xuICAgICAgICAnPGRpdiBjbGFzcz1cInJvdyByaWdodC10by1sZWZ0XCI+JyxcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImNvbHVtbiBvbmUtb2YtdGhyZWUgcmVnaW9ucy1wbGFjZXNcIj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJyZWdpb25hbC1pbmZvLW1vZHVsZS1yZWdpb25zXCI+PC9kaXY+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicmVnaW9uYWwtaW5mby1tb2R1bGUtcGxhY2VzXCI+PC9kaXY+JyxcbiAgICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImNvbHVtbiB0d28tb2YtdGhyZWVcIj4nLFxuICAgICAgICAgICAgJzxhIGhyZWY9XCInLCBtYXBMaW5rLCAnXCI+JyxcbiAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJyZWdpb25hbC1pbmZvLW1vZHVsZS1tYXBcIj48L2Rpdj4nLFxuICAgICAgICAgICAgICAnVmlldyBJbnRlcmFjdGl2ZSBNYXAnLFxuICAgICAgICAgICAgJzwvYT4nLFxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwicmVnaW9uYWwtaW5mby1tb2R1bGUtdGVjdG9uaWMtc3VtbWFyeVwiPjwvZGl2PicsXG4gICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICc8L2Rpdj4nLFxuICAgIF0uam9pbignJyk7XG5cbiAgICBfbWFwRWwgPSBlbC5xdWVyeVNlbGVjdG9yKCcucmVnaW9uYWwtaW5mby1tb2R1bGUtbWFwJyk7XG4gICAgX25lYXJieVBsYWNlc0VsID0gZWwucXVlcnlTZWxlY3RvcignLnJlZ2lvbmFsLWluZm8tbW9kdWxlLXBsYWNlcycpO1xuICAgIF9vdGhlclJlZ2lvbkluZm9FbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5yZWdpb25hbC1pbmZvLW1vZHVsZS1yZWdpb25zJyk7XG4gICAgX3RlY3RvbmljU3VtbWFyeUVsID0gZWwucXVlcnlTZWxlY3RvcihcbiAgICAgICAgJy5yZWdpb25hbC1pbmZvLW1vZHVsZS10ZWN0b25pYy1zdW1tYXJ5Jyk7XG4gIH07XG5cblxuICAvKipcbiAgICogRnJlZSByZWZlcmVuY2VzLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF90aGlzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKF9uZWFyYnlQbGFjZXNWaWV3KSB7XG4gICAgICBfbmVhcmJ5UGxhY2VzVmlldy5vZmYoJ3BsYWNlcycsICdvbk5lYXJieVBsYWNlcycsIF90aGlzKTtcbiAgICAgIF9uZWFyYnlQbGFjZXNWaWV3Lm9mZigncGxhY2VzLWVycm9yJywgJ29uTmVhcmJ5UGxhY2VzJywgX3RoaXMpO1xuICAgICAgX25lYXJieVBsYWNlc1ZpZXcuZGVzdHJveSgpO1xuICAgICAgX25lYXJieVBsYWNlc1ZpZXcgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChfdGVjdG9uaWNTdW1tYXJ5Vmlldykge1xuICAgICAgX3RlY3RvbmljU3VtbWFyeVZpZXcuZGVzdHJveSgpO1xuICAgICAgX3RlY3RvbmljU3VtbWFyeVZpZXcgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5tYXApIHtcbiAgICAgIF90aGlzLm1hcC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBfbWFwRWwgPSBudWxsO1xuICAgIF9tYXBSYWRpdXMgPSBudWxsO1xuICAgIF9uZWFyYnlQbGFjZXNFbCA9IG51bGw7XG4gICAgX290aGVyUmVnaW9uSW5mb0VsID0gbnVsbDtcbiAgICBfdGVjdG9uaWNTdW1tYXJ5RWwgPSBudWxsO1xuXG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuXG4gIC8qKlxuICAgKiBGaW5kcyBhIG5vbi1hdXRvbWF0aWMgbmVhcmJ5LWNpdGllcyBwcm9kdWN0LiBJZiBub25lIGV4aXN0cywgcmV0dXJucyBudWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZXYge0NhdGFsb2dFdmVudH1cbiAgICogICAgIFRoZSBldmVudCBjb250YWluaW5nIG5lYXJieS1jaXRpZXMgcHJvZHVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcge09iamVjdH1cbiAgICogICAgIEFuIG9iamVjdCBjb250YWluaW5nIGEgU0NFTkFSSU9fTU9ERSBhbmQvb3IgSU5URVJOQUxfTU9ERSBmbGFnXG4gICAqICAgICAoYm9vbGVhbikgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGZ1bGwgcHJvZHVjdCB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybiB7UHJvZHVjdH1cbiAgICogICAgIFRoZSBtb3N0IHByZWZlcnJlZCwgbm9uLWF1dG9tYXRpYyBuZWFyYnktY2l0aWVzIHByb2R1Y3Qgb3IgbnVsbCBpZlxuICAgKiAgICAgbm9uZSBleGlzdC5cbiAgICovXG4gIF90aGlzLmdldE5lYXJieVBsYWNlc1Byb2R1Y3QgPSBmdW5jdGlvbiAoZXYsIGNvbmZpZykge1xuICAgIHZhciBuZWFyYnlDaXRpZXMsXG4gICAgICAgIG9yaWdpbnMsXG4gICAgICAgIHByb2R1Y3Q7XG5cbiAgICBwcm9kdWN0ID0gbnVsbDtcblxuICAgIG5lYXJieUNpdGllcyA9IGV2LmdldFByb2R1Y3RzKFByb2R1Y3QuZ2V0RnVsbFR5cGUoJ25lYXJieS1jaXRpZXMnKSwgY29uZmlnKTtcbiAgICBvcmlnaW5zID0gZXYuZ2V0UHJvZHVjdHMoUHJvZHVjdC5nZXRGdWxsVHlwZSgnb3JpZ2luJyksIGNvbmZpZyk7XG5cbiAgICAvLyBIYXZlIGJvdGggbmVhcmJ5LWNpdGllcyBhbmQgb3JpZ2luIHByb2R1Y3RzLiBMb29rIGZvciBhIG5lYXJieS1jaXRpZXNcbiAgICAvLyBwcm9kdWN0IHRoYXQgZG9lcyBub3QgZGlyZWN0bHkgY29ycmVzcG9uZCB0byBhbiBvcmlnaW4uIFRoZSByZXN1bHRpbmdcbiAgICAvLyBsaXN0IG9mIG5lYXJieS1jaXRpZXMgcHJvZHVjdHMgd2lsbCBiZSBvbmx5IHRob3NlIG1hbnVhbGx5IHNlbnQgYnkgUlNOcy5cbiAgICBuZWFyYnlDaXRpZXMgPSBuZWFyYnlDaXRpZXMuZmlsdGVyKGZ1bmN0aW9uIChuZWFyYnlDaXR5KSB7XG4gICAgICB2YXIgbWF0Y2g7XG5cbiAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICBvcmlnaW5zLnNvbWUoZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICBtYXRjaCA9IF90aGlzLmlzQXV0b21hdGljTmVhcmJ5Q2l0eShuZWFyYnlDaXR5LCBvcmlnaW4pO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuICFtYXRjaDsgLy8gSWYgbm90IG1hdGNoZWQsIHRoZW4gbm90IGF1dG9tYXRpYyAtLT4ga2VlcCBwcm9kdWN0XG4gICAgfSk7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGFueSBub24tYXV0b21hdGljIG5lYXJieS1jaXRpZXMsIHVzZSB0aGUgZmlyc3QgKG1vc3RcbiAgICAvLyBwcmVmZXJyZWQpIG9uZS5cbiAgICBpZiAobmVhcmJ5Q2l0aWVzLmxlbmd0aCkge1xuICAgICAgcHJvZHVjdCA9IG5lYXJieUNpdGllc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZHVjdDtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gbmVhcmJ5Q2l0eSBwcm9kdWN0IGlzIGFuIGF1dG9tYXRpYyBwcm9kdWN0IHRoYXRcbiAgICogd2FzIGdlbmVyYXRlZCBieSB0aGUgZ2l2ZW4gb3JpZ2luIHByb2R1Y3QuXG4gICAqXG4gICAqIEBwYXJhbSBuZWFyYnlDaXR5IHtQcm9kdWN0fVxuICAgKiAgICAgVGhlIG5lYXJieSBjaXR5IHByb2R1Y3QgdG8gY2hlY2tcbiAgICogQHBhcmFtIG9yaWdpbiB7UHJvZHVjdH1cbiAgICogICAgIFRoZSBvcmlnaW4gcHJvZHVjdCB0byBjaGVjayBhZ2FpbnN0XG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqICAgICBUcnVlIGlmIHRoZSBuZWFyYnlDaXR5IHByb2R1Y3Qgd2FzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5XG4gICAqICAgICB0aGUgb3JpZ2luIHByb2R1Y3QuXG4gICAqL1xuICBfdGhpcy5pc0F1dG9tYXRpY05lYXJieUNpdHkgPSBmdW5jdGlvbiAobmVhcmJ5Q2l0eSwgb3JpZ2luKSB7XG4gICAgdmFyIGNpdHlDb2RlLFxuICAgICAgICBjaXR5U291cmNlLFxuICAgICAgICBvcmlnaW5Db2RlO1xuXG4gICAgY2l0eVNvdXJjZSA9IG5lYXJieUNpdHkuZ2V0KCdzb3VyY2UnKTtcbiAgICBjaXR5Q29kZSA9IG5lYXJieUNpdHkuZ2V0KCdjb2RlJyk7XG4gICAgb3JpZ2luQ29kZSA9IG9yaWdpbi5nZXQoJ2NvZGUnKTtcblxuICAgIC8vIElmIGNvZGUgbWF0Y2hlcyBhbmQgc291cmNlIGlzIFwidXNcIiB0aGVuIHByb2R1Y3QgaXMgYXV0b21hdGljLlxuICAgIHJldHVybiAoXG4gICAgICBjaXR5U291cmNlID09PSAndXMnICYmXG4gICAgICBjaXR5Q29kZSA9PT0gb3JpZ2luQ29kZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIG1ldGhvZCB3aGVuIHRoZSB7TmVhcmJ5UGxhY2VzVmlld30gcmVjZWl2ZXMgYW5kIHJlbmRlcnMgZGF0YS4gVGhpc1xuICAgKiBtZXRob2QgdXBkYXRlcyB0aGUgbWFwIGV4dGVudCB0byBwb3RlbnRpYWxseSBpbmNsdWRlIGFsbCB0aGUgbmVhcmJ5XG4gICAqIHBsYWNlcyBpbiB0aGUgZ2l2ZW4gYHBsYWNlc2AgYXJyYXkuIEEgbWluaW11bSBleHRlbnQgaXMgdXNlZCBpblxuICAgKiBjYXNlIGFsbCB0aGUgbmVhcmJ5IHBsYWNlcyBhcmUgdmVyeSBuZWFyYnkgc3VjaCB0aGF0IG5vIG1hcCBjb250ZXh0IHdvdWxkXG4gICAqIGJlIHZpc2libGUuXG4gICAqXG4gICAqIEBwYXJhbSBwbGFjZXMge0FycmF5fVxuICAgKiAgICAgQW4gYXJyYXkgb2YgcGxhY2VzIHRvIHVzZSBhcyBhIGJhc2lzIGZvciBtYXAgY29udGV4dC5cbiAgICovXG4gIF90aGlzLm9uTmVhcmJ5UGxhY2VzID0gZnVuY3Rpb24gKHBsYWNlcykge1xuICAgIHZhciBkZWdyZWVzLFxuICAgICAgICBldixcbiAgICAgICAga20sXG4gICAgICAgIGxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGUsXG4gICAgICAgIHBsYWNlO1xuXG4gICAgZXYgPSBfdGhpcy5tb2RlbC5nZXQoJ2V2ZW50Jyk7XG5cbiAgICBpZiAoZXYgJiYgX3RoaXMubWFwKSB7XG4gICAgICBwbGFjZXMgPSBwbGFjZXMgfHwgW107XG4gICAgICBwbGFjZSA9IHBsYWNlc1twbGFjZXMubGVuZ3RoIC0gMV0gfHwge307XG4gICAgICBrbSA9IHBsYWNlLmRpc3RhbmNlO1xuXG4gICAgICBsYXRpdHVkZSA9IGV2LmdldExhdGl0dWRlKCk7XG4gICAgICBsb25naXR1ZGUgPSBldi5nZXRMb25naXR1ZGUoKTtcblxuICAgICAgaWYgKGxhdGl0dWRlID09PSBudWxsIHx8IGxvbmdpdHVkZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChrbSkge1xuICAgICAgICBkZWdyZWVzID0ga20gLyAxMTEuMjsgLy8gbm90IHJlZ2FyZGluZyBsYXRpdHVkZSwgYnV0IGNsb3NlIGVub3VnaFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVncmVlcyA9IF9tYXBSYWRpdXM7XG4gICAgICB9XG5cbiAgICAgIC8vIFByb3ZpZGUgc29tZSBtaW5pbXVtIGV4dGVudCBmb3IgY29udGV4dC4uLlxuICAgICAgZGVncmVlcyA9IE1hdGgubWF4KGRlZ3JlZXMsIDEpO1xuXG4gICAgICBfdGhpcy5tYXAuZml0Qm91bmRzKFtcbiAgICAgICAgW2xhdGl0dWRlICsgZGVncmVlcywgbG9uZ2l0dWRlICsgZGVncmVlc10sXG4gICAgICAgIFtsYXRpdHVkZSAtIGRlZ3JlZXMsIGxvbmdpdHVkZSAtIGRlZ3JlZXNdXG4gICAgICBdKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIG1ldGhvZCB3aGVuIHRoZSBBSkFYIGNhbGwgdG8gZ2Vvc2VydmUgZm9yIG90aGVyIHJlZ2lvbmFsXG4gICAqIGNvbXBsZXRlcy4gVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgXCJBZG1pbmlzdHJhdGl2ZSBSZWdpb25cIiBhbmQgXCJGRSBSZWdpb25cIlxuICAgKiBzZWN0aW9ucyBvZiB0aGUgcGFnZS5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEge09iamVjdH1cbiAgICogICAgICBBbiBvYmplY3QgY29udGFpbmluZyBcImFkbWluXCIgcmVnaW9uIGluZm9ybWF0aW9uIGFzXG4gICAqICAgICAgcmV0dXJuZWQgYnkgR2Vvc2VydmUuXG4gICAqL1xuICBfdGhpcy5vbk90aGVyUmVnaW9uQ29tcGxldGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBhZG1pbixcbiAgICAgICAgbWFya3VwO1xuXG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLmFkbWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWFya3VwID0gW107XG4gICAgYWRtaW4gPSBkYXRhLmFkbWluLmZlYXR1cmVzWzBdIHx8IHt9O1xuXG4gICAgaWYgKGFkbWluLnByb3BlcnRpZXMpIHtcbiAgICAgIGFkbWluID0gYWRtaW4ucHJvcGVydGllcztcbiAgICAgIG1hcmt1cC5wdXNoKFtcbiAgICAgICAgJzxoMz5BZG1pbmlzdHJhdGl2ZSBSZWdpb248L2gzPicsXG4gICAgICAgICc8ZGwgY2xhc3M9XCJuby1zdHlsZSByZWdpb25hbC1pbmZvLW1vZHVsZS1hZG1pbiB2ZXJ0aWNhbFwiPicsXG4gICAgICAgICAgJzxkdCBjbGFzcz1cInJlZ2lvbmFsLWluZm8tbW9kdWxlLWFkbWluLWlzb1wiPicsXG4gICAgICAgICAgICAnSVNPJyxcbiAgICAgICAgICAnPC9kdD4nLFxuICAgICAgICAgICc8ZGQ+JyxcbiAgICAgICAgICAgIChhZG1pbi5pc28gPT09IG51bGwpID8gJyZuZGFzaDsnIDogYWRtaW4uaXNvLFxuICAgICAgICAgICc8L2RkPicsXG4gICAgICAgICAgJzxkdCBjbGFzcz1cInJlZ2lvbmFsLWluZm8tbW9kdWxlLWFkbWluLWNvdW50cnlcIj4nLFxuICAgICAgICAgICAgJ0NvdW50cnknLFxuICAgICAgICAgICc8L2R0PicsXG4gICAgICAgICAgJzxkZD4nLFxuICAgICAgICAgICAgKGFkbWluLmNvdW50cnkgPT09IG51bGwpID8gJyZuZGFzaDsnIDogYWRtaW4uY291bnRyeSxcbiAgICAgICAgICAnPC9kZD4nLFxuICAgICAgICAgICc8ZHQgY2xhc3M9XCJyZWdpb25hbC1pbmZvLW1vZHVsZS1hZG1pbi1yZWdpb25cIj4nLFxuICAgICAgICAgICAgJ1JlZ2lvbicsXG4gICAgICAgICAgJzwvZHQ+JyxcbiAgICAgICAgICAnPGRkPicsXG4gICAgICAgICAgICAoYWRtaW4ucmVnaW9uID09PSBudWxsKSA/ICcmbmRhc2g7JyA6IGFkbWluLnJlZ2lvbixcbiAgICAgICAgICAnPC9kZD4nLFxuICAgICAgICAnPC9kbD4nLFxuICAgICAgXS5qb2luKCcnKSk7XG5cbiAgICAgIF9vdGhlclJlZ2lvbkluZm9FbC5pbm5lckhUTUwgPSBtYXJrdXAuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9vdGhlclJlZ2lvbkluZm9FbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9vdGhlclJlZ2lvbkluZm9FbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHJlbmRlcmluZyBwcm9jZXNzLiBTb21lIHBhcnRzIG9mIHRoZSBwYWdlIHJlbmRlciBzeW5jaHJvbm91c2x5XG4gICAqIHdoaWxlIG90aGVycyBub3Qgc28uIFJlbmRlcmluZyBpcyBkZWxlZ2F0ZWQgdG8gc3ViLW1ldGhvZHMuXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2O1xuXG4gICAgZXYgPSBfdGhpcy5tb2RlbC5nZXQoJ2V2ZW50Jyk7XG5cbiAgICBfdGhpcy5yZW5kZXJIZWFkZXIoZXYpO1xuXG4gICAgX3RoaXMucmVuZGVyTWFwKGV2KTtcblxuICAgIF90aGlzLnJlbmRlck90aGVyUmVnaW9uSW5mbyhldik7XG4gICAgX3RoaXMucmVuZGVyTmVhcmJ5UGxhY2VzKGV2KTtcblxuICAgIF90aGlzLnJlbmRlclRlY3RvbmljU3VtbWFyeShldik7XG5cbiAgICBfdGhpcy5yZW5kZXJGb290ZXIoZXYpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgbW9kdWxlIGZvb3Rlci5cbiAgICpcbiAgICogQHBhcmFtIGV2IHtDYXRhbG9nRXZlbnR9XG4gICAqICAgICB0aGUgZXZlbnQuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJGb290ZXIgPSBmdW5jdGlvbiAoLypldiovKSB7XG4gICAgX3RoaXMuZm9vdGVyLmlubmVySFRNTCA9ICcnOyAvLyBUT0RPIDo6IEFueXRoaW5nP1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgbW9kdWxlIGhlYWRlci5cbiAgICpcbiAgICogQHBhcmFtIGV2IHtDYXRhbG9nRXZlbnR9XG4gICAqICAgICB0aGUgZXZlbnQuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJIZWFkZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICB2YXIgbGF0aXR1ZGUsXG4gICAgICAgIGV2ZW50aWQ7XG5cbiAgICBVdGlsLmVtcHR5KF90aGlzLmhlYWRlcik7XG5cbiAgICBpZiAoIWV2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRpZCA9IGV2LmdldEV2ZW50SWQoKTtcbiAgICBsYXRpdHVkZSA9IGV2LmdldExhdGl0dWRlKCk7XG5cbiAgICAvLyBJZiBsb2NhdGlvbiBsYXRpdHVkZSBleHRlbnRzIGFyZSArIG9yIC0gODUgZGVncmVlcyBzaG93IHdhcm5pbmdcbiAgICBpZiAoTWF0aC5hYnMobGF0aXR1ZGUpID4gODUuMCkge1xuICAgICAgX3RoaXMuaGVhZGVyLmlubmVySFRNTCA9IFtcbiAgICAgICAgJzxwIGNsYXNzPVwiYWxlcnQgd2FybmluZ1wiPicsXG4gICAgICAgICAgJ0R1ZSB0byB0aGUgaGlnaCBsYXRpdHVkZSBvZiB0aGlzJyxcbiAgICAgICAgICAnIGV2ZW50LCB0aGUgbG9jYXRpb24gbWFwIGRvZXMgbm90IHNob3cgdGhlIGNvcnJlY3QgbG9jYXRpb24uJyxcbiAgICAgICAgICAnIFRvIHNlZSB0aGUgYWN0dWFsIGxvY2F0aW9uIHdlIHJlY29tbWVuZCB1c2luZycsXG4gICAgICAgICAgJyA8YSBocmVmPVwiL2VhcnRocXVha2VzL2ZlZWQvdjEuMC9kZXRhaWwvJywgZXZlbnRpZCwgJy5rbWxcIj4nLFxuICAgICAgICAgICdHb29nbGUgRWFydGggS01MJyxcbiAgICAgICAgICAnPC9hPi4nLFxuICAgICAgICAnPC9wPidcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmhlYWRlci5pbm5lckhUTUwgPSAnJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBtYXAgaW5mb3JtYXRpb24gZm9yIHRoZSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2IHtDYXRhbG9nRXZlbnR9XG4gICAqICAgICB0aGUgZXZlbnQuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJNYXAgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICB2YXIgbGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZTtcblxuICAgIGlmIChfdGhpcy5tYXApIHtcbiAgICAgIF90aGlzLm1hcC5yZW1vdmUoKTtcbiAgICAgIF90aGlzLm1hcCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFldikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxhdGl0dWRlID0gZXYuZ2V0TGF0aXR1ZGUoKTtcbiAgICBsb25naXR1ZGUgPSBldi5nZXRMb25naXR1ZGUoKTtcblxuICAgIGlmIChsYXRpdHVkZSA9PT0gbnVsbCB8fCBsb25naXR1ZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfdGhpcy5tYXAgPSBMLm1hcChfbWFwRWwsIHtcbiAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogZmFsc2UsXG4gICAgICBib3hab29tOiBmYWxzZSxcbiAgICAgIGNlbnRlcjogW2xhdGl0dWRlLCBsb25naXR1ZGVdLFxuICAgICAgem9vbTogMSxcbiAgICAgIGRvdWJsZUNsaWNrWm9vbTogZmFsc2UsXG4gICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICBmYWRlQW5pbWF0aW9uOiBmYWxzZSxcbiAgICAgIGtleWJvYXJkOiBmYWxzZSxcbiAgICAgIG1hcmtlclpvb21BbmltYXRpb246IGZhbHNlLFxuICAgICAgbGF5ZXJzOiBbXG4gICAgICAgIFRlcnJhaW4oe3Byb3ZpZGVyOiBUZXJyYWluLk5BVEdFT30pLFxuICAgICAgICBIaXN0b3JpY1NlaXNtaWNpdHkoKSxcbiAgICAgICAgLy8gVE9ETyA6OiBQb3B1bGF0aW9uIGRlbnNpdHkgbGF5ZXIgLi4uIG5lZWQgdGlsZSBsYXllciBpbiBHSVMgZmlyc3RcbiAgICAgICAgTC5tYXJrZXIoW2xhdGl0dWRlLCBsb25naXR1ZGVdLCB7XG4gICAgICAgICAgekluZGV4T2Zmc2V0OiA5OSxcbiAgICAgICAgICBpY29uOiBMLmljb24oe1xuICAgICAgICAgICAgaWNvblVybDogJ2ltYWdlcy9zdGFyLnBuZycsXG4gICAgICAgICAgICBpY29uU2l6ZTogWzMyLCAzMl0sXG4gICAgICAgICAgICBpY29uQW5jaG9yOiBbMTYsIDE2XVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICBdLFxuICAgICAgc2Nyb2xsV2hlZWxab29tOiBmYWxzZSxcbiAgICAgIHRhcDogZmFsc2UsXG4gICAgICB0b3VjaFpvb206IGZhbHNlLFxuICAgICAgem9vbUFuaW1hdGlvbjogZmFsc2UsXG4gICAgICB6b29tQ29udHJvbDogZmFsc2VcbiAgICB9KTtcblxuICAgIEwuY29udHJvbC5zY2FsZSh7cG9zaXRpb246ICdib3R0b21sZWZ0J30pLmFkZFRvKF90aGlzLm1hcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBuZWFyYnktY2l0aWVzIHByb2R1Y3QsIG9yIG5lYXJieSBwbGFjZXMgZnJvbSBnZW9zZXJ2ZS5cbiAgICpcbiAgICogQHBhcmFtIGV2IHtDYXRhbG9nRXZlbnR9XG4gICAqL1xuICBfdGhpcy5yZW5kZXJOZWFyYnlQbGFjZXMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICB2YXIgY29uZmlnLFxuICAgICAgICBwcm9kdWN0O1xuXG4gICAgaWYgKF9uZWFyYnlQbGFjZXNWaWV3KSB7XG4gICAgICBfbmVhcmJ5UGxhY2VzVmlldy5vZmYoJ3BsYWNlcycsICdvbk5lYXJieVBsYWNlcycsIF90aGlzKTtcbiAgICAgIF9uZWFyYnlQbGFjZXNWaWV3Lm9mZigncGxhY2VzLWVycm9yJywgJ29uTmVhcmJ5UGxhY2VzJywgX3RoaXMpO1xuICAgICAgX25lYXJieVBsYWNlc1ZpZXcuZGVzdHJveSgpO1xuICAgICAgX25lYXJieVBsYWNlc1ZpZXcgPSBudWxsO1xuICAgIH1cbiAgICBVdGlsLmVtcHR5KF9uZWFyYnlQbGFjZXNFbCk7XG5cbiAgICBpZiAoIWV2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnID0gX3RoaXMubW9kZWwuZ2V0KCdjb25maWcnKTtcblxuICAgIHByb2R1Y3QgPSBfdGhpcy5nZXROZWFyYnlQbGFjZXNQcm9kdWN0KGV2LCBjb25maWcpO1xuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBfbmVhcmJ5UGxhY2VzVmlldyA9IE5lYXJieVBsYWNlc1ZpZXcoe1xuICAgICAgICBtb2RlbDogcHJvZHVjdCxcbiAgICAgICAgcmVuZGVyTmV3TGF5b3V0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZHVjdCA9IGV2LmdldFByZWZlcnJlZE9yaWdpblByb2R1Y3QoKTtcbiAgICAgIF9uZWFyYnlQbGFjZXNWaWV3ID0gR2Vvc2VydmVOZWFyYnlQbGFjZXNWaWV3KHtcbiAgICAgICAgbW9kZWw6IHByb2R1Y3QsXG4gICAgICAgIHJlbmRlck5ld0xheW91dDogdHJ1ZSxcbiAgICAgICAgdXJsOiAoY29uZmlnID8gY29uZmlnLkdFT1NFUlZFX1dTX1VSTCA6ICcvd3MvZ2Vvc2VydmUvJylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9uZWFyYnlQbGFjZXNWaWV3Lm9uKCdwbGFjZXMnLCAnb25OZWFyYnlQbGFjZXMnLCBfdGhpcyk7XG4gICAgX25lYXJieVBsYWNlc1ZpZXcub24oJ3BsYWNlcy1lcnJvcicsICdvbk5lYXJieVBsYWNlcycsIF90aGlzKTtcblxuICAgIF9uZWFyYnlQbGFjZXNFbC5pbm5lckhUTUwgPSAnPGgzPk5lYXJieSBQbGFjZXM8L2gzPicgK1xuICAgICAgICAnPHNtYWxsPicgK1xuICAgICAgICAgICdEaXJlY3Rpb24gZGF0YSAoYmVsb3cpIGluZGljYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgJyArXG4gICAgICAgICAgJ3JlbGF0aXZlIHRvIHRoZSBwbGFjZS4nICtcbiAgICAgICAgJzwvc21hbGw+JztcblxuICAgIF9uZWFyYnlQbGFjZXNFbC5hcHBlbmRDaGlsZChfbmVhcmJ5UGxhY2VzVmlldy5lbCk7XG4gICAgX25lYXJieVBsYWNlc1ZpZXcucmVuZGVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVzIG9mZiBhIEdlb3NlcnZlIHJlcXVlc3QgZm9yIG90aGVyIHJlZ2lvbmFsIGluZm9ybWF0aW9uLiBXaGVuIHRoYXRcbiAgICogcmVxdWVzdCBjb21wbGV0ZXMsIHRoZSBgb25PdGhlclJlZ2lvbkluZm9Db21wbGV0ZWAgbWV0aG9kIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSBldiB7Q2F0YWxvZ0V2ZW50fVxuICAgKi9cbiAgX3RoaXMucmVuZGVyT3RoZXJSZWdpb25JbmZvID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIGNvbmZpZyxcbiAgICAgICAgbGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZTtcblxuICAgIFV0aWwuZW1wdHkoX290aGVyUmVnaW9uSW5mb0VsKTtcblxuICAgIGlmICghZXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWcgPSBfdGhpcy5tb2RlbC5nZXQoJ2NvbmZpZycpO1xuICAgIGxhdGl0dWRlID0gZXYuZ2V0TGF0aXR1ZGUoKTtcbiAgICBsb25naXR1ZGUgPSBldi5nZXRMb25naXR1ZGUoKTtcblxuICAgIGlmIChsYXRpdHVkZSA9PT0gbnVsbCB8fCBsb25naXR1ZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBYaHIuYWpheCh7XG4gICAgICB1cmw6ICgoY29uZmlnKSA/IGNvbmZpZy5HRU9TRVJWRV9XU19VUkwgOiAnL3dzL2dlb3NlcnZlLycpICtcbiAgICAgICAgICAncmVnaW9ucy5qc29uJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGU6IGxvbmdpdHVkZSxcbiAgICAgICAgdHlwZTogJ2FkbWluLGZlJ1xuICAgICAgfSxcbiAgICAgIHN1Y2Nlc3M6IF90aGlzLm9uT3RoZXJSZWdpb25Db21wbGV0ZSxcbiAgICAgIGVycm9yOiBfdGhpcy5vbk90aGVyUmVnaW9uQ29tcGxldGVcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSB0ZWN0b25pYy1zdW1tYXJ5IHByb2R1Y3QgaWYgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gZXYge0NhdGFsb2dFdmVudH1cbiAgICogICAgIHRoZSBldmVudC5cbiAgICovXG4gIF90aGlzLnJlbmRlclRlY3RvbmljU3VtbWFyeSA9IGZ1bmN0aW9uIChldikge1xuICAgIHZhciBwcm9kdWN0O1xuXG4gICAgaWYgKF90ZWN0b25pY1N1bW1hcnlWaWV3KSB7XG4gICAgICBfdGVjdG9uaWNTdW1tYXJ5Vmlldy5kZXN0cm95KCk7XG4gICAgICBfdGVjdG9uaWNTdW1tYXJ5VmlldyA9IG51bGw7XG4gICAgfVxuXG4gICAgVXRpbC5lbXB0eShfdGVjdG9uaWNTdW1tYXJ5RWwpO1xuXG4gICAgaWYgKCFldikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByb2R1Y3QgPSBldi5nZXRQcmVmZXJyZWRPcmlnaW5Qcm9kdWN0KCk7XG5cbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgX3RlY3RvbmljU3VtbWFyeVZpZXcgPSBHZW9zZXJ2ZVJlZ2lvblN1bW1hcnlWaWV3KHtcbiAgICAgICAgZWw6IF90ZWN0b25pY1N1bW1hcnlFbCxcbiAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgIH0pO1xuICAgICAgX3RlY3RvbmljU3VtbWFyeVZpZXcucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cblJlZ2lvbmFsSW5mb01vZHVsZS5JRCA9IF9JRDtcblJlZ2lvbmFsSW5mb01vZHVsZS5USVRMRSA9IF9USVRMRTtcblxuUmVnaW9uYWxJbmZvTW9kdWxlLmhhc0NvbnRlbnQgPSBfaGFzQ29udGVudDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZ2lvbmFsSW5mb01vZHVsZTtcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEJhc2ljUGluVmlldyA9IHJlcXVpcmUoJ2NvcmUvQmFzaWNQaW5WaWV3JyksXG4gICAgSGlzdG9yaWNTZWlzbWljaXR5ID0gcmVxdWlyZSgnbGVhZmxldC9sYXllci9IaXN0b3JpY1NlaXNtaWNpdHknKSxcbiAgICBUZXJyYWluID0gcmVxdWlyZSgnbGVhZmxldC9sYXllci9UZXJyYWluJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIG1vZHVsZToge0lEOiAncmVnaW9uLWluZm8nLCBUSVRMRTogJ1JlZ2lvbmFsIEluZm9ybWF0aW9uJ31cbn07XG5cblxudmFyIFJlZ2lvbmFsSW5mb1BpblZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX21hcEVsLFxuICAgICAgX21hcFZpZXcsXG4gICAgICBfbWFya2VyO1xuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgX3RoaXMgPSBCYXNpY1BpblZpZXcob3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIG5ldyBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqL1xuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgvKm9wdGlvbnMqLykge1xuICAgIHZhciBsYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlO1xuXG4gICAgX21hcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX21hcEVsLmNsYXNzTGlzdC5hZGQoJ3JlZ2lvbmFsLWluZm8tbWFwJyk7XG4gICAgX3RoaXMuY29udGVudC5hcHBlbmRDaGlsZChfbWFwRWwpO1xuXG4gICAgbGF0aXR1ZGUgPSBwYXJzZUZsb2F0KF90aGlzLm1vZGVsLmdldFByb3BlcnR5KCdsYXRpdHVkZScpKTtcbiAgICBsb25naXR1ZGUgPSBwYXJzZUZsb2F0KF90aGlzLm1vZGVsLmdldFByb3BlcnR5KCdsb25naXR1ZGUnKSk7XG5cbiAgICBpZiAoaXNOYU4obGF0aXR1ZGUpIHx8IGlzTmFOKGxvbmdpdHVkZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfbWFya2VyID0gTC5tYXJrZXIoW2xhdGl0dWRlLCBsb25naXR1ZGVdLCB7XG4gICAgICAgIHpJbmRleE9mZnNldDogOTksXG4gICAgICAgIGljb246IEwuaWNvbih7XG4gICAgICAgICAgaWNvblVybDogJ2ltYWdlcy9zdGFyLnBuZycsXG4gICAgICAgICAgaWNvblNpemU6IFsxNiwgMTZdLFxuICAgICAgICAgIGljb25BbmNob3I6IFs4LCA4XVxuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICBfbWFwVmlldyA9IEwubWFwKF9tYXBFbCwge1xuICAgICAgYXR0cmlidXRpb25Db250cm9sOiBmYWxzZSxcbiAgICAgIGJveFpvb206IGZhbHNlLFxuICAgICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICB6b29tOiAwLFxuICAgICAgZG91YmxlQ2xpY2tab29tOiBmYWxzZSxcbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIGZhZGVBbmltYXRpb246IGZhbHNlLFxuICAgICAga2V5Ym9hcmQ6IGZhbHNlLFxuICAgICAgbWFya2VyWm9vbUFuaW1hdGlvbjogZmFsc2UsXG4gICAgICBsYXllcnM6IFtcbiAgICAgICAgVGVycmFpbih7cHJvdmlkZXI6IFRlcnJhaW4uTkFUR0VPfSksXG4gICAgICAgIEhpc3RvcmljU2Vpc21pY2l0eSgpLFxuICAgICAgICAvLyBUT0RPIDo6IFBvcHVsYXRpb24gZGVuc2l0eSBsYXllciAuLi4gbmVlZCB0aWxlIGxheWVyIGluIEdJUyBmaXJzdFxuICAgICAgICBfbWFya2VyXG4gICAgICBdLFxuICAgICAgc2Nyb2xsV2hlZWxab29tOiBmYWxzZSxcbiAgICAgIHRhcDogZmFsc2UsXG4gICAgICB0b3VjaFpvb206IGZhbHNlLFxuICAgICAgem9vbUFuaW1hdGlvbjogZmFsc2UsXG4gICAgICB6b29tQ29udHJvbDogZmFsc2VcbiAgICB9KTtcbiAgfTtcblxuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3RoaXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMubWFwKSB7XG4gICAgICBfdGhpcy5tYXAucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgX21hcEVsID0gbnVsbDtcbiAgICBfbWFwVmlldyA9IG51bGw7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogUmVuZGVyIG1hcCBpbmZvcm1hdGlvbiBmb3IgdGhlIGV2ZW50LlxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVuZGVyUGluQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZTtcblxuICAgIGlmIChfbWFwVmlldykge1xuICAgICAgbGF0aXR1ZGUgPSBwYXJzZUZsb2F0KF90aGlzLm1vZGVsLmdldFByb3BlcnR5KCdsYXRpdHVkZScpKTtcbiAgICAgIGxvbmdpdHVkZSA9IHBhcnNlRmxvYXQoX3RoaXMubW9kZWwuZ2V0UHJvcGVydHkoJ2xvbmdpdHVkZScpKTtcblxuICAgICAgX21hcFZpZXcuaW52YWxpZGF0ZVNpemUoKTtcbiAgICAgIC8vIGdpdmUgYSAyIGRlZ3JlZSBidWZmZXIgYXJvdW5kIGNlbnRlciBwb2ludFxuICAgICAgX21hcFZpZXcuZml0Qm91bmRzKFtcbiAgICAgICAgICBbbGF0aXR1ZGUgLSAyLjAsIGxvbmdpdHVkZSAtIDIuMF0sXG4gICAgICAgICAgW2xhdGl0dWRlICsgMi4wLCBsb25naXR1ZGUgKyAyLjBdXG4gICAgICBdKTtcbiAgICB9XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWdpb25hbEluZm9QaW5WaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBCYXNpY1BpblZpZXcgPSByZXF1aXJlKCdjb3JlL0Jhc2ljUGluVmlldycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0RFRkFVTFRTO1xuXG5fREVGQVVMVFMgPSB7XG4gIGJhZGdlSW1hZ2U6ICdpbWFnZXMvbG9nb3MvdHN1bmFtaS5qcGcnLFxuICBtb2R1bGU6IHtJRDogJyMnLCBUSVRMRTogJ1RzdW5hbWknfVxufTtcblxuXG4vKipcbiAqIEEgcGluIHZpZXcgdG8gbGluayB0byB0aGUgY3VycmVudCB0c3VuYW1pIGFkdmlzb3JpZXMgcGFnZS5cbiAqXG4gKi9cbnZhciBUc3VuYW1pUGluVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IEJhc2ljUGluVmlldyhvcHRpb25zKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwaW4gdmlldy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuYmFkZ2VJbWFnZSB7U3RyaW5nfVxuICAgKiAgICAgQSBVUkwgdG8gYW4gaW1hZ2UgdG8gdXNlLlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3RzdW5hbWktcGluLXZpZXcnKTtcbiAgICBfdGhpcy5iYWRnZUltYWdlID0gb3B0aW9ucy5iYWRnZUltYWdlO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgIFRoZSBsaW5rIHRvIHVzZSB3aGVuIGNsaWNraW5nIG9uIHRoZSBwaW4uXG4gICAqL1xuICBfdGhpcy5nZXRMaW5rVXJsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnaHR0cDovL3d3dy50c3VuYW1pLmdvdi8nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBwaW4gY29udGVudC4gUHV0cyBhIGJhZGdlIHdpdGggc29tZSB0ZXh0IGludG8gdGhlIGNvbnRlbnQuXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXJQaW5Db250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gW1xuICAgICAgJzxmaWd1cmUgY2xhc3M9XCJwaW4tYmFkZ2VcIj4nLFxuICAgICAgICAnPGltZyBzcmM9XCInLCBfdGhpcy5iYWRnZUltYWdlLCAnXCIgYWx0PVwiVHN1bmFtaSBXYXJuaW5nIENlbnRlclwiICcsXG4gICAgICAgICAgICAnY2xhc3M9XCJ0c3VuYW1pLXBpbi1sb2dvXCIvPicsXG4gICAgICAnPC9maWd1cmU+JyxcbiAgICAgICc8c21hbGwgY2xhc3M9XCJkaXNjbGFpbWVyXCI+JyxcbiAgICAgICAgJ1RvIHZpZXcgYW55IGN1cnJlbnQgdHN1bmFtaSBhZHZpc29yaWVzIGZvciB0aGlzIGFuZCBvdGhlciBldmVudHMsICcsXG4gICAgICAgICdwbGVhc2UgdmlzaXQgPGEgaHJlZj1cImh0dHA6Ly93d3cudHN1bmFtaS5nb3YvXCI+JyxcbiAgICAgICAgJ2h0dHA6Ly93d3cudHN1bmFtaS5nb3Y8L2E+LicsXG4gICAgICAnPC9zbWFsbD4nXG4gICAgXS5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcGluIGZvb3Rlci4gUHV0cyBhIGxpbmsgdG8gTk9BQSBpbiB0aGUgZm9vdGVyLlxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVuZGVyUGluRm9vdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmZvb3Rlci5pbm5lckhUTUwgPSBbXG4gICAgICAnPGEgaHJlZj1cIicsIF90aGlzLmdldExpbmtVcmwoKSwgJ1wiPk5PQUE8L2E+J1xuICAgIF0uam9pbignJyk7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUc3VuYW1pUGluVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEF0dHJpYnV0aW9uID0gcmVxdWlyZSgnY29yZS9BdHRyaWJ1dGlvbicpLFxuICAgIEZvcm1hdHRlciA9IHJlcXVpcmUoJ2NvcmUvRm9ybWF0dGVyJyksXG4gICAgU3VtbWFyeU1vZHVsZSA9IHJlcXVpcmUoJ2NvcmUvU3VtbWFyeU1vZHVsZScpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKSxcblxuICAgIC8vIHRoZXNlIG1vZHVsZXMgY3JlYXRlIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSxcbiAgICAvLyByZXF1aXJlIHRoZW0gaW4gaW5pdGlhbGl6ZVxuICAgIERZRklNb2R1bGUsXG4gICAgUEFHRVJNb2R1bGUsXG4gICAgU2hha2VNYXBNb2R1bGU7XG5cblxudmFyIF9JRCxcbiAgICBfVElUTEUsXG4gICAgX1RZUEVTO1xuXG5fSUQgPSAnaW1wYWN0Jztcbl9USVRMRSA9ICdJbXBhY3QnO1xuX1RZUEVTID0gWydkeWZpJywgJ3NoYWtlbWFwJywgJ2xvc3NwYWdlciddO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG5cbn07XG5cblxuLyoqXG4gKiBTdW1tYXJ5IG1vZHVsZSBmb3IgdGhlIGltcGFjdCBwcm9kdWN0cy5cbiAqXG4gKi9cbnZhciBJbXBhY3RTdW1tYXJ5TW9kdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9mb3JtYXR0ZXI7XG5cblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gU3VtbWFyeU1vZHVsZShvcHRpb25zKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IuIEluaXRpYWxpemVzIGEgbmV3IHtJbXBhY3RTdW1tYXJ5TW9kdWxlfS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogICAgIFNlZSBNb2R1bGUjaW5pdGlhbGl6ZSBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF9mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBGb3JtYXR0ZXIoKTtcblxuICAgIF90aGlzLklEID0gX0lEO1xuICAgIF90aGlzLlRJVExFID0gX1RJVExFO1xuXG4gICAgLy8gdGhlc2UgbW9kdWxlcyBjcmVhdGUgYSBjaXJjdWxhciBkZXBlbmRlbmN5LFxuICAgIC8vIHJlcXVpcmUgdGhlbSBmaXJzdCB0aW1lIGluaXRpYWxpemUgaXMgY2FsbGVkXG4gICAgRFlGSU1vZHVsZSA9IERZRklNb2R1bGUgfHwgcmVxdWlyZSgnZHlmaS9EWUZJTW9kdWxlJyk7XG4gICAgUEFHRVJNb2R1bGUgPSBQQUdFUk1vZHVsZSB8fCByZXF1aXJlKCdsb3NzcGFnZXIvUEFHRVJNb2R1bGUnKTtcbiAgICBTaGFrZU1hcE1vZHVsZSA9IFNoYWtlTWFwTW9kdWxlIHx8IHJlcXVpcmUoJ3NoYWtlbWFwL1NoYWtlTWFwTW9kdWxlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZyZWVzIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtb2R1bGUuXG4gICAqXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBfZm9ybWF0dGVyID0gbnVsbDtcblxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdW1tYXJ5IGZvciB0aGUgbGlzdCBvZiBEWUZJIHByb2R1Y3RzLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdHMge0FycmF5fVxuICAgKiAgICAgQW4gYXJyYXkgb2YgRFlGSSB7UHJvZHVjdH1zIHRvIHN1bW1hcml6ZS5cbiAgICpcbiAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICogICAgIEEgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgc3VtbWFyeSBmb3IgdGhlIHByb2R1Y3RzLlxuICAgKi9cbiAgX3RoaXMuZ2V0RHlmaVN1bW1hcnkgPSBmdW5jdGlvbiAocHJvZHVjdHMpIHtcbiAgICByZXR1cm4gX3RoaXMuY3JlYXRlU3VtbWFyeShwcm9kdWN0cywgJ0RpZCBZb3UgRmVlbCBJdD8nLCBbXG4gICAgICAgICdDYXRhbG9nJyxcbiAgICAgICAgJzxhYmJyIHRpdGxlPVwiQ29tbXVuaXR5IERldGVybWluZWQgSW50ZW5zaXR5XCI+Q0RJPC9hYmJyPicsXG4gICAgICAgICdSZXNwb25zZXMnLFxuICAgICAgICAnU291cmNlJ1xuICAgICAgXSwgX3RoaXMuZ2V0RHlmaVJvdyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzaW5nbGUgc3VtbWFyeSByb3cgZm9yIHRoZSBzaW5nbGUgZ2l2ZW4gcHJvZHVjdC5cbiAgICpcbiAgICogQHBhcmFtIHByb2R1Y3Qge1Byb2R1Y3R9XG4gICAqICAgICBUaGUgcHJvZHVjdCB0byBzdW1tYXJpemUuXG4gICAqIEBwYXJhbSBpbmRleCB7TnVtYmVyfVxuICAgKiAgICAgVGhlIHJlbGF0aXZlIHByZWZlcnJlZCBudW1iZXIgZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxuICAgKiAgICAgMCA9IG1vc3QgcHJlZmVycmVkXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG4gICAqICAgICBBIFRSIERPTSBFbGVtZW50IGZvciB0aGUgcm93IHN1bW1hcnkuXG4gICAqL1xuICBfdGhpcy5nZXREeWZpUm93ID0gZnVuY3Rpb24gKHByb2R1Y3QsIGluZGV4KSB7XG4gICAgdmFyIHByZWZlcnJlZCxcbiAgICAgICAgcm93O1xuXG4gICAgcHJlZmVycmVkID0gKGluZGV4ID09PSAwKTtcbiAgICByb3cgPSBfdGhpcy5jcmVhdGVSb3cocHJlZmVycmVkKTtcbiAgICByb3cuaW5uZXJIVE1MID0gW1xuICAgICAgJzx0aCBzY29wZT1cInJvd1wiPicsXG4gICAgICAgIF90aGlzLmdldENhdGFsb2dNYXJrdXAoRFlGSU1vZHVsZSwgcHJvZHVjdCwgcHJlZmVycmVkKSxcbiAgICAgICc8L3RoPicsXG4gICAgICAnPHRkPicsXG4gICAgICAgIF9mb3JtYXR0ZXIuaW50ZW5zaXR5KHByb2R1Y3QuZ2V0UHJvcGVydHkoJ21heG1taScpKSxcbiAgICAgICc8L3RkPicsXG4gICAgICAnPHRkPicsXG4gICAgICAgIHByb2R1Y3QuZ2V0UHJvcGVydHkoJ251bS1yZXNwb25zZXMnKSxcbiAgICAgICc8L3RkPicsXG4gICAgICAnPHRkPicsXG4gICAgICAgIEF0dHJpYnV0aW9uLmdldFByb2R1Y3RBdHRyaWJ1dGlvbihwcm9kdWN0KSxcbiAgICAgICc8L3RkPidcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgcmV0dXJuIHJvdztcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgaGVhZGVyIGZvciB0aGUgbGlua3Mgc2VjdGlvbiBmb3IgdGhpcyBtb2R1bGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG4gICAqICAgICBUaGUgaGVhZGVyIGVsZW1lbnQuXG4gICAqL1xuICBfdGhpcy5nZXRMaW5rc0hlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGVhZGVyO1xuXG4gICAgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKTtcbiAgICBoZWFkZXIuaW5uZXJIVE1MID0gJ0ltcGFjdCBMaW5rcyc7XG5cbiAgICByZXR1cm4gaGVhZGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdW1tYXJ5IGZvciB0aGUgbGlzdCBvZiBMb3NzUEFHRVIgcHJvZHVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9kdWN0cyB7QXJyYXl9XG4gICAqICAgICBBbiBhcnJheSBvZiBMb3NzUEFHRVIge1Byb2R1Y3R9cyB0byBzdW1tYXJpemUuXG4gICAqXG4gICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gICAqICAgICBBIGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIHN1bW1hcnkgZm9yIHRoZSBwcm9kdWN0cy5cbiAgICovXG4gIF90aGlzLmdldFBhZ2VyU3VtbWFyeSA9IGZ1bmN0aW9uIChwcm9kdWN0cykge1xuICAgIHJldHVybiBfdGhpcy5jcmVhdGVTdW1tYXJ5KHByb2R1Y3RzLCAnUEFHRVInLCBbXG4gICAgICAgICdDYXRhbG9nJyxcbiAgICAgICAgJ0FsZXJ0IExldmVsJyxcbiAgICAgICAgJ1NvdXJjZSdcbiAgICAgIF0sIF90aGlzLmdldFBhZ2VyUm93KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIHNpbmdsZSBzdW1tYXJ5IHJvdyBmb3IgdGhlIHNpbmdsZSBnaXZlbiBwcm9kdWN0LlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIFRoZSBwcm9kdWN0IHRvIHN1bW1hcml6ZS5cbiAgICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9XG4gICAqICAgICBUaGUgcmVsYXRpdmUgcHJlZmVycmVkIG51bWJlciBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gICAqICAgICAwID0gbW9zdCBwcmVmZXJyZWRcbiAgICpcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH1cbiAgICogICAgIEEgVFIgRE9NIEVsZW1lbnQgZm9yIHRoZSByb3cgc3VtbWFyeS5cbiAgICovXG4gIF90aGlzLmdldFBhZ2VyUm93ID0gZnVuY3Rpb24gKHByb2R1Y3QsIGluZGV4KSB7XG4gICAgdmFyIGFsZXJ0TGV2ZWwsXG4gICAgICAgIHByZWZlcnJlZCxcbiAgICAgICAgcm93O1xuXG4gICAgcHJlZmVycmVkID0gKGluZGV4ID09PSAwKTtcbiAgICByb3cgPSBfdGhpcy5jcmVhdGVSb3cocHJlZmVycmVkKTtcblxuICAgIGFsZXJ0TGV2ZWwgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdhbGVydGxldmVsJykgfHwgJ3BlbmRpbmcnO1xuXG4gICAgcm93LmlubmVySFRNTCA9IFtcbiAgICAgICc8dGggc2NvcGU9XCJyb3dcIj4nLFxuICAgICAgICBfdGhpcy5nZXRDYXRhbG9nTWFya3VwKFBBR0VSTW9kdWxlLCBwcm9kdWN0LCBwcmVmZXJyZWQpLFxuICAgICAgJzwvdGg+JyxcbiAgICAgICc8dGQ+JyxcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwibW1pIHBhZ2VyLWFsZXJ0bGV2ZWwtJywgYWxlcnRMZXZlbC50b0xvd2VyQ2FzZSgpLCAnXCI+JyxcbiAgICAgICAgICAnPHN0cm9uZyBjbGFzcz1cInJvbWFuXCI+JyxcbiAgICAgICAgICAgIGFsZXJ0TGV2ZWwudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAnPC9zdHJvbmc+JyxcbiAgICAgICAgJzwvc3Bhbj4nLFxuICAgICAgJzwvdGQ+JyxcbiAgICAgICc8dGQ+JyxcbiAgICAgICAgQXR0cmlidXRpb24uZ2V0UHJvZHVjdEF0dHJpYnV0aW9uKHByb2R1Y3QpLFxuICAgICAgJzwvdGQ+J1xuICAgIF0uam9pbignJyk7XG5cbiAgICByZXR1cm4gcm93O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdW1tYXJ5IGZvciB0aGUgbGlzdCBvZiBTaGFrZU1hcCBwcm9kdWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHByb2R1Y3RzIHtBcnJheX1cbiAgICogICAgIEFuIGFycmF5IG9mIFNoYWtlTWFwIHtQcm9kdWN0fXMgdG8gc3VtbWFyaXplLlxuICAgKlxuICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICAgKiAgICAgQSBmcmFnbWVudCBjb250YWluaW5nIHRoZSBzdW1tYXJ5IGZvciB0aGUgcHJvZHVjdHMuXG4gICAqL1xuICBfdGhpcy5nZXRTaGFrZU1hcFN1bW1hcnkgPSBmdW5jdGlvbiAocHJvZHVjdHMpIHtcbiAgICByZXR1cm4gX3RoaXMuY3JlYXRlU3VtbWFyeShwcm9kdWN0cywgJ1NoYWtlTWFwJywgW1xuICAgICAgICAnQ2F0YWxvZycsXG4gICAgICAgICc8YWJiciB0aXRsZT1cIk1heGltdW0gTW9kaWZpZWQgTWVyY2FsbGkgSW50ZW5zaXR5XCI+TU1JPC9hYmJyPicsXG4gICAgICAgICdTb3VyY2UnLFxuICAgICAgICAnRGVzY3JpcHRpb24nXG4gICAgICBdLCBfdGhpcy5nZXRTaGFrZU1hcFJvdyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzaW5nbGUgc3VtbWFyeSByb3cgZm9yIHRoZSBzaW5nbGUgZ2l2ZW4gcHJvZHVjdC5cbiAgICpcbiAgICogQHBhcmFtIHByb2R1Y3Qge1Byb2R1Y3R9XG4gICAqICAgICBUaGUgcHJvZHVjdCB0byBzdW1tYXJpemUuXG4gICAqIEBwYXJhbSBpbmRleCB7TnVtYmVyfVxuICAgKiAgICAgVGhlIHJlbGF0aXZlIHByZWZlcnJlZCBudW1iZXIgZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxuICAgKiAgICAgMCA9IG1vc3QgcHJlZmVycmVkXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG4gICAqICAgICBBIFRSIERPTSBFbGVtZW50IGZvciB0aGUgcm93IHN1bW1hcnkuXG4gICAqL1xuICBfdGhpcy5nZXRTaGFrZU1hcFJvdyA9IGZ1bmN0aW9uIChwcm9kdWN0LCBpbmRleCkge1xuICAgIHZhciBwcmVmZXJyZWQsXG4gICAgICAgIHJvdztcblxuICAgIHByZWZlcnJlZCA9IChpbmRleCA9PT0gMCk7XG4gICAgcm93ID0gX3RoaXMuY3JlYXRlUm93KHByZWZlcnJlZCk7XG5cbiAgICByb3cuaW5uZXJIVE1MID0gW1xuICAgICAgJzx0aCBzY29wZT1cInJvd1wiPicsXG4gICAgICAgIF90aGlzLmdldENhdGFsb2dNYXJrdXAoU2hha2VNYXBNb2R1bGUsIHByb2R1Y3QsIHByZWZlcnJlZCksXG4gICAgICAnPC90aD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICBfZm9ybWF0dGVyLmludGVuc2l0eShwcm9kdWN0LmdldFByb3BlcnR5KCdtYXhtbWknKSksXG4gICAgICAnPC90ZD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICBBdHRyaWJ1dGlvbi5nZXRQcm9kdWN0QXR0cmlidXRpb24ocHJvZHVjdCksXG4gICAgICAnPC90ZD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICBwcm9kdWN0LmdldFByb3BlcnR5KCdldmVudC1kZXNjcmlwdGlvbicpIHx8ICcmbmRhc2g7JyxcbiAgICAgICc8L3RkPidcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgcmV0dXJuIHJvdztcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc3VtbWFyeSBjb250ZW50LiBEZWZlcnMgdG8gc3ViLW1ldGhvZHMuXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGR5ZmksXG4gICAgICAgIGZyYWdtZW50LFxuICAgICAgICBoZWFkZXIsXG4gICAgICAgIGxpbmssXG4gICAgICAgIHBhZ2VyLFxuICAgICAgICBzaGFrZW1hcCxcbiAgICAgICAgdGV4dDtcblxuICAgIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgX3RoaXMuY2xlYXJUZXh0cyh0cnVlKTtcbiAgICBfdGhpcy5jbGVhckxpbmtzKHRydWUpO1xuXG4gICAgaGVhZGVyID0gX3RoaXMuZ2V0UHJvZHVjdHMoJ2ltcGFjdC1oZWFkZXInKTtcbiAgICBkeWZpID0gX3RoaXMuZ2V0UHJvZHVjdHMoJ2R5ZmknKTtcbiAgICBzaGFrZW1hcCA9IF90aGlzLmdldFByb2R1Y3RzKCdzaGFrZW1hcCcpO1xuICAgIHBhZ2VyID0gX3RoaXMuZ2V0UHJvZHVjdHMoJ2xvc3NwYWdlcicpO1xuXG4gICAgdGV4dCA9IF90aGlzLmdldFByb2R1Y3RzKCdpbXBhY3QtdGV4dCcpO1xuICAgIGxpbmsgPSBfdGhpcy5nZXRQcm9kdWN0cygnaW1wYWN0LWxpbmsnKTtcblxuICAgIFV0aWwuZW1wdHkoX3RoaXMuaGVhZGVyKTtcbiAgICBfdGhpcy5oZWFkZXIuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0VGV4dHMoaGVhZGVyKSk7XG5cbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChfdGhpcy5nZXREeWZpU3VtbWFyeShkeWZpKSk7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0U2hha2VNYXBTdW1tYXJ5KHNoYWtlbWFwKSk7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0UGFnZXJTdW1tYXJ5KHBhZ2VyKSk7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0VGV4dHModGV4dCkpO1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKF90aGlzLmdldExpbmtzKGxpbmspKTtcblxuICAgIFV0aWwuZW1wdHkoX3RoaXMuY29udGVudCk7XG4gICAgX3RoaXMuY29udGVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cbiAgICBfdGhpcy5mb290ZXIuaW5uZXJIVE1MID0gJyc7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuSW1wYWN0U3VtbWFyeU1vZHVsZS5JRCA9IF9JRDtcbkltcGFjdFN1bW1hcnlNb2R1bGUuVElUTEUgPSBfVElUTEU7XG5JbXBhY3RTdW1tYXJ5TW9kdWxlLlRZUEVTID0gX1RZUEVTO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSW1wYWN0U3VtbWFyeU1vZHVsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgSW1wYWN0U3VtbWFyeU1vZHVsZSA9IHJlcXVpcmUoJ2ltcGFjdC9JbXBhY3RTdW1tYXJ5TW9kdWxlJyksXG4gICAgTW9kdWxlID0gcmVxdWlyZSgnY29yZS9Nb2R1bGUnKSxcbiAgICBQYWdlclZpZXcgPSByZXF1aXJlKCdsb3NzcGFnZXIvUEFHRVJWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfSUQsXG4gICAgX1RJVExFLFxuICAgIF9UWVBFUztcblxuX0lEID0gJ3BhZ2VyJztcbl9USVRMRSA9ICdQQUdFUic7XG5fVFlQRVMgPSBbJ2xvc3NwYWdlciddO1xuXG5cbnZhciBQQUdFUk1vZHVsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfcGFnZXJWaWV3O1xuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIF90aGlzID0gTW9kdWxlKG9wdGlvbnMpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLklEID0gX0lEO1xuICAgIF90aGlzLlRJVExFID0gX1RJVExFO1xuICB9O1xuXG5cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9wYWdlclZpZXcpIHtcbiAgICAgIF9wYWdlclZpZXcuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIF9wYWdlclZpZXcgPSBudWxsO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGRldGFpbHMgZm9yIHRoaXMgbW9kdWxlLiBEZWZlcnMgYnVsayBvZiBoZWFkZXIgSW5mb3JtYXRpb25cbiAgICogdG8gZ2VuZXJhbGl6ZWQgaGVhZGVyIHJlbmRlcmluZy4gVXNlcyB7UEFHRVJWaWV3fSBmb3IgYnVsayBvZiBjb250ZW50XG4gICAqIHJlbmRlcmluZy5cbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG93bmxvYWRzLFxuICAgICAgICBwcm9kdWN0O1xuXG4gICAgX3RoaXMuaGVhZGVyLmlubmVySFRNTCA9ICc8aDM+UEFHRVI8L2gzPic7XG5cbiAgICBwcm9kdWN0ID0gX3RoaXMuZ2V0UHJvZHVjdCgnbG9zc3BhZ2VyJyk7XG4gICAgaWYgKCFwcm9kdWN0KSB7XG4gICAgICBfdGhpcy5jb250ZW50LmlubmVySFRNTCA9XG4gICAgICAgICAgJzxwIGNsYXNzPVwiYWxlcnQgd2FybmluZ1wiPk5vIFBBR0VSIEZvdW5kPC9wPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmhlYWRlci5hcHBlbmRDaGlsZChfdGhpcy5nZXRQcm9kdWN0SGVhZGVyKHtcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgc3VtbWFyeU1vZHVsZTogSW1wYWN0U3VtbWFyeU1vZHVsZVxuICAgICAgfSkpO1xuXG4gICAgICBpZiAoIV9wYWdlclZpZXcpIHtcbiAgICAgICAgX3BhZ2VyVmlldyA9IFBhZ2VyVmlldyh7XG4gICAgICAgICAgZWw6IF90aGlzLmNvbnRlbnQsXG4gICAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF9wYWdlclZpZXcucmVuZGVyKCk7XG5cbiAgICAgIGRvd25sb2FkcyA9IF90aGlzLmdldFByb2R1Y3RGb290ZXIoe3Byb2R1Y3Q6IHByb2R1Y3R9KTtcbiAgICB9XG5cbiAgICBfdGhpcy5mb290ZXIuaW5uZXJIVE1MID1cbiAgICAgICc8aDM+Rm9yIE1vcmUgSW5mb3JtYXRpb248L2gzPicgK1xuICAgICAgJzx1bD4nICtcbiAgICAgICAgJzxsaT4nICtcbiAgICAgICAgICAnPGEgaHJlZj1cIi9kYXRhL3BhZ2VyL1wiPlNjaWVudGlmaWMgQmFja2dyb3VuZCBmb3IgUEFHRVI8L2E+JyArXG4gICAgICAgICc8L2xpPicgK1xuICAgICAgJzwvdWw+JztcblxuICAgIGlmIChkb3dubG9hZHMpIHtcbiAgICAgIF90aGlzLmZvb3Rlci5hcHBlbmRDaGlsZChkb3dubG9hZHMpO1xuICAgIH1cbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKCk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cblBBR0VSTW9kdWxlLklEID0gX0lEO1xuUEFHRVJNb2R1bGUuVElUTEUgPSBfVElUTEU7XG5QQUdFUk1vZHVsZS5UWVBFUyA9IF9UWVBFUztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBBR0VSTW9kdWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBCYXNpY1BpblZpZXcgPSByZXF1aXJlKCdjb3JlL0Jhc2ljUGluVmlldycpLFxuICAgIEZvcm1hdHRlciA9IHJlcXVpcmUoJ2NvcmUvRm9ybWF0dGVyJyksXG4gICAgUEFHRVJNb2R1bGUgPSByZXF1aXJlKCdsb3NzcGFnZXIvUEFHRVJNb2R1bGUnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIG1vZHVsZTogUEFHRVJNb2R1bGVcbn07XG5cblxudmFyIFBBR0VSUGluVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfZm9ybWF0dGVyO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IEJhc2ljUGluVmlldyhvcHRpb25zKTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGhpc3RvZ3JhbXMgYXMgUEFHRVJQaW5WaWV3IGNvbnRlbnRcbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlclBpbkNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVjb25vbWljLFxuICAgICAgICBmYXRhbGl0eSxcbiAgICAgICAgbWFya3VwO1xuXG4gICAgbWFya3VwID0gW107XG4gICAgZWNvbm9taWMgPSBfdGhpcy5tb2RlbC5nZXRDb250ZW50KCdhbGVydGVjb25fc21hbGxlci5wbmcnKTtcbiAgICBmYXRhbGl0eSA9IF90aGlzLm1vZGVsLmdldENvbnRlbnQoJ2FsZXJ0ZmF0YWxfc21hbGxlci5wbmcnKTtcblxuICAgIGlmIChlY29ub21pYykge1xuICAgICAgbWFya3VwLnB1c2goJzxzcGFuPkVzdGltYXRlZCBFY29ub21pYyBMb3NzZXM8L3NwYW4+JyArXG4gICAgICAgICAgJzxpbWcgc3JjPVwiJyArIGVjb25vbWljLmdldCgndXJsJykgKyAnXCIgLz4nKTtcbiAgICB9XG5cbiAgICBpZiAoZmF0YWxpdHkpIHtcbiAgICAgIG1hcmt1cC5wdXNoKCc8c3Bhbj5Fc3RpbWF0ZWQgRmF0YWxpdGllczwvc3Bhbj4nICtcbiAgICAgICAgICAnPGltZyBzcmM9XCInICsgZmF0YWxpdHkuZ2V0KCd1cmwnKSArICdcIiAvPicpO1xuICAgIH1cblxuICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gbWFya3VwLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgaGVhZGVyIGZvciBQQUdFUlBpblZpZXcgd2l0aCBpbXBhY3QgYnViYmxlXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXJQaW5IZWFkZXIgPSBVdGlsLmNvbXBvc2UoX3RoaXMucmVuZGVyUGluSGVhZGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFsZXJ0bGV2ZWw7XG5cbiAgICBhbGVydGxldmVsID0gX3RoaXMubW9kZWwuZ2V0UHJvcGVydHkoJ2FsZXJ0bGV2ZWwnKTtcbiAgICBpZiAoYWxlcnRsZXZlbCkge1xuICAgICAgX3RoaXMuaGVhZGVyLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJyxcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwicGFnZXItYnViYmxlIGJ1YmJsZS1ib3JkZXIgcGFnZXItYWxlcnRsZXZlbC0nICtcbiAgICAgICAgICAgIGFsZXJ0bGV2ZWwgKyAnXCI+JyArXG4gICAgICAgICAgJzxzdHJvbmcgY2xhc3M9XCJyb21hblwiPicgK1xuICAgICAgICAgICAgYWxlcnRsZXZlbC50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAnPC9zdHJvbmc+JyArXG4gICAgICAgICc8L3NwYW4+J1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBBR0VSUGluVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBhZ2VyWG1sUGFyc2VyID0gcmVxdWlyZSgnbG9zc3BhZ2VyL1BhZ2VyWG1sUGFyc2VyJyksXG4gICAgUHJvZHVjdFZpZXcgPSByZXF1aXJlKCdjb3JlL1Byb2R1Y3RWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIFhociA9IHJlcXVpcmUoJ3V0aWwvWGhyJyk7XG5cbnZhciBfREVGQVVMVFM7XG5cbl9ERUZBVUxUUyA9IHtcbiAgZXJyb3JNZXNzYWdlOiAnRXJyb3IgbG9hZGluZyBQQUdFUiB2aWV3J1xufTtcblxudmFyIF9jcmVhdGVIaXN0b2dyYW0gPSBmdW5jdGlvbiAoY29udGFpbmVyLCB0aXRsZSwgcGRmLCBwbmcsIGNhcHRpb24pIHtcbiAgdmFyIGZpZ3VyZSxcbiAgICAgIGZpZ3VyZU1hcmt1cCxcbiAgICAgIGhlYWRlcjtcblxuICBoZWFkZXIgPSBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKSk7XG4gIGhlYWRlci5pbm5lckhUTUwgPSB0aXRsZTtcbiAgZmlndXJlTWFya3VwID0gW107XG5cbiAgaWYgKHBkZiAmJiBwbmcpIHtcbiAgICBmaWd1cmUgPSBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmlndXJlJykpO1xuICAgIGZpZ3VyZU1hcmt1cC5wdXNoKCc8YSBocmVmPVwiJyArIHBkZi5nZXQoJ3VybCcpICsgJ1wiPicpO1xuICAgIGZpZ3VyZU1hcmt1cC5wdXNoKCc8aW1nIHNyYz1cIicgKyBwbmcuZ2V0KCd1cmwnKSArICdcIiBhbHQ9XCJcIi8+Jyk7XG4gICAgZmlndXJlTWFya3VwLnB1c2goJzwvYT4nKTtcbiAgICBpZiAoY2FwdGlvbikge1xuICAgICAgZmlndXJlTWFya3VwLnB1c2goJzxmaWdjYXB0aW9uPicgKyBjYXB0aW9uICsgJzwvZmlnY2FwdGlvbj4nKTtcbiAgICB9XG4gICAgZmlndXJlLmlubmVySFRNTCA9IGZpZ3VyZU1hcmt1cC5qb2luKCcnKTtcbiAgfSBlbHNlIHtcbiAgICBmaWd1cmUgPSBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpKTtcbiAgICBmaWd1cmUuaW5uZXJIVE1MID0gJ0FsZXJ0IGluZm9ybWF0aW9uIHVuYXZhaWxhYmxlJztcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXI7XG59O1xuXG5cbi8qKlxuICogVmlldyBmb3IgbG9zc3BhZ2VyIHByb2R1Y3QuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAqICAgIGFsbCBvcHRpb25zIGFyZSBwYXNzZWQgdG8gUHJvZHVjdFZpZXcuXG4gKi9cbnZhciBQQUdFUlZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2NvbW1lbnRFbCxcbiAgICAgIF9lY29ub21pY0hpc3RvZ3JhbUVsLFxuICAgICAgX2Vycm9yTWVzc2FnZSxcbiAgICAgIF9leHBvc3VyZUNpdHlFbCxcbiAgICAgIF9leHBvc3VyZUNpdHlUYWJsZSxcbiAgICAgIF9leHBvc3VyZUNpdHlUb2dnbGUsXG4gICAgICBfZXhwb3N1cmVNYXBFbCxcbiAgICAgIF9leHBvc3VyZVBvcHVsYXRpb25FbCxcbiAgICAgIF9mYXRhbGl0eUhpc3RvZ3JhbUVsLFxuICAgICAgX3BhZ2VySW5mbyxcbiAgICAgIF9wZW5kaW5nTWVzc2FnZUVsO1xuXG4gIF90aGlzID0gUHJvZHVjdFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zIHx8IHt9KTtcbiAgICBfZXJyb3JNZXNzYWdlID0gb3B0aW9ucy5lcnJvck1lc3NhZ2U7XG4gICAgX3RoaXMuY3JlYXRlU2NhZmZvbGRpbmcoKTtcbiAgfTtcblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgdG8gY3JlYXRlIGV4cG9zdXJlIGl0ZW0gbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0gZXhwb3N1cmUge09iamVjdH1cbiAgICogICAgICBUaGUgZXhwb3N1cmUgbGV2ZWwgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICAgVGhlIG1hcmt1cC5cbiAgICovXG4gIF90aGlzLmNyZWF0ZUV4cG9zdXJlSXRlbSA9IGZ1bmN0aW9uIChleHBvc3VyZSkge1xuICAgIHJldHVybiAnPHRyPicgK1xuICAgICAgJzx0ZCBjbGFzcz1cImV4cG9zdXJlLW1taVwiPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJyb21hbiBtbWkgJyArIGV4cG9zdXJlLmNzcyArICdcIj4nICtcbiAgICAgICAgZXhwb3N1cmUubGFiZWwgKyAnPC9zcGFuPicgK1xuICAgICAgJzwvdGQ+JyArXG4gICAgICAnPHRkIGNsYXNzPVwiZXhwb3N1cmUtcGVyY1wiPicgKyBleHBvc3VyZS5wZXJjICsgJzwvdGQ+JyArXG4gICAgICAnPHRkIGNsYXNzPVwiZXhwb3N1cmUtcG9wdWxhdGlvblwiPicgKyBleHBvc3VyZS5wb3B1bGF0aW9uRGlzcGxheSArXG4gICAgICAgICAgJzwvdGQ+JyArXG4gICAgJzwvdHI+JztcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB1cCBiYXNpYyBsYXlvdXQgb2YgdGhlIFBhZ2VyIHZpZXcgYW5kIGxvYWRzIGV2ZXJ5dGhpbmcgdGhhdCBjYW5cbiAgICogYmUgcHVsbGVkIGZyb20gdGhlIG1vZGVsLlxuICAgKi9cbiAgX3RoaXMuY3JlYXRlU2NhZmZvbGRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnbG9zc3BhZ2VyJyk7XG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID1cbiAgICAgICc8ZGl2IGNsYXNzPVwiYWxlcnQtd3JhcHBlciByb3dcIj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJjb2x1bW4gb25lLW9mLW9uZSBwYWdlci1wZW5kaW5nXCI+PC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiY29sdW1uIG9uZS1vZi10d28gZmF0YWxpdHktaGlzdG9ncmFtXCI+PC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiY29sdW1uIG9uZS1vZi10d28gZWNvbm9taWMtaGlzdG9ncmFtXCI+PC9kaXY+JyArXG4gICAgICAnPC9kaXY+JyArXG4gICAgICAnPGRpdiBjbGFzcz1cInJvdyBwYWdlci1jb250ZW50XCI+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiY29sdW1uIG9uZS1vZi10d29cIj4nICtcbiAgICAgICAgICAnPGgzPkVzdGltYXRlZCBQb3B1bGF0aW9uIEV4cG9zdXJlIHRvIEVhcnRocXVha2UgU2hha2luZzwvaDM+JyArXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJleHBvc3VyZS1tYXBcIj48L2Rpdj4nICtcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImV4cG9zdXJlLXBvcHVsYXRpb25cIj48L2Rpdj4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cImNvbHVtbiBvbmUtb2YtdHdvXCI+JyArXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJjb21tZW50LXdyYXBwZXJcIj48L2Rpdj4nICtcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImV4cG9zdXJlLWNpdHlcIj4nICtcbiAgICAgICAgICAgICc8aDM+U2VsZWN0ZWQgQ2l0aWVzIEV4cG9zZWQ8L2gzPicgK1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJob3Jpem9udGFsLXNjcm9sbGluZ1wiPicgK1xuICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwicGFnZXItY2l0aWVzXCI+PC90YWJsZT4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInBhZ2VyLWRpc2NsYWltZXJcIj4nICtcbiAgICAgICAgICAgICAgJ0Zyb20gR2VvTmFtZXMgRGF0YWJhc2Ugb2YgQ2l0aWVzIHdpdGggMSwwMDAgb3IgbW9yZSAnICtcbiAgICAgICAgICAgICAgJ3Jlc2lkZW50cyAoayA9IHgxLDAwMCknICtcbiAgICAgICAgICAgICc8L3NwYW4+JyArXG4gICAgICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cInRvZ2dsZVwiPlNob3cvSGlkZSBGdWxsIENpdHkgTGlzdDwvYnV0dG9uPicgK1xuICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgJzwvZGl2Pic7XG5cbiAgICBfcGVuZGluZ01lc3NhZ2VFbCA9IF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5wYWdlci1wZW5kaW5nJyk7XG4gICAgX2ZhdGFsaXR5SGlzdG9ncmFtRWwgPSBfdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZmF0YWxpdHktaGlzdG9ncmFtJyk7XG4gICAgX2Vjb25vbWljSGlzdG9ncmFtRWwgPSBfdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZWNvbm9taWMtaGlzdG9ncmFtJyk7XG5cbiAgICBfZXhwb3N1cmVNYXBFbCA9IF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5leHBvc3VyZS1tYXAnKTtcbiAgICBfZXhwb3N1cmVQb3B1bGF0aW9uRWwgPSBfdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZXhwb3N1cmUtcG9wdWxhdGlvbicpO1xuXG4gICAgX2NvbW1lbnRFbCA9IF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5jb21tZW50LXdyYXBwZXInKTtcbiAgICBfZXhwb3N1cmVDaXR5RWwgPSBfdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZXhwb3N1cmUtY2l0eScpO1xuICAgIF9leHBvc3VyZUNpdHlUb2dnbGUgPSBfZXhwb3N1cmVDaXR5RWwucXVlcnlTZWxlY3RvcignLnRvZ2dsZScpO1xuICAgIF9leHBvc3VyZUNpdHlUYWJsZSA9IF9leHBvc3VyZUNpdHlFbC5xdWVyeVNlbGVjdG9yKCcucGFnZXItY2l0aWVzJyk7XG5cbiAgICBfZXhwb3N1cmVDaXR5VG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMub25DaXR5Q2xpY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IGFsbCB0aGUgdGhpbmdzLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgX2NvbW1lbnRFbCA9IG51bGw7XG4gICAgX2Vjb25vbWljSGlzdG9ncmFtRWwgPSBudWxsO1xuICAgIF9lcnJvck1lc3NhZ2UgPSBudWxsO1xuICAgIF9leHBvc3VyZUNpdHlFbCA9IG51bGw7XG4gICAgX2V4cG9zdXJlQ2l0eVRhYmxlID0gbnVsbDtcbiAgICBfZXhwb3N1cmVDaXR5VG9nZ2xlID0gbnVsbDtcbiAgICBfZXhwb3N1cmVNYXBFbCA9IG51bGw7XG4gICAgX2V4cG9zdXJlUG9wdWxhdGlvbkVsID0gbnVsbDtcbiAgICBfZmF0YWxpdHlIaXN0b2dyYW1FbCA9IG51bGw7XG4gICAgX3BhZ2VySW5mbyA9IG51bGw7XG4gICAgX3BlbmRpbmdNZXNzYWdlRWwgPSBudWxsO1xuXG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgZGF0YS5cbiAgICovXG4gIF90aGlzLmZldGNoRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGVudDtcblxuICAgIGNvbnRlbnQgPSBfdGhpcy5tb2RlbC5nZXRDb250ZW50KCdwYWdlci54bWwnKTtcblxuICAgIGlmKCFjb250ZW50KSB7XG4gICAgICBfdGhpcy5vbkVycm9yKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgWGhyLmFqYXgoe1xuICAgICAgdXJsOiBjb250ZW50LmdldCgndXJsJyksXG4gICAgICBzdWNjZXNzOiBfdGhpcy5vblN1Y2Nlc3MsXG4gICAgICBlcnJvcjogX3RoaXMub25FcnJvclxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVc2VzIGNvcnJlY3QgY29tbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBjb21tZW50VHlwZSB7U3RyaW5nfTtcbiAgICogICAgU3RyaW5nIGNhbiBiZSBmYXRhbGl0eSBvciBlY29ub21pYy5cbiAgICovXG4gIF90aGlzLmdldEFsZXJ0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50VHlwZSkge1xuICAgIHZhciBjb21tZW50cyxcbiAgICAgICAgZWNvbm9taWNDb21tZW50LFxuICAgICAgICBmYXRhbGl0eUNvbW1lbnQ7XG5cbiAgICBpZiAoX3BhZ2VySW5mbyAmJiBfcGFnZXJJbmZvLmNvbW1lbnRzKSB7XG4gICAgICBjb21tZW50cyA9IF9wYWdlckluZm8uY29tbWVudHMuaW1wYWN0O1xuICAgIH1cblxuICAgIGlmICghY29tbWVudHMpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAoY29tbWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAoY29tbWVudHNbMF0gIT09ICcnKSB7XG4gICAgICAgIGZhdGFsaXR5Q29tbWVudCA9IGNvbW1lbnRzWzBdO1xuICAgICAgICBlY29ub21pY0NvbW1lbnQgPSBjb21tZW50c1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhdGFsaXR5Q29tbWVudCA9IGNvbW1lbnRzWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmYXRhbGl0eUNvbW1lbnQgPSBjb21tZW50c1swXTtcbiAgICB9XG5cbiAgICBpZiAoY29tbWVudFR5cGUgPT09ICdmYXRhbGl0eScpIHtcbiAgICAgIHJldHVybiBmYXRhbGl0eUNvbW1lbnQ7XG4gICAgfSBlbHNlIGlmIChjb21tZW50VHlwZSA9PT0gJ2Vjb25vbWljJykge1xuICAgICAgcmV0dXJuIGVjb25vbWljQ29tbWVudDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGNsaWNrIGV2ZW50cyBvbiBjaXR5IGxpc3QgdG9nZ2xlIGNvbnRyb2wuXG4gICAqL1xuICBfdGhpcy5vbkNpdHlDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBfZXhwb3N1cmVDaXR5VGFibGUuY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdy1hZGRpdGlvbmFsJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIGEgcHJvYmxlbS5cbiAgICpcbiAgICogQHBhcmFtIGVycm9yTWVzc2FnZSB7U3RyaW5nfVxuICAgKiAgICBBIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvciB0aGF0IG9jY3VycmVkLlxuICAgKi9cbiAgX3RoaXMub25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSBfZXJyb3JNZXNzYWdlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiBYaHIgaXMgc3VjY2Vzc2Z1bCBhbmQgY2FsbGVzIGFsbCBtZXRob2RzXG4gICAqIHRoYXQgcmVuZGVyIFBBR0VSIGNvbnRlbnQuXG4gICAqL1xuICBfdGhpcy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSwgeGhyKSB7XG4gICAgdmFyIHhtbDtcblxuICAgIHhtbCA9ICgoeGhyICYmIHhoci5yZXNwb25zZVhNTCkgPyB4aHIucmVzcG9uc2VYTUwgOiBkYXRhKTtcblxuICAgIF9wYWdlckluZm8gPSBQYWdlclhtbFBhcnNlci5wYXJzZSh4bWwpO1xuXG4gICAgX3RoaXMucmVuZGVyRmF0YWxpdHlIaXN0b2dyYW0oKTtcbiAgICBfdGhpcy5yZW5kZXJFY29ub21pY0hpc3RvZ3JhbSgpO1xuICAgIF90aGlzLnJlbmRlckV4cG9zdXJlcygpO1xuICAgIF90aGlzLnJlbmRlckNpdGllcygpO1xuICAgIF90aGlzLnJlbmRlckNvbW1lbnRzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBtb2RlbCBjaGFuZ2VzLiBJbml0aWFsbHkgc2V0cyBhIGxvYWRpbmcgbWVzc2FnZVxuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLnJlbmRlclBlbmRpbmcoKTtcblxuICAgIF90aGlzLnJlbmRlckV4cG9zdXJlTWFwKCk7XG4gICAgX3RoaXMuZmV0Y2hEYXRhKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIG5lYXJieSBjaXRpZXMgbGlzdCB0byB0aGUgcGFnZS4gQ2l0aWVzIGhhdmUgYSB2ZXJ5IHNwZWNpYWwgc29ydGluZ1xuICAgKiBhbGdvcml0aG0uIFRoZSBmaXJzdCAxMSBjaXRpZXMgYXJlIGRpc3BsYXllZCBieSBkZWZhdWx0IGFuZCBhIGNvbnRyb2wgaXNcbiAgICogdXNlZCB0byBzaG93L2hpZGUgYWRkaXRpb25hbCBjaXRpZXMuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJDaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNpdGllcyxcbiAgICAgICAgY2l0eSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuLFxuICAgICAgICBtYXJrdXA7XG5cbiAgICBtYXJrdXAgPSBbXTtcbiAgICBjaXRpZXMgPSBfcGFnZXJJbmZvLmNpdGllcztcbiAgICBsZW4gPSBjaXRpZXMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA8PSAxMSkge1xuICAgICAgX2V4cG9zdXJlQ2l0eUVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8dGhlYWQ+JyArXG4gICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICc8dGg+PGFiYnIgdGl0bGU9XCJNb2RpZmllZCBNZXJjYWxsaSBJbnRlbnNpdHlcIj5NTUk8L2FiYnI+PC90aD4nICtcbiAgICAgICAgICAgICc8dGg+Q2l0eTwvdGg+JyArXG4gICAgICAgICAgICAnPHRoPjxhYmJyIHRpdGxlPVwiUG9wdWxhdGlvblwiPlBvcC48L2FiYnI+PC90aD4nICtcbiAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgJzwvdGhlYWQ+J1xuICAgICk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNpdHkgPSBjaXRpZXNbaV07XG5cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPHRyIGNsYXNzPVwiJyArICgoaT4xMCk/J2NpdHktYWRkaXRpb25hbCc6JycpICsnXCI+JyArXG4gICAgICAgICAgJzx0ZCBjbGFzcz1cImNpdGllcy1tbWlcIj4nICtcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInJvbWFuIG1taSAnICsgY2l0eS5jc3MgKyAnXCI+JyArXG4gICAgICAgICAgICAgIGNpdHkucm9tYW4gK1xuICAgICAgICAgICAgJzwvc3Bhbj4nICtcbiAgICAgICAgICAnPC90ZD4nICtcbiAgICAgICAgICAnPHRkPicgKyBjaXR5Lm5hbWUgKyAnPC90ZD4nICtcbiAgICAgICAgICAnPHRkIGNsYXNzPVwiY2l0aWVzLXBvcHVsYXRpb25cIj4nICsgY2l0eS5wb3B1bGF0aW9uRGlzcGxheSArICc8L3RkPicgK1xuICAgICAgICAnPC90cj4nXG4gICAgICApO1xuICAgIH1cblxuICAgIG1hcmt1cC5wdXNoKFxuICAgICAgJzwvdGJvZHk+J1xuICAgICk7XG5cbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBfZXhwb3N1cmVDaXR5RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfZXhwb3N1cmVDaXR5RWwpO1xuICAgICAgX2V4cG9zdXJlQ2l0eUVsID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2V4cG9zdXJlQ2l0eVRhYmxlLmlubmVySFRNTCA9IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHN0cnVjdHVyZSBjb21tZW50IGFuZCBzZWNvbmRhcnkgZWZmZWN0cyBjb21tZW50cyB0byB0aGUgcGFnZS5cbiAgICovXG4gIF90aGlzLnJlbmRlckNvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb21tZW50cyA9IF9wYWdlckluZm8uY29tbWVudHMsXG4gICAgICAgIG1hcmt1cCA9IFtdO1xuXG4gICAgaWYgKGNvbW1lbnRzLmhhc093blByb3BlcnR5KCdzdHJ1Y3R1cmUnKSkge1xuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8ZGl2IGNsYXNzPVwid3JhcHBlclwiPicgK1xuICAgICAgICAgICc8aDM+U3RydWN0dXJlIEluZm9ybWF0aW9uIFN1bW1hcnk8L2gzPicgK1xuICAgICAgICAgICc8cD4nICsgY29tbWVudHMuc3RydWN0dXJlICsgJzwvcD4nICtcbiAgICAgICAgJzwvZGl2PidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1lbnRzLmhhc093blByb3BlcnR5KCdlZmZlY3RzJykpIHtcbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGRpdiBjbGFzcz1cIndyYXBwZXJcIj4nICtcbiAgICAgICAgICAnPGgzPlNlY29uZGFyeSBFZmZlY3RzPC9oMz4nICtcbiAgICAgICAgICAnPHA+JyArIGNvbW1lbnRzLmVmZmVjdHMgKyAnPC9wPicgK1xuICAgICAgICAnPC9kaXY+J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAobWFya3VwLmxlbmd0aCkge1xuICAgICAgX2NvbW1lbnRFbC5pbm5lckhUTUwgPSBtYXJrdXAuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIGNvbW1lbnRzLCByZW1vdmUgdGhpcyBzZWN0aW9uXG4gICAgICBfY29tbWVudEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX2NvbW1lbnRFbCk7XG4gICAgICBfY29tbWVudEVsID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbmRzIF9jcmVhdGVIaXN0b2dyYW0gdGhlIHBhcmFtcyBuZWVkZWQgdG8gcmVuZGVyIGVjb25vbWljXG4gICAqIGhpc3RvZ3JhbS5cbiAgICovXG4gIF90aGlzLnJlbmRlckVjb25vbWljSGlzdG9ncmFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFsZXJ0TGV2ZWwsXG4gICAgICAgICAgY29tbWVudCxcbiAgICAgICAgICBwZGYsXG4gICAgICAgICAgcG5nO1xuXG4gICAgICBhbGVydExldmVsID0gX3RoaXMubW9kZWwuZ2V0UHJvcGVydHkoJ2FsZXJ0bGV2ZWwnKTtcbiAgICAgIGNvbW1lbnQgPSBfdGhpcy5nZXRBbGVydENvbW1lbnQoJ2Vjb25vbWljJyk7XG4gICAgICBwbmcgPSBfdGhpcy5tb2RlbC5nZXRDb250ZW50KCdhbGVydGVjb25fc21hbGwucG5nJykgfHxcbiAgICAgICAgICBfdGhpcy5tb2RlbC5nZXRDb250ZW50KCdhbGVydGVjb24ucG5nJyk7XG4gICAgICBwZGYgPSBfdGhpcy5tb2RlbC5nZXRDb250ZW50KCdhbGVydGVjb24ucGRmJyk7XG5cbiAgICAgIGlmIChhbGVydExldmVsICE9PSAncGVuZGluZycpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVIaXN0b2dyYW0oX2Vjb25vbWljSGlzdG9ncmFtRWwsICdFc3RpbWF0ZWQgRWNvbm9taWMgTG9zc2VzJyxcbiAgICAgICAgICBwZGYsIHBuZywgY29tbWVudCk7XG4gICAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBleHBvc3VyZSBtYXAuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJFeHBvc3VyZU1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGVudDtcblxuICAgIGNvbnRlbnQgPSBfdGhpcy5tb2RlbC5nZXRDb250ZW50KCdleHBvc3VyZS5wbmcnKTtcblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBfZXhwb3N1cmVNYXBFbC5pbm5lckhUTUwgPSBbXG4gICAgICAgICc8ZmlndXJlPicsXG4gICAgICAgICAgJzxpbWcgc3JjPVwiJywgY29udGVudC5nZXQoJ3VybCcpLCAnXCIgYWx0PVwiUG9wdWxhdGlvbiBFeHBvc3VyZSBNYXBcIi8+JyxcbiAgICAgICAgICAnPGZpZ2NhcHRpb24+JyxcbiAgICAgICAgICAgICdQb3B1bGF0aW9uIHBlciB+MSBzcS4ga20uIGZyb20gTGFuZFNjYW4nLFxuICAgICAgICAgICc8L2ZpZ2NhcHRpb24+JyxcbiAgICAgICAgJzwvZmlndXJlPidcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9leHBvc3VyZU1hcEVsLmlubmVySFRNTCA9ICcmbmRhc2g7JztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgZXhwb3N1cmUgdGFibGUgaW5mbyB0byBQQUdFUiB2aWV3LlxuICAgKi9cbiAgX3RoaXMucmVuZGVyRXhwb3N1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHBvc3VyZSxcbiAgICAgICAgZXhwb3N1cmVzLFxuICAgICAgICBpLFxuICAgICAgICBsZW4sXG4gICAgICAgIG1hcmt1cDtcblxuICAgIG1hcmt1cCA9IFtdO1xuICAgIGV4cG9zdXJlcyA9IF9wYWdlckluZm8uZXhwb3N1cmVzO1xuICAgIGxlbiA9IGV4cG9zdXJlcy5sZW5ndGg7XG5cbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBfZXhwb3N1cmVQb3B1bGF0aW9uRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfZXhwb3N1cmVQb3B1bGF0aW9uRWwpO1xuICAgICAgX2V4cG9zdXJlUG9wdWxhdGlvbkVsID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtYXJrdXAucHVzaChcbiAgICAgICc8ZGl2IGNsYXNzPVwiaG9yaXpvbnRhbC1zY3JvbGxpbmdcIj4nICtcbiAgICAgICc8dGFibGUgY2xhc3M9XCJwYWdlci1leHBvc3VyZXNcIj4nICtcbiAgICAgICAgJzx0aGVhZD4nICtcbiAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgJzx0aD48YWJiciB0aXRsZT1cIk1vZGlmaWVkIE1lcmNhbGxpIEludGVuc2l0eVwiPk1NSTwvYWJicj48L3RoPicgK1xuICAgICAgICAgICAgJzx0aD48YWJiciB0aXRsZT1cIlBlcmNlaXZlZCBTaGFraW5nXCI+U2hha2luZzwvYWJicj48L3RoPicgK1xuICAgICAgICAgICAgJzx0aD48YWJiciB0aXRsZT1cIlBvcHVsYXRpb24gRXhwb3N1cmVcIj5Qb3AuPC9hYmJyPjwvdGg+JyArXG4gICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICc8L3RoZWFkPicgK1xuICAgICAgICAnPHRib2R5PidcbiAgICAgICk7XG5cbiAgICAvLyBnZW5lcmF0ZSB0YWJsZSByb3cgY29udGVudFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZXhwb3N1cmUgPSBleHBvc3VyZXNbaV07XG4gICAgICBtYXJrdXAucHVzaChfdGhpcy5jcmVhdGVFeHBvc3VyZUl0ZW0oZXhwb3N1cmUpKTtcbiAgICB9XG5cbiAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzwvdGJvZHk+JyArXG4gICAgICAnPC90YWJsZT4nICtcbiAgICAgICc8L2Rpdj4nICtcbiAgICAgICc8c3BhbiBjbGFzcz1cInBhZ2VyLWRpc2NsYWltZXJcIj4nICtcbiAgICAgICAgJypFc3RpbWF0ZWQgZXhwb3N1cmUgb25seSBpbmNsdWRlcyBwb3B1bGF0aW9uIHdpdGhpbiAnICtcbiAgICAgICAgJ21hcCBhcmVhIChrID0geDEsMDAwKScgK1xuICAgICAgICAnPC9icj48YSBocmVmPVwiaHR0cHM6Ly9lYXJ0aHF1YWtlLnVzZ3MuZ292L3Jlc2VhcmNoL3NoYWtlbWFwLyNpbnRtYXBzXCI+JytcbiAgICAgICAgJ01vZGlmaWVkIE1lcmNhbGxpIEludGVuc2l0eSAoTU1JKSBzY2FsZTwvYT4nICtcbiAgICAgICc8L3NwYW4+J1xuICAgICk7XG5cbiAgICBfZXhwb3N1cmVQb3B1bGF0aW9uRWwuaW5uZXJIVE1MID0gbWFya3VwLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kcyBfY3JlYXRlSGlzdG9ncmFtIHRoZSBwYXJhbXMgbmVlZGVkIHRvIHJlbmRlciBmYXRhbGl0eVxuICAgKiBoaXN0b2dyYW0uXG4gICAqL1xuICBfdGhpcy5yZW5kZXJGYXRhbGl0eUhpc3RvZ3JhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhbGVydExldmVsLFxuICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgcGRmLFxuICAgICAgICAgIHBuZztcblxuICAgICAgYWxlcnRMZXZlbCA9IF90aGlzLm1vZGVsLmdldFByb3BlcnR5KCdhbGVydGxldmVsJyk7XG4gICAgICBjb21tZW50ID0gX3RoaXMuZ2V0QWxlcnRDb21tZW50KCdmYXRhbGl0eScpO1xuICAgICAgcG5nID0gX3RoaXMubW9kZWwuZ2V0Q29udGVudCgnYWxlcnRmYXRhbF9zbWFsbC5wbmcnKSB8fFxuICAgICAgICAgIF90aGlzLm1vZGVsLmdldENvbnRlbnQoJ2FsZXJ0ZmF0YWwucG5nJyk7XG4gICAgICBwZGYgPSBfdGhpcy5tb2RlbC5nZXRDb250ZW50KCdhbGVydGZhdGFsLnBkZicpO1xuXG4gICAgICBpZiAoYWxlcnRMZXZlbCAhPT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgIHJldHVybiBfY3JlYXRlSGlzdG9ncmFtKF9mYXRhbGl0eUhpc3RvZ3JhbUVsLCAnRXN0aW1hdGVkIEZhdGFsaXRpZXMnLFxuICAgICAgICAgICAgcGRmLCBwbmcsIGNvbW1lbnQpO1xuICAgICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIHBlbmRpbmcgbWFya3VwIGlmIGFsZXJ0TGV2ZWwgaXMgZXF1YWwgdG8gcGVuZGluZy5cbiAgICovXG4gIF90aGlzLnJlbmRlclBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFsZXJ0TGV2ZWw7XG5cbiAgICBhbGVydExldmVsID0gX3RoaXMubW9kZWwuZ2V0UHJvcGVydHkoJ2FsZXJ0bGV2ZWwnKTtcblxuICAgIGlmIChhbGVydExldmVsID09PSAncGVuZGluZycpIHtcbiAgICAgIF9wZW5kaW5nTWVzc2FnZUVsLmlubmVySFRNTCA9IFtcbiAgICAgICAgJzxwIGNsYXNzPVwiaW5mbyBhbGVydFwiPicsXG4gICAgICAgICAgJ0FsZXJ0IGluZm9ybWF0aW9uIGZvciB0aGlzIGV2ZW50IGlzIGN1cnJlbnRseSB1bmRlciByZXZpZXcgYW5kICcsXG4gICAgICAgICAgJ3dpbGwgYmUgYXZhaWxhYmxlIHNvb24uIFRoYW5rIHlvdSBmb3IgeW91ciBwYXRpZW5jZS4nLFxuICAgICAgICAnPC9wPidcbiAgICAgIF0uam9pbignJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYWdlckluZm8gdG8gYmUgcmVuZGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSBwYWdlckluZm8ge09iamVjdH1cbiAgICogICAgIFRoZSBQQUdFUiBpbmZvIHRvIHVzZSBmb3IgcmVuZGVyaW5nLlxuICAgKi9cbiAgX3RoaXMuc2V0UGFnZXJJbmZvID0gZnVuY3Rpb24gKHBhZ2VySW5mbykge1xuICAgIF9wYWdlckluZm8gPSBwYWdlckluZm87XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUEFHRVJWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBYTUxfVkVSU0lPTl9TVFJJTkcgPSAnMS4wJzsgLy8gcGFnZXIueG1sIHZlcnNpb24gbnVtYmVyXG5cbi8vIE1ldGEgaW5mbyBhYm91dCB0aGUgZXhwb3N1cmUgbGV2ZWxzXG52YXIgRVhQT1NVUkVfSU5GTyA9IFtcbiAgLy8gTU1JLTAgZG9lc24ndCBleGlzdCwgYnV0IGFycmF5cyBhcmUgemVyby1pbmRleGVkLCB0aGlzIGlzIGEgcGxhY2Vob2xkZXJcbiAge3BlcmM6J05vdCBGZWx0JyxyZXNpc3Q6J25vbmUnLHZ1bG46J25vbmUnLHJvbWFuOidJJyxsYWJlbDonSScsY3NzOidtbWlJJ30sXG4gIHtwZXJjOidOb3QgRmVsdCcscmVzaXN0Oidub25lJyx2dWxuOidub25lJyxyb21hbjonSScsbGFiZWw6J0knLGNzczonbW1pSSd9LFxuXG4gIC8vIE1NSS1JSSBhbmQgTU1JLUlJSSBhcmUgY29tYmluZWQsIG5lZWQgc2VwYXJhdGUgcGxhY2Vob2xkZXJzXG4gIHtwZXJjOidXZWFrJyxyZXNpc3Q6J25vbmUnLHZ1bG46J25vbmUnLHJvbWFuOidJSScsbGFiZWw6J0lJLUlJSScsXG4gICAgICBjc3M6J21taUlJJ30sXG4gIHtwZXJjOidXZWFrJyxyZXNpc3Q6J25vbmUnLHZ1bG46J25vbmUnLHJvbWFuOidJSUknLGxhYmVsOidJSS1JSUknLFxuICAgICAgY3NzOidtbWlJSUknfSxcblxuICB7cGVyYzonTGlnaHQnLHJlc2lzdDonbm9uZScsdnVsbjonbm9uZScscm9tYW46J0lWJyxsYWJlbDonSVYnLGNzczonbW1pSVYnfSxcbiAge3BlcmM6J01vZGVyYXRlJyxyZXNpc3Q6J1ZlcnkgTGlnaHQnLHZ1bG46J0xpZ2h0Jyxyb21hbjonVicsbGFiZWw6J1YnLFxuICAgICAgY3NzOidtbWlWJ30sXG4gIHtwZXJjOidTdHJvbmcnLHJlc2lzdDonTGlnaHQnLHZ1bG46J01vZGVyYXRlJyxyb21hbjonVkknLGxhYmVsOidWSScsXG4gICAgICBjc3M6J21taVZJJ30sXG4gIHtwZXJjOidWZXJ5IFN0cm9uZycscmVzaXN0OidNb2RlcmF0ZScsdnVsbjonTW9kZXJhdGUvSGVhdnknLHJvbWFuOidWSUknLFxuICAgICAgbGFiZWw6J1ZJSScsY3NzOidtbWlWSUknfSxcbiAge3BlcmM6J1NldmVyZScscmVzaXN0OidNb2RlcmF0ZS9IZWF2eScsdnVsbjonSGVhdnknLHJvbWFuOidWSUlJJyxcbiAgICAgIGxhYmVsOidWSUlJJyxjc3M6J21taVZJSUknfSxcbiAge3BlcmM6J1Zpb2xlbnQnLHJlc2lzdDonSGVhdnknLHZ1bG46J1ZlcnkgSGVhdnknLHJvbWFuOidJWCcsbGFiZWw6J0lYJyxcbiAgICAgIGNzczonbW1pSVgnfSxcbiAge3BlcmM6J0V4dHJlbWUnLHJlc2lzdDonVmVyeSBIZWF2eScsdnVsbjonVmVyeSBIZWF2eScscm9tYW46J1gnLGxhYmVsOidYJyxcbiAgICAgIGNzczonbW1pWCd9LFxuICB7cGVyYzonRXh0cmVtZScscmVzaXN0OidWZXJ5IEhlYXZ5Jyx2dWxuOidWZXJ5IEhlYXZ5Jyxyb21hbjonWEknLGxhYmVsOidYSScsXG4gICAgICBjc3M6J21taVgnfSxcbiAge3BlcmM6J0V4dHJlbWUnLHJlc2lzdDonVmVyeSBIZWF2eScsdnVsbjonVmVyeSBIZWF2eScscm9tYW46J1hJSScsXG4gICAgICBsYWJlbDonWElJJyxjc3M6J21taVgnfVxuXTtcblxuXG4vKipcbiAqIFNvcnRzIHRoZSBjaXRpZXMgc28gdGhlIGZpcnN0IDExIGluIHRoZSBsaXN0IG9mIHRoZSBcInNlbGVjdGVkXCIgY2l0aWVzIGFuZFxuICogdGhlIHJlbWFpbmRlciBvZiB0aGUgbGlzdCBpcyBzb3J0ZWQgYnkgTU1JIChkZWNyZWFzaW5nKS5cbiAqXG4gKiBAcGFyYW0gY2l0aWVzIHtBcnJheX1cbiAqICAgICAgQW4gYXJyYXkgb2YgY2l0eSBpbmZvcm1hdGlvbiB0byBzb3J0LiBUaGlzIGFycmF5IGlzIG1vZGlmaWVkIGluLXBsYWNlLFxuICogICAgICBzbyBjYWxsZXJzIG9mIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYXJlZnVsIHRvIHBhc3MgaW4gYSBjb3B5XG4gKiAgICAgIChBcnJheS5zbGljZSkgb2YgdGhlIGFycmF5IGlmIHRoZXkgbmVlZCB0aGUgb3JpZ2luYWwgdG8gcmVtYWluXG4gKiAgICAgIHVuY2hhbmdlZC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgQSBzcGVjaWFsbHktc29ydGVkIGFycmF5IG9mIGNpdHkgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfc29ydENpdGllcyA9IGZ1bmN0aW9uIChjaXRpZXMpIHtcbiAgdmFyIHNvcnRlZENpdGllcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVNbWkgKGEsIGIpIHtcbiAgICByZXR1cm4gYi5tbWkgLSBhLm1taTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVQb3B1bGF0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIucG9wdWxhdGlvbiAtIGEucG9wdWxhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVDYXBpdGFsIChhLCBiKSB7XG4gICAgdmFyIGFjYXAgPSBhLmlzQ2FwaXRhbCxcbiAgICAgICAgYmNhcCA9IGIuaXNDYXBpdGFsO1xuXG4gICAgaWYgKChhY2FwICYmIGJjYXApIHx8ICghYWNhcCAmJiAhYmNhcCkpIHtcbiAgICAgIHJldHVybiBjb21wYXJlUG9wdWxhdGlvbihhLCBiKTtcbiAgICB9IGVsc2UgaWYgKGFjYXApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGJjYXApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wYXJlUG9wdWxhdGlvbihhLCBiKTtcbiAgfVxuXG4gIC8vIFNvcnQgYnkgbGFyZ2VzdCBNTUkgZmlyc3RcbiAgY2l0aWVzLnNvcnQoY29tcGFyZU1taSk7XG4gIC8vIFRha2UgdXAgdG8gZmlyc3QgNi1sYXJnZXN0IE1NSVxuICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShzb3J0ZWRDaXRpZXMsIGNpdGllcy5zcGxpY2UoMCwgNikpO1xuXG4gIC8vIFNvcnQgYnkgY2FwaXRhbC9wb3B1bGF0aW9uXG4gIGNpdGllcy5zb3J0KGNvbXBhcmVDYXBpdGFsKTtcbiAgLy8gVGFrZSB1cCB0byBmaXJzdCA1LWNhcGl0YWxzXG4gIHdoaWxlIChjaXRpZXMubGVuZ3RoICYmIGNpdGllc1swXS5pc0NhcGl0YWwgJiYgc29ydGVkQ2l0aWVzLmxlbmd0aCA8IDExKSB7XG4gICAgc29ydGVkQ2l0aWVzLnB1c2goY2l0aWVzLnNwbGljZSgwLCAxKVswXSk7XG4gIH1cblxuICAvLyBTb3J0IGJ5IHBvcHVsYXRpb25cbiAgY2l0aWVzLnNvcnQoY29tcGFyZVBvcHVsYXRpb24pO1xuICAvLyBGaWxsIGluIGFueSByZW1haW5pbmcgc2VsZWN0aW9ucyBiYXNlZCBvbiBwb3B1bGF0aW9uXG4gIHdoaWxlIChjaXRpZXMubGVuZ3RoICYmIHNvcnRlZENpdGllcy5sZW5ndGggPCAxMSkge1xuICAgIHNvcnRlZENpdGllcy5wdXNoKGNpdGllcy5zcGxpY2UoMCwgMSlbMF0pO1xuICB9XG5cbiAgLy8gU29ydCBlYWNoIHBhcnQgYnkgTU1JIGFuZCBjb21iaW5lIHRvIGEgc2luZ2xlIGxpc3RcbiAgcmV0dXJuIHNvcnRlZENpdGllcy5zb3J0KGNvbXBhcmVNbWkpLmNvbmNhdChjaXRpZXMuc29ydChjb21wYXJlTW1pKSk7XG59O1xuXG4vKipcbiAqIEluamVjdHMgdGhvdXNhbmRzIG51bWJlciBzZXBhcmF0b3IgYmV0d2VlbiBlYWNoIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIG51bWJlciB7SW50ZWdlcn1cbiAqICAgICAgVGhlIG51bWJlciB0byBmb3JtYXQuXG4gKiBAcGFyYW0gc2VwYXJhdG9yIHtTdHJpbmd9IE9wdGlvbmFsLlxuICogICAgICBUaGUgc3RyaW5nIHRvIHVzZSBhcyBhIHRob3VzYW5kcyBzZXBhcmF0b3IuIERlZmF1bHQgJywnLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqICAgICAgVGhlIG51bWJlciB3aXRoIHRob3VzYW5kcyBzZWdtZW50cyBzZXBhcmF0b3IgYnkgc2VwYXJhdG9yLlxuICovXG52YXIgX2luamVjdE51bWJlclNlcGFyYXRvciA9IGZ1bmN0aW9uIChudW1iZXIsIHNlcGFyYXRvcikge1xuICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJywnO1xuICByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgc2VwYXJhdG9yKTtcbn07XG5cbi8qKlxuICogRm9ybWF0IHRoZSBwb3B1bGF0aW9uIGZvciB0aGUgY2l0eSBsaXN0IGRpc3BsYXkuXG4gKlxuICogQHBhcmFtIHBvcHVsYXRpb24ge0ludGVnZXJ9XG4gKiAgICAgIFRoZSBwb3B1bGF0aW9uIHZhbHVlIHRvIGZvcm1hdC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiAgICAgIEEgZm9ybWF0dGVkIGRpc3BsYXkgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBwb3B1bGF0aW9uLlxuICovXG52YXIgX2Zvcm1hdENpdHlQb3B1bGF0aW9uID0gZnVuY3Rpb24gKHBvcHVsYXRpb24pIHtcbiAgaWYgKHBvcHVsYXRpb24gPCAxMDAwKSB7XG4gICAgcmV0dXJuICcmbHQ7MSBrJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gX2luamVjdE51bWJlclNlcGFyYXRvcihNYXRoLnJvdW5kKHBvcHVsYXRpb24gLyAxMDAwKSkgKyAnIGsnO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcm1hdCBwb3B1bGF0aW9uIGZvciB0aGUgZXhwb3N1cmUgdGFibGUgZGlzcGxheS5cbiAqXG4gKiBAcGFyYW0gcG9wdWxhdGlvbiB7SW50ZWdlcn1cbiAqICAgICAgVGhlIHBvcHVsYXRpb24gdmFsdWUgdG8gZm9ybWF0LlxuICogQHBhcmFtIGluY29tcGxldGUge0Jvb2xlYW59IE9wdGlvbmFsLiBEZWZhdWx0OiBmYWxzZVxuICogICAgICBUcnVlIGlmIHRoZSBleHBvc3VyZSBjb250b3VyIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBwb3B1bGF0aW9uIHZhbHVlXG4gKiAgICAgIGV4dGVuZHMgYmV5b25kIHRoZSBtYXBwZWQgYm91bmRhcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiAgICAgIEEgZm9ybWF0ZWQgZGlzcGxheSB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHBvcHVsYXRpb24uXG4gKi9cbnZhciBfZm9ybWF0RXhwb3N1cmVQb3B1bGF0aW9uID0gZnVuY3Rpb24gKHBvcHVsYXRpb24sIGluY29tcGxldGUpIHtcbiAgdmFyIGRpc3BsYXkgPSBfaW5qZWN0TnVtYmVyU2VwYXJhdG9yKE1hdGgucm91bmQocG9wdWxhdGlvbiAvIDEwMDApKSArICcgayc7XG5cbiAgaWYgKGluY29tcGxldGUpIHtcbiAgICBpZiAocG9wdWxhdGlvbiA9PT0gMCkge1xuICAgICAgICBkaXNwbGF5ID0gJy0tJztcbiAgICB9XG5cbiAgICBkaXNwbGF5ICs9ICcqJztcbiAgfVxuXG4gIHJldHVybiBkaXNwbGF5O1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQYXJzaW5nIGZ1bmN0aW9ucyBmb3IgZWFjaCBjb21wb25lbnQgcGllY2Ugb2YgZGF0YVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEBwYXJhbSB4bWwge0RvY3VtZW50fVxuICogICAgICBUaGUgWE1MIGRvY3VtZW50IGZyb20gd2hpY2ggdG8gcGFyc2UgYWxlcnQgaW5mb3JtYXRpb24uXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICBBbiBvYmplY3Qgb2YgcGFyc2VkIGFsZXJ0IGluZm9ybWF0aW9uLiBLZXllZCBieSBhbGVydCB0eXBlLlxuICovXG52YXIgX3BhcnNlQWxlcnRzID0gZnVuY3Rpb24gKHhtbCkge1xuICB2YXIgYWxlcnQsXG4gICAgICB0eXBlLFxuICAgICAgYmlucyxcbiAgICAgIGJpbkl0ZXIsXG4gICAgICBudW1CaW5zLFxuICAgICAgYmluLFxuICAgICAgYWxlcnRzID0geG1sLnF1ZXJ5U2VsZWN0b3JBbGwoJ3BhZ2VyID4gYWxlcnRzID4gYWxlcnQnKSxcbiAgICAgIGFsZXJ0SXRlciA9IDAsXG4gICAgICBudW1BbGVydHMgPSBhbGVydHMubGVuZ3RoLFxuICAgICAgZGF0YSA9IHt9O1xuXG4gIGZvciAoOyBhbGVydEl0ZXIgPCBudW1BbGVydHM7IGFsZXJ0SXRlcisrKSB7XG4gICAgYWxlcnQgPSBhbGVydHNbYWxlcnRJdGVyXTtcbiAgICB0eXBlID0gYWxlcnQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cbiAgICBkYXRhW2FsZXJ0LmdldEF0dHJpYnV0ZSgndHlwZScpXSA9IHtcbiAgICAgIGxldmVsOiBhbGVydC5nZXRBdHRyaWJ1dGUoJ2xldmVsJyksXG4gICAgICB1bml0czogYWxlcnQuZ2V0QXR0cmlidXRlKCd1bml0cycpLFxuICAgICAgYmluczogW11cbiAgICB9O1xuXG4gICAgYmlucyA9IGFsZXJ0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2JpbicpO1xuICAgIGZvciAoYmluSXRlciA9IDAsIG51bUJpbnMgPSBiaW5zLmxlbmd0aDsgYmluSXRlciA8IG51bUJpbnM7IGJpbkl0ZXIrKykge1xuICAgICAgYmluID0gYmluc1tiaW5JdGVyXTtcblxuICAgICAgZGF0YVt0eXBlXS5iaW5zLnB1c2goe1xuICAgICAgICBtaW46IGJpbi5nZXRBdHRyaWJ1dGUoJ21pbicpLFxuICAgICAgICBtYXg6IGJpbi5nZXRBdHRyaWJ1dGUoJ21heCcpLFxuICAgICAgICBwcm9iOiBiaW4uZ2V0QXR0cmlidXRlKCdwcm9iYWJpbGl0eScpLFxuICAgICAgICBjb2xvcjogYmluLmdldEF0dHJpYnV0ZSgnY29sb3InKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB4bWwge0RvY3VtZW50fVxuICogICAgICBUaGUgWE1MIGRvY3VtZW50IGZyb20gd2hpY2ggdG8gcGFyc2UgZXhwb3N1cmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiAgICAgIEFuIGFycmF5IG9mIHBhcnNlZCBleHBvc3VyZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9wYXJzZUV4cG9zdXJlcyA9IGZ1bmN0aW9uICh4bWwpIHtcbiAgdmFyIGV4cG9zdXJlLFxuICAgICAgYmluTWluLFxuICAgICAgYmluTWF4LFxuICAgICAgcG9wdWxhdGlvbixcbiAgICAgIG9uTWFwLFxuICAgICAgc3VtUG9wLFxuICAgICAgc3VtT25NYXAsXG4gICAgICBleHBvc3VyZXMgPSB4bWwucXVlcnlTZWxlY3RvckFsbCgncGFnZXIgPiBleHBvc3VyZScpLFxuICAgICAgZXhwb3N1cmVJdGVyID0gMCxcbiAgICAgIG51bUV4cG9zdXJlcyA9IGV4cG9zdXJlcy5sZW5ndGgsXG4gICAgICBkYXRhID0gW107XG5cbiAgZm9yICg7IGV4cG9zdXJlSXRlciA8IG51bUV4cG9zdXJlczsgZXhwb3N1cmVJdGVyKyspIHtcbiAgICBleHBvc3VyZSA9IGV4cG9zdXJlc1tleHBvc3VyZUl0ZXJdO1xuXG4gICAgYmluTWluID0gcGFyc2VGbG9hdChleHBvc3VyZS5nZXRBdHRyaWJ1dGUoJ2RtaW4nKSk7XG4gICAgYmluTWF4ID0gcGFyc2VGbG9hdChleHBvc3VyZS5nZXRBdHRyaWJ1dGUoJ2RtYXgnKSk7XG4gICAgcG9wdWxhdGlvbiA9IHBhcnNlSW50KGV4cG9zdXJlLmdldEF0dHJpYnV0ZSgnZXhwb3N1cmUnKSwgMTApO1xuICAgIG9uTWFwID0gKGV4cG9zdXJlLmdldEF0dHJpYnV0ZSgncmFuZ2VJbnNpZGVNYXAnKSA9PT0gJzEnKTtcblxuICAgIGRhdGEucHVzaChVdGlsLmV4dGVuZCh7fSxcbiAgICAgIEVYUE9TVVJFX0lORk9bTWF0aC5yb3VuZChiaW5NaW4pXSxcbiAgICAgIHtcbiAgICAgICAgbWluOiBiaW5NaW4sXG4gICAgICAgIG1heDogYmluTWF4LFxuICAgICAgICBwb3B1bGF0aW9uOiBwb3B1bGF0aW9uLFxuICAgICAgICBvbk1hcDogb25NYXAsXG4gICAgICAgIHBvcHVsYXRpb25EaXNwbGF5OiBfZm9ybWF0RXhwb3N1cmVQb3B1bGF0aW9uKHBvcHVsYXRpb24sICFvbk1hcCksXG4gICAgICB9XG4gICAgKSk7XG4gIH1cblxuICAvLyBHZW5lcmFsbHkgbm90IHJlcXVpcmVkLiBJZiBpdCBiZWNvbWVzIGEgcHJvYmxlbSwgdGhpcyB3aWxsIHNvcnQgaXQgb3V0LlxuICBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5taW4gLSBiLm1pbjtcbiAgfSk7XG5cbiAgLy8gQ29tYmluZSBiaW5zIElJLUlJSSB0b2dldGhlclxuICBpZiAoZGF0YVsxXSAmJiBkYXRhWzJdKSB7XG4gICAgc3VtUG9wID0gZGF0YVsxXS5wb3B1bGF0aW9uICsgZGF0YVsyXS5wb3B1bGF0aW9uO1xuICAgIHN1bU9uTWFwID0gKGRhdGFbMV0ub25NYXAgJiYgZGF0YVsyXS5vbk1hcCk7XG5cbiAgICBkYXRhLnNwbGljZSgxLCAyLCB7XG4gICAgICBtaW46IGRhdGFbMV0ubWluLFxuICAgICAgbWF4OiBkYXRhWzJdLm1heCxcbiAgICAgIHBvcHVsYXRpb246IHN1bVBvcCxcbiAgICAgIG9uTWFwOiBzdW1Pbk1hcCxcbiAgICAgIHBvcHVsYXRpb25EaXNwbGF5OiBfZm9ybWF0RXhwb3N1cmVQb3B1bGF0aW9uKHN1bVBvcCwgIXN1bU9uTWFwKSxcbiAgICAgIHBlcmM6ZGF0YVsxXS5wZXJjLFxuICAgICAgcmVzaXN0OmRhdGFbMV0ucmVzaXN0LFxuICAgICAgdnVsbjpkYXRhWzFdLnZ1bG4sXG4gICAgICBsYWJlbDpkYXRhWzFdLmxhYmVsLFxuICAgICAgY3NzOmRhdGFbMV0uY3NzXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHhtbCB7RG9jdW1lbnR9XG4gKiAgICAgIFRoZSBYTUwgZG9jdW1lbnQgZnJvbSB3aGljaCB0byBwYXJzZSBjaXR5IGluZm9ybWF0aW9uLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICBBbiBhcnJheSBvZiBwYXJzZWQgY2l0eSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9wYXJzZUNpdGllcyA9IGZ1bmN0aW9uICh4bWwpIHtcbiAgdmFyIGNpdHksXG4gICAgICBwb3B1bGF0aW9uLFxuICAgICAgbW1pLFxuICAgICAgY2l0aWVzID0geG1sLnF1ZXJ5U2VsZWN0b3JBbGwoJ3BhZ2VyID4gY2l0eScpLFxuICAgICAgY2l0eUl0ZXIgPSAwLFxuICAgICAgbnVtQ2l0aWVzID0gY2l0aWVzLmxlbmd0aCxcbiAgICAgIGRhdGEgPSBbXTtcblxuICBmb3IgKDsgY2l0eUl0ZXIgPCBudW1DaXRpZXM7IGNpdHlJdGVyKyspIHtcbiAgICBjaXR5ID0gY2l0aWVzW2NpdHlJdGVyXTtcbiAgICBwb3B1bGF0aW9uID0gcGFyc2VJbnQoY2l0eS5nZXRBdHRyaWJ1dGUoJ3BvcHVsYXRpb24nKSwgMTApO1xuICAgIG1taSA9IHBhcnNlRmxvYXQoY2l0eS5nZXRBdHRyaWJ1dGUoJ21taScpKTtcblxuICAgIGRhdGEucHVzaChVdGlsLmV4dGVuZCh7fSxcbiAgICAgIEVYUE9TVVJFX0lORk9bTWF0aC5yb3VuZChtbWkpXSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogY2l0eS5nZXRBdHRyaWJ1dGUoJ25hbWUnKSxcbiAgICAgICAgbGF0aXR1ZGU6IHBhcnNlRmxvYXQoY2l0eS5nZXRBdHRyaWJ1dGUoJ2xhdCcpKSxcbiAgICAgICAgbG9uZ2l0dWRlOiBwYXJzZUZsb2F0KGNpdHkuZ2V0QXR0cmlidXRlKCdsb24nKSksXG4gICAgICAgIHBvcHVsYXRpb246IHBvcHVsYXRpb24sXG4gICAgICAgIHBvcHVsYXRpb25EaXNwbGF5OiBfZm9ybWF0Q2l0eVBvcHVsYXRpb24ocG9wdWxhdGlvbiksXG4gICAgICAgIG1taTogbW1pLFxuICAgICAgICBpc0NhcGl0YWw6IChjaXR5LmdldEF0dHJpYnV0ZSgnaXNjYXBpdGFsJykgPT09ICcxJylcbiAgICAgIH1cbiAgICApKTtcbiAgfVxuXG4gIC8vIFNvcnQgc28gZmlyc3QgMTAgY2l0aWVzIGFyZSBcInNlbGVjdGVkXCIgY2l0aWVzXG4gIGRhdGEgPSBfc29ydENpdGllcyhkYXRhKTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHhtbCB7RG9jdW1lbnR9XG4gKiAgICAgIFRoZSBYTUwgZG9jdW1lbnQgZnJvbSB3aGljaCB0byBwYXJzZSBjb21tZW50IGluZm9ybWF0aW9uLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFyc2VkIGNvbW1lbnQgaW5mb3JtYXRpb24uIEtleWVkIGJ5IGNvbW1lbnRcbiAqICAgICAgdHlwZS5cbiAqL1xudmFyIF9wYXJzZUNvbW1lbnRzID0gZnVuY3Rpb24gKHhtbCkge1xuICB2YXIgY29tbWVudCxcbiAgICAgIGRhdGEgPSB7fTtcblxuICAvLyBUT0RPIDo6IENoZWNrIG9sZCBjb21tZW50IHBhcnNpbmcgYW5kIG1ha2Ugc3VyZSBpdCByZW1haW5zIGNvbnNpc3RlbnRcbiAgY29tbWVudCA9IHhtbC5xdWVyeVNlbGVjdG9yQWxsKCdwYWdlciA+IHN0cnVjdGNvbW1lbnQnKTtcbiAgaWYgKGNvbW1lbnQgJiYgY29tbWVudC5sZW5ndGgpIHtcbiAgICBkYXRhLnN0cnVjdHVyZSA9IGNvbW1lbnRbMF0udGV4dENvbnRlbnQudHJpbSgpO1xuICB9XG5cbiAgY29tbWVudCA9IHhtbC5xdWVyeVNlbGVjdG9yQWxsKCdwYWdlciA+IHNlY29uZGFyeV9lZmZlY3RzJyk7XG4gIGlmIChjb21tZW50ICYmIGNvbW1lbnQubGVuZ3RoKSB7XG4gICAgY29tbWVudCA9IGNvbW1lbnRbMF0udGV4dENvbnRlbnQudHJpbSgpO1xuICAgIGlmIChjb21tZW50ICE9PSAnJykge1xuICAgICAgZGF0YS5lZmZlY3RzID0gY29tbWVudDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPIDo6IFRoaXMgaXMgYSBjbHVzdGVyLiBQQUdFUiB0ZWFtIHNob3VsZCBzb3J0IG91dCBhIGJldHRlciB3YXkgdG9cbiAgLy8gICAgICAgICBzZW5kIGNvbW1lbnRzIG9mIHRoaXMgbmF0dXJlLlxuICBjb21tZW50ID0geG1sLnF1ZXJ5U2VsZWN0b3JBbGwoJ3BhZ2VyID4gaW1wYWN0X2NvbW1lbnQnKTtcbiAgaWYgKGNvbW1lbnQgJiYgY29tbWVudC5sZW5ndGgpIHtcbiAgICBkYXRhLmltcGFjdCA9IGNvbW1lbnRbMF0udGV4dENvbnRlbnQudHJpbSgpLnNwbGl0KCcjJykucmV2ZXJzZSgpO1xuICAgIGlmIChkYXRhLmltcGFjdFswXS5pbmRleE9mKCdlY29ub21pYycpICE9PSAtMSkge1xuICAgICAgZGF0YS5pbXBhY3QucmV2ZXJzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXR1cm4gdGhlIHBhcnNlciBvYmplY3Qgd2l0aCBBUEkgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgUGFnZXJYbWxQYXJzZXIgPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICAgVGhlIHZlcnNpb24gaWRlbnRpZmllciBmb3Igd2hpY2ggdGhpcyBwYXJzZXIgaXMgY29tcGF0aWJsZS5cbiAgICovXG4gIHZlcnNpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gWE1MX1ZFUlNJT05fU1RSSU5HO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gWE1MIHN0cmluZy9vYmplY3QgaW50byBhbiBvYmplY3Qgd2l0aCBQQUdFUiBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIFBBR0VSIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcGFyc2U6IGZ1bmN0aW9uICh4bWwpIHtcbiAgICB2YXIgZG9tUGFyc2VyO1xuXG4gICAgaWYgKHR5cGVvZiB4bWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkb21QYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICB4bWwgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhbGVydHM6IF9wYXJzZUFsZXJ0cyh4bWwpLFxuICAgICAgZXhwb3N1cmVzOiBfcGFyc2VFeHBvc3VyZXMoeG1sKSxcbiAgICAgIGNpdGllczogX3BhcnNlQ2l0aWVzKHhtbCksXG4gICAgICBjb21tZW50czogX3BhcnNlQ29tbWVudHMoeG1sKVxuICAgIH07XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlclhtbFBhcnNlcjtcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEZvcm1hdHRlciA9IHJlcXVpcmUoJ2NvcmUvRm9ybWF0dGVyJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5yZXF1aXJlKCdsZWFmbGV0L2xheWVyL0FzeW5jaHJvbm91c0dlb0pzb24nKTtcblxuXG52YXIgX0RFRkFVTFRTLFxuICAgIF9GT1JNQVRURVI7XG5cbl9ERUZBVUxUUyA9IHtcbiAgY2xpY2thYmxlOiB0cnVlLFxuXG4gIHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yLFxuICAgICAgd2VpZ2h0OiBmZWF0dXJlLnByb3BlcnRpZXMud2VpZ2h0LFxuICAgICAgb3BhY2l0eTogMS4wXG4gICAgfTtcbiAgfSxcblxuICBvbkVhY2hGZWF0dXJlOiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICB2YXIgcm9tYW47XG5cbiAgICByb21hbiA9IF9GT1JNQVRURVIubW1pKGZlYXR1cmUucHJvcGVydGllcy52YWx1ZSk7XG5cbiAgICBpZiAodGhpcy5jbGlja2FibGUpIHtcbiAgICAgIGxheWVyLmJpbmRQb3B1cChcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cInJvbWFuIHN0YXRpb24tc3VtbWFyeS1pbnRlbnNpdHkgbW1pJyArIHJvbWFuICsgJ1wiPicgK1xuICAgICAgICAgICAgcm9tYW4gK1xuICAgICAgICAgICAgJzxicj48YWJiciB0aXRsZT1cIk1vZGlmaWVkIE1lcmNhbGxpIEludGVuc2l0eVwiPm1taTwvYWJicj4nICtcbiAgICAgICAgICAnPC9kaXY+Jyk7XG4gICAgfVxuICB9XG59O1xuXG5fRk9STUFUVEVSID0gRm9ybWF0dGVyKCk7XG5cblxudmFyIENvbnRvdXJzTGF5ZXIgPSBMLkFzeW5jaHJvbm91c0dlb0pzb24uZXh0ZW5kKHtcblxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIEwuQXN5bmNocm9ub3VzR2VvSnNvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsXG4gICAgICAgIFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpKTtcbiAgfVxuXG59KTtcblxuXG5MLkNvbnRvdXJzTGF5ZXIgPSBDb250b3Vyc0xheWVyO1xuXG5MLmNvbnRvdXJzTGF5ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gbmV3IENvbnRvdXJzTGF5ZXIob3B0aW9ucyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTC5jb250b3Vyc0xheWVyO1xuIiwiLyogZ2xvYmFsIEwgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEZvcm1hdHRlciA9IHJlcXVpcmUoJ2NvcmUvRm9ybWF0dGVyJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5yZXF1aXJlKCdsZWFmbGV0L2xheWVyL0FzeW5jaHJvbm91c0dlb0pzb24nKTtcblxuXG52YXIgX0RFRkFVTFRfRk9STUFUVEVSID0gRm9ybWF0dGVyKCk7XG5cbnZhciBfREVGQVVMVF9PUFRJT05TID0ge1xuICBzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICB2YXIgY29sb3IgPSBfREVGQVVMVF9GT1JNQVRURVIubW1pQ29sb3IoZmVhdHVyZS5wcm9wZXJ0aWVzLmNkaSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnIzk5OScsXG4gICAgICBmaWxsQ29sb3I6IGNvbG9yLFxuICAgICAgZmlsbE9wYWNpdHk6IDAuOSxcbiAgICAgIG9wYWNpdHk6IDAuOSxcbiAgICAgIHdlaWdodDogMC41XG4gICAgfTtcbiAgfSxcblxuICBvbkVhY2hGZWF0dXJlOiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICBsYXllci5iaW5kUG9wdXAodGhpcy5mb3JtYXRQb3B1cChmZWF0dXJlKSk7XG4gIH0sXG5cbiAgZm9ybWF0UG9wdXA6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgdmFyIG1taSxcbiAgICAgICAgcDtcblxuICAgIHAgPSBmZWF0dXJlLnByb3BlcnRpZXM7XG4gICAgbW1pID0gX0RFRkFVTFRfRk9STUFUVEVSLm1taShwLmNkaSk7XG5cbiAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJkeWZpLXBvcHVwXCI+JyArXG4gICAgICAnPGgyIGNsYXNzPVwiZHlmaS1uYW1lXCI+JyArIHAubmFtZSArICc8L2gyPicgK1xuICAgICAgJzx1bCBjbGFzcz1cImR5Zmktc3VtbWFyeVwiPicgK1xuICAgICAgICAnPGxpIGNsYXNzPVwiZHlmaS1zdW1tYXJ5LWludGVuc2l0eSByb21hbiBtbWknICsgbW1pICsgJ1wiPicgK1xuICAgICAgICAgIG1taSArXG4gICAgICAgICAgJzxici8+PGFiYnIgdGl0bGU9XCJDb21tdW5pdHkgRGV0ZXJtaW5lZCBJbnRlbnNpdHlcIj5jZGk8L2FiYnI+JyArXG4gICAgICAgICc8L2xpPicgK1xuICAgICAgICAnPGxpIGNsYXNzPVwiZHlmaS1zdW1tYXJ5LW5yZXNwXCI+JyArXG4gICAgICAgICAgX0RFRkFVTFRfRk9STUFUVEVSLm51bWJlcihwLm5yZXNwLCAwLCAnJm5kYXNoOycpICtcbiAgICAgICAgICAnPGJyLz48YWJiciB0aXRsZT1cIk51bWJlciBvZiBSZXNwb25zZXNcIj5yZXNwb25zZXM8L2FiYnI+JyArXG4gICAgICAgICc8L2xpPicgK1xuICAgICAgICAnPGxpIGNsYXNzPVwiZHlmaS1zdW1tYXJ5LWRpc3RhbmNlXCI+JyArXG4gICAgICAgICAgX0RFRkFVTFRfRk9STUFUVEVSLm51bWJlcihwLmRpc3QsIDAsICcmbmRhc2g7JywgJ2ttJykgK1xuICAgICAgICAgICc8YnIvPjxhYmJyIHRpdGxlPVwiRGlzdGFuY2UgZnJvbSBIeXBvY2VudGVyXCI+ZGlzdGFuY2U8L2FiYnI+JyArXG4gICAgICAgICc8L2xpPicgK1xuICAgICAgJzwvdWw+JyArXG4gICAgJzwvZGl2Pic7XG4gIH1cbn07XG5cblxudmFyIER5ZmlVdG1MYXllciA9IEwuQXN5bmNocm9ub3VzR2VvSnNvbi5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgTC5Bc3luY2hyb25vdXNHZW9Kc29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyxcbiAgICAgICAgVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpKTtcbiAgfVxuXG59KTtcblxuXG5MLkR5ZmlVdG1MYXllciA9IER5ZmlVdG1MYXllcjtcblxuTC5keWZpVXRtTGF5ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gbmV3IER5ZmlVdG1MYXllcihvcHRpb25zKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMLmR5ZmlVdG1MYXllcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgRXZlbnRzID0gcmVxdWlyZSgndXRpbC9FdmVudHMnKSxcbiAgICBJbnRlcmFjdGl2ZU1hcFZpZXcgPSByZXF1aXJlKCdtYXAvSW50ZXJhY3RpdmVNYXBWaWV3JyksXG4gICAgTW9kYWxWaWV3ID0gcmVxdWlyZSgnbXZjL01vZGFsVmlldycpLFxuICAgIE1vZHVsZSA9IHJlcXVpcmUoJ2NvcmUvTW9kdWxlJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMsXG4gICAgX0lELFxuICAgIF9USVRMRSxcbiAgICBfVFlQRVM7XG5cbl9JRCA9ICdtYXAnO1xuX1RJVExFID0gJ0ludGVyYWN0aXZlIE1hcCc7XG5fVFlQRVMgPSBbJ29yaWdpbiddO1xuXG5fREVGQVVMVFMgPSB7XG5cbn07XG5cblxuLyoqXG4gKiBUaGUgbW9kdWxlIGhhbmRsZXMgaW50ZXJhY3Rpb24gYmV0d2VlbiB0aGUgSW50ZXJhY3RpdmVNYXBWaWV3IGFuZCB0aGUgbGFyZ2VyXG4gKiBFdmVudFBhZ2UgZnJhbWV3b3JrLiBUaGVyZSBhcmUgdHdvIHRvcC1sZXZlbCBjb21wb25lbnRzIHRvIHRoaXMgbW9kdWxlOlxuICpcbiAqIFRoZSBmaXJzdCBpcyB0aGUgYmFja2dyb3VuZCwgaW4tcGFnZSwgY29udGVudC4gVGhpcyBjb250ZW50IGlzIHZlcnkgc2ltcGxlXG4gKiBhbmQgb25seSB1c2VkIGFzIGEgZmFsbGJhY2sgdG8gYWxsb3cgbmF2aWdhdGlvbiBvciB0byByZS1vcGVuIHRoZSBtb2RhbCB2aWV3LlxuICpcbiAqIFRoZSBzZWNvbmQgdG9wLWxldmVsIGNvbXBvbmVudCBpcyB0aGUgbW9kYWwgdmlldyBpdHNlbGYuIFRoaXMgdmlldyBwcm92aWRlc1xuICogdGhlIGNvbnRhaW5lciBpbnRvIHdoaWNoIHRoZSBtYXAgaXRzZWxmIHdpbGwgYmUgcmVuZGVyZWQuXG4gKlxuICogQ2xvc2luZyB0aGUgbWFwIHdpbGwgbmF2aWdhdGUgdGhlIHBhZ2UgdG8gZWl0aGVyICgxKSB0aGUgcHJldmlvdXMgRXZlbnRQYWdlXG4gKiBtb2R1bGUgdGhhdCB0aGUgdXNlciB3YXMgdmlld2luZyBvciAoMikgdGhlIGRlZmF1bHQgRXZlbnRQYWdlIG1vZHVsZSBpbiB0aGVcbiAqIGNhc2UgdGhhdCB0aGUgdXNlciB3YXMgbGlua2VkIGRpcmVjdGx5IGludG8gdGhlIG1hcC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgICBTZWUgZG9jdW1lbnRhdGlvbiBvbiBfaW5pdGlhbGl6ZSBtZXRob2QgZm9yIGRldGFpbHMuXG4gKi9cbnZhciBJbnRlcmFjdGl2ZU1hcE1vZHVsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfY2xvc2VCdXR0b24sXG4gICAgICBfbWFwVmlldyxcbiAgICAgIF9tb2RhbCxcbiAgICAgIF9zY2VuYXJpb0JhZGdlO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IE1vZHVsZShvcHRpb25zKTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgbmV3IG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICovXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgY29uZmlnO1xuXG4gICAgX3RoaXMuSUQgPSBfSUQ7XG4gICAgX3RoaXMuVElUTEUgPSBfVElUTEU7XG4gICAgX3RoaXMuVFlQRVMgPSBfVFlQRVM7XG5cbiAgICBjb25maWcgPSBfdGhpcy5tb2RlbC5nZXQoJ2NvbmZpZycpO1xuXG4gICAgX3RoaXMuY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzLm9uQ29udGVudENsaWNrKTtcblxuICAgIF9tYXBWaWV3ID0gSW50ZXJhY3RpdmVNYXBWaWV3KHtcbiAgICAgIGZvcm1hdHRlcjogb3B0aW9ucy5mb3JtYXR0ZXIsXG4gICAgICBtb2RlbDogX3RoaXMubW9kZWwsXG4gICAgICBtb2R1bGU6IF90aGlzXG4gICAgfSk7XG5cbiAgICBfbW9kYWwgPSBNb2RhbFZpZXcoX21hcFZpZXcuZWwsIHtcbiAgICAgIGJ1dHRvbnM6IG51bGwsIC8vIG5vIGZvb3RlclxuICAgICAgdGl0bGU6IG51bGwgICAgLy8gbm8gaGVhZGVyXG4gICAgfSk7XG5cbiAgICBfbW9kYWwuZWwuY2xhc3NMaXN0LmFkZCgnbW9kYWwtbWFwJyk7XG4gICAgX3RoaXMuYXBwZW5kQ2xvc2VCdXR0b24oKTtcblxuICAgIGlmIChjb25maWcgJiYgY29uZmlnLlNDRU5BUklPX01PREUgPT09IHRydWUpIHtcbiAgICAgIF90aGlzLmFwcGVuZFNjZW5hcmlvQmFkZ2UoKTtcbiAgICB9XG4gIH07XG5cblxuICBfdGhpcy5hcHBlbmRDbG9zZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV9jbG9zZUJ1dHRvbikge1xuICAgICAgX2Nsb3NlQnV0dG9uID0gX21vZGFsLmVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpKTtcbiAgICAgIF9jbG9zZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdjYW5jZWwnKTtcbiAgICAgIF9jbG9zZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdtb2RhbC1jbG9zZScpO1xuICAgICAgX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9ICdDbG9zZSBNYXAnO1xuXG4gICAgICBfY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5vbkNsb3NlQnV0dG9uQ2xpY2spO1xuICAgIH1cbiAgfTtcblxuICBfdGhpcy5hcHBlbmRTY2VuYXJpb0JhZGdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX3NjZW5hcmlvQmFkZ2UpIHtcbiAgICAgIF9zY2VuYXJpb0JhZGdlID0gX21vZGFsLmVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgIF9zY2VuYXJpb0JhZGdlLmNsYXNzTGlzdC5hZGQoJ3NjZW5hcmlvLWJhZGdlJyk7XG4gICAgICBfc2NlbmFyaW9CYWRnZS5jbGFzc0xpc3QuYWRkKCdsZWFmbGV0LWNvbnRyb2wnKTtcbiAgICAgIF9zY2VuYXJpb0JhZGdlLmlubmVySFRNTCA9ICdTY2VuYXJpbyc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGcmVlIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBNb2R1bGUgYW5kIHRoZW4gY2FsbCBwYXJlbnRcbiAgICogZGVzdHJveSBtZXRob2QgYXMgd2VsbC5cbiAgICpcbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5vbkNvbnRlbnRDbGljayk7XG4gICAgX2Nsb3NlQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX3RoaXMub25DbG9zZUJ1dHRvbkNsaWNrKTtcblxuICAgIF9tYXBWaWV3LmRlc3Ryb3koKTtcbiAgICBfbW9kYWwuaGlkZSgpO1xuICAgIF9tb2RhbC5kZXN0cm95KCk7XG5cbiAgICBfbWFwVmlldyA9IG51bGw7XG4gICAgX21vZGFsID0gbnVsbDtcblxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIF90aGlzLm9uQ2xvc2VCdXR0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBFdmVudHMudHJpZ2dlcignYmFjaycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWxlZ2F0ZWRlIGV2ZW50IGxpc3RlbmVyIHRvIGNhcHR1cmUgY2xpY2tzIG9uIHRoZSBidXR0b24gYW5kIHNob3dcbiAgICogdGhlIG1vZGFsIHZpZXcuIFRoaXMgaXMgYSBmYWxsYmFjayBzbyB1c2VyIGNhbiBnZXQgYmFjayB0byBtYXAgaWZcbiAgICogdGhleSBzb21laG93IGVuZCB1cCB2aWV3aW5nIHRoZSBiYWNrZ3JvdW5kIGNvbnRlbnQgb2YgdGhpcyBtb2R1bGUuXG4gICAqXG4gICAqL1xuICBfdGhpcy5vbkNvbnRlbnRDbGljayA9IGZ1bmN0aW9uIChldikge1xuICAgIGlmIChldi50YXJnZXQgJiYgZXYudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc2hvdy1tYXAnKSkge1xuICAgICAgX3RoaXMuc2hvd01hcCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYmFja2dyb3VuZCBpbmZvcm1hdGlvbiBhbmQgdGhlbiBzaG93cyB0aGUgbWFwLlxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERvIGJhc2ljIGJhY2tncm91bmQgcmVuZGVyaW5nIHN0dWZmLiBUaGlzIHdpbGwgbGFyZ2VseSBnbyB1bnNlZW4uXG4gICAgX3RoaXMuaGVhZGVyLmlubmVySFRNTCA9ICc8YSBjbGFzcz1cImJhY2stdG8tc3VtbWFyeS1saW5rXCIgJyArXG4gICAgICAgICdocmVmPVwiI1wiPkJhY2sgdG8gR2VuZXJhbCBTdW1tYXJ5PC9hPic7XG4gICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPSAnPGJ1dHRvbiBjbGFzcz1cInNob3ctbWFwXCI+U2hvdyBNYXA8L2J1dHRvbj4nO1xuICAgIF90aGlzLmZvb3Rlci5pbm5lckhUTUwgPSAnJztcblxuICAgIF90aGlzLnNob3dNYXAoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvd3MgdGhlIG1hcCBhbmQgbm90aWZpZXMgdGhlIHN1Yi12aWV3IHRoYXQgaXRzIGNvbnRlbnQgaXMgaW4gdGhlIERPTVxuICAgKiBzbyB0aGUgdmlldyBjYW4gaW52YWxpZGF0ZSBkaW1lbnNpb25zIGV0Yy4uLlxuICAgKlxuICAgKi9cbiAgX3RoaXMuc2hvd01hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfbW9kYWwuc2hvdygpO1xuICAgIF9tYXBWaWV3Lm9uRG9tUmVhZHkoKTtcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5JbnRlcmFjdGl2ZU1hcE1vZHVsZS5JRCA9IF9JRDtcbkludGVyYWN0aXZlTWFwTW9kdWxlLlRJVExFID0gX1RJVExFO1xuSW50ZXJhY3RpdmVNYXBNb2R1bGUuVFlQRVMgPSBfVFlQRVM7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmFjdGl2ZU1hcE1vZHVsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgQXR0cmlidXRpb24gPSByZXF1aXJlKCdjb3JlL0F0dHJpYnV0aW9uJyksXG4gICAgQmFzaWNQaW5WaWV3ID0gcmVxdWlyZSgnY29yZS9CYXNpY1BpblZpZXcnKSxcbiAgICBJbnRlcmFjdGl2ZU1hcFZpZXcgPSByZXF1aXJlKCdtYXAvSW50ZXJhY3RpdmVNYXBWaWV3JyksXG4gICAgUHJvZHVjdCA9IHJlcXVpcmUoJ3BkbC9Qcm9kdWN0JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIG1vZHVsZToge0lEOiAnbWFwJywgVElUTEU6ICdJbnRlcmFjdGl2ZSBNYXAnfVxufTtcblxuXG52YXIgTWFwUGluVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfbWFwVmlldztcblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gQmFzaWNQaW5WaWV3KG9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBuZXcgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoLypvcHRpb25zKi8pIHtcbiAgICB2YXIgZWwsXG4gICAgICAgIGV2O1xuXG4gICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKCdsb2NhdGlvbnZpZXctbWFwJyk7XG5cbiAgICBldiA9IF90aGlzLm1vZGVsLmdldCgnZXZlbnQnKTtcblxuICAgIGlmIChldikge1xuICAgICAgX3RoaXMucHJvZHVjdCA9IGV2LmdldFByZWZlcnJlZE9yaWdpblByb2R1Y3QoKTtcbiAgICB9XG5cbiAgICBpZiAoIV90aGlzLnByb2R1Y3QpIHtcbiAgICAgIF90aGlzLnByb2R1Y3QgPSBQcm9kdWN0KCk7XG4gICAgfVxuXG4gICAgX3RoaXMuY29udGVudC5hcHBlbmRDaGlsZChlbCk7XG5cbiAgICBfbWFwVmlldyA9IEludGVyYWN0aXZlTWFwVmlldyh7XG4gICAgICBlbDogZWwsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBtYXJrZXJTaXplOiAxNixcbiAgICAgIG1vZGVsOiBfdGhpcy5tb2RlbCxcbiAgICAgIHNjYWxlQ29udHJvbDogZmFsc2VcbiAgICB9KTtcbiAgfTtcblxuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3RoaXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX21hcFZpZXcuZGVzdHJveSgpO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgX3RoaXMucmVuZGVyUGluQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfbWFwVmlldy5vbkRvbVJlYWR5KCk7XG4gICAgX21hcFZpZXcucmVuZGVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGJhc2UgZnVuY3Rpb24uXG4gICAqIFRoaXMgcGluIGRvZXNuJ3QgaGF2ZSBhIGNvbnRyaWJ1dG9yLlxuICAgKi9cbiAgX3RoaXMucmVuZGVyUGluRm9vdGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgX3RoaXMuZm9vdGVyLmlubmVySFRNTCA9ICdDb250cmlidXRlZCBieSAnICtcbiAgICAgICAgQXR0cmlidXRpb24uZ2V0UHJvZHVjdEF0dHJpYnV0aW9uKF90aGlzLnByb2R1Y3QpO1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFwUGluVmlldztcbiIsIi8qIGdsb2JhbCBMICovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIENvbnRvdXJzTGF5ZXIgPSByZXF1aXJlKCdtYXAvQ29udG91cnNMYXllcicpLFxuICAgIER5ZmlVdG1MYXllciA9IHJlcXVpcmUoJ21hcC9EeWZpVXRtTGF5ZXInKSxcbiAgICBHcmF5c2NhbGUgPSByZXF1aXJlKCdsZWFmbGV0L2xheWVyL0dyYXlzY2FsZScpLFxuICAgIFRlcnJhaW4gPSByZXF1aXJlKCdsZWFmbGV0L2xheWVyL1RlcnJhaW4nKSxcbiAgICBGb3JtYXR0ZXIgPSByZXF1aXJlKCdjb3JlL0Zvcm1hdHRlcicpLFxuICAgIEhhekRldkxheWVycyA9IHJlcXVpcmUoJ2xlYWZsZXQvY29udHJvbC9IYXpEZXZMYXllcnMnKSxcbiAgICBIaXN0b3JpY1NlaXNtaWNpdHkgPSByZXF1aXJlKCdsZWFmbGV0L2xheWVyL0hpc3RvcmljU2Vpc21pY2l0eScpLFxuICAgIE1vZHVsZSA9IHJlcXVpcmUoJ2NvcmUvTW9kdWxlJyksXG4gICAgTW91c2VQb3NpdGlvbiA9IHJlcXVpcmUoJ2xlYWZsZXQvY29udHJvbC9Nb3VzZVBvc2l0aW9uJyksXG4gICAgU2F0ZWxsaXRlID0gcmVxdWlyZSgnbGVhZmxldC9sYXllci9TYXRlbGxpdGUnKSxcbiAgICBTdHJlZXQgPSByZXF1aXJlKCdsZWFmbGV0L2xheWVyL1N0cmVldCcpLFxuICAgIFByb2R1Y3QgPSByZXF1aXJlKCdwZGwvUHJvZHVjdCcpLFxuICAgIFNoYWtlTWFwU3RhdGlvbkxheWVyID0gcmVxdWlyZSgnbWFwL1NoYWtlTWFwU3RhdGlvbkxheWVyJyksXG4gICAgVGVjdG9uaWNQbGF0ZXMgPSByZXF1aXJlKCdsZWFmbGV0L2xheWVyL1RlY3RvbmljUGxhdGVzJyksXG4gICAgVXNGYXVsdCA9IHJlcXVpcmUoJ2xlYWZsZXQvbGF5ZXIvVXNGYXVsdCcpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKSxcbiAgICBWaWV3ID0gcmVxdWlyZSgnbXZjL1ZpZXcnKTtcblxuXG4vLyBEaXNwbGF5IG5hbWVzIG9mIG92ZXJsYXlzXG52YXIgX0RZRklfMTBLX09WRVJMQVkgPSAnRFlGSSBSZXNwb25zZXMgMTAga20nLFxuICAgIF9EWUZJXzFLX09WRVJMQVkgPSAnRFlGSSBSZXNwb25zZXMgMSBrbScsXG4gICAgX0RZRklfREVGQVVMVF9PVkVSTEFZID0gJ0RZRkkgUmVzcG9uc2VzJyxcbiAgICBfRVBJQ0VOVEVSX09WRVJMQVkgPSAnRXBpY2VudGVyJyxcbiAgICBfRkFVTFRTX09WRVJMQVkgPSAnVS5TLiBGYXVsdHMnLFxuICAgIF9ISVNUX1NFSVNfT1ZFUkxBWSA9ICdIaXN0b3JpY2FsIFNlaXNtaWNpdHknLFxuICAgIF9QTEFURVNfT1ZFUkxBWSA9ICdUZWN0b25pYyBQbGF0ZXMnLFxuICAgIF9QT1BVTEFUSU9OX09WRVJMQVkgPSAnUG9wdWxhdGlvbiBEZW5zaXR5JyxcbiAgICBfU0hBS0VNQVBfQ09OVE9VUlMgPSAnU2hha2VNYXAgTU1JIENvbnRvdXJzJyxcbiAgICBfU0hBS0VNQVBfU1RBVElPTlMgPSAnU2hha2VNYXAgU3RhdGlvbnMnO1xuXG52YXIgX0RFRkFVTFRTID0ge1xuICBjb25maWc6IHtcbiAgICBiYXNlTGF5ZXI6ICdUZXJyYWluJ1xuICB9LFxuICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgbWFya2VyU2l6ZTogMzJcbn07XG5cbi8vIFNldCB1cCB3aGF0IHdlIHdhbnQgZW5hYmxlZCBieSBkZWZhdWx0XG5fREVGQVVMVFMuY29uZmlnW19FUElDRU5URVJfT1ZFUkxBWV0gPSAndHJ1ZSc7XG5fREVGQVVMVFMuY29uZmlnW19QTEFURVNfT1ZFUkxBWV0gPSAndHJ1ZSc7XG5fREVGQVVMVFMuY29uZmlnW19GQVVMVFNfT1ZFUkxBWV0gPSAndHJ1ZSc7XG5fREVGQVVMVFMuY29uZmlnW19TSEFLRU1BUF9DT05UT1VSU10gPSAndHJ1ZSc7XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGxhdGl0dWRlL2xvbmdpdHVkZSByZXByZXNlbnQgYSBsb2NhdGlvbiB3aXRoaW4gdGhlIFUuUy5cbiAqIHdoZXJlIHRoZSBVLlMuIGZhdWx0IGxheWVyIGhhcyBkYXRhIChzbyBzb21lIHJlZ2lvbnMgYXJlIG5vdCBjb25zaWRlcmVkKS5cbiAqXG4gKiBAcGFyYW0gbGF0aXR1ZGUge051bWJlcn1cbiAqICAgICBEZWNpbWFsIGRlZ3JlZXMgbGF0aXR1ZGUuXG4gKiBAcGFyYW0gbG9uZ2l0dWRlIHtOdW1iZXJ9XG4gKiAgICAgRGVjaW1hbCBkZWdyZWVzIGxvbmdpdHVkZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICAgIFRydWUgaWYgdGhlIGxvY2F0aW9uIGlzIHdpdGhpbiB0aGUgY29uc2lkZXJlZCBVLlMuLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZhciBfX2luVXMgPSBmdW5jdGlvbiAobGF0aXR1ZGUsIGxvbmdpdHVkZSkge1xuICAvLyBOb3RlIDo6IE9ubHkgY29uc2lkZXJpbmcgVS5TLiByZWdpb25zIHRoYXQgaGF2ZSBmYXVsdCBsYXllciBkYXRhLi4uXG4gIHJldHVybiAoXG4gICAgKCAvLyBDb250ZW1yaW5vdXMgVS5TLlxuICAgICAgbGF0aXR1ZGUgPD0gNTAuMCAmJiBsYXRpdHVkZSA+PSAyNC42ICYmXG4gICAgICBsb25naXR1ZGUgPD0gNjUuMCAmJiBsb25naXR1ZGUgPj0gLTEyNS4wXG4gICAgKSB8fFxuICAgICggLy8gSGF3YWlpXG4gICAgICBsYXRpdHVkZSA8PSAyMy4wICYmIGxhdGl0dWRlID49IDIzLjAgJiZcbiAgICAgIGxvbmdpdHVkZSA8PSAtMTU0LjAgJiYgbG9uZ2l0dWRlID49IC0xNjEuMFxuICAgIClcbiAgKTtcbn07XG5cblxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIGEgdmlldyB0aGF0IHJlbmRlcnMgYW4gaW50ZXJhY3RpdmUgbWFwIGluIGEgY29udGFpbmVyLiBJdFxuICogZXhwZWN0cyBhIG1vZGVsIHRoYXQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIEV2ZW50UGFnZU1vZGVsIChjdXJyZW50bHkgYW5cbiAqIGp1c3QgYSBnZW5lcmFsaXplZCB7TW9kZWx9IGluc3RhbmNlIHdpdGggXCJldmVudFwiIGFuZCBcImNvbmZpZ1wiIHByb3BlcnRpZXMpLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gKiAgICAgU2VlIF9pbml0aWFsaXplIG1ldGhvZCBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuICovXG52YXIgSW50ZXJhY3RpdmVNYXBWaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9iYXNlTGF5ZXJzLFxuICAgICAgX2RlZmF1bHRDb25maWcsXG4gICAgICBfZm9ybWF0dGVyLFxuICAgICAgX2ludGVyYWN0aXZlLFxuICAgICAgX2xheWVyc0NvbnRyb2wsXG4gICAgICBfbWFwLFxuICAgICAgX21hcmtlclNpemUsXG4gICAgICBfbW9kdWxlLFxuICAgICAgX292ZXJsYXlzLFxuICAgICAgX3Bvc2l0aW9uQ29udHJvbCxcbiAgICAgIF9zY2FsZUNvbnRyb2w7XG5cblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gVmlldyhvcHRpb25zKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IuIEluaXRpYWxpemVzIGEgbmV3IEludGVyYWN0aXZlTWFwVmlldy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogICAgIENvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU3BlY2lmaWNhbGx5Li4uXG4gICAqIEBwYXJhbSBvcHRpb25zLm1vZGVsIHtNb2RlbH1cbiAgICogICAgIFRoZSBFdmVudFBhZ2VNb2RlbCBmb3IgdGhpcyB2aWV3IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIG9wdGlvbnMuZm9ybWF0dGVyIHtGb3JtYXR0ZXJ9XG4gICAqICAgICBUaGUgZm9ybWF0dGluZyB1dGlsaXR5IGNsYXNzIHRvIHVzZSB3aGVuIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2NhbGVDb250cm9sIHtib29sZWFufVxuICAgKiAgICBUaGUgc2NhbGVcbiAgICovXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBfdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdpbnRlcmFjdGl2ZS1tYXAtdmlldycpO1xuXG4gICAgX2RlZmF1bHRDb25maWcgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLmNvbmZpZyk7XG4gICAgX21vZHVsZSA9IG9wdGlvbnMubW9kdWxlIHx8IE1vZHVsZSgpO1xuXG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuICAgIF9pbnRlcmFjdGl2ZSA9IG9wdGlvbnMuaW50ZXJhY3RpdmU7XG4gICAgX21hcmtlclNpemUgPSBvcHRpb25zLm1hcmtlclNpemU7XG5cbiAgICBfYmFzZUxheWVycyA9IHt9O1xuICAgIF9vdmVybGF5cyA9IHt9O1xuXG4gICAgX21hcCA9IEwubWFwKF90aGlzLmVsLCB7XG4gICAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IGZhbHNlLFxuICAgICAgYm94Wm9vbTogX2ludGVyYWN0aXZlLFxuICAgICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICBkb3VibGVDbGlja1pvb206IF9pbnRlcmFjdGl2ZSxcbiAgICAgIGRyYWdnaW5nOiBfaW50ZXJhY3RpdmUsXG4gICAgICBzY3JvbGxXaGVlbFpvb206IF9pbnRlcmFjdGl2ZSxcbiAgICAgIHRhcDogX2ludGVyYWN0aXZlLFxuICAgICAgdG91Y2hab29tOiBfaW50ZXJhY3RpdmUsXG4gICAgICB6b29tOiAwLFxuICAgICAgem9vbUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgIHpvb21Db250cm9sOiBfaW50ZXJhY3RpdmVcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSB0aGUgY29udHJvbCBoZXJlLCB0aGUgXCJnZXRBdmFpbGFibGUqXCIgbWV0aG9kcyBkZXRlcm1pbmUgd2hhdFxuICAgIC8vIGlzIGluY2x1ZGVkIGluIHRoaXMgY29udHJvbC4uLlxuICAgIF9sYXllcnNDb250cm9sID0gSGF6RGV2TGF5ZXJzKFxuICAgICAgX3RoaXMuZ2V0QXZhaWxhYmxlQmFzZUxheWVycygpLFxuICAgICAge31cbiAgICApO1xuICAgIGlmIChfaW50ZXJhY3RpdmUpIHtcbiAgICAgIF9tYXAuYWRkQ29udHJvbChfbGF5ZXJzQ29udHJvbCk7XG4gICAgfVxuXG4gICAgaWYgKCFVdGlsLmlzTW9iaWxlKCkpIHtcbiAgICAgIGlmIChfaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgX3Bvc2l0aW9uQ29udHJvbCA9IE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgX21hcC5hZGRDb250cm9sKF9wb3NpdGlvbkNvbnRyb2wpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zY2FsZUNvbnRyb2wgIT09IGZhbHNlKSB7XG4gICAgICAgIF9zY2FsZUNvbnRyb2wgPSBMLmNvbnRyb2wuc2NhbGUoe3Bvc2l0aW9uOiAnYm90dG9tbGVmdCd9KTtcbiAgICAgICAgX21hcC5hZGRDb250cm9sKF9zY2FsZUNvbnRyb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgYXBwcm9wcmlhdGUgRFlGSSBvdmVybGF5cyBiYXNlZCBvbiB0aGUgZ2l2ZW4gcHJvZHVjdC5cbiAgICogQWRkcyBlYWNoIG92ZXJsYXkgdG8gdGhlIGluc3RhbmNlIF9vdmVybGF5cyBtYXBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gZHlmaSB7UHJvZHVjdH1cbiAgICogICAgIFRoZSBEWUZJIHByb2R1Y3QgZm9yIHdoaWNoIHRvIGNyZWF0ZSBvdmVybGF5cy4gSWYgbnVsbCwgbm8gb3ZlcmxheXNcbiAgICogICAgIGFyZSBhZGRlZC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgVGhlIF9vdmVybGF5cyBpbnN0YW5jZSB2YXJpYWJsZSwgYXMgYXVnbWVudGVkIHdpdGggbmV3IGxheWVycy5cbiAgICovXG4gIF90aGlzLmFkZER5ZmlPdmVybGF5cyA9IGZ1bmN0aW9uIChkeWZpKSB7XG4gICAgdmFyIGNvbnRlbnQ7XG5cbiAgICBpZiAoIWR5ZmkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAxMGsgcmVzcG9uc2VzIGFnZ3JlZ2F0aW9uXG4gICAgY29udGVudCA9IGR5ZmkuZ2V0Q29udGVudCgnZHlmaV9nZW9fMTBrbS5nZW9qc29uJyk7XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIF9vdmVybGF5c1tfRFlGSV8xMEtfT1ZFUkxBWV0gPSBEeWZpVXRtTGF5ZXIoe1xuICAgICAgICB1cmw6IGNvbnRlbnQuZ2V0KCd1cmwnKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gMWttIHJlc3BvbnNlcyBhZ2dyZWdhdGlvblxuICAgIGNvbnRlbnQgPSBkeWZpLmdldENvbnRlbnQoJ2R5ZmlfZ2VvXzFrbS5nZW9qc29uJyk7XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIF9vdmVybGF5c1tfRFlGSV8xS19PVkVSTEFZXSA9IER5ZmlVdG1MYXllcih7XG4gICAgICAgIHVybDogY29udGVudC5nZXQoJ3VybCcpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayByZXNwb25zZXMgYWdncmVnYXRpb25cbiAgICBpZiAoIV9vdmVybGF5cy5oYXNPd25Qcm9wZXJ0eShfRFlGSV8xMEtfT1ZFUkxBWSkgJiZcbiAgICAgICAgIV9vdmVybGF5cy5oYXNPd25Qcm9wZXJ0eShfRFlGSV8xS19PVkVSTEFZKSkge1xuXG4gICAgICBjb250ZW50ID0gZHlmaS5nZXRDb250ZW50KCdkeWZpX2dlby5nZW9qc29uJyk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBfb3ZlcmxheXNbX0RZRklfREVGQVVMVF9PVkVSTEFZXSA9IER5ZmlVdG1MYXllcih7XG4gICAgICAgICAgdXJsOiBjb250ZW50LmdldCgndXJsJylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9vdmVybGF5cztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgYXBwcm9wcmlhdGUgU2hha2VNYXAgb3ZlcmxheXMgYmFzZWQgb24gdGhlIGdpdmVuIHByb2R1Y3QuXG4gICAqIEFkZHMgZWFjaCBvdmVybGF5IHRvIHRoZSBpbnN0YW5jZSBfb3ZlcmxheXMgbWFwcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHNoYWtlbWFwIHtQcm9kdWN0fVxuICAgKiAgICAgVGhlIFNoYWtlTWFwIHByb2R1Y3QgZm9yIHdoaWNoIHRvIGNyZWF0ZSBvdmVybGF5cy4gSWYgbnVsbCwgbm8gb3ZlcmxheXNcbiAgICogICAgIGFyZSBhZGRlZC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgVGhlIF9vdmVybGF5cyBpbnN0YW5jZSB2YXJpYWJsZSwgYXMgYXVnbWVudGVkIHdpdGggbmV3IGxheWVycy5cbiAgICovXG4gIF90aGlzLmFkZFNoYWtlTWFwT3ZlcmxheXMgPSBmdW5jdGlvbiAoc2hha2VtYXApIHtcbiAgICB2YXIgY29udGVudDtcblxuICAgIGlmICghc2hha2VtYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZW50ID0gc2hha2VtYXAuZ2V0Q29udGVudCgnZG93bmxvYWQvY29udF9taS5qc29uJyk7XG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIF9vdmVybGF5c1tfU0hBS0VNQVBfQ09OVE9VUlNdID0gQ29udG91cnNMYXllcih7XG4gICAgICAgIGNsaWNrYWJsZTogX2ludGVyYWN0aXZlLFxuICAgICAgICB1cmw6IGNvbnRlbnQuZ2V0KCd1cmwnKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udGVudCA9IHNoYWtlbWFwLmdldENvbnRlbnQoJ2Rvd25sb2FkL3N0YXRpb25saXN0Lmpzb24nKTtcbiAgICBpZiAoY29udGVudCkge1xuICAgICAgX292ZXJsYXlzW19TSEFLRU1BUF9TVEFUSU9OU10gPSBTaGFrZU1hcFN0YXRpb25MYXllcihcbiAgICAgICAgICBjb250ZW50LmdldCgndXJsJykpO1xuICAgIH1cblxuICAgIHJldHVybiBfb3ZlcmxheXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtYXJrZXIgdG8gaW5kaWNhdGUgdGhlIGVwaWNlbnRlciBhdCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kXG4gICAqIGxvbmdpdHVkZSBjb29yZGluYXRlcy4gSW5jbHVkZXMgdGhlIG1hZ25pdHVkZSBpbiB0aGUgdG9vbHRpcCB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0gbGF0aXR1ZGUge051bWJlcn1cbiAgICogICAgIERlY2ltYWwgZGVncmVlcyBsYXRpdHVkZS5cbiAgICogQHBhcmFtIGxvbmdpdHVkZSB7TnVtYmVyfVxuICAgKiAgICAgRGVjaW1hbCBkZWdyZWVzIGxvbmdpdHVkZS5cbiAgICogQHBhcmFtIG1hZ25pdHVkZSB7TnVtYmVyfVxuICAgKiAgICAgTWFnbml0dWRlIG9mIGV2ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtMLk1hcmtlcn1cbiAgICogICAgIEEgbWFya2VyIGNlbnRlcmVkIG9uIHRoZSBnaXZlbiBsYXRpdHVkZS9sb25naXR1ZGUgY29vcmRpbmF0ZSB3aXRoXG4gICAqICAgICB0b29sdGlwIHRleHQgaW5jbHVkaW5nIHRoZSBtYWduaXR1ZGUuXG4gICAqL1xuICBfdGhpcy5jcmVhdGVFcGljZW50ZXJNYXJrZXIgPSBmdW5jdGlvbiAobGF0aXR1ZGUsIGxvbmdpdHVkZSwgbWFnbml0dWRlKSB7XG4gICAgdmFyIG1hcmtlcjtcblxuICAgIG1hcmtlciA9IEwubWFya2VyKFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSwge1xuICAgICAgekluZGV4T2Zmc2V0OiA5OSxcbiAgICAgIGljb246IEwuaWNvbih7XG4gICAgICAgIGljb25Vcmw6ICdpbWFnZXMvc3Rhci5wbmcnLFxuICAgICAgICBpY29uU2l6ZTogW19tYXJrZXJTaXplLCBfbWFya2VyU2l6ZV0sXG4gICAgICAgIGljb25BbmNob3I6IFtfbWFya2VyU2l6ZS8yLCBfbWFya2VyU2l6ZS8yXVxuICAgICAgfSlcbiAgICB9KTtcblxuICAgIGlmIChfaW50ZXJhY3RpdmUpIHtcbiAgICAgIG1hcmtlci5iaW5kUG9wdXAoW1xuICAgICAgICAnRXBpY2VudGVyIE0nLCBfZm9ybWF0dGVyLm1hZ25pdHVkZShtYWduaXR1ZGUpLFxuICAgICAgICAnPGJyLz4nLFxuICAgICAgICBfZm9ybWF0dGVyLmxvY2F0aW9uKGxhdGl0dWRlLCBsb25naXR1ZGUpXG4gICAgICBdLmpvaW4oJycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya2VyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGcmVlIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyB2aWV3IGFuZCB0aGVuIGNhbGwgZGVmYXVsdFxuICAgKiBWaWV3LmRlc3Ryb3kuXG4gICAqXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3Bvc2l0aW9uQ29udHJvbCkge1xuICAgICAgX3Bvc2l0aW9uQ29udHJvbC5yZW1vdmVGcm9tKF9tYXApO1xuICAgIH1cblxuICAgIGlmIChfc2NhbGVDb250cm9sKSB7XG4gICAgICBfc2NhbGVDb250cm9sLnJlbW92ZUZyb20oX21hcCk7XG4gICAgfVxuXG4gICAgX21hcC5yZW1vdmUoKTsgLy8gZGVzdHJveSBtYXAgYW5kIGZyZWUgcmVzb3VyY2VzXG5cblxuICAgIF9iYXNlTGF5ZXJzID0gbnVsbDtcbiAgICBfZGVmYXVsdENvbmZpZyA9IG51bGw7XG4gICAgX2Zvcm1hdHRlciA9IG51bGw7XG4gICAgX2xheWVyc0NvbnRyb2wgPSBudWxsO1xuICAgIF9tYXAgPSBudWxsO1xuICAgIF9tYXJrZXJTaXplID0gbnVsbDtcbiAgICBfbW9kdWxlID0gbnVsbDtcbiAgICBfb3ZlcmxheXMgPSBudWxsO1xuICAgIF9wb3NpdGlvbkNvbnRyb2wgPSBudWxsO1xuICAgIF9zY2FsZUNvbnRyb2wgPSBudWxsO1xuXG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5zdGFuY2UgYF9iYXNlTGF5ZXJzYCBvYmplY3QgdG8gYSBtYXAgb2YgTGF5ZXJOYW1lID0+IExheWVyIGZvclxuICAgKiBlYWNoIHN1cHBvcnRlZCBiYXNlIGxheWVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICBUaGUgdXBkYXRlZCBfYmFzZUxheWVycyBvYmplY3QuXG4gICAqL1xuICBfdGhpcy5nZXRBdmFpbGFibGVCYXNlTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIF9iYXNlTGF5ZXJzID0ge1xuICAgICAgJ1RlcnJhaW4nOiBUZXJyYWluKHtwcm92aWRlcjogVGVycmFpbi5OQVRHRU99KSxcbiAgICAgICdHcmF5c2NhbGUnOiBHcmF5c2NhbGUoKSxcbiAgICAgICdTdHJlZXQnOiBTdHJlZXQoKSxcbiAgICAgICdTYXRlbGxpdGUnOiBTYXRlbGxpdGUoKVxuICAgIH07XG5cbiAgICByZXR1cm4gX2Jhc2VMYXllcnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGluc3RhbmNlIGBfb3ZlcmxheXNgIG9iamVjdCB0byBhIG1hcCBvZiBMYXllck5hbWUgPT4gTGF5ZXIgZm9yXG4gICAqIGVhY2ggc3VwcG9ydGVkIG92ZXJsYXkgbGF5ZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgIFRoZSB1cGRhdGVkIF9vdmVybGF5cyBvYmplY3QuXG4gICAqL1xuICBfdGhpcy5nZXRBdmFpbGFibGVPdmVybGF5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2F0YWxvZ0V2ZW50LFxuICAgICAgICBldmVudExhdGl0dWRlLFxuICAgICAgICBldmVudExvbmdpdHVkZTtcblxuICAgIF9vdmVybGF5cyA9IHt9O1xuXG4gICAgY2F0YWxvZ0V2ZW50ID0gX3RoaXMubW9kZWwuZ2V0KCdldmVudCcpO1xuXG4gICAgaWYgKCFjYXRhbG9nRXZlbnQpIHtcbiAgICAgIC8vIE5vIGV2ZW50LCBubyBvdmVybGF5cyB0byBjcmVhdGVcbiAgICAgIHJldHVybiBfb3ZlcmxheXM7XG4gICAgfVxuXG4gICAgZXZlbnRMYXRpdHVkZSA9IGNhdGFsb2dFdmVudC5nZXRMYXRpdHVkZSgpO1xuICAgIGV2ZW50TG9uZ2l0dWRlID0gY2F0YWxvZ0V2ZW50LmdldExvbmdpdHVkZSgpO1xuXG4gICAgaWYgKGV2ZW50TGF0aXR1ZGUgIT09IG51bGwgJiYgZXZlbnRMb25naXR1ZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFB1dCBhIHN0YXIgb3ZlciB0aGUgZXBpY2VudGVyXG4gICAgICBfb3ZlcmxheXNbX0VQSUNFTlRFUl9PVkVSTEFZXSA9IF90aGlzLmNyZWF0ZUVwaWNlbnRlck1hcmtlcihldmVudExhdGl0dWRlLFxuICAgICAgICAgIGV2ZW50TG9uZ2l0dWRlLCBjYXRhbG9nRXZlbnQuZ2V0TWFnbml0dWRlKCkpO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBpbmNsdWRlIHRlY3RvbmljIHBsYXRlc1xuICAgIF9vdmVybGF5c1tfUExBVEVTX09WRVJMQVldID0gVGVjdG9uaWNQbGF0ZXMoKTtcblxuICAgIC8vIEluY2x1ZGUgZmF1bHRzIGxheWVyIGlmIGluIFUuUy5cbiAgICBpZiAoX19pblVzKGV2ZW50TGF0aXR1ZGUsIGV2ZW50TG9uZ2l0dWRlKSkge1xuICAgICAgX292ZXJsYXlzW19GQVVMVFNfT1ZFUkxBWV0gPSBVc0ZhdWx0KCk7XG4gICAgfVxuXG4gICAgLy8gSGlzdG9yaWMgc2Vpc21pY2l0eVxuICAgIF9vdmVybGF5c1tfSElTVF9TRUlTX09WRVJMQVldID0gSGlzdG9yaWNTZWlzbWljaXR5KCk7XG5cbiAgICAvLyBDYWxsaW5nIF9tb2R1bGUuZ2V0UHJvZHVjdCB3aWxsIGdldCB0aGUgY3VycmVudCBwcm9kdWN0IGluIHRoZVxuICAgIC8vIGNhc2UgdGhhdCBhIHNwZWNpZmljID9zb3VyY2U9JmNvZGU9IHdlcmUgcmVxdWVzdGVkLi4uXG5cbiAgICAvLyBEWUZJXG4gICAgX3RoaXMuZ2V0UHJvZHVjdE92ZXJsYXlzKCdkeWZpJywgX3RoaXMuYWRkRHlmaU92ZXJsYXlzKTtcblxuICAgIC8vIFNoYWtlTWFwXG4gICAgX3RoaXMuZ2V0UHJvZHVjdE92ZXJsYXlzKCdzaGFrZW1hcCcsIF90aGlzLmFkZFNoYWtlTWFwT3ZlcmxheXMpO1xuXG4gICAgcmV0dXJuIF9vdmVybGF5cztcbiAgfTtcblxuICBfdGhpcy5nZXRQcm9kdWN0T3ZlcmxheXMgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgY2F0YWxvZ0V2ZW50LFxuICAgICAgICBjb2RlS2V5LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHByb2R1Y3QsXG4gICAgICAgIHNvdXJjZUtleTtcblxuICAgIGNhdGFsb2dFdmVudCA9IF90aGlzLm1vZGVsLmdldCgnZXZlbnQnKTtcblxuICAgIGlmICghY2F0YWxvZ0V2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnID0gVXRpbC5leHRlbmQoe30sIF9kZWZhdWx0Q29uZmlnLCBfdGhpcy5tb2RlbC5nZXQoJ21hcCcpKTtcbiAgICBzb3VyY2VLZXkgPSB0eXBlICsgJ1NvdXJjZSc7XG4gICAgY29kZUtleSA9IHR5cGUgKyAnQ29kZSc7XG4gICAgdHlwZSA9IFByb2R1Y3QuZ2V0RnVsbFR5cGUodHlwZSwgX21vZHVsZS5tb2RlbC5nZXQoJ2NvbmZpZycpKTtcblxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoc291cmNlS2V5KSAmJlxuICAgICAgICBjb25maWcuaGFzT3duUHJvcGVydHkoY29kZUtleSkpIHtcbiAgICAgIHByb2R1Y3QgPSBjYXRhbG9nRXZlbnQuZ2V0UHJvZHVjdEJ5SWQodHlwZSwgY29uZmlnW3NvdXJjZUtleV0sXG4gICAgICAgICAgY29uZmlnW2NvZGVLZXldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZHVjdCA9IGNhdGFsb2dFdmVudC5nZXRQcmVmZXJyZWRQcm9kdWN0KHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBjYWxsYmFjayhwcm9kdWN0KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBDYWxsZWQgdG8gbm90aWZ5IHRoZSB2aWV3IHRoYXQgaXQncyBlbGVtZW50IGlzIG5vdyBpbiB0aGUgRE9NIHNvXG4gICAqIHRoaW5ncyBsaWtlIGRpbWVuc2lvbnMgY2FuIGJlIGluc3BlY3RlZCBldGMuLi5cbiAgICpcbiAgICovXG4gIF90aGlzLm9uRG9tUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9tYXAgJiYgX21hcC5nZXRDb250YWluZXIoKSAmJiBfbWFwLmdldENvbnRhaW5lcigpLnBhcmVudE5vZGUpIHtcbiAgICAgIF9tYXAuaW52YWxpZGF0ZVNpemUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG1hcC5cbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2F0YWxvZ0V2ZW50LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGU7XG5cbiAgICBjb25maWcgPSBVdGlsLmV4dGVuZCh7fSwgX2RlZmF1bHRDb25maWcsIF90aGlzLm1vZGVsLmdldCgnbWFwJykpO1xuXG4gICAgT2JqZWN0LmtleXMoX2Jhc2VMYXllcnMpLmZvckVhY2goZnVuY3Rpb24gKGxheWVyTmFtZSkge1xuICAgICAgdmFyIGxheWVyO1xuXG4gICAgICBsYXllciA9IF9iYXNlTGF5ZXJzW2xheWVyTmFtZV07XG5cbiAgICAgIGlmIChsYXllci5tYXApIHtcbiAgICAgICAgbGF5ZXIucmVtb3ZlRnJvbShfbWFwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxheWVyTmFtZSA9PT0gY29uZmlnLmJhc2VMYXllcikge1xuICAgICAgICBsYXllci5hZGRUbyhfbWFwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF90aGlzLnVwZGF0ZU92ZXJsYXlzKGNvbmZpZyk7XG5cblxuICAgIC8vIFpvb20gdG8gYSB0d28tZGVncmVlIG1hcCBjZW50ZXJlZCBvbiBldmVudFxuICAgIGNhdGFsb2dFdmVudCA9IF90aGlzLm1vZGVsLmdldCgnZXZlbnQnKTtcbiAgICBpZiAoY2F0YWxvZ0V2ZW50KSB7XG4gICAgICBsYXRpdHVkZSA9IGNhdGFsb2dFdmVudC5nZXRMYXRpdHVkZSgpO1xuICAgICAgbG9uZ2l0dWRlID0gY2F0YWxvZ0V2ZW50LmdldExvbmdpdHVkZSgpO1xuICAgICAgX21hcC5maXRCb3VuZHMoW1tsYXRpdHVkZSArIDIuMCwgbG9uZ2l0dWRlICsgMi4wXSxcbiAgICAgICAgICBbbGF0aXR1ZGUgLSAyLjAsIGxvbmdpdHVkZSAtIDIuMF1dKTtcbiAgICB9XG4gIH07XG5cbiAgX3RoaXMudXBkYXRlT3ZlcmxheXMgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgLy8gQ2xlYXIgZXhpc3Rpbmcgb3ZlcmxheXMgKGlmIGFueSlcbiAgICBPYmplY3Qua2V5cyhfb3ZlcmxheXMpLmZvckVhY2goZnVuY3Rpb24gKGxheWVyTmFtZSkge1xuICAgICAgdmFyIGxheWVyO1xuXG4gICAgICBsYXllciA9IF9vdmVybGF5c1tsYXllck5hbWVdO1xuXG4gICAgICBpZiAobGF5ZXIuX21hcCkge1xuICAgICAgICBfbWFwLnJlbW92ZUxheWVyKGxheWVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9sYXllcnNDb250cm9sICYmIF9sYXllcnNDb250cm9sLl9sYXllcnMuaGFzT3duUHJvcGVydHkobGF5ZXJOYW1lKSkge1xuICAgICAgICBfbGF5ZXJzQ29udHJvbC5yZW1vdmVMYXllcihsYXllcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfdGhpcy5nZXRBdmFpbGFibGVPdmVybGF5cygpO1xuXG4gICAgLy8gTm93IGFkZCBlYWNoIG92ZXJsYXkgdG8gY29udHJvbCBhbmQgcG90ZW50aWFsbHkgYWRkIHRvIG1hcCBpZiBzb1xuICAgIC8vIGNvbmZpZ3VyZWRcbiAgICBPYmplY3Qua2V5cyhfb3ZlcmxheXMpLmZvckVhY2goZnVuY3Rpb24gKGxheWVyTmFtZSkge1xuICAgICAgdmFyIGxheWVyO1xuXG4gICAgICBsYXllciA9IF9vdmVybGF5c1tsYXllck5hbWVdO1xuXG4gICAgICBpZiAoX2xheWVyc0NvbnRyb2wpIHtcbiAgICAgICAgX2xheWVyc0NvbnRyb2wuYWRkT3ZlcmxheShsYXllciwgbGF5ZXJOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZ1tsYXllck5hbWVdID09PSAndHJ1ZScpIHtcbiAgICAgICAgbGF5ZXIuYWRkVG8oX21hcCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cbi8vIEV4cG9zZSB0aGVzZSBzbyBvdGhlcnMga25vdyB0aGUgbGF5ZXJzIGF2YWlsYWJsZVxuSW50ZXJhY3RpdmVNYXBWaWV3LkRZRklfMTBLX09WRVJMQVkgPSBfRFlGSV8xMEtfT1ZFUkxBWTtcbkludGVyYWN0aXZlTWFwVmlldy5EWUZJXzFLX09WRVJMQVkgPSBfRFlGSV8xS19PVkVSTEFZO1xuSW50ZXJhY3RpdmVNYXBWaWV3LkRZRklfREVGQVVMVF9PVkVSTEFZID0gX0RZRklfREVGQVVMVF9PVkVSTEFZO1xuSW50ZXJhY3RpdmVNYXBWaWV3LkVQSUNFTlRFUl9PVkVSTEFZID0gX0VQSUNFTlRFUl9PVkVSTEFZO1xuSW50ZXJhY3RpdmVNYXBWaWV3LkZBVUxUU19PVkVSTEFZID0gX0ZBVUxUU19PVkVSTEFZO1xuSW50ZXJhY3RpdmVNYXBWaWV3LkhJU1RfU0VJU19PVkVSTEFZID0gX0hJU1RfU0VJU19PVkVSTEFZO1xuSW50ZXJhY3RpdmVNYXBWaWV3LlBMQVRFU19PVkVSTEFZID0gX1BMQVRFU19PVkVSTEFZO1xuSW50ZXJhY3RpdmVNYXBWaWV3LlBPUFVMQVRJT05fT1ZFUkxBWSA9IF9QT1BVTEFUSU9OX09WRVJMQVk7XG5JbnRlcmFjdGl2ZU1hcFZpZXcuU0hBS0VNQVBfQ09OVE9VUlMgPSBfU0hBS0VNQVBfQ09OVE9VUlM7XG5JbnRlcmFjdGl2ZU1hcFZpZXcuU0hBS0VNQVBfU1RBVElPTlMgPSBfU0hBS0VNQVBfU1RBVElPTlM7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmFjdGl2ZU1hcFZpZXc7XG4iLCIvKiBnbG9iYWwgTCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBGb3JtYXR0ZXIgPSByZXF1aXJlKCdjb3JlL0Zvcm1hdHRlcicpLFxuICAgIFhociA9IHJlcXVpcmUoJ3V0aWwvWGhyJyk7XG5cblxudmFyIEZMQUdfREVTQ1JJUFRJT05TID0ge1xuICAnTSc6ICdNYW51YWxseSBmbGFnZ2VkJyxcbiAgJ1QnOiAnT3V0bGllcicsXG4gICdHJzogJ0dsaXRjaCAoY2xpcHBlZCBvciBiZWxvdyBub2lzZSknLFxuICAnSSc6ICdJbmNvbXBsZXRlIHRpbWUgc2VyaWVzJyxcbiAgJ04nOiAnTm90IGluIGxpc3Qgb2Yga25vd24gc3RhdGlvbnMnXG59O1xuXG5cbnZhciBTaGFrZU1hcFN0YXRpb25MYXllciA9IEwuR2VvSlNPTi5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChzdGF0aW9uSnNvbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9mb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKCk7XG4gICAgdGhpcy5fbGF5ZXJzID0ge307XG5cbiAgICB0aGlzLnN0YXRpb25VUkwgPSBzdGF0aW9uSnNvbjtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgcG9pbnRUb0xheWVyOiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF0bG5nKSB7XG4gICAgICAgIHZhciBwID0gZmVhdHVyZS5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgcm9tYW5JbnRlbnNpdHkgPSBfdGhpcy5fZm9ybWF0dGVyLm1taShwLmludGVuc2l0eSk7XG5cbiAgICAgICAgaWYgKHAubmV0d29yayA9PT0gJ0RZRkknIHx8IHAubmV0d29yayA9PT0gJ0lOVEVOU0lUWScpIHtcbiAgICAgICAgICByZXR1cm4gTC5tYXJrZXIobGF0bG5nLCB7XG4gICAgICAgICAgICBpY29uOiBMLmRpdkljb24oe1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdkeWZpLWxheWVyLWljb24gZHlmaS1zdGF0aW9uLW1taScrcm9tYW5JbnRlbnNpdHkrJycsXG4gICAgICAgICAgICAgIGljb25TaXplOiBbMTQsIDE0XSxcbiAgICAgICAgICAgICAgaWNvbkFuY2hvcjogWzcsIDddLFxuICAgICAgICAgICAgICBwb3B1cEFuY2hvcjogWzAsIDBdXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBMLm1hcmtlcihsYXRsbmcsIHtcbiAgICAgICAgICAgIGljb246IEwuZGl2SWNvbih7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3N0YXRpb24tbGF5ZXItaWNvbiBzdGF0aW9uLW1taScrcm9tYW5JbnRlbnNpdHkrJycsXG4gICAgICAgICAgICAgIGljb25TaXplOiBbMTQsIDEwXSxcbiAgICAgICAgICAgICAgaWNvbkFuY2hvcjogWzcsIDhdLFxuICAgICAgICAgICAgICBwb3B1cEFuY2hvcjogWzAsIC00XVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb25FYWNoRmVhdHVyZTogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7XG4gICAgICAgIGxheWVyLm9wdGlvbnMudGl0bGUgPSBfdGhpcy5fZm9ybWF0VGl0bGUoZmVhdHVyZSwgdHJ1ZSk7XG4gICAgICAgIGxheWVyLmJpbmRQb3B1cChfdGhpcy5fZ2VuZXJhdGVQb3B1cENvbnRlbnQoZmVhdHVyZSksXG4gICAgICAgICAgICB7bWluV2lkdGg6MzAwfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgIGlmICh0aGlzLmRhdGEgPT09IG51bGwpIHtcbiAgICAgIFhoci5hamF4KHtcbiAgICAgICAgdXJsOiB0aGlzLnN0YXRpb25VUkwsXG4gICAgICAgIHN1Y2Nlc3M6IChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGxheWVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgbGF5ZXIuYWRkRGF0YShkYXRhKTtcbiAgICAgICAgICAgIEwuTGF5ZXJHcm91cC5wcm90b3R5cGUub25BZGQuY2FsbChsYXllciwgbWFwKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRGF0YSh0aGlzLmRhdGEpO1xuICAgICAgTC5MYXllckdyb3VwLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgfVxuICB9LFxuXG4gIF9nZW5lcmF0ZVBvcHVwQ29udGVudDogZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICB2YXIgcCA9IGZlYXR1cmUucHJvcGVydGllcyxcbiAgICAgICAgcm9tYW5JbnRlbnNpdHkgPSB0aGlzLl9mb3JtYXR0ZXIubW1pKHAuaW50ZW5zaXR5KTtcblxuICAgIHZhciBtYXJrdXAgPSBbJzxkaXYgY2xhc3M9XCJzdGF0aW9uLXBvcHVwXCI+JyxcbiAgICAgICc8aDIgY2xhc3M9XCJzdGF0aW9uLXRpdGxlXCI+JywgdGhpcy5fZm9ybWF0VGl0bGUoZmVhdHVyZSksICc8L2gyPicsXG4gICAgICAnPHVsIGNsYXNzPVwic3RhdGlvbi1zdW1tYXJ5XCI+JyxcbiAgICAgICAgJzxsaSBjbGFzcz1cInN0YXRpb24tc3VtbWFyeS1pbnRlbnNpdHkgcm9tYW4gbW1pJywgcm9tYW5JbnRlbnNpdHksICdcIj4nLFxuICAgICAgICAgIHJvbWFuSW50ZW5zaXR5LFxuICAgICAgICAgICc8YnI+PGFiYnIgdGl0bGU9XCJNb2RpZmllZCBNZXJjYWxsaSBJbnRlbnNpdHlcIj5tbWk8L2FiYnI+PC9icj4nLFxuICAgICAgICAnPC9saT4nLFxuICAgICAgICAnPGxpIGNsYXNzPVwic3RhdGlvbi1zdW1tYXJ5LXBnYVwiPicsXG4gICAgICAgICAgdGhpcy5fZm9ybWF0dGVyLm51bWJlcihwLnBnYSwgMywgJyZuZGFzaDsnKSxcbiAgICAgICAgICAnPGJyPjxhYmJyIHRpdGxlPVwiTWF4aW11bSBIb3Jpem9udGFsIFBlYWsgR3JvdW5kIFZlbG9jaXR5ICglZylcIj5wZ2E8L2FiYnI+PC9icj4nLFxuICAgICAgICAnPC9saT4nLFxuICAgICAgICAnPGxpIGNsYXNzPVwic3RhdGlvbi1zdW1tYXJ5LXBndlwiPicsXG4gICAgICAgICAgdGhpcy5fZm9ybWF0dGVyLm51bWJlcihwLnBndiwgMywgJyZuZGFzaDsnKSxcbiAgICAgICAgICAnPGJyPjxhYmJyIHRpdGxlPVwiTWF4aW11bSBIb3Jpem9udGFsIFBlYWsgR3JvdW5kIFZlbG9jaXR5IChjbS9zKVwiPnBndjwvYWJicj48L2JyPicsXG4gICAgICAgICc8L2xpPicsXG4gICAgICAgICc8bGkgY2xhc3M9XCJzdGF0aW9uLXN1bW1hcnktZGlzdGFuY2VcIj4nLFxuICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlci5udW1iZXIocC5kaXN0YW5jZSwgMSwgJyZuZGFzaDsnKSwnIGttJyxcbiAgICAgICAgICAnPGJyPjxhYmJyIHRpdGxlPVwiRGlzdGFuY2UgKGttKVwiPmRpc3Q8L2FiYnI+PC9icj4nLFxuICAgICAgICAnPC9saT4nLFxuICAgICAgJzwvdWw+JyxcbiAgICAgICc8ZGwgY2xhc3M9XCJzdGF0aW9uLW1ldGFkYXRhIGhvcml6b250YWxcIj4nLFxuICAgICAgICAnPGR0IGNsYXNzPVwic3RhdGlvbi1tZXRhZGF0YS10eXBlXCI+VHlwZTwvZHQ+JyxcbiAgICAgICAgICAnPGRkIGNsYXNzPVwic3RhdGlvbi1tZXRhZGF0YS10eXBlXCI+JyxcbiAgICAgICAgICAgIChwLmluc3RydW1lbnRUeXBlfHwnJm5kYXNoOycpLFxuICAgICAgICAgICc8L2RkPicsXG4gICAgICAgICc8ZHQgY2xhc3M9XCJzdGF0aW9uLW1ldGFkYXRhLWxvY2F0aW9uXCI+TG9jYXRpb248L2R0PicsXG4gICAgICAgICAgJzxkZCBjbGFzcz1cInN0YXRpb24tbWV0YWRhdGEtbG9jYXRpb25cIj4nLFxuICAgICAgICAgICAgdGhpcy5fZm9ybWF0TG9jYXRpb24oZmVhdHVyZSksXG4gICAgICAgICAgJzwvZGQ+JyxcbiAgICAgICAgJzxkdCBjbGFzcz1cInN0YXRpb24tbWV0YWRhdGEtc291cmNlXCI+U291cmNlPC9kdD4nLFxuICAgICAgICAgICc8ZGQgY2xhc3M9XCJzdGF0aW9uLW1ldGFkYXRhLXNvdXJjZVwiPicsIChwLnNvdXJjZSB8fCAnJm5kYXNoOycpLCAnPC9kZD4nLFxuICAgICAgICAnPGR0IGNsYXNzPVwic3RhdGlvbi1tZXRhZGF0YS1pbnRlbnNpdHlcIj5JbnRlbnNpdHk8L2R0PicsXG4gICAgICAgICAgJzxkZCBjbGFzcz1cInN0YXRpb24tbWV0YWRhdGEtaW50ZW5zaXR5XCI+JyxcbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlci5udW1iZXIocC5pbnRlbnNpdHksIDEsICcmbmRhc2g7JyksXG4gICAgICAgICAgJzwvZGQ+JyxcbiAgICAgICc8L2RsPicsXG4gICAgICB0aGlzLl9jcmVhdGVDaGFubmVsVGFibGUocC5jaGFubmVscyksXG4gICAgJzwvZGl2PiddO1xuXG4gICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgfSxcblxuICBfY3JlYXRlQ2hhbm5lbFRhYmxlOiBmdW5jdGlvbiAoY2hhbm5lbHMpIHtcbiAgICB2YXIgaSA9IDAsIG51bUNoYW5uZWxzID0gY2hhbm5lbHMubGVuZ3RoO1xuXG4gICAgdmFyIG1hcmt1cCA9IFtcbiAgICAgICc8dGFibGUgY2xhc3M9XCJzdGF0aW9uLWNoYW5uZWxzLW1hcFwiPicsXG4gICAgICAgICc8dGhlYWQ+JyxcbiAgICAgICAgICAnPHRyPicsXG4gICAgICAgICAgICAnPHRoIHNjb3BlPVwiY29sXCIgY2xhc3M9XCJzdGF0aW9uLWNoYW5uZWxzLW1hcC1uYW1lXCI+bmFtZTwvdGg+JyxcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIiBjbGFzcz1cInN0YXRpb24tY2hhbm5lbHMtbWFwLXBnYVwiPnBnYTwvdGg+JyxcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIiBjbGFzcz1cInN0YXRpb24tY2hhbm5lbHMtbWFwLXBndlwiPnBndjwvdGg+JyxcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIiBjbGFzcz1cInN0YXRpb24tY2hhbm5lbHMtbWFwLXBzYTAzXCI+cHNhMDM8L3RoPicsXG4gICAgICAgICAgICAnPHRoIHNjb3BlPVwiY29sXCIgY2xhc3M9XCJzdGF0aW9uLWNoYW5uZWxzLW1hcC1wc2ExMFwiPnBzYTEwPC90aD4nLFxuICAgICAgICAgICAgJzx0aCBzY29wZT1cImNvbFwiIGNsYXNzPVwic3RhdGlvbi1jaGFubmVscy1tYXAtcHNhMzBcIj5wc2EzMDwvdGg+JyxcbiAgICAgICAgICAnPC90cj4nLFxuICAgICAgICAnPC90aGVhZD4nLFxuICAgICAgICAnPHRib2R5PidcbiAgICBdO1xuXG4gICAgZm9yICg7IGkgPCBudW1DaGFubmVsczsgaSsrKSB7XG4gICAgICBtYXJrdXAucHVzaCh0aGlzLl9jcmVhdGVDaGFubmVsUm93KGNoYW5uZWxzW2ldKSk7XG4gICAgfVxuXG4gICAgbWFya3VwLnB1c2goJzwvdGJvZHk+PC90YWJsZT4nKTtcblxuICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gIH0sXG5cbiAgX2NyZWF0ZUFtcGxpdHVkZXNPYmplY3Q6IGZ1bmN0aW9uIChhbXBsaXR1ZGVzKSB7XG4gICAgdmFyIGFtcCA9IHt9LFxuICAgICAgICBpLFxuICAgICAgICBsZW4gPSBhbXBsaXR1ZGVzLmxlbmd0aCxcbiAgICAgICAgYW1wbGl0dWRlID0gbnVsbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYW1wbGl0dWRlID0gYW1wbGl0dWRlc1tpXTtcbiAgICAgIGFtcFthbXBsaXR1ZGUubmFtZV0gPSBhbXBsaXR1ZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFtcDtcbiAgfSxcblxuICBfY3JlYXRlQ2hhbm5lbFJvdzogZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICB2YXIgYW1wbGl0dWRlID0gdGhpcy5fY3JlYXRlQW1wbGl0dWRlc09iamVjdChjaGFubmVsLmFtcGxpdHVkZXMpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICc8dHI+JyxcbiAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiIGNsYXNzPVwic3RhdGlvbi1jaGFubmVsLW5hbWVcIj4nLFxuICAgICAgICAgIGNoYW5uZWwubmFtZSxcbiAgICAgICAgJzwvdGg+JyxcbiAgICAgICAgJzx0ZCBjbGFzcz1cInN0YXRpb24tY2hhbm5lbC1wZ2FcIj4nLFxuICAgICAgICB0aGlzLl9mb3JtYXRDb21wb25lbnQoYW1wbGl0dWRlLnBnYSksXG4gICAgICAgICc8L3RkPicsXG4gICAgICAgICc8dGQgY2xhc3M9XCJzdGF0aW9uLWNoYW5uZWwtcGd2XCI+JyxcbiAgICAgICAgdGhpcy5fZm9ybWF0Q29tcG9uZW50KGFtcGxpdHVkZS5wZ3YpLFxuICAgICAgICAnPC90ZD4nLFxuICAgICAgICAnPHRkIGNsYXNzPVwic3RhdGlvbi1jaGFubmVsLXBzYTAzXCI+JyxcbiAgICAgICAgICB0aGlzLl9mb3JtYXRDb21wb25lbnQoYW1wbGl0dWRlLnBzYTAzKSxcbiAgICAgICAgJzx0ZCBjbGFzcz1cInN0YXRpb24tY2hhbm5lbC1wc2ExMFwiPicsXG4gICAgICAgICAgdGhpcy5fZm9ybWF0Q29tcG9uZW50KGFtcGxpdHVkZS5wc2ExMCksXG4gICAgICAgICc8L3RkPicsXG4gICAgICAgICc8dGQgY2xhc3M9XCJzdGF0aW9uLWNoYW5uZWwtcHNhMzBcIj4nLFxuICAgICAgICAgIHRoaXMuX2Zvcm1hdENvbXBvbmVudChhbXBsaXR1ZGUucHNhMzApLFxuICAgICAgICAnPC90ZD4nLFxuICAgICAgJzwvdHI+J1xuICAgIF0uam9pbignJyk7XG4gIH0sXG5cbiAgX2Zvcm1hdFRpdGxlOiBmdW5jdGlvbiAoZmVhdHVyZSwgcGxhaW5UZXh0KSB7XG4gICAgdmFyIHAgPSBmZWF0dXJlLnByb3BlcnRpZXM7XG5cbiAgICB2YXIgdGl0bGUgPSBbXTtcblxuICAgIGlmICghcGxhaW5UZXh0KSB7IHRpdGxlLnB1c2goJzxzcGFuIGNsYXNzPVwic3RhdGlvbi1jb2RlXCI+Jyk7IH1cbiAgICB0aXRsZS5wdXNoKHAuY29kZSB8fCAnJm5kYXNoOycpO1xuICAgIGlmICghcGxhaW5UZXh0KSB7IHRpdGxlLnB1c2goJzwvc3Bhbj4nKTsgfVxuXG4gICAgdGl0bGUucHVzaCgnICcpO1xuXG4gICAgaWYgKCFwbGFpblRleHQpIHsgdGl0bGUucHVzaCgnPHNwYW4gY2xhc3M9XCJzdGF0aW9uLW5hbWVcIj4nKTsgfVxuICAgIHRpdGxlLnB1c2gocC5uYW1lIHx8ICcmbmRhc2g7Jyk7XG4gICAgaWYgKCFwbGFpblRleHQpIHsgdGl0bGUucHVzaCgnPC9zcGFuPicpOyB9XG5cbiAgICByZXR1cm4gdGl0bGUuam9pbignJyk7XG4gIH0sXG5cbiAgX2Zvcm1hdExvY2F0aW9uOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgIHJldHVybiAoKGZlYXR1cmUucHJvcGVydGllcy5sb2NhdGlvbikgP1xuICAgICAgICAoZmVhdHVyZS5wcm9wZXJ0aWVzLmxvY2F0aW9uICsgJzxici8+JykgOiAnJykgKyAnICgnICtcbiAgICAgICAgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSArICcsICcgK1xuICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdICsgJyknO1xuICB9LFxuXG4gIF9mb3JtYXRDb21wb25lbnQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBbXSxcbiAgICAgICAgZmxhZyxcbiAgICAgICAgdmFsdWU7XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgZmxhZyA9IGRhdGEuZmxhZztcbiAgICAgIHZhbHVlID0gZGF0YS52YWx1ZTtcblxuICAgICAgLy8gQWRkIGZsYWcgY2xhc3MgZm9yIGFsbCBub24temVybyBmbGFnc1xuICAgICAgaWYgKGZsYWcgJiYgZmxhZyAhPT0gJzAnKSB7XG4gICAgICAgIGNvbnRlbnQucHVzaCgnPHNwYW4gY2xhc3M9XCJzdGF0aW9uLWZsYWdcIj4nKTtcbiAgICAgICAgY29udGVudC5wdXNoKHBhcnNlRmxvYXQodmFsdWUsIDEwKS50b0ZpeGVkKDMpKTtcblxuICAgICAgICAvLyBkaXNwbGF5IGZsYWcgd2l0aCB0aXRsZSB0ZXh0XG4gICAgICAgIGlmIChGTEFHX0RFU0NSSVBUSU9OUy5oYXNPd25Qcm9wZXJ0eShmbGFnKSkge1xuICAgICAgICAgIGNvbnRlbnQucHVzaCgnPGFiYnIgdGl0bGU9XCInICsgRkxBR19ERVNDUklQVElPTlNbZmxhZ10gKyAnXCI+KCcgK1xuICAgICAgICAgICAgICBmbGFnICsgJyk8L2FiYnI+Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudC5wdXNoKCcoJyArIGZsYWcgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQucHVzaCgnPC9zcGFuPicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudC5wdXNoKCc8c3Bhbj4nKTtcbiAgICAgICAgY29udGVudC5wdXNoKHBhcnNlRmxvYXQodmFsdWUsIDEwKS50b0ZpeGVkKDMpKTtcbiAgICAgICAgY29udGVudC5wdXNoKCc8L3NwYW4+Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQucHVzaCgnPHNwYW4+Jm5kYXNoOzwvc3Bhbj4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudC5qb2luKCcnKTtcbiAgfVxufSk7XG5cblxuTC5TaGFrZU1hcFN0YXRpb25MYXllciA9IFNoYWtlTWFwU3RhdGlvbkxheWVyO1xuXG5MLnNoYWtlTWFwU3RhdGlvbkxheWVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTaGFrZU1hcFN0YXRpb25MYXllcihvcHRpb25zKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMLnNoYWtlTWFwU3RhdGlvbkxheWVyO1xuIiwiLyogVGhpcyBpcyBiYXNlZCBvbiBjb2RlIGluIEdNVCwgdXRpbG1lY2EuYy4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbnZhcyA9IHJlcXVpcmUoJ21vbWVudC10ZW5zb3IvQ2FudmFzJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIFZpZXcgPSByZXF1aXJlKCdtdmMvVmlldycpO1xuXG5cbnZhciBfRDJSLFxuICAgIF9ERUZBVUxUUyxcbiAgICBfRVBTSUxPTixcbiAgICBfTUVSR0VfVEhSRVNIT0xELFxuICAgIF9SMkQsXG4gICAgX1NQTElUX1RIUkVTSE9MRDtcblxuX0QyUiA9IE1hdGguUEkgLyAxODA7XG5fUjJEID0gMTgwIC8gTWF0aC5QSTtcblxuX0VQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNjtcblxuLy8gdGhyZXNob2xkIHggYW5kIHkgcGl4ZWwgZGlmZmVyZW5jZSB3aGVuIHBvbHlnb25zIHNob3VsZCBiZSBtZXJnZWQuXG4vLyBQaXhlbHMgYXJlIGluIHRoZSByYW5nZSBbLTEsIDFdLCBzbyAwLjAyIHJlcHJlc2VudHMgYSAxJSBkaWZmZXJlbmNlLlxuX01FUkdFX1RIUkVTSE9MRCA9IDAuMDI7XG5cbi8vIHRocmVzaG9sZCB0YWtlb2ZmIGFuZ2xlIHdoZW4gcG9seWdvbnMgc2hvdWxkIGJlIHNwbGl0LlxuX1NQTElUX1RIUkVTSE9MRCA9IDg1ICogX0QyUjtcblxuX0RFRkFVTFRTID0ge1xuICBheGlzU2l6ZTogbnVsbCxcbiAgYmdDb2xvcjogJyNmZmYnLFxuICBmaWxsQ29sb3I6ICcjZGRkJyxcbiAgaGVpZ2h0OiBudWxsLFxuICBsYWJlbEF4ZXM6IHRydWUsXG4gIGxhYmVsQXhlc0ZvbnQ6ICcyNHB4IEFyaWFsJyxcbiAgbGFiZWxQbGFuZXM6IHRydWUsXG4gIGxhYmVsUGxhbmVzRm9udDogJzE0cHggQXJpYWwnLFxuICBsaW5lQ29sb3I6ICcjMDAwJyxcbiAgbGluZVdpZHRoOiAwLjI1LFxuICBwbG90QXhlczogZmFsc2UsXG4gIHBsb3RQbGFuZXM6IHRydWUsXG4gIHJhZGl1czogbnVsbCxcbiAgc2l6ZTogMjAwLFxuICB0ZW5zb3I6IG51bGwsXG4gIHdpZHRoOiBudWxsLFxuICB4MDogbnVsbCxcbiAgeTA6IG51bGxcbn07XG5cblxuLyoqXG4gKiBNYWtlIHN1cmUgbnVtYmVyIGlzIGJldHdlZW4gMCBhbmQgMnBpLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfVxuICogICAgIGFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiAgICAgYW5nbGUgaW4gcmFkaWFucywgaW4gdGhlIHJhbmdlIFswLCAycGkpLlxuICovXG52YXIgX18wVG8yUGkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHR3b1BpO1xuXG4gIHR3b1BpID0gMiAqIE1hdGguUEk7XG4gIHdoaWxlICh2YWx1ZSA8IDApIHtcbiAgICB2YWx1ZSArPSB0d29QaTtcbiAgfVxuICB3aGlsZSAodmFsdWUgPj0gdHdvUGkpIHtcbiAgICB2YWx1ZSAtPSB0d29QaTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdHJpZyB2YWx1ZXMgb2YgYXhpcy5cbiAqXG4gKiBAcGFyYW0gYXhpcyB7VmVjdG9yM31cbiAqICAgICAgICBwcmluY2lwYWwgYXhpcywgd2l0aCB2YWx1ZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCB0aGVzZSBrZXlzOlxuICogICAgICAgICB2OiB2YWx1ZSxcbiAqICAgICAgICAgYTogYXppbXV0aCxcbiAqICAgICAgICAgY2E6IGNvcyhhemltdXRoKSxcbiAqICAgICAgICAgc2E6IHNpbihhemltdXRoKSxcbiAqICAgICAgICAgcDogcGx1bmdlLFxuICogICAgICAgICBjcDogY29zKHBsdW5nZSksXG4gKiAgICAgICAgIHNwOiBzaW4ocGx1bmdlKS5cbiAqL1xudmFyIF9fYXhpc0NhY2hlID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgdmFyIGF6aW11dGgsXG4gICAgICBwbHVuZ2U7XG5cbiAgLy8gVmVjdG9yIGF6aW11dGggbWV0aG9kIHJldHVybnMgY2xvY2t3aXNlIGZyb20gbm9ydGhcbiAgLy8gY29kZSBpbiB0aGlzIGZpbGUgZXhwZWN0cyBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIGVhc3RcbiAgYXppbXV0aCA9IChNYXRoLlBJIC8gMikgLSBheGlzLmF6aW11dGgoKTtcbiAgcGx1bmdlID0gYXhpcy5wbHVuZ2UoKTtcbiAgLy8gbWFrZSBheGlzIHBsdW5nZSBkb3dud2FyZCAobmVnYXRpdmUgdmFsdWVzIGFyZSB1cClcbiAgaWYgKHBsdW5nZSA8IDApIHtcbiAgICBwbHVuZ2UgKj0gLTE7XG4gICAgYXppbXV0aCArPSBNYXRoLlBJO1xuICB9XG4gIC8vIG1ha2UgYXppbXV0aCBpbiByYW5nZSBbMCwgMipQSSlcbiAgYXppbXV0aCA9IF9fMFRvMlBpKGF6aW11dGgsIDAsIE1hdGguUEkgKiAyKTtcblxuICByZXR1cm4ge1xuICAgIHY6IGF4aXMuZWlnZW52YWx1ZSxcbiAgICBhOiBhemltdXRoLFxuICAgIGNhOiBNYXRoLmNvcyhhemltdXRoKSxcbiAgICBzYTogTWF0aC5zaW4oYXppbXV0aCksXG4gICAgcDogcGx1bmdlLFxuICAgIGNwOiBNYXRoLmNvcyhwbHVuZ2UpLFxuICAgIHNwOiBNYXRoLnNpbihwbHVuZ2UpXG4gIH07XG59O1xuXG5cbnZhciBCZWFjaEJhbGxWaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9heGlzU2l6ZSxcbiAgICAgIF9iZ0NvbG9yLFxuICAgICAgX2NhbnZhcyxcbiAgICAgIF9maWxsQ29sb3IsXG4gICAgICBfaGVpZ2h0LFxuICAgICAgX2xhYmVsQXhlcyxcbiAgICAgIF9sYWJlbEF4ZXNGb250LFxuICAgICAgX2xhYmVsUGxhbmVzLFxuICAgICAgX2xhYmVsUGxhbmVzRm9udCxcbiAgICAgIF9saW5lQ29sb3IsXG4gICAgICBfbGluZVdpZHRoLFxuICAgICAgX3Bsb3RBeGVzLFxuICAgICAgX3Bsb3RQbGFuZXMsXG4gICAgICBfcmFkaXVzLFxuICAgICAgX3NpemUsXG4gICAgICBfdGVuc29yLFxuICAgICAgX3dpZHRoLFxuICAgICAgX3gwLFxuICAgICAgX3kwO1xuXG4gIF90aGlzID0gVmlldyhvcHRpb25zKTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuXG4gICAgX2JnQ29sb3IgPSBvcHRpb25zLmJnQ29sb3I7XG4gICAgX2ZpbGxDb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yO1xuICAgIF9sYWJlbEF4ZXMgPSBvcHRpb25zLmxhYmVsQXhlcztcbiAgICBfbGFiZWxBeGVzRm9udCA9IG9wdGlvbnMubGFiZWxBeGVzRm9udDtcbiAgICBfbGFiZWxQbGFuZXMgPSBvcHRpb25zLmxhYmVsUGxhbmVzO1xuICAgIF9sYWJlbFBsYW5lc0ZvbnQgPSBvcHRpb25zLmxhYmVsUGxhbmVzRm9udDtcbiAgICBfbGluZUNvbG9yID0gb3B0aW9ucy5saW5lQ29sb3I7XG4gICAgX2xpbmVXaWR0aCA9IG9wdGlvbnMubGluZVdpZHRoO1xuICAgIF9wbG90QXhlcyA9IG9wdGlvbnMucGxvdEF4ZXM7XG4gICAgX3Bsb3RQbGFuZXMgPSBvcHRpb25zLnBsb3RQbGFuZXM7XG4gICAgX3NpemUgPSBvcHRpb25zLnNpemU7XG4gICAgX3RlbnNvciA9IG9wdGlvbnMudGVuc29yO1xuXG4gICAgLy8gb3B0aW9ucyB3aXRoIGNvbXB1dGVkIGRlZmF1bHRzXG4gICAgX3JhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IHBhcnNlSW50KChfc2l6ZSAtIDIpIC8gMiwgMTApO1xuICAgIF9heGlzU2l6ZSA9IG9wdGlvbnMuYXhpc1NpemUgfHwgcGFyc2VJbnQoX3JhZGl1cyAvIDEyLjUsIDEwKTtcbiAgICBfaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgX3NpemU7XG4gICAgX3dpZHRoID0gb3B0aW9ucy53aWR0aCB8fCBfc2l6ZTtcbiAgICBfeDAgPSBvcHRpb25zLngwIHx8IF93aWR0aCAvIDI7XG4gICAgX3kwID0gb3B0aW9ucy55MCB8fCBfaGVpZ2h0IC8gMjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSBwb2x5Z29uLCBieSBpbnNlcnRpbmcgcG9pbnRzIGF0IGVkZ2Ugb2YgY2lyY2xlLlxuICAgKlxuICAgKiBAcGFyYW0gcG9seSB7T2JqZWN0fVxuICAgKiAgICAgcG9seWdvbiB0byBwb3RlbnRpYWxseSBjb21wbGV0ZS5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgY29tcGxldGVkIHBvbHlnb24uXG4gICAqL1xuICBfdGhpcy5jb21wbGV0ZVBvbHlnb24gPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgIHZhciBheixcbiAgICAgICAgYXoxLFxuICAgICAgICBhejIsXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG5cbiAgICBpZiAocG9seWdvbi54Lmxlbmd0aCA9PT0gMzYwKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgY29tcGxldGUgcG9seWdvblxuICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgfVxuXG4gICAgYXoxID0gcG9seWdvbi5zdGFydEF6LmF6O1xuICAgIGF6MiA9IHBvbHlnb24uZW5kQXouYXo7XG4gICAgeCA9IHBvbHlnb24ueDtcbiAgICB5ID0gcG9seWdvbi55O1xuICAgIC8vIGZpbGwgaW4gY2lyY2xlIHBvcnRpb24gb2YgcG9seWdvbnNcbiAgICBpZiAoYXoxIC0gYXoyID4gTWF0aC5QSSkge1xuICAgICAgYXoxIC09IDIgKiBNYXRoLlBJO1xuICAgIH1cbiAgICBpZiAoYXoyIC0gYXoxID4gTWF0aC5QSSkge1xuICAgICAgYXoxICs9IDIgKiBNYXRoLlBJO1xuICAgIH1cbiAgICBpZiAoYXoxIDwgYXoyKSB7XG4gICAgICBmb3IgKGF6ID0gYXoyIC0gX0QyUjsgYXogPiBhejE7IGF6IC09IF9EMlIpIHtcbiAgICAgICAgeC5wdXNoKE1hdGguc2luKGF6KSk7XG4gICAgICAgIHkucHVzaChNYXRoLmNvcyhheikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGF6ID0gYXoyICsgX0QyUjsgYXogPCBhejE7IGF6ICs9IF9EMlIpIHtcbiAgICAgICAgeC5wdXNoKE1hdGguc2luKGF6KSk7XG4gICAgICAgIHkucHVzaChNYXRoLmNvcyhheikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIGF6aW11dGggbGFiZWwgcmVsYXRpdmUgcG9zaXRpb25pbmcuXG4gICAqXG4gICAqIEBwYXJhbSBsYWJlbCB7T2JqZWN0fVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICBzYW1lIGBsYWJlbGAgb2JqZWN0LCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllczpcbiAgICogICAgIC0gYGFsaWduYCB7U3RyaW5nfVxuICAgKiAgICAgICAgICdsZWZ0JyBvciAncmlnaHQnXG4gICAqICAgICAtIGBzaXplYCB7T2JqZWN0fVxuICAgKiAgICAgICAgIGB3aWR0aGAgYW5kIGBoZWlnaHRgIG9mIGxhYmVsXG4gICAqICAgICAtIGB0aWNrYCB7T2JqZWN0fVxuICAgKiAgICAgICAgIGB4YCBhbmQgYHlgIHJlbGF0aXZlIHRpY2sgY29vcmRpbmF0ZXMuXG4gICAqICAgICAtIGB4YCB7TnVtYmVyfVxuICAgKiAgICAgICAgIHJlbGF0aXZlIHggY29vcmRpbmF0ZSBvZiBsYWJlbC5cbiAgICogICAgIC0gYHlgIHtOdW1iZXJ9XG4gICAqICAgICAgICAgcmVsYXRpdmUgeSBjb29yZGluYXRlIG9mIGxhYmVsLlxuICAgKi9cbiAgX3RoaXMuY29tcHV0ZUF6aW11dGhMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIHZhciBhbGlnbixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIGxhYmVsT2Zmc2V0LFxuICAgICAgICBzaXplLFxuICAgICAgICB0aWNrTGVuZ3RoLFxuICAgICAgICB4LFxuICAgICAgICB5O1xuXG4gICAgLy8gcG9pbnQgb24gZWRnZVxuICAgIHBvaW50ID0gX3RoaXMuZ2V0UG9pbnQobGFiZWwuYXppbXV0aCwgMCk7XG4gICAgeCA9IHBvaW50Lng7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgYWxpZ24gPSAoeCA8IDApID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICBzaXplID0gX3RoaXMubWVhc3VyZVRleHQobGFiZWwudGV4dCwgbGFiZWwuZm9udCk7XG5cbiAgICBsYWJlbE9mZnNldCA9IChfcmFkaXVzICsgMTApIC8gX3JhZGl1cztcbiAgICB0aWNrTGVuZ3RoID0gKF9yYWRpdXMgKyA1KSAvIF9yYWRpdXM7XG5cbiAgICBsYWJlbC5hbGlnbiA9IGFsaWduO1xuICAgIGxhYmVsLnNpemUgPSBzaXplO1xuICAgIGxhYmVsLnRpY2sgPSB7XG4gICAgICB4OiBbeCwgeCAqIHRpY2tMZW5ndGhdLFxuICAgICAgeTogW3ksIHkgKiB0aWNrTGVuZ3RoXSxcbiAgICB9O1xuICAgIGxhYmVsLnggPSB4ICogbGFiZWxPZmZzZXQ7XG4gICAgbGFiZWwueSA9IHkgKiBsYWJlbE9mZnNldDtcblxuICAgIGlmICh5IDwgMCkge1xuICAgICAgLy8gc2hpZnQgbGFiZWwgZG93biB3aGVuIGluIGJvdHRvbSBoYWxmXG4gICAgICBsYWJlbC55ID0geSAqIChfcmFkaXVzICsgMTAgKyBNYXRoLmFicyh5KSAqIHNpemUuaGVpZ2h0IC8gMikgLyBfcmFkaXVzO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbiAgfTtcblxuICAvKipcbiAgICogRnJlZSByZWZlcmVuY2VzLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFfdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9heGlzU2l6ZSA9IG51bGw7XG4gICAgX2JnQ29sb3IgPSBudWxsO1xuICAgIF9maWxsQ29sb3IgPSBudWxsO1xuICAgIF9sYWJlbEF4ZXMgPSBudWxsO1xuICAgIF9sYWJlbEF4ZXNGb250ID0gbnVsbDtcbiAgICBfbGFiZWxQbGFuZXMgPSBudWxsO1xuICAgIF9sYWJlbFBsYW5lc0ZvbnQgPSBudWxsO1xuICAgIF9saW5lQ29sb3IgPSBudWxsO1xuICAgIF9saW5lV2lkdGggPSBudWxsO1xuICAgIF9wbG90QXhlcyA9IG51bGw7XG4gICAgX3Bsb3RQbGFuZXMgPSBudWxsO1xuICAgIF9zaXplID0gbnVsbDtcbiAgICBfdGVuc29yID0gbnVsbDtcblxuICAgIF9yYWRpdXMgPSBudWxsO1xuICAgIF9oZWlnaHQgPSBudWxsO1xuICAgIF93aWR0aCA9IG51bGw7XG4gICAgX3gwID0gbnVsbDtcbiAgICBfeTAgPSBudWxsO1xuXG4gICAgX3RoaXMgPSBudWxsO1xuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpbmUgZm9yIGEgbm9kYWwgcGxhbmUuXG4gICAqXG4gICAqIEBwYXJhbSBucCB7T2JqZWN0fVxuICAgKiAgICAgTm9kYWwgcGxhbmUgb2JqZWN0IHdpdGgga2V5cyBgc3RyaWtlYCwgYGRpcGAsIGFuZCBgcmFrZWAgYW5kXG4gICAqICAgICB2YWx1ZXMgaW4gZGVncmVlcy5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgV2l0aCBwcm9wZXJ0aWVzIGB4YCBhbmQgYHlgIHRoYXQgYXJlIEFycmF5cyBvZiBwb2ludHMgaW4gdGhlXG4gICAqICAgICByYW5nZSBbLTEsIDFdLlxuICAgKi9cbiAgX3RoaXMuZ2V0UGxhbmVMaW5lID0gZnVuY3Rpb24gKG5wKSB7XG4gICAgdmFyIGRpcCxcbiAgICAgICAgaixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHN0cmlrZSxcbiAgICAgICAgdGFuRGlwLFxuICAgICAgICB2ZXJ0aWNhbCxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIHN0cmlrZSA9IG5wLnN0cmlrZSAqIF9EMlI7XG4gICAgZGlwID0gbnAuZGlwICogX0QyUjtcbiAgICB4ID0gW107XG4gICAgeSA9IFtdO1xuXG4gICAgdmVydGljYWwgPSAoTWF0aC5hYnMoZGlwIC0gTWF0aC5QSSAvIDIpKSA8IF9FUFNJTE9OO1xuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgeC5wdXNoKE1hdGguc2luKHN0cmlrZSksIE1hdGguc2luKHN0cmlrZSArIE1hdGguUEkpKTtcbiAgICAgIHkucHVzaChNYXRoLmNvcyhzdHJpa2UpLCBNYXRoLmNvcyhzdHJpa2UgKyBNYXRoLlBJKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhbkRpcCA9IE1hdGgudGFuKGRpcCk7XG4gICAgICBmb3IgKGogPSAwOyBqIDw9IE1hdGguUEk7IGogKz0gX0QyUikge1xuICAgICAgICAvLyBkaXAgZnJvbSBbMCwwLDBdIHRvIGludGVyc2VjdGlvbiBvZiBwbGFuZSBhbmQgZm9jYWwgc3BoZXJlXG4gICAgICAgIC8vIGF0IGF6aW11dGggYHN0cmlrZSArIGpgXG4gICAgICAgIGRpcCA9IE1hdGguYXRhbih0YW5EaXAgKiBNYXRoLnNpbihqKSk7XG4gICAgICAgIHBvaW50ID0gX3RoaXMuZ2V0UG9pbnQoc3RyaWtlICsgaiwgZGlwKTtcbiAgICAgICAgeC5wdXNoKHBvaW50LngpO1xuICAgICAgICB5LnB1c2gocG9pbnQueSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHgsIHkgY29vcmRpbmF0ZXMgZm9yIGEgdmVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gdmVjdG9yIHtWZWN0b3J9XG4gICAqICAgICB2ZWN0b3IgcmVwcmVuZW50aW5nIHBvaW50LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICB3aXRoIHByb3BlcnRpZXMgYHhgIGFuZCBgeWAgaW4gdGhlIHJhbmdlIFstMSwgMV0gcmVwcmVzZW50aW5nIGxvY2F0aW9uXG4gICAqICAgICBvZiBwb2ludCBpbiBmb2NhbCBzcGhlcmUuXG4gICAqL1xuICBfdGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uIChhemltdXRoLCBwbHVuZ2UpIHtcbiAgICB2YXIgcixcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIGlmIChwbHVuZ2UgPCAwKSB7XG4gICAgICBwbHVuZ2UgKj0gLTE7XG4gICAgICBhemltdXRoICs9IE1hdGguUEk7XG4gICAgfVxuICAgIGF6aW11dGggPSBfXzBUbzJQaShhemltdXRoKTtcblxuICAgIHIgPSBNYXRoLnNxcnQoMSAtIE1hdGguc2luKHBsdW5nZSkpO1xuICAgIHggPSByICogTWF0aC5zaW4oYXppbXV0aCk7XG4gICAgeSA9IHIgKiBNYXRoLmNvcyhhemltdXRoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBQb2x5Z29ucyByZXByZXNlbnRpbmcgcHJlc3N1cmUgYW5kIHRlbnNpb24gcmVnaW9ucyBvZiB0aGUgYmVhY2hiYWxsLlxuICAgKlxuICAgKiBNYXkgc3dhcCBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIGNvbG9ycy5cbiAgICpcbiAgICogQHBhcmFtIHRlbnNvciB7VGVuc29yfVxuICAgKiAgICAgICAgdGVuc29yLlxuICAgKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSBlYWNoIG9iamVjdCB3aWxsIGhhdmUgcHJvcGVydGllczpcbiAgICogICAgICAgICB4OiB7QXJyYXk8TnVtYmVyPn0geCBjb29yZGluYXRlcyBvZiBsaW5lLFxuICAgKiAgICAgICAgIHk6IHtBcnJheTxOdW1iZXJ9IHkgY29vcmRpbmF0ZXMgb2YgbGluZSxcbiAgICogICAgICAgICBzdGFydEF6OiB7T2JqZWN0fSBzdGFydCBhemltdXRoIG9mIGxpbmUsXG4gICAqICAgICAgICAgZW5kQXo6IHtPYmplY3R9IGVuZCBhemltdXRoIG9mIGxpbmUuXG4gICAqL1xuICBfdGhpcy5nZXRQb2x5Z29ucyA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICB2YXIgYWxwaGFuLFxuICAgICAgICBheixcbiAgICAgICAgYXplcyxcbiAgICAgICAgYXpwLFxuICAgICAgICBjLFxuICAgICAgICBjZmksXG4gICAgICAgIGYsXG4gICAgICAgIGZpcixcbiAgICAgICAgaSxcbiAgICAgICAgaXNvLFxuICAgICAgICBuLFxuICAgICAgICBwLFxuICAgICAgICBwb2x5Z29uLFxuICAgICAgICBwb2x5Z29ucyxcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgczJhbHBoYW4sXG4gICAgICAgIHNmaSxcbiAgICAgICAgc3dhcENvbG9ycyxcbiAgICAgICAgdCxcbiAgICAgICAgdG1wLFxuICAgICAgICB0YWtlb2ZmLFxuICAgICAgICB2aSxcbiAgICAgICAgeCxcbiAgICAgICAgeGUsXG4gICAgICAgIHhuLFxuICAgICAgICB4eixcbiAgICAgICAgeTtcblxuICAgIHQgPSBfX2F4aXNDYWNoZSh0ZW5zb3IuVCk7XG4gICAgbiA9IF9fYXhpc0NhY2hlKHRlbnNvci5OKTtcbiAgICBwID0gX19heGlzQ2FjaGUodGVuc29yLlApO1xuXG4gICAgYXplcyA9IFtdO1xuICAgIHBvbHlnb25zID0gW107XG5cblxuICAgIHZpID0gKHQudiArIG4udiArIHAudikgLyAzO1xuICAgIHQudiAtPSB2aTtcbiAgICBuLnYgLT0gdmk7XG4gICAgcC52IC09IHZpO1xuXG4gICAgLy8gY29tcHV0ZSBmLCBpc29cbiAgICBmID0gKC1uLnYgLyB0LnYpIHx8IF9FUFNJTE9OO1xuICAgIGlzbyA9ICh2aSAvIHQudikgfHwgX0VQU0lMT047XG5cbiAgICAvLyBidWlsZCBhemVzXG4gICAgc3dhcENvbG9ycyA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCAzNjA7IGkrKykge1xuICAgICAgZmlyID0gaSAqIF9EMlI7XG4gICAgICBzZmkgPSBNYXRoLnNpbihmaXIpO1xuICAgICAgY2ZpID0gTWF0aC5jb3MoZmlyKTtcbiAgICAgIHMyYWxwaGFuID0gKDIgKyAyICogaXNvKSAvICgzICsgKDEgLSAyICogZikgKiBNYXRoLmNvcygyICogZmlyKSk7XG4gICAgICBpZiAoTWF0aC5hYnMoMSAtIHMyYWxwaGFuKSA8PSBfRVBTSUxPTikge1xuICAgICAgICBzMmFscGhhbiA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoczJhbHBoYW4gPiAxKSB7XG4gICAgICAgIC8vIHN3YXAgYXhlc1xuICAgICAgICB0bXAgPSB0O1xuICAgICAgICB0ID0gcDtcbiAgICAgICAgcCA9IHRtcDtcbiAgICAgICAgLy8gc3dhcCBiZy9maWxsIGNvbG9yc1xuICAgICAgICBzd2FwQ29sb3JzID0gIXN3YXBDb2xvcnM7XG4gICAgICAgIC8vIHJlY29tcHV0ZSBmLCBpc28sIHMyYWxwaGFuXG4gICAgICAgIGYgPSAoLW4udiAvIHQudikgfHwgX0VQU0lMT047XG4gICAgICAgIGlzbyA9ICh2aSAvIHQudikgfHwgX0VQU0lMT047XG4gICAgICAgIHMyYWxwaGFuID0gKDIgKyAyICogaXNvKSAvICgzICsgKDEgLSAyICogZikgKiBNYXRoLmNvcygyICogZmlyKSk7XG4gICAgICB9XG4gICAgICAvLyBjb21wdXRlIHosbixlIGNvbXBvbmVudHNcbiAgICAgIGFscGhhbiA9IE1hdGguYXNpbihNYXRoLnNxcnQoczJhbHBoYW4pKTtcbiAgICAgIHMgPSBNYXRoLnNpbihhbHBoYW4pO1xuICAgICAgYyA9IE1hdGguY29zKGFscGhhbik7XG4gICAgICB4eiA9IGMgKiB0LnNwICAgICAgICArIHMgKiBzZmkgKiBuLnNwICAgICAgICArIHMgKiBjZmkgKiBwLnNwO1xuICAgICAgeG4gPSBjICogdC5jcCAqIHQuY2EgKyBzICogc2ZpICogbi5jcCAqIG4uY2EgKyBzICogY2ZpICogcC5jcCAqIHAuY2E7XG4gICAgICB4ZSA9IGMgKiB0LmNwICogdC5zYSArIHMgKiBzZmkgKiBuLmNwICogbi5zYSArIHMgKiBjZmkgKiBwLmNwICogcC5zYTtcbiAgICAgIC8vIGNvbXB1dGUgYXppbXV0aCBhbmQgdGFrZW9mZiBhbmdsZVxuICAgICAgaWYgKE1hdGguYWJzKHhuKSA8IF9FUFNJTE9OICYmIE1hdGguYWJzKHhlKSA8IF9FUFNJTE9OKSB7XG4gICAgICAgIGF6ID0gMDtcbiAgICAgICAgdGFrZW9mZiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBheiA9IF9fMFRvMlBpKE1hdGguYXRhbjIoeGUsIHhuKSk7XG4gICAgICAgIHRha2VvZmYgPSBNYXRoLmFjb3MoeHogLyBNYXRoLnNxcnQoeHoqeHogKyB4bip4biArIHhlKnhlKSk7XG4gICAgICAgIGlmICh0YWtlb2ZmID4gTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgICBheiA9IF9fMFRvMlBpKGF6ICsgTWF0aC5QSSk7XG4gICAgICAgICAgdGFrZW9mZiA9IE1hdGguUEkgLSB0YWtlb2ZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBzYXZlIGZvciBsYXRlclxuICAgICAgYXplcy5wdXNoKHtcbiAgICAgICAgYXo6IGF6LFxuICAgICAgICB0YWtlb2ZmOiB0YWtlb2ZmXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBidWlsZCBwb2x5Z29uc1xuICAgIHBvbHlnb24gPSBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhemVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBheiA9IGF6ZXNbaV07XG4gICAgICByID0gTWF0aC5TUVJUMiAqIE1hdGguc2luKGF6LnRha2VvZmYgLyAyKTtcbiAgICAgIHggPSByICogTWF0aC5zaW4oYXouYXopO1xuICAgICAgeSA9IHIgKiBNYXRoLmNvcyhhei5heik7XG4gICAgICBpZiAocG9seWdvbiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBjaGVjayBpZiBjdXJyZW50IHBvaW50IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgcG9seWdvblxuICAgICAgICBhenAgPSBhemVzWyhpID09PSAwKSA/IGF6ZXMubGVuZ3RoIC0gMSA6IGkgLSAxXTtcbiAgICAgICAgaWYgKE1hdGguYWJzKE1hdGguYWJzKGF6LmF6IC0gYXpwLmF6KSAtIE1hdGguUEkpIDwgMTAgKiBfRDJSKSB7XG4gICAgICAgICAgLy8gcG9seWdvbnMgc2hvdWxkIG9ubHkgZW5kIGF0IGVkZ2Ugb2YgYmVhY2hiYWxsXG4gICAgICAgICAgaWYgKGF6LnRha2VvZmYgPiBfU1BMSVRfVEhSRVNIT0xEICYmXG4gICAgICAgICAgICAgIGF6cC50YWtlb2ZmID4gX1NQTElUX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgLy8gZW5kIGEgcG9seWdvblxuICAgICAgICAgICAgaWYgKHBvbHlnb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcG9seWdvbi5lbmRBeiA9IGF6cDtcbiAgICAgICAgICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgICAgICAgICAgICAgcG9seWdvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9seWdvbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBzdGFydCBhIHBvbHlnb25cbiAgICAgICAgcG9seWdvbiA9IHtcbiAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICB5OiBbXSxcbiAgICAgICAgICBzdGFydEF6OiBheixcbiAgICAgICAgICBlbmRBejogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gYWRkIHBvaW50IHRvIGN1cnJlbnQgcG9seWdvblxuICAgICAgcG9seWdvbi54LnB1c2goeCk7XG4gICAgICBwb2x5Z29uLnkucHVzaCh5KTtcbiAgICB9XG4gICAgLy8gY2xvc2UgbGFzdCBwb2x5Z29uXG4gICAgcG9seWdvbi5lbmRBeiA9IGF6ZXNbYXplcy5sZW5ndGggLSAxXTtcbiAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuXG4gICAgLy8gZml4IHVwIHBvbHlnb25zXG4gICAgcG9seWdvbnMgPSBfdGhpcy5tZXJnZVBvbHlnb25zKHBvbHlnb25zKTtcbiAgICBwb2x5Z29ucyA9IHBvbHlnb25zLm1hcChfdGhpcy5jb21wbGV0ZVBvbHlnb24pO1xuICAgIHBvbHlnb25zLnN3YXBDb2xvcnMgPSBzd2FwQ29sb3JzO1xuICAgIHJldHVybiBwb2x5Z29ucztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCBnZXRQb2ludCB1c2luZyBhIFZlY3Rvci5cbiAgICpcbiAgICogVmVjdG9yIGF6aW11dGggaXMgcmVwb3J0ZWQgY291bnRlci1jbG9ja3dpc2UgZnJvbSBlYXN0LlxuICAgKiBnZXRQb2ludCBleHBlY3RzIGF6aW11dGggdG8gYmUgY2xvY2t3aXNlIGZyb20gbm9ydGguXG4gICAqXG4gICAqIEBwYXJhbSB2ZWN0b3Ige1ZlY3Rvcn1cbiAgICogICAgIHRoZSB2ZWN0b3IuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgIHJlbGF0aXZlIHBvaW50IHdpdGhpbiBmb2NhbCBzcGhlcmUuXG4gICAqL1xuICBfdGhpcy5nZXRWZWN0b3JQb2ludCA9IGZ1bmN0aW9uICh2ZWN0b3IpIHtcbiAgICByZXR1cm4gX3RoaXMuZ2V0UG9pbnQoXG4gICAgICAoTWF0aC5QSSAvIDIpIC0gdmVjdG9yLmF6aW11dGgoKSxcbiAgICAgIHZlY3Rvci5wbHVuZ2UoKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lYXN1cmUgcGl4ZWwgc2l6ZSBvZiB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0gdGV4dCB7U3RyaW5nfVxuICAgKiAgICAgdGV4dCB0byBtZWFzdXJlLlxuICAgKiBAcGFyYW0gZm9udCB7U3RyaW5nfVxuICAgKiAgICAgY3NzL2NhbnZhcyBmb250IHByb3BlcnR5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICB3aXRoIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHByb3BlcnRpZXMgdGhhdCBhcmUgdGhlIHBpeGVsIHNpemUgb2YgYHRleHRgLlxuICAgKi9cbiAgX3RoaXMubWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgZm9udCkge1xuICAgIHZhciBlbCxcbiAgICAgICAgc2l6ZTtcblxuICAgIC8vIGNyZWF0ZSBoaWRkZW4gZWxlbWVudCB3aXRoIHRleHQgY29udGVudFxuICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsXG4gICAgICAgICdoZWlnaHQ6YXV0bzsnICtcbiAgICAgICAgJ3Bvc2l0aW9uOmFic29sdXRlOycgK1xuICAgICAgICAndmlzaWJpbGl0eTpoaWRkZW47JyArXG4gICAgICAgICd3aGl0ZS1zcGFjZTpub3dyYXA7JyArXG4gICAgICAgICd3aWR0aDphdXRvOycgK1xuICAgICAgICAnZm9udDonICsgZm9udCArICc7Jyk7XG4gICAgZWwuaW5uZXJUZXh0ID0gdGV4dDtcblxuICAgIC8vIGFkZCB0byB2aWV3IGVsZW1lbnQgYW5kIG1lYXN1cmVcbiAgICBfdGhpcy5lbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgc2l6ZSA9IHtcbiAgICAgIGhlaWdodDogZWwuc2Nyb2xsSGVpZ2h0LFxuICAgICAgd2lkdGg6IGVsLnNjcm9sbFdpZHRoXG4gICAgfTtcblxuICAgIC8vIGNsZWFuIHVwXG4gICAgX3RoaXMuZWwucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIGVsID0gbnVsbDtcblxuICAgIHJldHVybiBzaXplO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMYWJlbCBhbiBheGlzLlxuICAgKlxuICAgKiBAcGFyYW0gYXhpcyB7VmVjdG9yfVxuICAgKiAgICAgYXhpcyB0byBsYWJlbC5cbiAgICogQHBhcmFtIHRleHQge1N0cmluZ31cbiAgICogICAgIGF4aXMgbGFiZWwuXG4gICAqL1xuICBfdGhpcy5sYWJlbEF4aXMgPSBmdW5jdGlvbiAoYXhpcywgdGV4dCkge1xuICAgIHZhciBwb2ludDtcblxuICAgIHBvaW50ID0gX3RoaXMuZ2V0VmVjdG9yUG9pbnQoYXhpcyk7XG4gICAgX2NhbnZhcy50ZXh0KHRleHQsXG4gICAgICAgIF9sYWJlbEF4ZXNGb250LFxuICAgICAgICBfdGhpcy5wcm9qZWN0WChwb2ludC54KSxcbiAgICAgICAgX3RoaXMucHJvamVjdFkocG9pbnQueSksXG4gICAgICAgIG51bGwsXG4gICAgICAgICdibGFjaycsXG4gICAgICAgICdjZW50ZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhbiBhemltdXRoIGxhYmVsLlxuICAgKlxuICAgKiBAcGFyYW0gbGFiZWwge09iamVjdH1cbiAgICogICAgIGxhYmVsIG9iamVjdCB3aXRoIGBhemltdXRoYCwgYHRleHRgLCBhbmQgYGZvbnRgIHByb3BlcnRpZXMuXG4gICAqL1xuICBfdGhpcy5sYWJlbEF6aW11dGggPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICB2YXIgdGljaztcblxuICAgIGlmICghKCdzaXplJyBpbiBsYWJlbCkpIHtcbiAgICAgIGxhYmVsID0gX3RoaXMuY29tcHV0ZUF6aW11dGhMYWJlbChsYWJlbCk7XG4gICAgfVxuXG4gICAgdGljayA9IGxhYmVsLnRpY2s7XG4gICAgX2NhbnZhcy5saW5lKFxuICAgICAgICB0aWNrLngubWFwKF90aGlzLnByb2plY3RYKSxcbiAgICAgICAgdGljay55Lm1hcChfdGhpcy5wcm9qZWN0WSksXG4gICAgICAgICdibGFjaycpO1xuXG4gICAgX2NhbnZhcy50ZXh0KGxhYmVsLnRleHQsIGxhYmVsLmZvbnQsXG4gICAgICAgIF90aGlzLnByb2plY3RYKGxhYmVsLngpLFxuICAgICAgICBfdGhpcy5wcm9qZWN0WShsYWJlbC55KSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgJ2JsYWNrJyxcbiAgICAgICAgbGFiZWwuYWxpZ24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGp1c3Qgc2l6ZSB0byBtYWtlIHJvb20gZm9yIGF6aW11dGggbGFiZWxzLlxuICAgKlxuICAgKiBVcGRhdGVzIF9jYW52YXMsIF9oZWlnaHQsIF93aWR0aCwgX3gwLCBhbmQgX3kwLlxuICAgKiBSZXNldHMgY2FudmFzIGNvbnRlbnQsIGFueSByZW5kZXJpbmcgc2hvdWxkIG9jY3VyIGFmdGVyIGNhbGxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBsYWJlbCB7T2JqZWN0fVxuICAgKiAgICAgbGFiZWwgb2JqZWN0IHdpdGggYGF6aW11dGhgLCBgdGV4dGAsIGFuZCBgZm9udGAgcHJvcGVydGllcy5cbiAgICovXG4gIF90aGlzLm1ha2VSb29tRm9yQXppbXV0aExhYmVsID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgdmFyIGJvdHRvbSxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHRvcCxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIGlmICghKCdzaXplJyBpbiBsYWJlbCkpIHtcbiAgICAgIGxhYmVsID0gX3RoaXMuY29tcHV0ZUF6aW11dGhMYWJlbChsYWJlbCk7XG4gICAgfVxuXG4gICAgeCA9IF90aGlzLnByb2plY3RYKGxhYmVsLngpO1xuICAgIHkgPSBfdGhpcy5wcm9qZWN0WShsYWJlbC55KTtcbiAgICBzaXplID0gbGFiZWwuc2l6ZTtcblxuICAgIC8vIG1lYXN1cmUgYWN0dWFsIHRvcC9yaWdodC9ib3R0b20vbGVmdFxuICAgIGJvdHRvbSA9IDA7XG4gICAgbGVmdCA9IDA7XG4gICAgcmlnaHQgPSAwO1xuICAgIHRvcCA9IDA7XG4gICAgYm90dG9tID0geSAtIHNpemUuaGVpZ2h0O1xuICAgIHRvcCA9IHkgKyBzaXplLmhlaWdodDtcbiAgICBpZiAobGFiZWwuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgbGVmdCA9IHg7XG4gICAgICByaWdodCA9IHggKyBzaXplLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0geCAtIHNpemUud2lkdGg7XG4gICAgICByaWdodCA9IHg7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBmcm9tIGFjdHVhbCBzaXplIHRvIHJlbGF0aXZlIHNpemUgaW5jcmVhc2VcbiAgICBpZiAoYm90dG9tIDwgMCkge1xuICAgICAgYm90dG9tID0gTWF0aC5hYnMoYm90dG9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm90dG9tID0gMDtcbiAgICB9XG4gICAgaWYgKHRvcCA+IF9oZWlnaHQpIHtcbiAgICAgIHRvcCA9IHRvcCAtIF9oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IDA7XG4gICAgfVxuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgbGVmdCA9IE1hdGguYWJzKGxlZnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gMDtcbiAgICB9XG4gICAgaWYgKHJpZ2h0ID4gX3dpZHRoKSB7XG4gICAgICByaWdodCA9IHJpZ2h0IC0gX3dpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodCA9IDA7XG4gICAgfVxuXG4gICAgLy8gY2hhbmdlIHNpemVcbiAgICBfd2lkdGggPSBfd2lkdGggKyBsZWZ0ICsgcmlnaHQ7XG4gICAgX3gwID0gX3gwICsgbGVmdDtcbiAgICBfaGVpZ2h0ID0gX2hlaWdodCArIHRvcCArIGJvdHRvbTtcbiAgICBfeTAgPSBfeTAgKyB0b3A7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFkamFjZW50IGxpbmVzIHRoYXQgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIHNhbWUgcG9seWdvbi5cbiAgICpcbiAgICogQHBhcmFtIHBvbHlnb25zIHtBcnJheTxPYmplY3Q+fVxuICAgKiAgICAgYXJyYXkgb2YgcG9seWdvbnMgdG8gcG90ZW50aWFsbHkgbWVyZ2UuXG4gICAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59XG4gICAqICAgICBhcnJheSBvZiBwb2x5Z29ucyB0aGF0IHJlbWFpbiBhZnRlciBhbnkgbWVyZ2VzLlxuICAgKi9cbiAgX3RoaXMubWVyZ2VQb2x5Z29ucyA9IGZ1bmN0aW9uIChwb2x5Z29ucykge1xuICAgIHZhciBpLFxuICAgICAgICBuZXh0SSxcbiAgICAgICAgcDEsXG4gICAgICAgIHAxeCxcbiAgICAgICAgcDF5LFxuICAgICAgICBwMixcbiAgICAgICAgcDJ4LFxuICAgICAgICBwMnk7XG5cbiAgICBpZiAocG9seWdvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBub3RoaW5nIHRvIG1lcmdlXG4gICAgICByZXR1cm4gcG9seWdvbnM7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXh0SSA9IChpID09PSBwb2x5Z29ucy5sZW5ndGggLSAxID8gMCA6IGkgKyAxKTtcbiAgICAgIHAxID0gcG9seWdvbnNbaV07XG4gICAgICBwMXggPSBwMS54O1xuICAgICAgcDF5ID0gcDEueTtcbiAgICAgIHAyID0gcG9seWdvbnNbbmV4dEldO1xuICAgICAgcDJ4ID0gcDIueDtcbiAgICAgIHAyeSA9IHAyLnk7XG4gICAgICBpZiAoTWF0aC5hYnMocDF4W3AxeC5sZW5ndGggLSAxXSAtIHAyeFswXSkgPCBfTUVSR0VfVEhSRVNIT0xEICYmXG4gICAgICAgICAgTWF0aC5hYnMocDF5W3AxeS5sZW5ndGggLSAxXSAtIHAyeVswXSkgPCBfTUVSR0VfVEhSRVNIT0xEKSB7XG4gICAgICAgIC8vIG1lcmdlIHBvbHlnb25zXG4gICAgICAgIHAxeC5wdXNoLmFwcGx5KHAxeCwgcDJ4KTtcbiAgICAgICAgcDF5LnB1c2guYXBwbHkocDF5LCBwMnkpO1xuICAgICAgICBwMS5lbmRBeiA9IHAyLmVuZEF6O1xuICAgICAgICBwb2x5Z29ucy5zcGxpY2UobmV4dEksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9seWdvbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSByZWxhdGl2ZSB4IGNvb3JkaW5hdGUgdG8gYSBjYW52YXMgcGl4ZWwgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHgge051bWJlcn1cbiAgICogICAgIHJlbGF0aXZlIHggY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgICAgY2FudmFzIHBpeGVsIHggY29vcmRpbmF0ZS5cbiAgICovXG4gIF90aGlzLnByb2plY3RYID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gX3gwICsgX3JhZGl1cyAqIHg7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSByZWxhdGl2ZSB5IGNvb3JkaW5hdGUgdG8gYSBjYW52YXMgcGl4ZWwgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHkge051bWJlcn1cbiAgICogICAgIHJlbGF0aXZlIHkgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgICAgY2FudmFzIHBpeGVsIHkgY29vcmRpbmF0ZS5cbiAgICovXG4gIF90aGlzLnByb2plY3RZID0gZnVuY3Rpb24gKHkpIHtcbiAgICByZXR1cm4gX2hlaWdodCAtIChfeTAgKyBfcmFkaXVzICogeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB2aWV3IGJhc2VkIG9uIGN1cnJlbnQgbW9kZWwgc2V0dGluZ3MuXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGF6aW11dGhMYWJlbHMsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2x5Z29ucyxcbiAgICAgICAgdG1wLFxuICAgICAgICB4LFxuICAgICAgICB5O1xuXG4gICAgYXppbXV0aExhYmVscyA9IFtdO1xuICAgIC8vIGNyZWF0ZSBhemltdXRoIGxhYmVscywgZm9yIG5vdyBvbmx5IG5vZGFsIHBsYW5lcy5cbiAgICBpZiAoX2xhYmVsUGxhbmVzKSB7XG4gICAgICBbX3RlbnNvci5OUDEsIF90ZW5zb3IuTlAyXS5mb3JFYWNoKGZ1bmN0aW9uIChucCkge1xuICAgICAgICB2YXIgYXppbXV0aCxcbiAgICAgICAgICAgIHRleHQ7XG5cbiAgICAgICAgYXppbXV0aCA9IG5wLnN0cmlrZSAqIF9EMlI7XG4gICAgICAgIHRleHQgPSAnKCcgK1xuICAgICAgICAgICAgbnAuc3RyaWtlLnRvRml4ZWQoMCkgKyAnLCAnICtcbiAgICAgICAgICAgIG5wLmRpcC50b0ZpeGVkKDApICsgJywgJyArXG4gICAgICAgICAgICBucC5yYWtlLnRvRml4ZWQoMCkgK1xuICAgICAgICAgICAgJyknO1xuICAgICAgICBhemltdXRoTGFiZWxzLnB1c2goe1xuICAgICAgICAgICdhemltdXRoJzogYXppbXV0aCxcbiAgICAgICAgICAnZm9udCc6IF9sYWJlbFBsYW5lc0ZvbnQsXG4gICAgICAgICAgJ3RleHQnOiB0ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGFkanVzdCBwbG90IGFyZWEgc28gbGFiZWxzIGFyZSB2aXNpYmxlLlxuICAgIGF6aW11dGhMYWJlbHMuZm9yRWFjaChfdGhpcy5tYWtlUm9vbUZvckF6aW11dGhMYWJlbCk7XG5cbiAgICBfY2FudmFzID0gQ2FudmFzKHtcbiAgICAgIGhlaWdodDogX2hlaWdodCxcbiAgICAgIHdpZHRoOiBfd2lkdGhcbiAgICB9KTtcbiAgICBfY2FudmFzLmNvbnRleHQubGluZVdpZHRoID0gX2xpbmVXaWR0aDtcblxuICAgIC8vIGdldCBwb2x5Z29uc1xuICAgIC8vIHJlcHJlc2VudHMgZWl0aGVyIHNvbGlkIHJlZ2lvbnMgKHN3YXBDb2xvcnMgPSBmYWxzZSksXG4gICAgLy8gb3IgaG9sZXMgKHN3YXBDb2xvcnMgPSB0cnVlKVxuICAgIHBvbHlnb25zID0gX3RoaXMuZ2V0UG9seWdvbnMoX3RlbnNvcik7XG4gICAgaWYgKHBvbHlnb25zLnN3YXBDb2xvcnMpIHtcbiAgICAgIHRtcCA9IF9iZ0NvbG9yO1xuICAgICAgX2JnQ29sb3IgPSBfZmlsbENvbG9yO1xuICAgICAgX2ZpbGxDb2xvciA9IHRtcDtcbiAgICB9XG5cbiAgICAvLyBjZW50ZXIgb2YgYmVhY2hiYWxsLlxuICAgIHggPSBfdGhpcy5wcm9qZWN0WCgwKTtcbiAgICB5ID0gX3RoaXMucHJvamVjdFkoMCk7XG5cbiAgICAvLyBwbG90IGNpcmNsZSBvdXRsaW5lLCB3aXRoIGJhY2tncm91bmQgY29sb3JcbiAgICAvLyBpbiBjYXNlIHBvbHlnb25zIHJlcHJlc2VudCBob2xlc1xuICAgIF9jYW52YXMuY2lyY2xlKHgsIHksIF9yYWRpdXMgKiAyLCBfbGluZUNvbG9yLCBfYmdDb2xvcik7XG5cbiAgICAvLyBkcmF3IHBvbHlnb25zXG4gICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICBfY2FudmFzLnBvbHlnb24oXG4gICAgICAgICAgcC54Lm1hcChfdGhpcy5wcm9qZWN0WCksXG4gICAgICAgICAgcC55Lm1hcChfdGhpcy5wcm9qZWN0WSksXG4gICAgICAgICAgX2xpbmVDb2xvcixcbiAgICAgICAgICBfZmlsbENvbG9yKTtcbiAgICB9KTtcblxuICAgIC8vIGRyYXcgbm9kYWwgcGxhbmUgbGluZXNcbiAgICBpZiAoX3Bsb3RQbGFuZXMpIHtcbiAgICAgIFtfdGVuc29yLk5QMSwgX3RlbnNvci5OUDJdLmZvckVhY2goZnVuY3Rpb24gKG5wKSB7XG4gICAgICAgIHZhciBsaW5lO1xuICAgICAgICBsaW5lID0gX3RoaXMuZ2V0UGxhbmVMaW5lKG5wKTtcbiAgICAgICAgX2NhbnZhcy5saW5lKFxuICAgICAgICAgICAgbGluZS54Lm1hcChfdGhpcy5wcm9qZWN0WCksXG4gICAgICAgICAgICBsaW5lLnkubWFwKF90aGlzLnByb2plY3RZKSxcbiAgICAgICAgICAgIF9saW5lQ29sb3IpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcGxvdCBjaXJjbGUgd2l0aG91dCBmaWxsLCBpbiBjYXNlIHBvbHlnb25zIGNvdmVyZWQgb3V0bGluZS5cbiAgICBfY2FudmFzLmNpcmNsZSh4LCB5LCBfcmFkaXVzICogMiwgX2xpbmVDb2xvcik7XG5cbiAgICBpZiAoX2xhYmVsQXhlcykge1xuICAgICAgX3RoaXMubGFiZWxBeGlzKF90ZW5zb3IuUCwgJ1AnKTtcbiAgICAgIF90aGlzLmxhYmVsQXhpcyhfdGVuc29yLlQsICdUJyk7XG4gICAgfSBlbHNlIGlmIChfcGxvdEF4ZXMpIHtcbiAgICAgIHBvaW50ID0gX3RoaXMuZ2V0VmVjdG9yUG9pbnQoX3RlbnNvci5QKTtcbiAgICAgIF9jYW52YXMuY2lyY2xlKHBvaW50LngsIHBvaW50LnksIF9heGlzU2l6ZSwgJ3doaXRlJywgJ2JsYWNrJyk7XG4gICAgICBwb2ludCA9IF90aGlzLmdldFZlY3RvclBvaW50KF90ZW5zb3IuVCk7XG4gICAgICBfY2FudmFzLmNpcmNsZShwb2ludC54LCBwb2ludC55LCBfYXhpc1NpemUsICdibGFjaycsICd3aGl0ZScpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgYXppbXV0aCBsYWJlbHNcbiAgICBhemltdXRoTGFiZWxzLmZvckVhY2goX3RoaXMubGFiZWxBemltdXRoKTtcblxuICAgIFV0aWwuZW1wdHkoX3RoaXMuZWwpO1xuICAgIF90aGlzLmVsLmFwcGVuZENoaWxkKF9jYW52YXMuY2FudmFzKTtcbiAgICBfY2FudmFzLmRlc3Ryb3koKTtcbiAgICBfY2FudmFzID0gbnVsbDtcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5CZWFjaEJhbGxWaWV3Lnplcm9Ub1R3b1BpID0gX18wVG8yUGk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCZWFjaEJhbGxWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIGNhbnZhczogbnVsbCxcbiAgaGVpZ2h0OiAxMDAsXG4gIHdpZHRoOiAxMDBcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgQ2FudmFzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogQHBhcmFtIG9wdGlvbnMuY2FudmFzIHtET01FbGVtZW50fVxuICogICAgICAgIE9wdGlvbmFsLCBBbiBleGlzdGluZyBjYW52YXMgZWxlbWVudC5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBhIG5ldyBjYW52YXMgZWxlbWVudCBpcyBjcmVhdGVkLlxuICogQHBhcmFtIG9wdGlvbnMud2lkdGgge051bWJlcn1cbiAqICAgICAgICBPcHRpb25hbCwgZGVmYXVsdCAxMDAuXG4gKiAgICAgICAgV2lkdGggb2YgY2FudmFzLCB3aGVuIG9wdGlvbnMuY2FudmFzIGlzIG51bGwuXG4gKiBAcGFyYW0gb3B0aW9ucy5oZWlnaHQge051bWJlcn1cbiAqICAgICAgICBPcHRpb25hbCwgZGVmYXVsdCAxMDAuXG4gKiAgICAgICAgSGVpZ2h0IG9mIGNhbnZhcywgd2hlbiBvcHRpb25zLmNhbnZhcyBpcyBudWxsLlxuICovXG52YXIgQ2FudmFzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9jYW52YXMsXG4gICAgICBfY29udGV4dDtcblxuICBfdGhpcyA9IHt9O1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG5cbiAgICBfY2FudmFzID0gb3B0aW9ucy5jYW52YXM7XG4gICAgaWYgKF9jYW52YXMgPT09IG51bGwpIHtcbiAgICAgIF9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIF9jYW52YXMud2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgX2NhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICB9XG4gICAgX2NvbnRleHQgPSBfY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgLy8gZXhwb3NlIHRoZXNlIGFzIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgX3RoaXMuY2FudmFzID0gX2NhbnZhcztcbiAgICBfdGhpcy5jb250ZXh0ID0gX2NvbnRleHQ7XG4gIH07XG5cblxuICAvKipcbiAgICogQ2xlYXIgdGhlIGNhbnZhcy5cbiAgICovXG4gIF90aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfY29udGV4dC5jbGVhclJlY3QpIHtcbiAgICAgIF9jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBfY2FudmFzLndpZHRoLCBfY2FudmFzLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9jYW52YXMud2lkdGggPSBfY2FudmFzLndpZHRoO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRnJlZSByZWZlcmVuY2VzLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfY2FudmFzID0gbnVsbDtcbiAgICBfY29udGV4dCA9IG51bGw7XG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyBhIGNpcmNsZVxuICAgKlxuICAgKiBAcGFyYW0geCB7TnVtYmVyfVxuICAgKiAgICAgICAgY2VudGVyIG9mIGNpcmNsZS5cbiAgICogQHBhcmFtIHkge051bWJlcn1cbiAgICogICAgICAgIGNlbnRlciBvZiBjaXJjbGUuXG4gICAqIEBwYXJhbSBzaXplIHtOdW1iZXJ9XG4gICAqICAgICAgICBkaWFtZXRlciBvZiBjaXJjbGUuXG4gICAqIEBwYXJhbSBzdHJva2Uge1N0cmluZ31cbiAgICogICAgICAgIHN0cm9rZVN0eWxlLCBvciBudWxsIHRvIG5vdCBzdHJva2UuXG4gICAqIEBwYXJhbSBmaWxsIHtTdHJpbmd9XG4gICAqICAgICAgICBmaWxsU3R5bGUsIG9yIG51bGwgdG8gbm90IGZpbGwuXG4gICAqL1xuICBfdGhpcy5jaXJjbGUgPSBmdW5jdGlvbiAoeCwgeSwgc2l6ZSwgc3Ryb2tlLCBmaWxsKSB7XG4gICAgdmFyIGM7XG5cbiAgICBjID0gX2NvbnRleHQ7XG4gICAgYy5iZWdpblBhdGgoKTtcbiAgICBjLmFyYyh4LCB5LCBzaXplLzIsIDAsIE1hdGguUEkqMiwgdHJ1ZSk7XG4gICAgYy5jbG9zZVBhdGgoKTtcblxuICAgIF90aGlzLl9zdHJva2VBbmRGaWxsKHN0cm9rZSwgZmlsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYXcgYSBwb2x5Z29uXG4gICAqXG4gICAqIEBwYXJhbSB4IHtBcnJheTxOdW1iZXI+fVxuICAgKiAgICAgICAgYXJyYXkgb2YgeCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHkge0FycmF5PE51bWJlcj59XG4gICAqICAgICAgICBhcnJheSBvZiB5IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0gc3Ryb2tlIHtTdHJpbmd9XG4gICAqICAgICAgICBzdHJva2VTdHlsZSwgb3IgbnVsbCB0byBub3Qgc3Ryb2tlLlxuICAgKiBAcGFyYW0gZmlsbCB7U3RyaW5nfVxuICAgKiAgICAgICAgZmlsbFN0eWxlLCBvciBudWxsIHRvIG5vdCBmaWxsLlxuICAgKi9cbiAgX3RoaXMucG9seWdvbiA9IGZ1bmN0aW9uICh4LCB5LCBzdHJva2UsIGZpbGwpIHtcbiAgICB2YXIgYyxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuO1xuXG4gICAgYyA9IF9jb250ZXh0O1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5tb3ZlVG8oeFswXSwgeVswXSk7XG4gICAgZm9yIChpID0gMSwgbGVuID0geC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYy5saW5lVG8oeFtpXSwgeVtpXSk7XG4gICAgfVxuICAgIGMuY2xvc2VQYXRoKCk7XG5cbiAgICBfdGhpcy5fc3Ryb2tlQW5kRmlsbChzdHJva2UsIGZpbGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEcmF3IGEgbGluZS5cbiAgICpcbiAgICogU2FtZSBhcyBwb2x5Z29uLCB3aXRob3V0IGNsb3NpbmdQYXRoIGJlZm9yZSBjYWxsaW5nIHN0cm9rZS9maWxsLlxuICAgKlxuICAgKiBAcGFyYW0geCB7QXJyYXk8TnVtYmVyPn1cbiAgICogICAgICAgIGFycmF5IG9mIHggY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB5IHtBcnJheTxOdW1iZXJ9XG4gICAqICAgICAgICBhcnJheSBvZiB5IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0gc3Ryb2tlIHtTdHJpbmd9XG4gICAqICAgICAgICBzdHJva2VTdHlsZSwgb3IgbnVsbCB0byBub3Qgc3Ryb2tlLlxuICAgKiBAcGFyYW0gZmlsbCB7U3RyaW5nfVxuICAgKiAgICAgICAgZmlsbFN0eWxlLCBvciBudWxsIHRvIG5vdCBmaWxsLlxuICAgKi9cbiAgX3RoaXMubGluZSA9IGZ1bmN0aW9uICh4LCB5LCBzdHJva2UsIGZpbGwpIHtcbiAgICB2YXIgYyxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuO1xuXG4gICAgYyA9IF9jb250ZXh0O1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5tb3ZlVG8oeFswXSwgeVswXSk7XG4gICAgZm9yIChpID0gMSwgbGVuID0geC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYy5saW5lVG8oeFtpXSwgeVtpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3Ryb2tlQW5kRmlsbChzdHJva2UsIGZpbGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNZWFzdXJlIGhvdyBtYW55IHBpeGVscyBhcmUgbmVlZGVkIHRvIHBsb3QgdGV4dCBpbiB0aGUgZ2l2ZW4gZm9udC5cbiAgICpcbiAgICogQHBhcmFtIGZvbnQge1N0cmluZ31cbiAgICogICAgIGNvbnRleHQgZm9udCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHRleHQge1N0cmluZ31cbiAgICogICAgIHRleHQgdG8gcGxvdC5cbiAgICogQHJldHVybiB7VGV4dE1ldHJpY3N9XG4gICAqICAgICBzaXplIG9mIHRleHQgb25jZSBwbG90dGVkLCBcIndpZHRoXCIgaXMgdGhlIG9ubHkgd2lkZWx5IHN1cHBvcnRlZFxuICAgKiAgICAgVGV4dE1ldHJpY3MgcHJvcGVydHkuXG4gICAqL1xuICBfdGhpcy5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uIChmb250LCB0ZXh0KSB7XG4gICAgdmFyIGM7XG5cbiAgICBjID0gX2NvbnRleHQ7XG4gICAgYy5mb250ID0gZm9udDtcbiAgICByZXR1cm4gYy5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgfTtcblxuICAvKipcbiAgICogRHJhdyB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0gdGV4dCB7U3RyaW5nfVxuICAgKiAgICAgICAgdGV4dCB0byBkcmF3LlxuICAgKiBAcGFyYW0gZm9udCB7U3RyaW5nfVxuICAgKiAgICAgICAgZm9udCB0byB1c2UsIGUuZy4gJzMwcHggQXJpYWwnLlxuICAgKiBAcGFyYW0geCB7TnVtYmVyfVxuICAgKiAgICAgICAgeCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0geSB7TnVtYmVyfVxuICAgKiAgICAgICAgeSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0gc3Ryb2tlIHtTdHJpbmd9XG4gICAqICAgICAgICBzdHJva2VTdHlsZSwgb3IgbnVsbCB0byBub3Qgc3Ryb2tlLlxuICAgKiBAcGFyYW0gZmlsbCB7U3RyaW5nfVxuICAgKiAgICAgICAgZmlsbFN0eWxlLCBvciBudWxsIHRvIG5vdCBmaWxsLlxuICAgKiBAcGFyYW0gYWxpZ24ge1N0cmluZ30gZGVmYXVsdCAnbGVmdCdcbiAgICogICAgICAgIHdoZXJlIHRvIGFsaWduIHRleHQgYXJvdW5kIHguXG4gICAqICAgICAgICAnbGVmdCcgc3RhcnRzIGF0IHguXG4gICAqICAgICAgICAnY2VudGVyJyBjZW50ZXJzIGFyb3VuZCB4LlxuICAgKiAgICAgICAgJ3JpZ2h0JyBlbmRzIGF0IHguXG4gICAqL1xuICBfdGhpcy50ZXh0ID0gZnVuY3Rpb24gKHRleHQsIGZvbnQsIHgsIHksIHN0cm9rZSwgZmlsbCwgYWxpZ24pIHtcbiAgICB2YXIgYyxcbiAgICAgICAgc2l6ZTtcblxuICAgIGMgPSBfY29udGV4dDtcbiAgICBhbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcblxuICAgIGMuZm9udCA9IGZvbnQ7XG4gICAgaWYgKGFsaWduICE9PSAnbGVmdCcpIHtcbiAgICAgIHNpemUgPSBjLm1lYXN1cmVUZXh0KHRleHQpO1xuICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICB4ID0geCAtIHNpemUud2lkdGggLyAyO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4ID0geCAtIHNpemUud2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgYy5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgIGMuc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoZmlsbCkge1xuICAgICAgYy5maWxsU3R5bGUgPSBmaWxsO1xuICAgICAgYy5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogU3Ryb2tlIGFuZCBmaWxsIHRoZSBjdXJyZW50IHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0IHtPYmplY3R9XG4gICAqICAgICAgICBjYW52YXMgY29udGV4dFxuICAgKiBAcGFyYW0gc3Ryb2tlIHtTdHJpbmd9XG4gICAqICAgICAgICBzdHJva2VTdHlsZSwgb3IgbnVsbCB0byBub3Qgc3Ryb2tlLlxuICAgKiBAcGFyYW0gZmlsbCB7U3RyaW5nfVxuICAgKiAgICAgICAgZmlsbFN0eWxlLCBvciBudWxsIHRvIG5vdCBmaWxsLlxuICAgKi9cbiAgX3RoaXMuX3N0cm9rZUFuZEZpbGwgPSBmdW5jdGlvbiAoc3Ryb2tlLCBmaWxsKSB7XG4gICAgdmFyIGM7XG5cbiAgICBjID0gX2NvbnRleHQ7XG5cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBjLnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgYy5zdHJva2UoKTtcbiAgICB9XG4gICAgaWYgKGZpbGwpIHtcbiAgICAgIGMuZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgIGMuZmlsbCgpO1xuICAgIH1cbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhcztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgRm9ybWF0dGVyID0gcmVxdWlyZSgnY29yZS9Gb3JtYXR0ZXInKSxcbiAgICBNb2R1bGUgPSByZXF1aXJlKCdjb3JlL01vZHVsZScpLFxuICAgIE1vbWVudFRlbnNvclZpZXcgPSByZXF1aXJlKCdtb21lbnQtdGVuc29yL01vbWVudFRlbnNvclZpZXcnKSxcbiAgICBTY2llbnRpZmljU3VtbWFyeU1vZHVsZSA9IHJlcXVpcmUoJ3NjaWVudGlmaWMvU2NpZW50aWZpY1N1bW1hcnlNb2R1bGUnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ERUZBVUxUUyxcbiAgICBfSUQsXG4gICAgX1RJVExFLFxuICAgIF9UWVBFUztcblxuXG5fSUQgPSAnbW9tZW50LXRlbnNvcic7XG5fVElUTEUgPSAnTW9tZW50IFRlbnNvcic7XG5fVFlQRVMgPSBbJ21vbWVudC10ZW5zb3InXTtcblxuX0RFRkFVTFRTID0ge1xuICBmb3JtYXR0ZXI6IG51bGxcbn07XG5cblxuLyoqXG4gKiBNb2R1bGUgdG8gZGlzcGxheSBhIG1vbWVudC10ZW5zb3IgdHlwZSB7UHJvZHVjdH0uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdHRlciB7Rm9ybWF0dGVyfVxuICogICAgIGZvcm1hdHRlciBvYmplY3QgdG8gcGFzcyB0byBNb21lbnRUZW5zb3JWaWV3LlxuICovXG52YXIgTW9tZW50VGVuc29yTW9kdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9mb3JtYXR0ZXIsXG4gICAgICBfbW9tZW50VGVuc29yVmlldztcblxuXG4gIF90aGlzID0gTW9kdWxlKG9wdGlvbnMpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuXG4gICAgX3RoaXMuSUQgPSBfSUQ7XG4gICAgX3RoaXMuVElUTEUgPSBfVElUTEU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZyZWUgcmVmZXJlbmNlcy5cbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfbW9tZW50VGVuc29yVmlldykge1xuICAgICAgX21vbWVudFRlbnNvclZpZXcuZGVzdHJveSgpO1xuICAgIH1cbiAgICBfbW9tZW50VGVuc29yVmlldyA9IG51bGw7XG5cbiAgICBfZm9ybWF0dGVyID0gbnVsbDtcbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogUmVuZGVyIHByb2R1Y3QgY29udGVudCwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBubyBwcm9kdWN0IGF2YWlsYWJsZS5cbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZHVjdDtcblxuICAgIHByb2R1Y3QgPSBfdGhpcy5nZXRQcm9kdWN0KCdtb21lbnQtdGVuc29yJyk7XG5cbiAgICBfdGhpcy5yZW5kZXJDb250ZW50KHByb2R1Y3QpO1xuICAgIF90aGlzLnJlbmRlckhlYWRlcihwcm9kdWN0KTtcbiAgICBfdGhpcy5yZW5kZXJGb290ZXIocHJvZHVjdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgY29udGVudCBzZWN0aW9uIG9mIHRoaXMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIHByb2R1Y3QgdG8gcmVuZGVyLCBvciBudWxsIGlmIG5vIHByb2R1Y3QuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJDb250ZW50ID0gZnVuY3Rpb24gKHByb2R1Y3QpIHtcbiAgICBpZiAoX21vbWVudFRlbnNvclZpZXcgJiYgX21vbWVudFRlbnNvclZpZXcuZGVzdHJveSkge1xuICAgICAgX21vbWVudFRlbnNvclZpZXcuZGVzdHJveSgpO1xuICAgICAgX21vbWVudFRlbnNvclZpZXcgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghcHJvZHVjdCkge1xuICAgICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPSAnPHAgY2xhc3M9XCJhbGVydCBlcnJvclwiPicgK1xuICAgICAgICAgICdObyBNb21lbnQgVGVuc29yIEZvdW5kIScgK1xuICAgICAgICAgICc8L3A+JztcbiAgICB9IGVsc2Uge1xuICAgICAgX21vbWVudFRlbnNvclZpZXcgPSBNb21lbnRUZW5zb3JWaWV3KHtcbiAgICAgICAgZWw6IF90aGlzLmNvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlcjogX2Zvcm1hdHRlcixcbiAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgIH0pO1xuICAgICAgX21vbWVudFRlbnNvclZpZXcucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGZvb3RlciBzZWN0aW9uIG9mIHRoaXMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIHByb2R1Y3QgdG8gcmVuZGVyLCBvciBudWxsIGlmIG5vIHByb2R1Y3QuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJGb290ZXIgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIHZhciBkb3dubG9hZHM7XG5cbiAgICBVdGlsLmVtcHR5KF90aGlzLmZvb3Rlcik7XG4gICAgaWYgKHByb2R1Y3QpIHtcbiAgICAgIGRvd25sb2FkcyA9IF90aGlzLmdldFByb2R1Y3RGb290ZXIoe1xuICAgICAgICBwcm9kdWN0OiBwcm9kdWN0XG4gICAgICB9KTtcbiAgICAgIGlmIChkb3dubG9hZHMpIHtcbiAgICAgICAgX3RoaXMuZm9vdGVyLmFwcGVuZENoaWxkKGRvd25sb2Fkcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGhlYWRlciBzZWN0aW9uIG9mIHRoaXMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIHByb2R1Y3QgdG8gcmVuZGVyLCBvciBudWxsIGlmIG5vIHByb2R1Y3QuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJIZWFkZXIgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIHZhciBoZWFkZXI7XG5cbiAgICBVdGlsLmVtcHR5KF90aGlzLmhlYWRlcik7XG4gICAgX3RoaXMuaGVhZGVyLmlubmVySFRNTCA9ICc8aDM+JyArIF90aGlzLlRJVExFICsgJzwvaDM+JztcblxuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBoZWFkZXIgPSBfdGhpcy5nZXRQcm9kdWN0SGVhZGVyKHtcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgc3VtbWFyeU1vZHVsZTogU2NpZW50aWZpY1N1bW1hcnlNb2R1bGVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIF90aGlzLmhlYWRlci5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5Nb21lbnRUZW5zb3JNb2R1bGUuSUQgPSBfSUQ7XG5Nb21lbnRUZW5zb3JNb2R1bGUuVElUTEUgPSBfVElUTEU7XG5Nb21lbnRUZW5zb3JNb2R1bGUuVFlQRVMgPSBfVFlQRVM7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNb21lbnRUZW5zb3JNb2R1bGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNpY1BpblZpZXcgPSByZXF1aXJlKCdjb3JlL0Jhc2ljUGluVmlldycpLFxuICAgIEJlYWNoQmFsbFZpZXcgPSByZXF1aXJlKCdtb21lbnQtdGVuc29yL0JlYWNoQmFsbFZpZXcnKSxcbiAgICBNb21lbnRUZW5zb3JNb2R1bGUgPSByZXF1aXJlKCdtb21lbnQtdGVuc29yL01vbWVudFRlbnNvck1vZHVsZScpLFxuICAgIFRlbnNvciA9IHJlcXVpcmUoJ21vbWVudC10ZW5zb3IvVGVuc29yJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIGNsYXNzTmFtZTogJ21vbWVudC10ZW5zb3ItcGluLWJlYWNoYmFsbCcsXG4gIGZpbGxDb2xvcjogJyM2ZWE4ZmYnLFxuICBtb2R1bGU6IE1vbWVudFRlbnNvck1vZHVsZVxufTtcblxuXG52YXIgTW9tZW50VGVuc29yUGluVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfYmVhY2hiYWxsVmlldyxcbiAgICAgIF9jbGFzc05hbWUsXG4gICAgICBfZmlsbENvbG9yLFxuICAgICAgX3RlbnNvcjtcblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gQmFzaWNQaW5WaWV3KG9wdGlvbnMpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NOYW1lID0gb3B0aW9ucy5jbGFzc05hbWU7XG4gICAgX2ZpbGxDb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yO1xuICAgIF90ZW5zb3IgPSBUZW5zb3IuZnJvbVByb2R1Y3QoX3RoaXMubW9kZWwpO1xuICB9O1xuXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfYmVhY2hiYWxsVmlldykge1xuICAgICAgX2JlYWNoYmFsbFZpZXcuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIF9iZWFjaGJhbGxWaWV3ID0gbnVsbDtcbiAgICBfY2xhc3NOYW1lID0gbnVsbDtcbiAgICBfZmlsbENvbG9yID0gbnVsbDtcbiAgICBfdGVuc29yID0gbnVsbDtcblxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBDcmVhdHMgcGluIGNvbnRlbnRcbiAgICovXG4gIF90aGlzLnJlbmRlclBpbkNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgVXRpbC5lbXB0eShfdGhpcy5jb250ZW50KTtcblxuICAgIF9iZWFjaGJhbGxWaWV3ID0gQmVhY2hCYWxsVmlldyh7XG4gICAgICBmaWxsQ29sb3I6IF9maWxsQ29sb3IsXG4gICAgICBsYWJlbEF4ZXM6IGZhbHNlLFxuICAgICAgbGFiZWxQbGFuZXM6IGZhbHNlLFxuICAgICAgc2l6ZTogMjAwLFxuICAgICAgdGVuc29yOiBfdGVuc29yXG4gICAgfSk7XG5cbiAgICBfYmVhY2hiYWxsVmlldy5lbC5jbGFzc0xpc3QuYWRkKF9jbGFzc05hbWUpO1xuICAgIF90aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQoX2JlYWNoYmFsbFZpZXcuZWwpO1xuICAgIF9iZWFjaGJhbGxWaWV3LnJlbmRlcigpO1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTW9tZW50VGVuc29yUGluVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEF0dHJpYnV0aW9uID0gcmVxdWlyZSgnY29yZS9BdHRyaWJ1dGlvbicpLFxuICAgIEJlYWNoQmFsbFZpZXcgPSByZXF1aXJlKCdtb21lbnQtdGVuc29yL0JlYWNoQmFsbFZpZXcnKSxcbiAgICBGb3JtYXR0ZXIgPSByZXF1aXJlKCdjb3JlL0Zvcm1hdHRlcicpLFxuICAgIFByb2R1Y3RWaWV3ID0gcmVxdWlyZSgnY29yZS9Qcm9kdWN0VmlldycpLFxuICAgIFRlbnNvciA9IHJlcXVpcmUoJ21vbWVudC10ZW5zb3IvVGVuc29yJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIGVtcHR5OiAnJm5kYXNoOycsXG4gIGZpbGxDb2xvcjogJyM2ZWE4ZmYnLFxuICBmb3JtYXR0ZXI6IG51bGwsXG4gIHRlbnNvcjogbnVsbFxufTtcblxudmFyIF9SMkQgPSAxODAgLyBNYXRoLlBJO1xuXG5cbi8qKlxuICogVmlldyBmb3IgYSBgbW9tZW50LXRlbnNvcmAgcHJvZHVjdC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogQHBhcmFtIG9wdGlvbnMuZW1wdHkge1N0cmluZ31cbiAqICAgICBzdHJpbmcgdG8gZGlzcGxheSBpZiBhIHZhbHVlIGlzIG1pc3NpbmcuXG4gKiAgICAgZGVmYXVsdCAnJm5kYXNoOycuXG4gKiBAcGFyYW0gb3B0aW9ucy5maWxsQ29sb3Ige1N0cmluZ31cbiAqICAgICBmaWxsIGNvbG9yIGZvciBiZWFjaGJhbGwuXG4gKiAgICAgZGVmYXVsdCAnIzZlYThmZicuXG4gKiBAcGFyYW0gb3B0aW9ucy5mb3JtYXR0ZXIge0Zvcm1hdHRlcn1cbiAqICAgICBmb3JtYXR0ZXIgb2JqZWN0LlxuICogICAgIGRlZmF1bHQgYEZvcm1hdHRlcigpYC5gXG4gKiBAcGFyYW0gb3B0aW9ucy5tb2RlbCB7UHJvZHVjdH1cbiAqICAgICBtb21lbnQtdGVuc29yIHByb2R1Y3QgdG8gZGlzcGxheS5cbiAqL1xudmFyIE1vbWVudFRlbnNvclZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2VtcHR5LFxuICAgICAgX2ZpbGxDb2xvcixcbiAgICAgIF9mb3JtYXR0ZXIsXG4gICAgICBfdGVuc29yO1xuXG5cbiAgX3RoaXMgPSBQcm9kdWN0VmlldyhvcHRpb25zKTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICAgIF9lbXB0eSA9IG9wdGlvbnMuZW1wdHk7XG4gICAgX2ZpbGxDb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yO1xuICAgIF9mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBGb3JtYXR0ZXIoKTtcbiAgICBfdGVuc29yID0gVGVuc29yLmZyb21Qcm9kdWN0KF90aGlzLm1vZGVsKTtcbiAgfTtcblxuICAvKipcbiAgICogRnJlZSByZWZlcmVuY2VzLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgX2VtcHR5ID0gbnVsbDtcbiAgICBfZmlsbENvbG9yID0gbnVsbDtcbiAgICBfZm9ybWF0dGVyID0gbnVsbDtcbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RlbnNvciA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogQ29udGVudCBmb3IgdGhlIFwiYXhlc1wiIHNlY3Rpb24gb2YgdGhlIG1vbWVudCB0ZW5zb3Igdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHRlbnNvciB7VGVuc29yfVxuICAgKiAgICAgdGhlIHRlbnNvciBiZWluZyBkaXNwbGF5ZWQuXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG4gICAqICAgICBtYXJrdXAgZm9yIHRoZSBheGVzIHNlY3Rpb24gb2YgdGhlIG1vbWVudCB0ZW5zb3Igdmlldy5cbiAgICovXG4gIF90aGlzLmdldEF4ZXMgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgdmFyIGVsLFxuICAgICAgICBmb3JtYXRBeGlzLFxuICAgICAgICBmcmFnbWVudDtcblxuICAgIGZvcm1hdEF4aXMgPSBmdW5jdGlvbiAoYXhpcywgbmFtZSkge1xuICAgICAgdmFyIGF6aW11dGgsXG4gICAgICAgICAgcGx1bmdlLFxuICAgICAgICAgIHZhbHVlO1xuXG4gICAgICBhemltdXRoID0gKE1hdGguUEkgLyAyKSAtIGF4aXMuYXppbXV0aCgpO1xuICAgICAgcGx1bmdlID0gYXhpcy5wbHVuZ2UoKTtcbiAgICAgIHZhbHVlID0gYXhpcy5laWdlbnZhbHVlIC8gdGVuc29yLnNjYWxlO1xuICAgICAgLy8gbWFrZSBzdXJlIHBsdW5nZSBpcyBkb3duXG4gICAgICBpZiAocGx1bmdlIDwgMCkge1xuICAgICAgICBhemltdXRoID0gYXppbXV0aCArIE1hdGguUEk7XG4gICAgICAgIHBsdW5nZSA9IHBsdW5nZSAqIC0xO1xuICAgICAgfVxuICAgICAgYXppbXV0aCA9IEJlYWNoQmFsbFZpZXcuemVyb1RvVHdvUGkoYXppbXV0aCk7XG5cbiAgICAgIC8vIGZvcm1hdCB2YWx1ZXNcbiAgICAgIGF6aW11dGggPSBNYXRoLnJvdW5kKGF6aW11dGggKiBfUjJEKSArICcmZGVnOyc7XG4gICAgICBwbHVuZ2UgPSBNYXRoLnJvdW5kKHBsdW5nZSAqIF9SMkQpICsgJyZkZWcnO1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b0ZpeGVkKDMpICsgJ2UrJyArIHRlbnNvci5leHBvbmVudCArICcgJyArIHRlbnNvci51bml0cztcblxuICAgICAgcmV0dXJuICc8dHI+JyArXG4gICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPicgKyBuYW1lICsgJzwvdGg+JyArXG4gICAgICAgICAgJzx0ZD4nICsgdmFsdWUgKyAnPC90ZD4nICtcbiAgICAgICAgICAnPHRkPicgKyBwbHVuZ2UgKyAnPC90ZD4nICtcbiAgICAgICAgICAnPHRkPicgKyBhemltdXRoICsgJzwvdGQ+JyArXG4gICAgICAgICAgJzwvdHI+JztcbiAgICB9O1xuXG4gICAgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2g0Jyk7XG4gICAgZWwuaW5uZXJIVE1MID0gJ1ByaW5jaXBhbCBBeGVzJztcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbCk7XG5cbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2hvcml6b250YWwtc2Nyb2xsaW5nJyk7XG4gICAgZWwuaW5uZXJIVE1MID1cbiAgICAgICAgJzx0YWJsZT4nICtcbiAgICAgICAgICAnPHRoZWFkPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aD5BeGlzPC90aD4nICtcbiAgICAgICAgICAgICAgJzx0aD5WYWx1ZTwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGg+UGx1bmdlPC90aD4nICtcbiAgICAgICAgICAgICAgJzx0aD5BemltdXRoPC90aD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICc8L3RoZWFkPicgK1xuICAgICAgICAgICc8dGJvZHk+JyArXG4gICAgICAgICAgICBmb3JtYXRBeGlzKHRlbnNvci5ULCAnVCcpICtcbiAgICAgICAgICAgIGZvcm1hdEF4aXModGVuc29yLk4sICdOJykgK1xuICAgICAgICAgICAgZm9ybWF0QXhpcyh0ZW5zb3IuUCwgJ1AnKSArXG4gICAgICAgICAgJzwvdGJvZHk+JyArXG4gICAgICAgICc8L3RhYmxlPic7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb250ZW50IGZvciB0aGUgXCJpbmZvXCIgc2VjdGlvbiBvZiB0aGUgbW9tZW50IHRlbnNvciB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gdGVuc29yIHtUZW5zb3J9XG4gICAqICAgICB0aGUgdGVuc29yIGJlaW5nIGRpc3BsYXllZC5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH1cbiAgICogICAgIG1hcmt1cCBmb3IgdGhlIGluZm8gc2VjdGlvbiBvZiB0aGUgbW9tZW50IHRlbnNvciB2aWV3LlxuICAgKi9cbiAgX3RoaXMuZ2V0SW5mbyA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICB2YXIgY2F0YWxvZyxcbiAgICAgICAgY29udHJpYnV0b3IsXG4gICAgICAgIGRhdGFTb3VyY2UsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBlbCxcbiAgICAgICAgaGFsZkR1cmF0aW9uLFxuICAgICAgICBtYWduaXR1ZGUsXG4gICAgICAgIG1vbWVudCxcbiAgICAgICAgcGVyY2VudERDLFxuICAgICAgICBwcm9kdWN0O1xuXG4gICAgcHJvZHVjdCA9IF90aGlzLm1vZGVsO1xuXG4gICAgY2F0YWxvZyA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2V2ZW50c291cmNlJyk7XG4gICAgY29udHJpYnV0b3IgPSBwcm9kdWN0LmdldCgnc291cmNlJyk7XG4gICAgZGF0YVNvdXJjZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2JlYWNoYmFsbC1zb3VyY2UnKSB8fCBjb250cmlidXRvcjtcbiAgICBkZXB0aCA9IF9mb3JtYXR0ZXIuZGVwdGgodGVuc29yLmRlcHRoLCAna20nKTtcbiAgICBoYWxmRHVyYXRpb24gPSBwcm9kdWN0LmdldFByb3BlcnR5KCdzb3VyY2V0aW1lLWR1cmF0aW9uJyk7XG4gICAgaWYgKGhhbGZEdXJhdGlvbikge1xuICAgICAgaGFsZkR1cmF0aW9uID0gKGhhbGZEdXJhdGlvbiAvIDIpICsgJyBzJztcbiAgICB9IGVsc2Uge1xuICAgICAgaGFsZkR1cmF0aW9uID0gX2VtcHR5O1xuICAgIH1cbiAgICBtYWduaXR1ZGUgPSBfZm9ybWF0dGVyLm1hZ25pdHVkZShcbiAgICAgICAgdGVuc29yLm1hZ25pdHVkZSxcbiAgICAgICAgcHJvZHVjdC5nZXRQcm9wZXJ0eSgnZGVyaXZlZC1tYWduaXR1ZGUtdHlwZScpIHx8ICcnKTtcbiAgICBtb21lbnQgPSAodGVuc29yLm1vbWVudCAvIHRlbnNvci5zY2FsZSkudG9GaXhlZCgzKSArXG4gICAgICAgICdlKycgKyB0ZW5zb3IuZXhwb25lbnQgKyAnICcgKyB0ZW5zb3IudW5pdHM7XG4gICAgcGVyY2VudERDID0gTWF0aC5yb3VuZCh0ZW5zb3IucGVyY2VudERDICogMTAwKSArICcgJSc7XG5cbiAgICBjYXRhbG9nID0gY2F0YWxvZy50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnRyaWJ1dG9yID0gQXR0cmlidXRpb24uZ2V0Q29udHJpYnV0b3JSZWZlcmVuY2UoY29udHJpYnV0b3IpO1xuICAgIGRhdGFTb3VyY2UgPSBBdHRyaWJ1dGlvbi5nZXRDb250cmlidXRvclJlZmVyZW5jZShkYXRhU291cmNlKTtcblxuICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9tZW50LXRlbnNvci1pbmZvJyk7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnaG9yaXpvbnRhbC1zY3JvbGxpbmcnKTtcbiAgICBlbC5pbm5lckhUTUwgPVxuICAgICAgICAnPHRhYmxlPicgK1xuICAgICAgICAgICc8dGJvZHk+JyArXG4gICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TW9tZW50PC90aD48L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyBtb21lbnQgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk1hZ25pdHVkZTwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIG1hZ25pdHVkZSArICc8L3RkPicgK1xuICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+RGVwdGg8L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyBkZXB0aCArICc8L3RkPicgK1xuICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+JyArXG4gICAgICAgICAgICAgICAgJ1BlcmNlbnQgPGFiYnIgdGl0bGU9XCJEb3VibGUgQ291cGxlXCI+REM8L2FiYnI+JyArXG4gICAgICAgICAgICAgICc8L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyBwZXJjZW50REMgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkhhbGYgRHVyYXRpb248L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyBoYWxmRHVyYXRpb24gKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkNhdGFsb2c8L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyBjYXRhbG9nICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5EYXRhIFNvdXJjZTwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIGRhdGFTb3VyY2UgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkNvbnRyaWJ1dG9yPC90aD4nICtcbiAgICAgICAgICAgICAgJzx0ZD4nICsgY29udHJpYnV0b3IgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICc8L3Rib2R5PicgK1xuICAgICAgICAnPC90YWJsZT4nO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb250ZW50IGZvciB0aGUgXCJwbGFuZXNcIiBzZWN0aW9uIG9mIHRoZSBtb21lbnQgdGVuc29yIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW5zb3Ige1RlbnNvcn1cbiAgICogICAgIHRoZSB0ZW5zb3IgYmVpbmcgZGlzcGxheWVkLlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fVxuICAgKiAgICAgbWFya3VwIGZvciB0aGUgaW5mbyBzZWN0aW9uIG9mIHRoZSBtb21lbnQgdGVuc29yIHZpZXcuXG4gICAqL1xuICBfdGhpcy5nZXRQbGFuZXMgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgdmFyIGVsLFxuICAgICAgICBmb3JtYXRQbGFuZSxcbiAgICAgICAgZnJhZ21lbnQ7XG5cbiAgICBmb3JtYXRQbGFuZSA9IGZ1bmN0aW9uIChwbGFuZSwgbmFtZSkge1xuICAgICAgdmFyIGRpcCxcbiAgICAgICAgICByYWtlLFxuICAgICAgICAgIHN0cmlrZTtcblxuICAgICAgZGlwID0gTWF0aC5yb3VuZChwbGFuZS5kaXApICsgJyZkZWc7JztcbiAgICAgIHJha2UgPSBNYXRoLnJvdW5kKHBsYW5lLnJha2UpICsgJyZkZWc7JztcbiAgICAgIHN0cmlrZSA9IE1hdGgucm91bmQocGxhbmUuc3RyaWtlKSArICcmZGVnJztcblxuICAgICAgcmV0dXJuICc8dHI+JyArXG4gICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPicgKyBuYW1lICsgJzwvdGg+JyArXG4gICAgICAgICAgJzx0ZD4nICsgc3RyaWtlICsgJzwvdGQ+JyArXG4gICAgICAgICAgJzx0ZD4nICsgZGlwICsgJzwvdGQ+JyArXG4gICAgICAgICAgJzx0ZD4nICsgcmFrZSArICc8L3RkPicgK1xuICAgICAgICAnPC90cj4nO1xuICAgIH07XG5cbiAgICBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDQnKTtcbiAgICBlbC5pbm5lckhUTUwgPSAnTm9kYWwgUGxhbmVzJztcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbCk7XG5cbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2hvcml6b250YWwtc2Nyb2xsaW5nJyk7XG4gICAgZWwuaW5uZXJIVE1MID1cbiAgICAgICAgJzx0YWJsZT4nICtcbiAgICAgICAgICAnPHRoZWFkPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICc8dGg+UGxhbmU8L3RoPicgK1xuICAgICAgICAgICAgJzx0aD5TdHJpa2U8L3RoPicgK1xuICAgICAgICAgICAgJzx0aD5EaXA8L3RoPicgK1xuICAgICAgICAgICAgJzx0aD5SYWtlPC90aD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICc8L3RoZWFkPicgK1xuICAgICAgICAgICc8dGJvZHk+JyArXG4gICAgICAgICAgICBmb3JtYXRQbGFuZSh0ZW5zb3IuTlAxLCAnTlAxJykgK1xuICAgICAgICAgICAgZm9ybWF0UGxhbmUodGVuc29yLk5QMiwgJ05QMicpICtcbiAgICAgICAgICAnPC90Ym9keT4nICtcbiAgICAgICAgJzwvdGFibGU+JztcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbCk7XG5cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGl0bGUgZm9yIHRoaXMgdGVuc29yLlxuICAgKlxuICAgKiBAcGFyYW0gdGVuc29yIHtUZW5zb3J9XG4gICAqICAgICB0ZW5zb3Igb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fVxuICAgKiAgICAgdGl0bGUgZm9yIHZpZXcuXG4gICAqL1xuICBfdGhpcy5nZXRUaXRsZSA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICB2YXIgZWwsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICB0eXBlO1xuXG4gICAgdHlwZSA9IHRlbnNvci50eXBlO1xuICAgIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgICAvLyB1c2UgZGVyaXZlZCBtYWduaXR1ZGUgdHlwZVxuICAgICAgdHlwZSA9IHR5cGUudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmICh0eXBlID09PSAnTVdXJykge1xuICAgICAgICB0aXRsZSA9ICdXLXBoYXNlIE1vbWVudCBUZW5zb3IgKE13dyknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTVdDJykge1xuICAgICAgICB0aXRsZSA9ICdDZW50cm9pZCBNb21lbnQgVGVuc29yIChNd2MpJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ01XQicpIHtcbiAgICAgICAgdGl0bGUgPSAnQm9keS13YXZlIE1vbWVudCBUZW5zb3IgKE13YiknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTVdSJykge1xuICAgICAgICB0aXRsZSA9ICdSZWdpb25hbCBNb21lbnQgVGVuc29yIChNd3IpJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRpdGxlKSB7XG4gICAgICBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgICAgICB0aXRsZSA9ICdNb21lbnQgVGVuc29yICgnICsgdGVuc29yLnR5cGUgKyAnKSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZSA9ICdNb21lbnQgVGVuc29yJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgZWwuaW5uZXJIVE1MID0gdGl0bGU7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB2aWV3LlxuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCxcbiAgICAgICAgYmVhY2hiYWxsLFxuICAgICAgICBpbmZvLFxuICAgICAgICB0aXRsZTtcblxuICAgIGVsID0gX3RoaXMuZWw7XG4gICAgZWwuaW5uZXJIVE1MID1cbiAgICAgICAgJzxzZWN0aW9uIGNsYXNzPVwibW9tZW50LXRlbnNvci12aWV3XCI+JyArXG4gICAgICAgICAgJzxoZWFkZXIgY2xhc3M9XCJ0aXRsZVwiPjwvaGVhZGVyPicgK1xuICAgICAgICAgICc8ZGl2IGNsYXNzPVwicm93XCI+JyArXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImNvbHVtbiBvbmUtb2YtdHdvXCI+PC9kaXY+JyArXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImNvbHVtbiBvbmUtb2YtdHdvXCI+PC9kaXY+JyArXG4gICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPC9zZWN0aW9uPic7XG4gICAgdGl0bGUgPSBlbC5xdWVyeVNlbGVjdG9yKCcudGl0bGUnKTtcbiAgICBpbmZvID0gZWwucXVlcnlTZWxlY3RvcignLmNvbHVtbicpO1xuICAgIGJlYWNoYmFsbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5jb2x1bW4gKyAuY29sdW1uJyk7XG5cbiAgICB0aXRsZS5hcHBlbmRDaGlsZChfdGhpcy5nZXRUaXRsZShfdGVuc29yKSk7XG5cbiAgICBpbmZvLmFwcGVuZENoaWxkKF90aGlzLmdldEluZm8oX3RlbnNvcikpO1xuICAgIGluZm8uYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0UGxhbmVzKF90ZW5zb3IpKTtcbiAgICBpbmZvLmFwcGVuZENoaWxkKF90aGlzLmdldEF4ZXMoX3RlbnNvcikpO1xuXG4gICAgYmVhY2hiYWxsID0gQmVhY2hCYWxsVmlldyh7XG4gICAgICBlbDogYmVhY2hiYWxsLFxuICAgICAgZmlsbENvbG9yOiBfZmlsbENvbG9yLFxuICAgICAgc2l6ZTogMzIwLFxuICAgICAgdGVuc29yOiBfdGVuc29yXG4gICAgfSk7XG4gICAgYmVhY2hiYWxsLnJlbmRlcigpO1xuICAgIGJlYWNoYmFsbC5kZXN0cm95KCk7XG4gICAgYmVhY2hiYWxsID0gbnVsbDtcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbWVudFRlbnNvclZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNYXRyaXggPSByZXF1aXJlKCdtYXRoL01hdHJpeCcpO1xuXG5cbnZhciBfQkVBQ0hCQUxMX01FVEhPRFMsXG4gICAgX0QyUixcbiAgICBfUjJELFxuICAgIF9fY2FsY3VsYXRlUGxhbmUsXG4gICAgX19mcm9tUHJvZHVjdCxcbiAgICBfX2Zyb21TdHJpa2VEaXBSYWtlLFxuICAgIF9fcmFuZ2UsXG4gICAgX19zb3J0RWlnZW52YWx1ZXMsXG4gICAgVGVuc29yO1xuXG5cbl9CRUFDSEJBTExfTUVUSE9EUyA9IHtcbiAgJ3NtaTpjaS5hbnNzLm9yZy9tb21lbnRUZW5zb3IvVE1UUyc6ICdUTVRTJyxcbiAgJ3NtaTpuYy5hbnNzLm9yZy9tb21lbnRUZW5zb3IvVE1UUyc6ICdUTVRTJyxcbiAgJ3NtaTpuYy5hbnNzLm9yZy9tb21lbnRUZW5zb3IvVE1UUy1JU08nOiAnVE1UUy1JU08nLFxuICAnc21pOnV1LmFuc3Mub3JnL21vbWVudFRlbnNvci9URE1UJzogJ1RETVQnXG59O1xuXG5fRDJSID0gTWF0aC5QSSAvIDE4MDtcbl9SMkQgPSAxODAgLyBNYXRoLlBJO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBvbmUgbm9kYWwgcGxhbmUuXG4gKlxuICogQXJndW1lbnQgb3JkZXIgbWF0dGVycywgc28gZ2V0UGxhbmUodjEsIHYyKSBhbmQgZ2V0UGxhbmUodjIsIHYxKVxuICogYXJlIGRpZmZlcmVudCBwbGFuZXMuXG4gKlxuICogQHBhcmFtIHYxIHtWZWN0b3J9XG4gKiAgICAgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHYyIHtWZWN0b3J9XG4gKiAgICAgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICBjb21wdXRlZCBwbGFuZSwgZGVmaW5lZCBhcyB0aGUgcHJvcGVydGllcyBzdHJpa2UsIGRpcCwgYW5kIHJha2UuXG4gKi9cbl9fY2FsY3VsYXRlUGxhbmUgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gIHYxID0gdjEudW5pdCgpO1xuICB2MiA9IHYyLnVuaXQoKTtcbiAgLy8gbWFrZSBzdXJlIGZpcnN0IHZlY3RvciBkaXBzIGRvd253YXJkXG4gIGlmICh2MS56KCkgPiAwKSB7XG4gICAgdjEgPSB2MS5tdWx0aXBseSgtMSk7XG4gICAgdjIgPSB2Mi5tdWx0aXBseSgtMSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdHJpa2U6IF9fcmFuZ2UoTWF0aC5hdGFuMigtdjEueCgpLCB2MS55KCkpLCAwLCAyICogTWF0aC5QSSkgKiBfUjJELFxuICAgIGRpcDogTWF0aC5hY29zKC12MS56KCkpICogX1IyRCxcbiAgICByYWtlOiBNYXRoLmF0YW4yKC12Mi56KCksIHYyLmNyb3NzKHYxKS56KCkpICogX1IyRFxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBUZW5zb3Igb2JqZWN0IGZyb20gYSBQcm9kdWN0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcHJvZHVjdCB7UHJvZHVjdH1cbiAqICAgICBhIGZvY2FsLW1lY2hhbmlzbSBvciBtb21lbnQtdGVuc29yIHByb2R1Y3QuXG4gKi9cbl9fZnJvbVByb2R1Y3QgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICB2YXIgZGVwdGgsXG4gICAgICBwcm9wcyxcbiAgICAgIHR5cGUsXG4gICAgICB0ZW5zb3I7XG5cbiAgdGVuc29yID0gbnVsbDtcbiAgdHlwZSA9IHByb2R1Y3QuZ2V0KCd0eXBlJyk7XG4gIHByb3BzID0gcHJvZHVjdC5nZXQoJ3Byb3BlcnRpZXMnKSB8fCB7fTtcblxuICBpZiAodHlwZSA9PT0gJ2ZvY2FsLW1lY2hhbmlzbScpIHtcbiAgICB0ZW5zb3IgPSBfX2Zyb21TdHJpa2VEaXBSYWtlKFxuICAgICAgICBOdW1iZXIocHJvcHNbJ25vZGFsLXBsYW5lLTEtc3RyaWtlJ10pLFxuICAgICAgICBOdW1iZXIocHJvcHNbJ25vZGFsLXBsYW5lLTEtZGlwJ10pLFxuICAgICAgICBOdW1iZXIocHJvcHNbJ25vZGFsLXBsYW5lLTEtcmFrZSddIHx8IHByb3BzWydub2RhbC1wbGFuZS0xLXNsaXAnXSB8fCAwKSxcbiAgICAgICAgTnVtYmVyKHByb3BzWydzY2FsYXItbW9tZW50J10gfHwgTWF0aC5TUVJUMikpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb21lbnQtdGVuc29yJykge1xuICAgIHRlbnNvciA9IFRlbnNvcih7XG4gICAgICBtcnI6IE51bWJlcihwcm9wc1sndGVuc29yLW1yciddKSxcbiAgICAgIG10dDogTnVtYmVyKHByb3BzWyd0ZW5zb3ItbXR0J10pLFxuICAgICAgbXBwOiBOdW1iZXIocHJvcHNbJ3RlbnNvci1tcHAnXSksXG4gICAgICBtcnQ6IE51bWJlcihwcm9wc1sndGVuc29yLW1ydCddKSxcbiAgICAgIG1ycDogTnVtYmVyKHByb3BzWyd0ZW5zb3ItbXJwJ10pLFxuICAgICAgbXRwOiBOdW1iZXIocHJvcHNbJ3RlbnNvci1tdHAnXSlcbiAgICB9KTtcblxuICAgIGRlcHRoID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnZGVyaXZlZC1kZXB0aCcpO1xuICAgIGlmIChkZXB0aCA9PT0gbnVsbCkgIHtcbiAgICAgIGRlcHRoID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnZGVwdGgnKTtcbiAgICB9XG5cbiAgICB0ZW5zb3IuZGVwdGggPSBkZXB0aDtcbiAgfVxuXG4gIGlmICh0ZW5zb3IpIHtcbiAgICB0eXBlID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnZGVyaXZlZC1tYWduaXR1ZGUtdHlwZScpO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgdHlwZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2JlYWNoYmFsbC10eXBlJyk7XG4gICAgICBpZiAodHlwZSAmJiBfQkVBQ0hCQUxMX01FVEhPRFMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgICAgdHlwZSA9IF9CRUFDSEJBTExfTUVUSE9EU1t0eXBlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgdGVuc29yLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0ZW5zb3I7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIFRlbnNvciBmcm9tIHN0cmlrZSwgZGlwLCBhbmQgcmFrZSBvZiBvbmUgbm9kYWwgcGxhbmUuXG4gKlxuICogQHBhcmFtIHN0cmlrZSB7TnVtYmVyfVxuICogICAgICAgIHN0cmlrZSBvZiBub2RhbCBwbGFuZSBpbiBkZWdyZWVzLlxuICogQHBhcmFtIGRpcCB7TnVtYmVyfVxuICogICAgICAgIGRpcCBvZiBub2RhbCBwbGFuZSBpbiBkZWdyZWVzLlxuICogQHBhcmFtIHJha2Uge051bWJlcn1cbiAqICAgICAgICByYWtlIG9mIG5vZGFsIHBsYW5lIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0gbW9tZW50IHtOdW1iZXJ9XG4gKiAgICAgICAgc2NhbGUgcmVzdWx0aW5nIG1hdHJpeCBieSB0aGlzIG51bWJlci5cbiAqIEByZXR1cm4gVGVuc29yIG9iamVjdC5cbiAqL1xuX19mcm9tU3RyaWtlRGlwUmFrZSA9IGZ1bmN0aW9uKHN0cmlrZSwgZGlwLCByYWtlLCBtb21lbnQpIHtcbiAgdmFyIGMyZCxcbiAgICAgIGMycyxcbiAgICAgIGNkLFxuICAgICAgY3IsXG4gICAgICBjcyxcbiAgICAgIGQsXG4gICAgICBteHgsXG4gICAgICBteHksXG4gICAgICBteHosXG4gICAgICBteXksXG4gICAgICBteXosXG4gICAgICBtenosXG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHMyZCxcbiAgICAgIHMycyxcbiAgICAgIHNkLFxuICAgICAgc3IsXG4gICAgICBzcztcblxuICBzID0gc3RyaWtlICogX0QyUjtcbiAgc3MgPSBNYXRoLnNpbihzKTtcbiAgY3MgPSBNYXRoLmNvcyhzKTtcbiAgczJzID0gTWF0aC5zaW4oMipzKTtcbiAgYzJzID0gTWF0aC5jb3MoMipzKTtcbiAgZCA9IGRpcCAqIF9EMlI7XG4gIHNkID0gTWF0aC5zaW4oZCk7XG4gIGNkID0gTWF0aC5jb3MoZCk7XG4gIHMyZCA9IE1hdGguc2luKDIqZCk7XG4gIGMyZCA9IE1hdGguY29zKDIqZCk7XG4gIHIgPSAocmFrZSAlIDkwICE9PSAwID8gcmFrZSA6IHJha2UgKyAxZS0xNSkgKiBfRDJSO1xuICBzciA9IE1hdGguc2luKHIpO1xuICBjciA9IE1hdGguY29zKHIpO1xuXG4gIC8vIG10dFxuICBteHggPSAtMSAqIChzZCAqIGNyICogczJzICsgczJkICogc3IgKiBzcyAqIHNzKTtcbiAgLy8gLW10cFxuICBteHkgPSAgICAgIChzZCAqIGNyICogYzJzICsgczJkICogc3IgKiBzMnMgKiAwLjUpO1xuICAvLyBtcnRcbiAgbXh6ID0gLTEgKiAoY2QgKiBjciAqIGNzICArIGMyZCAqIHNyICogc3MpO1xuICAvLyBtcHBcbiAgbXl5ID0gICAgICAoc2QgKiBjciAqIHMycyAtIHMyZCAqIHNyICogY3MgKiBjcyk7XG4gIC8vIC1tcnBcbiAgbXl6ID0gLTEgKiAoY2QgKiBjciAqIHNzICAtIGMyZCAqIHNyICogY3MpO1xuICAvLyBtcnJcbiAgbXp6ID0gICAgICAoczJkICogc3IpO1xuXG4gIHJldHVybiBUZW5zb3Ioe1xuICAgIG1ycjogIG16eiAqIG1vbWVudCxcbiAgICBtdHQ6ICBteHggKiBtb21lbnQsXG4gICAgbXBwOiAgbXl5ICogbW9tZW50LFxuICAgIG10cDogLW14eSAqIG1vbWVudCxcbiAgICBtcnA6IC1teXogKiBtb21lbnQsXG4gICAgbXJ0OiAgbXh6ICogbW9tZW50XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTaGlmdCBhIG51bWJlciB1bnRpbCBpdCBpcyBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxuICpcbiAqIEFkZCBvciBzdWJ0cmFjdCB0aGUgcmFuZ2Ugc2l6ZSAobWF4IC0gbWluKSB1bnRpbCB2YWx1ZSBpcyBiZXR3ZWVuLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfVxuICogICAgICAgIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAqIEBwYXJhbSBtaW4ge051bWJlcn1cbiAqICAgICAgICByYW5nZSBtaW5pbXVtLlxuICogQHBhcmFtIG1heCB7TnVtYmVyfVxuICogICAgICAgIHJhbmdlIG1heGltdW0uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlIGluIHRoZSByYW5nZSBbbWluLCBtYXgpLlxuICovXG5fX3JhbmdlID0gZnVuY3Rpb24gKHZhbHVlLCBtaW4sIG1heCkge1xuICB2YXIgc3BhbiA9IG1heCAtIG1pbjtcbiAgd2hpbGUgKHZhbHVlIDwgbWluKSB7XG4gICAgdmFsdWUgKz0gc3BhbjtcbiAgfVxuICB3aGlsZSAodmFsdWUgPj0gbWF4KSB7XG4gICAgdmFsdWUgLT0gc3BhbjtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNvcnQgZWlnZW4gdmVjdG9ycyBpbiBkZXNjZW5kaW5nIG9yZGVyIGJ5IG1hZ25pdHVkZS5cbiAqXG4gKiBAcGFyYW0gdjEge1ZlY3Rvcn1cbiAqICAgICBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0gdjIge1ZlY3Rvcn1cbiAqICAgICBzZWNvbmQgdmVjdG9yLlxuICovXG5fX3NvcnRFaWdlbnZhbHVlcyA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgdmFyIHYxbWFnLFxuICAgICAgdjJtYWc7XG4gIC8vIGxhcmdlc3QgdmFsdWUgZmlyc3RcbiAgdjFtYWcgPSB2MS5laWdlbnZhbHVlO1xuICB2Mm1hZyA9IHYyLmVpZ2VudmFsdWU7XG4gIGlmICh2MW1hZyA8IHYybWFnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAodjFtYWcgPiB2Mm1hZykge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yLlxuICpcbiAqIEBwYXJhbSBtdHQge051bWJlcn1cbiAqICAgICAgICBtdHQgdmFsdWUgaW4gTi1tLlxuICogQHBhcmFtIG1wcCB7TnVtYmVyfVxuICogICAgICAgIG1wcCB2YWx1ZSBpbiBOLW0uXG4gKiBAcGFyYW0gbXJyIHtOdW1iZXJ9XG4gKiAgICAgICAgbXJyIHZhbHVlIGluIE4tbS5cbiAqIEBwYXJhbSBtcnQge051bWJlcn1cbiAqICAgICAgICBtcnQgdmFsdWUgaW4gTi1tLlxuICogQHBhcmFtIG1ycCB7TnVtYmVyfVxuICogICAgICAgIG1ycCB2YWx1ZSBpbiBOLW0uXG4gKiBAcGFyYW0gbXRwIHtOdW1iZXJ9XG4gKiAgICAgICAgbXRwIHZhbHVlIGluIE4tbS5cbiAqL1xuIFRlbnNvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplO1xuXG4gIF90aGlzID0ge307XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBlaWdlbixcbiAgICAgICAgZXhwb25lbnQsXG4gICAgICAgIGwsXG4gICAgICAgIG1vbWVudCxcbiAgICAgICAgbW9tZW50X2xvZzEwLFxuICAgICAgICBtcHAsXG4gICAgICAgIG1ycixcbiAgICAgICAgbXJ0LFxuICAgICAgICBtcnAsXG4gICAgICAgIG10cCxcbiAgICAgICAgbXR0LFxuICAgICAgICBuLFxuICAgICAgICBwLFxuICAgICAgICB0O1xuXG4gICAgX3RoaXMubXR0ID0gbXR0ID0gb3B0aW9ucy5tdHQgfHwgb3B0aW9ucy5teHggfHwgMDtcbiAgICBfdGhpcy5tcHAgPSBtcHAgPSBvcHRpb25zLm1wcCB8fCBvcHRpb25zLm15eSB8fCAwO1xuICAgIF90aGlzLm1yciA9IG1yciA9IG9wdGlvbnMubXJyIHx8IG9wdGlvbnMubXp6IHx8IDA7XG4gICAgX3RoaXMubXJ0ID0gbXJ0ID0gb3B0aW9ucy5tcnQgfHwgb3B0aW9ucy5teHogfHwgMDtcbiAgICBfdGhpcy5tcnAgPSBtcnAgPSBvcHRpb25zLm1ycCB8fCAtb3B0aW9ucy5teXogfHwgMDtcbiAgICBfdGhpcy5tdHAgPSBtdHAgPSBvcHRpb25zLm10cCB8fCAtb3B0aW9ucy5teHkgfHwgMDtcbiAgICBfdGhpcy51bml0cyA9ICdOLW0nO1xuXG4gICAgLy8gY2FsY3VsYXRlIG1vbWVudCBhbmQgZGVyaXZlZCB2YWx1ZXNcbiAgICBfdGhpcy5tb21lbnQgPSBtb21lbnQgPSBNYXRoLnNxcnQoMC41ICpcbiAgICAgICAgKCAobXJyICogbXJyICsgbXR0ICogbXR0ICsgbXBwICogbXBwKSArXG4gICAgICAgIDIgKiAobXJ0ICogbXJ0ICsgbXJwICogbXJwICsgbXRwICogbXRwKSApKTtcbiAgICBfdGhpcy5tb21lbnRfbG9nMTAgPSBtb21lbnRfbG9nMTAgPSBNYXRoLmxvZyhtb21lbnQpIC8gTWF0aC5MTjEwO1xuICAgIF90aGlzLmV4cG9uZW50ID0gZXhwb25lbnQgPSBwYXJzZUludChtb21lbnRfbG9nMTAsIDEwKTtcbiAgICBfdGhpcy5zY2FsZSA9IE1hdGgucG93KDEwLCBleHBvbmVudCk7XG4gICAgX3RoaXMubWFnbml0dWRlID0gKDIvMykgKiAobW9tZW50X2xvZzEwIC0gOS4xKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBwcmluY2lwYWwgYXhlc1xuICAgIF90aGlzLm1hdHJpeCA9IE1hdHJpeChbXG4gICAgICBtdHQsIC1tdHAsIG1ydCxcbiAgICAgIC1tdHAsIG1wcCwgLW1ycCxcbiAgICAgIG1ydCwgLW1ycCwgbXJyXG4gICAgXSwgMywgMyk7XG4gICAgZWlnZW4gPSBfdGhpcy5tYXRyaXguamFjb2JpKCk7XG4gICAgZWlnZW4uc29ydChfX3NvcnRFaWdlbnZhbHVlcyk7XG4gICAgX3RoaXMuVCA9IHQgPSBlaWdlblswXTtcbiAgICBfdGhpcy5OID0gbiA9IGVpZ2VuWzFdO1xuICAgIF90aGlzLlAgPSBwID0gZWlnZW5bMl07XG4gICAgX3RoaXMuZkNMVkQgPSBuLmVpZ2VudmFsdWUgL1xuICAgICAgICBNYXRoLm1heChNYXRoLmFicyh0LmVpZ2VudmFsdWUpLCBNYXRoLmFicyhwLmVpZ2VudmFsdWUpKTtcbiAgICBfdGhpcy5wZXJjZW50REMgPSBNYXRoLmFicygxIC0gTWF0aC5hYnMoX3RoaXMuZkNMVkQpIC8gMC41KTtcbiAgICBfdGhpcy5mb3JjZVRocnVzdCA9IE1hdGgucG93KE1hdGguc2luKHQucGx1bmdlKCkpLCAyKTtcbiAgICBfdGhpcy5mb3JjZVN0cmlrZVNsaXAgPSBNYXRoLnBvdyhNYXRoLnNpbihuLnBsdW5nZSgpKSwgMik7XG4gICAgX3RoaXMuZm9yY2VOb3JtYWwgPSBNYXRoLnBvdyhNYXRoLnNpbihwLnBsdW5nZSgpKSwgMik7XG5cbiAgICAvLyBjYWxjdWxhdGUgbm9kYWwgcGxhbmVzXG4gICAgLy8gcCA9IChuIC0gbCkgLyBzcXJ0MlxuICAgIC8vIHQgPSAobiArIGwpIC8gc3FydDJcbiAgICBsID0gdC5zdWJ0cmFjdChwKS51bml0KCk7XG4gICAgbiA9IHQuYWRkKHApLnVuaXQoKTtcbiAgICBfdGhpcy5OUDEgPSBfX2NhbGN1bGF0ZVBsYW5lKGwsIG4pO1xuICAgIF90aGlzLk5QMiA9IF9fY2FsY3VsYXRlUGxhbmUobiwgbCk7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuLy8gYWRkIHN0YXRpYyBtZXRob2RzXG5UZW5zb3IuY2FsY3VsYXRlUGxhbmUgPSBfX2NhbGN1bGF0ZVBsYW5lO1xuVGVuc29yLmZyb21Qcm9kdWN0ID0gX19mcm9tUHJvZHVjdDtcblRlbnNvci5mcm9tU3RyaWtlRGlwUmFrZSA9IF9fZnJvbVN0cmlrZURpcFJha2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUZW5zb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudHMgPSByZXF1aXJlKCcuLi91dGlsL0V2ZW50cycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL1V0aWwnKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSBkYXRhIHtPYmplY3R9XG4gKiAgICAgIGtleS92YWx1ZSBhdHRyaWJ1dGVzIG9mIHRoaXMgbW9kZWwuXG4gKi9cbnZhciBNb2RlbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfbW9kZWw7XG5cblxuICBfdGhpcyA9IEV2ZW50cygpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIF9tb2RlbCA9IFV0aWwuZXh0ZW5kKHt9LCBkYXRhKTtcblxuICAgIC8vIHRyYWNrIGlkIGF0IHRvcCBsZXZlbFxuICAgIGlmIChkYXRhICYmIGRhdGEuaGFzT3duUHJvcGVydHkoJ2lkJykpIHtcbiAgICAgIF90aGlzLmlkID0gZGF0YS5pZDtcbiAgICB9XG5cbiAgICBkYXRhID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9uZSBvciBtb3JlIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIGtleSB7U3RyaW5nfVxuICAgKiAgICAgIHRoZSB2YWx1ZSB0byBnZXQ7IHdoZW4ga2V5IGlzIHVuZGVmaW5lZCwgcmV0dXJucyB0aGUgb2JqZWN0IHdpdGggYWxsXG4gICAqICAgICAgdmFsdWVzLlxuICAgKiBAcmV0dXJuXG4gICAqICAgICAgLSBpZiBrZXkgaXMgc3BlY2lmaWVkLCB0aGUgdmFsdWUgb3IgbnVsbCBpZiBubyB2YWx1ZSBleGlzdHMuXG4gICAqICAgICAgLSB3aGVuIGtleSBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgdW5kZXJseWluZyBvYmplY3QgaXMgcmV0dXJuZWQuXG4gICAqICAgICAgICAoQW55IGNoYW5nZXMgdG8gdGhpcyB1bmRlcmx5aW5nIG9iamVjdCB3aWxsIG5vdCB0cmlnZ2VyIGV2ZW50cyEhISlcbiAgICovXG4gIF90aGlzLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAodHlwZW9mKGtleSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gX21vZGVsO1xuICAgIH1cblxuICAgIGlmIChfbW9kZWwuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIF9tb2RlbFtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgb25lIG9yIG1vcmUgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB7T2JqZWN0fVxuICAgKiAgICAgIHRoZSBrZXlzIGFuZCB2YWx1ZXMgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICAgKiAgICAgIG9wdGlvbnMgZm9yIHRoaXMgbWV0aG9kLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWxlbnQge0Jvb2xlYW59XG4gICAqICAgICAgZGVmYXVsdCBmYWxzZS4gdHJ1ZSB0byBzdXBwcmVzcyBhbnkgZXZlbnRzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGJlXG4gICAqICAgICAgdHJpZ2dlcmVkLlxuICAgKi9cbiAgX3RoaXMuc2V0ID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAvLyBkZXRlY3QgY2hhbmdlc1xuICAgIHZhciBjaGFuZ2VkID0ge30sXG4gICAgICBhbnlDaGFuZ2VkID0gZmFsc2UsXG4gICAgICBjO1xuXG4gICAgZm9yIChjIGluIGRhdGEpIHtcbiAgICAgIGlmICghX21vZGVsLmhhc093blByb3BlcnR5KGMpIHx8IF9tb2RlbFtjXSAhPT0gZGF0YVtjXSkge1xuICAgICAgICBjaGFuZ2VkW2NdID0gZGF0YVtjXTtcbiAgICAgICAgYW55Q2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGVyc2lzdCBjaGFuZ2VzXG4gICAgX21vZGVsID0gVXRpbC5leHRlbmQoX21vZGVsLCBkYXRhKTtcblxuICAgIC8vIGlmIGlkIGlzIGNoYW5naW5nLCB1cGRhdGUgdGhlIG1vZGVsIGlkXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5oYXNPd25Qcm9wZXJ0eSgnaWQnKSkge1xuICAgICAgX3RoaXMuaWQgPSBkYXRhLmlkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3NpbGVudCcpICYmIG9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAvLyBkb24ndCB0cmlnZ2VyIGFueSBldmVudHNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGV2ZW50cyBiYXNlZCBvbiBjaGFuZ2VzXG4gICAgaWYgKGFueUNoYW5nZWQgfHxcbiAgICAgICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZm9yY2UnKSAmJiBvcHRpb25zLmZvcmNlKSkge1xuICAgICAgZm9yIChjIGluIGNoYW5nZWQpIHtcbiAgICAgICAgLy8gZXZlbnRzIHNwZWNpZmljIHRvIGEgcHJvcGVydHlcbiAgICAgICAgX3RoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjLCBjaGFuZ2VkW2NdKTtcbiAgICAgIH1cbiAgICAgIC8vIGdlbmVyaWMgZXZlbnQgZm9yIGFueSBjaGFuZ2VcbiAgICAgIF90aGlzLnRyaWdnZXIoJ2NoYW5nZScsIGNoYW5nZWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdG9KU09OIG1ldGhvZCB0byBzZXJpYWxpemUgb25seSBtb2RlbCBkYXRhLlxuICAgKi9cbiAgX3RoaXMudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBqc29uID0gVXRpbC5leHRlbmQoe30sIF9tb2RlbCksXG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWU7XG5cbiAgICBmb3IgKGtleSBpbiBqc29uKSB7XG4gICAgICB2YWx1ZSA9IGpzb25ba2V5XTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAganNvbltrZXldID0gdmFsdWUudG9KU09OKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb247XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZSgpO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBBIGxpZ2h0d2VpZ2h0IHZpZXcgY2xhc3MuXG4gKlxuICogUHJpbWFyaWx5IG1hbmFnZXMgYW4gZWxlbWVudCB3aGVyZSBhIHZpZXcgY2FuIHJlbmRlciBpdHMgZGF0YS5cbiAqL1xuXG5cbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKSxcblxuICAgIEV2ZW50cyA9IHJlcXVpcmUoJy4uL3V0aWwvRXZlbnRzJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG59O1xuXG5cbi8qKiBjcmVhdGUgYSBuZXcgdmlldy4gKi9cbnZhciBWaWV3ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2Rlc3Ryb3lNb2RlbDtcblxuXG4gIF90aGlzID0gRXZlbnRzKCk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgcGFyYW1zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgcGFyYW1zKTtcblxuICAgIC8vIEVsZW1lbnQgd2hlcmUgdGhpcyB2aWV3IGlzIHJlbmRlcmVkXG4gICAgX3RoaXMuZWwgPSAocGFyYW1zICYmIHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgnZWwnKSkgP1xuICAgICAgICBwYXJhbXMuZWwgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIF90aGlzLm1vZGVsID0gcGFyYW1zLm1vZGVsO1xuXG4gICAgaWYgKCFfdGhpcy5tb2RlbCkge1xuICAgICAgX3RoaXMubW9kZWwgPSBNb2RlbCh7fSk7XG4gICAgICBfZGVzdHJveU1vZGVsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfdGhpcy5tb2RlbC5vbignY2hhbmdlJywgJ3JlbmRlcicsIF90aGlzKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBBUEkgTWV0aG9kXG4gICAqXG4gICAqIFJlbmRlcnMgdGhlIHZpZXdcbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJbXBlbGVtZW50YXRpb25zIHNob3VsZCB1cGRhdGUgdGhlIHZpZXcgYmFzZWQgb24gdGhlIGN1cnJlbnRcbiAgICAvLyBtb2RlbCBwcm9wZXJ0aWVzLlxuICB9O1xuXG4gIC8qKlxuICAgKiBBUEkgTWV0aG9kXG4gICAqXG4gICAqIENsZWFucyB1cCByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IHRoZSB2aWV3LiBTaG91bGQgYmUgY2FsbGVkIGJlZm9yZVxuICAgKiBkaXNjYXJkaW5nIGEgdmlldy5cbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfdGhpcyA9PT0gIG51bGwpIHtcbiAgICAgIHJldHVybjsgLy8gYWxyZWFkeSBkZXN0cm95ZWRcbiAgICB9XG5cbiAgICBfdGhpcy5tb2RlbC5vZmYoJ2NoYW5nZScsICdyZW5kZXInLCBfdGhpcyk7XG5cbiAgICBpZiAoX2Rlc3Ryb3lNb2RlbCkge1xuICAgICAgX3RoaXMubW9kZWwuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIF9kZXN0cm95TW9kZWwgPSBudWxsO1xuXG4gICAgX3RoaXMubW9kZWwgPSBudWxsO1xuICAgIF90aGlzLmVsID0gbnVsbDtcblxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG5cbiAgX2luaXRpYWxpemUocGFyYW1zKTtcbiAgcGFyYW1zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBGb3JlY2FzdFZpZXcgPSByZXF1aXJlKCdvYWYvRm9yZWNhc3RWaWV3JyksXG4gICAgRm9ybWF0dGVyID0gcmVxdWlyZSgnY29yZS9Gb3JtYXR0ZXInKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcblxufTtcblxuXG52YXIgRm9yZWNhc3RUYWJsZVZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2Zvcm1hdHRlcjtcblxuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgX3RoaXMgPSBGb3JlY2FzdFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ29hZi1mb3JlY2FzdC10YWJsZS12aWV3Jyk7XG5cbiAgICBfZm9ybWF0dGVyID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgRm9ybWF0dGVyKCk7XG4gIH07XG5cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnb2FmLWZvcmVjYXN0LXRhYmxlLXZpZXcnKTtcblxuICAgIF9mb3JtYXR0ZXIgPSBudWxsO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgX3RoaXMuZ2V0Um93SGVhZGVyID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICB2YXIgdGg7XG5cbiAgICB0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XG4gICAgdGguc2V0QXR0cmlidXRlKCdzY29wZScsICdyb3cnKTtcbiAgICB0aC5zZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nLCBpbmZvLmJpbnMubGVuZ3RoKTtcblxuICAgIHRoLmlubmVySFRNTCA9IFtcbiAgICAgICc8c3Ryb25nPicsIGluZm8ubGFiZWwsICc8L3N0cm9uZz4nLFxuICAgICAgJzxici8+JyxcbiAgICAgIF9mb3JtYXR0ZXIuZGF0ZXRpbWUobmV3IERhdGUoaW5mby50aW1lU3RhcnQpKSxcbiAgICAgICc8YnIvPnRocm91Z2g8YnIvPicsXG4gICAgICBfZm9ybWF0dGVyLmRhdGV0aW1lKG5ldyBEYXRlKGluZm8udGltZUVuZCkpXG4gICAgXS5qb2luKCcnKTtcblxuICAgIHJldHVybiB0aDtcbiAgfTtcblxuICBfdGhpcy5nZXRUYWJsZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHRhYmxlLFxuICAgICAgICB3cmFwcGVyO1xuXG4gICAgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnaG9yaXpvbnRhbC1zY3JvbGxpbmcnKTtcblxuICAgIHRhYmxlID0gd3JhcHBlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpKTtcblxuICAgIHRhYmxlLmlubmVySFRNTCA9IFtcbiAgICAgICc8dGhlYWQ+JyxcbiAgICAgICAgJzx0cj4nLFxuICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj4nLFxuICAgICAgICAgICAgJ1RpbWUgV2luZG93IGZvciBBbmFseXNpcycsXG4gICAgICAgICAgJzwvdGg+JyxcbiAgICAgICAgICAnPHRoIHNjb3BlPVwiY29sXCI+JyxcbiAgICAgICAgICAgICdNYWduaXR1ZGUgKE0pIHJhbmdlIG9mIGFmdGVyc2hvY2tzIGNvbnNpZGVyZWQnLFxuICAgICAgICAgICc8L3RoPicsXG4gICAgICAgICAgJzx0aCBzY29wZT1cImNvbFwiPicsXG4gICAgICAgICAgICAnTW9zdCBsaWtlbHkgbnVtYmVyIG9mIGFmdGVyc2hvY2tzICg5NSAlIGNvbmRpZGVuY2UpJyxcbiAgICAgICAgICAnPC90aD4nLFxuICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj4nLFxuICAgICAgICAgICAgJ1Byb2JhYmlsaXR5IG9mIG9uZSBvciBtb3JlIGFmdGVyc2hvY2tzJyxcbiAgICAgICAgICAnPC90aD4nLFxuICAgICAgICAnPC90cj4nLFxuICAgICAgJzwvdGhlYWQ+J1xuICAgIF0uam9pbignJyk7XG5cbiAgICB0YWJsZS5hcHBlbmRDaGlsZChfdGhpcy5nZXRUYWJsZUJvZHkoZGF0YSkpO1xuXG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH07XG5cbiAgX3RoaXMuZ2V0VGFibGVCb2R5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgYm9keTtcblxuICAgIGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpO1xuXG4gICAgZGF0YS5mb3JlY2FzdC5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBib2R5LmFwcGVuZENoaWxkKF90aGlzLmdldFRhYmxlUm93KGluZm8pKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBib2R5O1xuICB9O1xuXG4gIF90aGlzLmdldFRhYmxlUm93ID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICB2YXIgZnJhZ21lbnQsXG4gICAgICAgIHJvdztcblxuICAgIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgcm93ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKSk7XG4gICAgcm93LmNsYXNzTGlzdC5hZGQoJ3NlcGFyYXRvcicpO1xuICAgIHJvdy5hcHBlbmRDaGlsZChfdGhpcy5nZXRSb3dIZWFkZXIoaW5mbykpO1xuXG4gICAgaW5mby5iaW5zLmZvckVhY2goZnVuY3Rpb24gKGJpbiwgaW5kZXgpIHtcbiAgICAgIHZhciBkZXRhaWxSb3c7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBkZXRhaWxSb3cgPSByb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXRhaWxSb3cgPSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpKTtcbiAgICAgIH1cblxuICAgICAgZGV0YWlsUm93LmFwcGVuZENoaWxkKF90aGlzLmdldFRhYmxlUm93RGV0YWlscyhiaW4pKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfTtcblxuICBfdGhpcy5nZXRUYWJsZVJvd0RldGFpbHMgPSBmdW5jdGlvbiAoYmluKSB7XG4gICAgdmFyIGV4cENlbGwsXG4gICAgICAgIG1hZ0NlbGwsXG4gICAgICAgIHA5NUNlbGwsXG4gICAgICAgIHJvdztcblxuICAgIHJvdyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIC8vIE1hZ25pdHVkZVxuICAgIG1hZ0NlbGwgPSByb3cuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKSk7XG4gICAgbWFnQ2VsbC5pbm5lckhUTUwgPSAnTSAmZ2U7ICcgKyBiaW4ubWFnbml0dWRlO1xuXG4gICAgLy8gOTUgJSBjb25maWRlbmNlXG4gICAgcDk1Q2VsbCA9IHJvdy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpKTtcbiAgICBpZiAoYmluLnA5NW1pbmltdW0gKyBiaW4ucDk1bWF4aW11bSkge1xuICAgICAgcDk1Q2VsbC5pbm5lckhUTUwgPSBiaW4ucDk1bWluaW11bSArICcgdG8gJyArIGJpbi5wOTVtYXhpbXVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBwOTVDZWxsLmlubmVySFRNTCA9ICcqJztcbiAgICB9XG5cbiAgICAvLyBFeHBlY3RhdGlvblxuICAgIGV4cENlbGwgPSByb3cuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKSk7XG4gICAgaWYgKGJpbi5wcm9iYWJpbGl0eSA8IDAuMDEpIHtcbiAgICAgIGV4cENlbGwuaW5uZXJIVE1MID0gJyZsdDsgMSAlJztcbiAgICB9IGVsc2UgaWYgKGJpbi5wcm9iYWJpbGl0eSA8IDEuMCkge1xuICAgICAgZXhwQ2VsbC5pbm5lckhUTUwgPSBfZm9ybWF0dGVyLm51bWJlcihcbiAgICAgICAgICBiaW4ucHJvYmFiaWxpdHkqMTAwLCAwLCAnJm5kYXNoJywgJyUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwQ2VsbC5pbm5lckhUTUwgPSAnJmd0OyA5OSAlJztcbiAgICB9XG5cbiAgICByZXR1cm4gcm93O1xuICB9O1xuXG4gIF90aGlzLnJlbmRlckZvcmVjYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb290bm90ZSxcbiAgICAgICAgdG9wbm90ZTtcblxuICAgIF90aGlzLmVsLmlubmVySFRNTCA9ICcnO1xuXG4gICAgdG9wbm90ZSA9IF90aGlzLmVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKSk7XG4gICAgdG9wbm90ZS5jbGFzc0xpc3QuYWRkKCdhbGVydCcpO1xuICAgIHRvcG5vdGUuaW5uZXJIVE1MID0gW1xuICAgICAgJ05vdGU6IFRoZSBleHBlY3RlZCByYXRlIG9mIGVhcnRocXVha2VzIGNvbnRpbnVlcyB0byBkZWNsaW5lIHRocm91Z2hvdXQgJyxcbiAgICAgICd0aGUgdGltZSB3aW5kb3dzLiBUaGUgcHJvYmFiaWxpdGllcyBpbiB0aGUgbG9uZ2VyIHRpbWUgd2luZG93cyBhcmUgJyxcbiAgICAgICdoaWdoZXIgb25seSBiZWNhdXNlIHRoZSByYXRlcyBhcmUgYmVpbmcgc3VtbWVkIG92ZXIgYSBsb25nZXIgdGltZSAnLFxuICAgICAgJ3BlcmlvZC4gVGhlc2UgbG9uZ2VyIHBlcmlvZHMgbWF5IGJlIHVzZWZ1bCB3aGVuIHBsYW5uaW5nIHJlY292ZXJ5ICcsXG4gICAgICAnYW5kIHJlYnVsaWRpbmcgcHJvamVjdHMuJ1xuICAgIF0uam9pbignJyk7XG5cbiAgICBfdGhpcy5lbC5hcHBlbmRDaGlsZChfdGhpcy5nZXRUYWJsZShfdGhpcy5mb3JlY2FzdCB8fCB7Zm9yZWNhc3Q6W119KSk7XG5cbiAgICBmb290bm90ZSA9IF90aGlzLmVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NtYWxsJykpO1xuICAgIGZvb3Rub3RlLmlubmVySFRNTCA9ICcqIEVhcnRocXVha2UgcG9zc2libGUgYnV0IHdpdGggYSBsb3cgcHJvYmFiaWxpdHkuJztcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcmVjYXN0VGFibGVWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBGb3JlY2FzdFZpZXcgPSByZXF1aXJlKCdvYWYvRm9yZWNhc3RWaWV3JyksXG4gICAgRm9ybWF0dGVyID0gcmVxdWlyZSgnY29yZS9Gb3JtYXR0ZXInKSxcbiAgICBQcm9kdWN0ID0gcmVxdWlyZSgncGRsL1Byb2R1Y3QnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcblxufTtcblxuXG52YXIgRm9yZWNhc3RUZXh0VmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfY2F0YWxvZ0V2ZW50LFxuICAgICAgX2Zvcm1hdHRlcixcbiAgICAgIF9wcm9kdWN0O1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IEZvcmVjYXN0VmlldyhvcHRpb25zKTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnb2FmLWZvcmVjYXN0LXRleHQtdmlldycpO1xuXG4gICAgX2NhdGFsb2dFdmVudCA9IG9wdGlvbnMuY2F0YWxvZ0V2ZW50O1xuICAgIF9mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBGb3JtYXR0ZXIoKTtcbiAgICBfcHJvZHVjdCA9IG9wdGlvbnMucHJvZHVjdCB8fCBQcm9kdWN0KCk7XG4gIH07XG5cblxuICBfdGhpcy5nZXRDb21tZW50YXJ5ID0gZnVuY3Rpb24gKGZvcmVjYXN0KSB7XG4gICAgdmFyIGF3YXJlbmVzc1RpbWVTcGFuLFxuICAgICAgICBjb21tZW50YXJ5LFxuICAgICAgICBlbGV2YXRlZFRpbWVTcGFuLFxuICAgICAgICBmZWx0VGltZVNwYW4sXG4gICAgICAgIG0zZGlzcGxheSxcbiAgICAgICAgbTVkaXNwbGF5LFxuICAgICAgICBtNmRpc3BsYXksXG4gICAgICAgIG03ZGlzcGxheSxcbiAgICAgICAgbWFnRGlzcGxheSxcbiAgICAgICAgbWFnbml0dWRlLFxuICAgICAgICBtb3N0QWZ0ZXJzaG9ja3NUaW1lU3BhbixcbiAgICAgICAgcGxhY2UsXG4gICAgICAgIHN1bW1hcnksXG4gICAgICAgIHdjRGlzcGxheSxcbiAgICAgICAgd2Vla0Zyb21Jc3N1ZSxcbiAgICAgICAgd2Vla0luZm87XG5cbiAgICBpZiAoX2NhdGFsb2dFdmVudCkge1xuICAgICAgc3VtbWFyeSA9IF9jYXRhbG9nRXZlbnQuZ2V0U3VtbWFyeSgpIHx8IHtwcm9wZXJ0aWVzOiB7fX07XG4gICAgICBtYWduaXR1ZGUgPSBfY2F0YWxvZ0V2ZW50LmdldE1hZ25pdHVkZSgpO1xuXG4gICAgICBlbGV2YXRlZFRpbWVTcGFuID0gKG1hZ25pdHVkZSA+PSA2LjApID9cbiAgICAgICAgICAndGhlIG5leHQgeWVhciBvciBsb25nZXInIDpcbiAgICAgICAgICAndGhlIG5leHQgbW9udGggb3IgbG9uZ2VyJztcblxuICAgICAgbW9zdEFmdGVyc2hvY2tzVGltZVNwYW4gPSAobWFnbml0dWRlID49IDYuMCkgP1xuICAgICAgICAgICd0aGUgZmlyc3QgZmV3IHdlZWtzJyA6XG4gICAgICAgICAgJ3RoZSBmaXJzdCBmZXcgZGF5cyc7XG5cbiAgICAgIG1hZ0Rpc3BsYXkgPSBfZm9ybWF0dGVyLm1hZ25pdHVkZShtYWduaXR1ZGUpO1xuICAgICAgcGxhY2UgPSBzdW1tYXJ5LnByb3BlcnRpZXMucGxhY2U7XG5cbiAgICAgIHdjRGlzcGxheSA9IF9mb3JtYXR0ZXIuZGlzdGFuY2UoXG4gICAgICAgICAgMiAqIF9wcm9kdWN0LmdldFByb3BlcnR5KCd3Y3JhZGl1cycpLCAna20nKTtcblxuICAgICAgYXdhcmVuZXNzVGltZVNwYW4gPSAobWFnbml0dWRlID49IDYuMCkgP1xuICAgICAgICAgICd0aGUgY29taW5nIG1vbnRocycgOlxuICAgICAgICAgICd0aGUgY29taW5nIHdlZWtzJztcblxuICAgICAgd2Vla0Zyb21Jc3N1ZSA9IF9mb3JtYXR0ZXIuZGF0ZXRpbWUoNjA0ODAwMDAwICtcbiAgICAgICAgICBfcHJvZHVjdC5nZXQoJ3VwZGF0ZVRpbWUnKSB8fCAwKTtcblxuICAgICAgd2Vla0luZm8gPSBmb3JlY2FzdC5mb3JlY2FzdFsxXTtcblxuICAgICAgbTNkaXNwbGF5ID0gX3RoaXMuZ2V0UHJvYkFuZEV4cCh3ZWVrSW5mby5iaW5zWzBdKTtcbiAgICAgIG01ZGlzcGxheSA9IF90aGlzLmdldFByb2JBbmRFeHAod2Vla0luZm8uYmluc1sxXSk7XG4gICAgICBtNmRpc3BsYXkgPSBfdGhpcy5nZXRQcm9iQW5kRXhwKHdlZWtJbmZvLmJpbnNbMl0pO1xuICAgICAgbTdkaXNwbGF5ID0gX3RoaXMuZ2V0UHJvYkFuZEV4cCh3ZWVrSW5mby5iaW5zWzNdKTtcblxuICAgICAgZmVsdFRpbWVTcGFuID0gKG1hZ25pdHVkZSA+PSA2LjApID9cbiAgICAgICAgICAnbmV4dCBtb250aCBhbmQgbmV4dCB5ZWFyJyA6XG4gICAgICAgICAgJ25leHQgd2VlayBhbmQgbmV4dCBtb250aCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoYXQgYXJlIGRvaW5nIGlmIG5vIGV2ZW50IC4uLiA/Pz9cbiAgICAgIGVsZXZhdGVkVGltZVNwYW4gPSAndGhlIG5leHQgbW9udGggb3IgbG9uZ2VyJztcbiAgICAgIG1vc3RBZnRlcnNob2Nrc1RpbWVTcGFuID0gJ3RoZSBmaXJzdCBmZXcgZGF5cyc7XG4gICAgICBwbGFjZSA9ICcmbmRhc2g7JztcbiAgICAgIHdjRGlzcGxheSA9ICcmbmRhc2g7JztcbiAgICAgIGF3YXJlbmVzc1RpbWVTcGFuID0gJ3RoZSBjb21pbmcgd2Vla3MnO1xuICAgICAgd2Vla0Zyb21Jc3N1ZSA9IF9mb3JtYXR0ZXIuZGF0ZXRpbWUoNjA0ODAwMDAwICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSk7XG5cbiAgICAgIG0zZGlzcGxheSA9IHtcbiAgICAgICAgZXhwZWN0YXRpb246ICcmbmRhc2g7JyxcbiAgICAgICAgcHJvYmFiaWxpdHk6ICcmbmRhc2g7J1xuICAgICAgfTtcblxuICAgICAgbTVkaXNwbGF5ID0ge1xuICAgICAgICBleHBlY3RhdGlvbjogJyZuZGFzaDsnLFxuICAgICAgICBwcm9iYWJpbGl0eTogJyZuZGFzaDsnXG4gICAgICB9O1xuXG4gICAgICBtNmRpc3BsYXkgPSB7XG4gICAgICAgIGV4cGVjdGF0aW9uOiAnJm5kYXNoOycsXG4gICAgICAgIHByb2JhYmlsaXR5OiAnJm5kYXNoOydcbiAgICAgIH07XG5cbiAgICAgIG03ZGlzcGxheSA9IHtcbiAgICAgICAgZXhwZWN0YXRpb246ICcmbmRhc2g7JyxcbiAgICAgICAgcHJvYmFiaWxpdHk6ICcmbmRhc2g7J1xuICAgICAgfTtcblxuICAgICAgZmVsdFRpbWVTcGFuID0gJ25leHQgd2VlayBhbmQgbmV4dCBtb250aCc7XG4gICAgfVxuXG4gICAgY29tbWVudGFyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2FydGljbGUnKTtcbiAgICBjb21tZW50YXJ5LmlubmVySFRNTCA9IFtcbiAgICAgICc8aDI+V2hhdCB0byBFeHBlY3Q8L2gyPicsXG4gICAgICAnPHA+JyxcbiAgICAgICAgJ0l0IGlzIG5vcm1hbCBmb3IgYW4gZWFydGhxdWFrZSBvZiB0aGlzIHNpemUgdG8gY2F1c2UgYW4gJyxcbiAgICAgICAgJ2luY3JlYXNlIGluIHRoZSBudW1iZXIgb2YgZWFydGhxdWFrZXMgKGNhbGxlZCBhZnRlcnNob2NrcykgJyxcbiAgICAgICAgJ2luIHRoZSBhcmVhIHdpdGhpbiAnLFxuICAgICAgICBlbGV2YXRlZFRpbWVTcGFuLCAnLiAnLFxuICAgICAgICAnTW9zdCBvZiB0aGVzZSBhZnRlcnNob2NrcyB3aWxsIGxpa2VseSBvY2N1ciB3aXRoaW4gJyxcbiAgICAgICAgbW9zdEFmdGVyc2hvY2tzVGltZVNwYW4sICcgJyxcbiAgICAgICAgJ2FuZCB0aGUgbnVtYmVyIG9mIGFmdGVyc2hvY2tzIHdpbGwgZHJvcCBvZmYgb3ZlciB0aW1lLCBidXQgYSAnLFxuICAgICAgICAnbGFyZ2UgYWZ0ZXJzaG9jayBjYW4gaW5jcmVhc2UgdGhlIG51bWJlcnMgYWdhaW4sIHRlbXBvcmFyaWx5LicsXG4gICAgICAnPC9wPicsXG4gICAgICAnPHA+JyxcbiAgICAgICAgJ1RoZSBhZnRlcnNob2NrcyB3aWxsIG9jY3VyIG1vc3RseSBpbiB0aGUgYXJlYSBhZmZlY3RlZCBieSB0aGUgJyxcbiAgICAgICAgJ21hZ25pdHVkZSAnLCBtYWdEaXNwbGF5LCAnICcsIHBsYWNlLCAnICcsXG4gICAgICAgICdlYXJ0aHF1YWtlLCBhcHByb3hpbWF0ZWx5IHdpdGhpbiAnLFxuICAgICAgICB3Y0Rpc3BsYXksICcgb2YgJywgcGxhY2UsICcuJyxcbiAgICAgICc8L3A+JyxcbiAgICAgICc8cD4nLFxuICAgICAgICAnV2hlbiB0aGVyZSBhcmUgbW9yZSBlYXJ0aHF1YWtlcywgdGhlIGNoYW5jZSBvZiBhIGxhcmdlICcsXG4gICAgICAgICdlYXJ0aHF1YWtlIGlzIGdyZWF0ZXIgYW5kIHRoZSBjaGFuY2Ugb2YgZGFtYWdlIGlzIGdyZWF0ZXIuICcsXG4gICAgICAgICdUaGUgVVNHUyBhZHZpc2VzIGV2ZXJ5b25lIHRvIHJlbWFpbiBhd2FyZSBvZiB0aGUgcG9zc2liaWxpdHkgJyxcbiAgICAgICAgJ29mIGFmdGVyc2hvY2tzIGluICcsIGF3YXJlbmVzc1RpbWVTcGFuLCAnLCAnLFxuICAgICAgICAnZXNwZWNpYWxseSB3aGVuIGluIG9yIGFyb3VuZCB2dWxuZXJhYmxlIHN0cnVjdHVyZXMgc3VjaCBhcyAnLFxuICAgICAgICAndW5yZWluZm9yY2VkIG1hc29ucnkgYnVpbGRpbmdzLicsXG4gICAgICAnPC9wPicsXG4gICAgICAnPHA+JyxcbiAgICAgICAgJ05vIG9uZSBjYW4gcHJlZGljdCB0aGUgZXhhY3QgdGltZSBvciBwbGFjZSBvZiBhbnkgZWFydGhxdWFrZSwgJyxcbiAgICAgICAgJ2luY2x1ZGluZyBhZnRlcnNob2Nrcy4gVGhlIFVTR1MgY2FuIGZvcmVjYXN0IGhvdyBtYW55ICcsXG4gICAgICAgICdlYXJ0aHF1YWtlcyB0byBleHBlY3QsIG9yIHRoZSBjaGFuY2Ugb2YgaGF2aW5nIGFuIGVhcnRocXVha2UgJyxcbiAgICAgICAgJ3dpdGhpbiBhIGdpdmVuIHRpbWUgcGVyaW9kLicsXG4gICAgICAnPC9wPicsXG5cbiAgICAgICc8aDI+Q3VycmVudCBBZnRlcnNob2NrIEZvcmVjYXN0PC9oMj4nLFxuICAgICAgJzxwPicsXG4gICAgICAgICdUaGUgVVNHUyBlc3RpbWF0ZXMgdGhlIGNoYW5jZSBvZiBtb3JlIGFmdGVyc2hvY2tzIGFzIGZvbGxvd3MuPGJyLz4nLFxuICAgICAgICAnV2l0aGluIHRoZSBuZXh0IHdlZWsgdW50aWwgJywgd2Vla0Zyb21Jc3N1ZSxcbiAgICAgICc8L3A+JyxcbiAgICAgICc8dWw+JyxcbiAgICAgICAgJzxsaT4nLFxuICAgICAgICAgICd0aGUgY2hhbmNlIG9mIGFuIGVhcnRocXVha2UgbGFyZ2UgZW5vdWdoIHRvIGZlZWwgJyxcbiAgICAgICAgICAnKG1hZ25pdHVkZSAzIG9yIGhpZ2hlcikgaXMgJyxcbiAgICAgICAgICBtM2Rpc3BsYXkucHJvYmFiaWxpdHksICcsIGFuZCAnLCBtM2Rpc3BsYXkuZXhwZWN0YXRpb24sICcuJyxcbiAgICAgICAgJzwvbGk+JyxcbiAgICAgICAgJzxsaT4nLFxuICAgICAgICAgICd0aGUgY2hhbmNlIG9mIGFuIGVhcnRocXVha2Ugb2YgbWFnbml0dWRlIDUgb3IgaGlnaGVyIGlzICcsXG4gICAgICAgICAgbTVkaXNwbGF5LnByb2JhYmlsaXR5LCAnLCBhbmQgJywgbTVkaXNwbGF5LmV4cGVjdGF0aW9uLCAnLicsXG4gICAgICAgICc8L2xpPicsXG4gICAgICAgICc8bGk+JyxcbiAgICAgICAgICAndGhlIGNoYW5jZSBvZiBhbiBlYXJ0aHF1YWtlIG9mIG1hZ25pdHVkZSA2IG9yIGhpZ2hlciBpcyAnLFxuICAgICAgICAgIG02ZGlzcGxheS5wcm9iYWJpbGl0eSwgJywgYW5kICcsIG02ZGlzcGxheS5leHBlY3RhdGlvbiwgJy4nLFxuICAgICAgICAnPC9saT4nLFxuICAgICAgICAnPGxpPicsXG4gICAgICAgICAgJ3RoZSBjaGFuY2Ugb2YgYW4gZWFydGhxdWFrZSBvZiBtYWduaXR1ZGUgNyBvciBoaWdoZXIgaXMgJyxcbiAgICAgICAgICBtN2Rpc3BsYXkucHJvYmFiaWxpdHksICcsIGFuZCAnLCBtN2Rpc3BsYXkuZXhwZWN0YXRpb24sICcuJyxcbiAgICAgICAgJzwvbGk+JyxcbiAgICAgICc8L3VsPicsXG4gICAgICAnPHA+JyxcbiAgICAgICAgJ1RoZSBjaGFuY2Ugb2YgZWFydGhxdWFrZXMgbGFyZ2UgZW5vdWdoIHRvIGJlIGZlbHQgb3IgdG8gY2F1c2UgJyxcbiAgICAgICAgJ2RhbWFnZSByZW1haW5zIGVsZXZhdGVkIGZvciB0aGUgJywgZmVsdFRpbWVTcGFuLCAnLicsXG4gICAgICAnPC9wPicsXG4gICAgICAnPHA+JyxcbiAgICAgICAgJ1RoZSBVU0dTIGNhbGN1bGF0ZXMgdGhpcyBlYXJ0aHF1YWtlIGZvcmVjYXN0IHVzaW5nIGEgc3RhdGlzdGljYWwgJyxcbiAgICAgICAgJ2FuYWx5c2lzIGJhc2VkIG9uIHBhc3QgZWFydGhxdWFrZXMgYW5kIHRoZSBhZnRlcnNob2NrcyByZWNvcmRlZCAnLFxuICAgICAgICAnZm9yIHRoaXMgc2VxdWVuY2UuIFRoZSBmb3JlY2FzdCBjaGFuZ2VzIGFzIHRpbWUgcGFzc2VzIGR1ZSB0byAnLFxuICAgICAgICAndGhlIGRlY2F5IGluIHRoZSBmcmVxdWVuY3kgb2YgYWZ0ZXJzaG9ja3MsIGxhcmdlciBhZnRlcnNob2NrcyAnLFxuICAgICAgICAndGhhdCBtYXkgdHJpZ2dlciBmdXJ0aGVyIGVhcnRocXVha2VzLCBhbmQgY2hhbmdlcyBpbiBmb3JlY2FzdCAnLFxuICAgICAgICAnbW9kZWxpbmcgYmFzZWQgb24gdGhlIGVhcnRocXVha2UgZGF0YSBjb2xsZWN0ZWQuJyxcbiAgICAgICc8L3A+J1xuICAgIF0uam9pbignJyk7XG5cbiAgICByZXR1cm4gY29tbWVudGFyeTtcbiAgfTtcblxuICBfdGhpcy5nZXRQcm9iQW5kRXhwID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICB2YXIgZXhwZWN0YXRpb24sXG4gICAgICAgIHByb2JhYmlsaXR5O1xuXG4gICAgaWYgKGluZm8ucHJvYmFiaWxpdHkgPD0gMC4wMSkge1xuICAgICAgcHJvYmFiaWxpdHkgPSAnMSBpbiAxMDAnO1xuICAgIH0gZWxzZSBpZiAoaW5mby5wcm9iYWJpbGl0eSA8IDEuMCkge1xuICAgICAgcHJvYmFiaWxpdHkgPSBfZm9ybWF0dGVyLm51bWJlcihcbiAgICAgICAgICBpbmZvLnByb2JhYmlsaXR5ICogMTAwLCAwLCAnJm5kYXNoJywgJyUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvYmFiaWxpdHkgPSAnJmd0OyA5OSAlJztcbiAgICB9XG5cbiAgICBpZiAoaW5mby5wOTVtaW5pbXVtICsgaW5mby5wOTVtYXhpbXVtKSB7XG4gICAgICBleHBlY3RhdGlvbiA9ICdpdCBpcyBtb3N0IGxpa2VseSB0aGF0ICcgK1xuICAgICAgICAgIGluZm8ucDk1bWluaW11bSArICcgdG8gJyArIGluZm8ucDk1bWF4aW11bSArXG4gICAgICAgICAgJyBzdWNoIGVhcnRocXVha2VzIG1heSBvY2N1cicgO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBlY3RhdGlvbiA9ICdzdWNoIGFuIGVhcnRocXVha2UgaXMgcG9zc2libGUsIGJ1dCB3aXRoIGxvdyBwcm9iYWJpbGl0eSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cGVjdGF0aW9uOiBleHBlY3RhdGlvbixcbiAgICAgIHByb2JhYmlsaXR5OiBwcm9iYWJpbGl0eVxuICAgIH07XG4gIH07XG5cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnb2FmLWZvcmNhc3QtdGV4dC12aWV3Jyk7XG5cbiAgICBfY2F0YWxvZ0V2ZW50ID0gbnVsbDtcbiAgICBfZm9ybWF0dGVyID0gbnVsbDtcbiAgICBfcHJvZHVjdCA9IG51bGw7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICBfdGhpcy5yZW5kZXJGb3JlY2FzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSAnJztcbiAgICBfdGhpcy5lbC5hcHBlbmRDaGlsZChfdGhpcy5nZXRDb21tZW50YXJ5KF90aGlzLmZvcmVjYXN0KSk7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGb3JlY2FzdFRleHRWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBDb250ZW50VmlldyA9IHJlcXVpcmUoJ2NvcmUvQ29udGVudFZpZXcnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcblxufTtcblxuXG52YXIgRm9yZWNhc3RWaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemU7XG5cblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gQ29udGVudFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoLypvcHRpb25zKi8pIHtcblxuICB9O1xuXG5cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICBfdGhpcy5vbkVycm9yID0gZnVuY3Rpb24gKC8qc3RhdHVzLCB4aHIqLykge1xuICAgIF90aGlzLmVsLmlubmVySFRNTCA9ICc8cCBjbGFzcz1cImFsZXJ0IGVycm9yXCI+JyArXG4gICAgICAgICdGYWlsZWQgdG8gbG9hZCBmb3JlY2FzdCBkYXRhLjwvcD4nO1xuICB9O1xuXG4gIF90aGlzLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLyosIHhociovKSB7XG4gICAgX3RoaXMuZm9yZWNhc3QgPSBkYXRhO1xuICAgIF90aGlzLnJlbmRlcigpO1xuICAgIF90aGlzLnRyaWdnZXIoJ2ZvcmVjYXN0JywgX3RoaXMuZm9yZWNhc3QpO1xuICB9O1xuXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV90aGlzLmZvcmVjYXN0KSB7XG4gICAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSAnPHA+TG9hZGluZyBjb250ZW50JmhlbGxpcDs8L3A+JztcbiAgICAgIF90aGlzLmZldGNoRGF0YSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5yZW5kZXJGb3JlY2FzdCgpO1xuICAgIH1cbiAgfTtcblxuICBfdGhpcy5yZW5kZXJGb3JlY2FzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShfdGhpcy5mb3JlY2FzdCk7XG4gIH07XG5cbiAgX3RoaXMuc2V0Rm9yZWNhc3QgPSBmdW5jdGlvbiAoZm9yZWNhc3QpIHtcbiAgICBfdGhpcy5mb3JlY2FzdCA9IGZvcmVjYXN0O1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRm9yZWNhc3RWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBGb3JlY2FzdFZpZXcgPSByZXF1aXJlKCdvYWYvRm9yZWNhc3RWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG5cbn07XG5cblxudmFyIE1vZGVsRGV0YWlsc1ZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZTtcblxuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgX3RoaXMgPSBGb3JlY2FzdFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoLypvcHRpb25zKi8pIHtcblxuICB9O1xuXG5cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICBfdGhpcy5yZW5kZXJGb3JlY2FzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBhZnRlcnNob2NrIG1hdGhlbWF0aWNhbCBtb2RlbCBhbmQgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCBNVkNcbiAgICBtb2RlbCA9IF90aGlzLmZvcmVjYXN0Lm1vZGVsO1xuXG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gW1xuICAgICAgJzxoMz4nLCBtb2RlbC5uYW1lLCAnPC9oMz4nLFxuICAgICAgJzxwPicsXG4gICAgICAgICdSZWZlcmVuY2UgTGluazogJyxcbiAgICAgICAgJzxhIGhyZWY9XCInLCBtb2RlbC5yZWZlcmVuY2UsICdcIj4nLCBtb2RlbC5yZWZlcmVuY2UsICc8L2E+JyxcbiAgICAgICc8L3A+JyxcbiAgICAgICc8dGFibGUgY2xhc3M9XCJvYWYtbW9kZWwtcGFyYW1ldGVyc1wiPicsXG4gICAgICAgICc8dGJvZHk+JyxcbiAgICAgICAgICBPYmplY3Qua2V5cyhtb2RlbC5wYXJhbWV0ZXJzKS5yZWR1Y2UoZnVuY3Rpb24gKG1hcmt1cCwga2V5KSB7XG4gICAgICAgICAgICBtYXJrdXAucHVzaCgnPHRyPjx0aCBzY29wZT1cInJvd1wiPicgKyBrZXkgKyAnPC90aD4nICtcbiAgICAgICAgICAgICAgICAnPHRkPicgKyBtb2RlbC5wYXJhbWV0ZXJzW2tleV0gKyAnPC90ZD48L3RyPicpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWFya3VwO1xuICAgICAgICAgIH0sIFtdKS5qb2luKCcnKSxcbiAgICAgICAgJzwvdGJvZHk+JyxcbiAgICAgICc8L3RhYmxlPidcbiAgICBdLmpvaW4oJycpO1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWxEZXRhaWxzVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgRm9ybWF0dGVyID0gcmVxdWlyZSgnY29yZS9Gb3JtYXR0ZXInKSxcbiAgICBMaW5rUHJvZHVjdFZpZXcgPSByZXF1aXJlKCdjb3JlL0xpbmtQcm9kdWN0VmlldycpLFxuICAgIE9hZlZpZXcgPSByZXF1aXJlKCdvYWYvT2FmVmlldycpLFxuICAgIFNjaWVudGlmaWNTdW1tYXJ5TW9kdWxlID0gcmVxdWlyZSgnc2NpZW50aWZpYy9TY2llbnRpZmljU3VtbWFyeU1vZHVsZScpLFxuICAgIFRleHRQcm9kdWN0VmlldyA9IHJlcXVpcmUoJ2NvcmUvVGV4dFByb2R1Y3RWaWV3JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIE1vZHVsZSA9IHJlcXVpcmUoJ2NvcmUvTW9kdWxlJyk7XG5cblxudmFyIF9ERUZBVUxUUyxcbiAgICBfSUQsXG4gICAgX1RJVExFLFxuICAgIF9UWVBFUztcblxuX0lEID0gJ29hZic7XG5fVElUTEUgPSAnQWZ0ZXJzaG9jayBGb3JlY2FzdCc7XG5fVFlQRVMgPSBbJ29hZiddO1xuXG5fREVGQVVMVFMgPSB7XG5cbn07XG5cblxudmFyIE9hZk1vZHVsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfZm9ybWF0dGVyLFxuICAgICAgX29hZlZpZXcsXG4gICAgICBfc3Vidmlld3M7XG5cblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gTW9kdWxlKG9wdGlvbnMpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBfdGhpcy5JRCA9IF9JRDtcbiAgICBfdGhpcy5USVRMRSA9IF9USVRMRTtcblxuICAgIF9mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBGb3JtYXR0ZXIoKTtcbiAgICBfc3Vidmlld3MgPSBbXTtcbiAgfTtcblxuXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmRlc3Ryb3lWaWV3cygpO1xuXG4gICAgX2Zvcm1hdHRlciA9IG51bGw7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICBfdGhpcy5kZXN0cm95Vmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9vYWZWaWV3ICYmIF9vYWZWaWV3LmRlc3Ryb3kpIHtcbiAgICAgIF9vYWZWaWV3LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBpZiAoX3N1YnZpZXdzKSB7XG4gICAgICBfc3Vidmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICBpZiAodmlldyAmJiB2aWV3LmRlc3Ryb3kpIHtcbiAgICAgICAgICB0cnkgeyB2aWV3LmRlc3Ryb3koKTsgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfb2FmVmlldyA9IG51bGw7XG4gICAgX3N1YnZpZXdzID0gbnVsbDtcbiAgfTtcblxuICBfdGhpcy5nZXRPYWZMaW5rVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhlYWRlcixcbiAgICAgICAgcHJvZHVjdHMsXG4gICAgICAgIHVsLFxuICAgICAgICB3cmFwcGVyO1xuXG4gICAgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIHByb2R1Y3RzID0gX3RoaXMuZ2V0UHJvZHVjdHMoJ29hZi1saW5rJyk7XG4gICAgaWYgKHByb2R1Y3RzLmxlbmd0aCkge1xuICAgICAgaGVhZGVyID0gd3JhcHBlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpKTtcbiAgICAgIHVsID0gd3JhcHBlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpKTtcblxuICAgICAgaGVhZGVyLmlubmVySFRNTCA9ICdNb3JlIEFmdGVyc2hvY2sgSW5mb3JtYXRpb24nO1xuXG4gICAgICBwcm9kdWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9kdWN0KSB7XG4gICAgICAgIHZhciB2aWV3O1xuXG4gICAgICAgIHZpZXcgPSBMaW5rUHJvZHVjdFZpZXcoe1xuICAgICAgICAgIGVsOiB1bC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpKSxcbiAgICAgICAgICBmb3JtYXR0ZXI6IF9mb3JtYXR0ZXIsXG4gICAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlldy5yZW5kZXIoKTtcblxuICAgICAgICBfc3Vidmlld3MucHVzaCh2aWV3KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwcGVyO1xuICB9O1xuXG4gIF90aGlzLmdldE9hZlRleHRWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnJhZ21lbnQsXG4gICAgICAgIHByb2R1Y3RzO1xuXG4gICAgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgcHJvZHVjdHMgPSBfdGhpcy5nZXRQcm9kdWN0cygnb2FmLWhlYWRlcicpO1xuXG4gICAgcHJvZHVjdHMuZm9yRWFjaChmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgICAgdmFyIHZpZXc7XG5cbiAgICAgIHZpZXcgPSBUZXh0UHJvZHVjdFZpZXcoe1xuICAgICAgICBtb2RlbDogcHJvZHVjdCxcbiAgICAgICAgZWw6IGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgfSk7XG5cbiAgICAgIHZpZXcucmVuZGVyKCk7XG5cbiAgICAgIF9zdWJ2aWV3cy5wdXNoKHZpZXcpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9O1xuXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZHVjdDtcblxuICAgIF90aGlzLmRlc3Ryb3lWaWV3cygpO1xuICAgIF9zdWJ2aWV3cyA9IFtdO1xuXG4gICAgX3RoaXMuaGVhZGVyLmlubmVySFRNTCA9ICcnO1xuICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgX3RoaXMuZm9vdGVyLmlubmVySFRNTCA9ICcnO1xuXG4gICAgcHJvZHVjdCA9IF90aGlzLmdldFByb2R1Y3QoJ29hZicpO1xuXG4gICAgaWYgKHByb2R1Y3QpIHtcbiAgICAgIF90aGlzLnJlbmRlckhlYWRlcihwcm9kdWN0KTtcbiAgICAgIF90aGlzLnJlbmRlckNvbnRlbnQocHJvZHVjdCk7XG4gICAgICBfdGhpcy5yZW5kZXJGb290ZXIocHJvZHVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gJzxwIGNsYXNzPVwiYWxlcnQgaW5mb1wiPicgK1xuICAgICAgICAgICdObyBhZnRlcnNob2NrIGZvcmVjYXN0IGlzIGF2YWlsYWJsZSBmb3IgdGhpcyBldmVudC48L3A+JztcbiAgICB9XG4gIH07XG5cbiAgX3RoaXMucmVuZGVyQ29udGVudCA9IGZ1bmN0aW9uIChwcm9kdWN0KSB7XG4gICAgaWYgKHByb2R1Y3QpIHtcbiAgICAgIF9vYWZWaWV3ID0gT2FmVmlldyh7XG4gICAgICAgIGNhdGFsb2dFdmVudDogX3RoaXMubW9kZWwuZ2V0KCdldmVudCcpLFxuICAgICAgICBlbDogX3RoaXMuY29udGVudCxcbiAgICAgICAgbW9kZWw6IHByb2R1Y3RcbiAgICAgIH0pO1xuXG4gICAgICBfb2FmVmlldy5yZW5kZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgX3RoaXMucmVuZGVyRm9vdGVyID0gZnVuY3Rpb24gKHByb2R1Y3QpIHtcbiAgICB2YXIgZXhwaXJlcztcblxuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBleHBpcmVzID0gX3RoaXMuZm9vdGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NtYWxsJykpO1xuICAgICAgZXhwaXJlcy5pbm5lckhUTUwgPSBbXG4gICAgICAgICdUaGlzIGFkdmlzb3J5IHdpbGwgYmUgdXBkYXRlZCBvbiBvciBiZWZvcmU6ICcsXG4gICAgICAgIF9mb3JtYXR0ZXIuZGF0ZXRpbWUobmV3IERhdGUoNjA0ODAwMDAwICsgcHJvZHVjdC5nZXQoJ3VwZGF0ZVRpbWUnKSkpXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH1cblxuICAgIF90aGlzLmZvb3Rlci5hcHBlbmRDaGlsZChfdGhpcy5nZXRPYWZMaW5rVmlld3MoKSk7XG5cbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgLy8gR2VuZXJhdGVzIGRvd25sb2FkIHNlY3Rpb25cbiAgICAgIF90aGlzLmZvb3Rlci5hcHBlbmRDaGlsZChfdGhpcy5nZXRQcm9kdWN0Rm9vdGVyKHtcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdFxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuICBfdGhpcy5yZW5kZXJIZWFkZXIgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIF90aGlzLmhlYWRlci5pbm5lckhUTUwgPSAnPGgzPicgKyBfdGhpcy5USVRMRSArICc8L2gzPic7XG5cbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgX3RoaXMuaGVhZGVyLmFwcGVuZENoaWxkKF90aGlzLmdldFByb2R1Y3RIZWFkZXIoe1xuICAgICAgICBwcm9kdWN0OiBwcm9kdWN0LFxuICAgICAgICBzdW1tYXJ5TW9kdWxlOiBTY2llbnRpZmljU3VtbWFyeU1vZHVsZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIF90aGlzLmhlYWRlci5hcHBlbmRDaGlsZChfdGhpcy5nZXRPYWZUZXh0Vmlld3MoKSk7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuT2FmTW9kdWxlLklEID0gX0lEO1xuT2FmTW9kdWxlLlRJVExFID0gX1RJVExFO1xuT2FmTW9kdWxlLlRZUEVTID0gX1RZUEVTO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gT2FmTW9kdWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBGb3JlY2FzdFRhYmxlVmlldyA9IHJlcXVpcmUoJ29hZi9Gb3JlY2FzdFRhYmxlVmlldycpLFxuICAgIEZvcmVjYXN0VGV4dFZpZXcgPSByZXF1aXJlKCdvYWYvRm9yZWNhc3RUZXh0VmlldycpLFxuICAgIE1vZGVsRGV0YWlsc1ZpZXcgPSByZXF1aXJlKCdvYWYvTW9kZWxEZXRhaWxzVmlldycpLFxuICAgIFByb2R1Y3RWaWV3ID0gcmVxdWlyZSgnY29yZS9Qcm9kdWN0VmlldycpLFxuICAgIFRhYkxpc3QgPSByZXF1aXJlKCd0YWJsaXN0L1RhYkxpc3QnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ERUZBVUxUUyxcbiAgICBfUkVTT1VSQ0VTO1xuXG5fREVGQVVMVFMgPSB7XG59O1xuXG5fUkVTT1VSQ0VTID0ge1xuICAnZm9yZWNhc3QtdGV4dCc6IHtcbiAgICB0aXRsZTogJ0NvbW1lbnRhcnknLFxuICAgIGNvbnRlbnQ6ICdmb3JlY2FzdC5qc29uJyxcbiAgICBzdWJ2aWV3OiBGb3JlY2FzdFRleHRWaWV3XG4gIH0sXG4gICdmb3JlY2FzdC10YWJsZSc6IHtcbiAgICB0aXRsZTogJ0ZvcmVjYXN0IFByb2JhYmlsaXRpZXMnLFxuICAgIGNvbnRlbnQ6ICdmb3JlY2FzdC5qc29uJyxcbiAgICBzdWJ2aWV3OiBGb3JlY2FzdFRhYmxlVmlld1xuICB9LFxuICAnZm9yZWNhc3QtbW9kZWwnOiB7XG4gICAgdGl0bGU6ICdNb2RlbCBEZXRhaWxzJyxcbiAgICBjb250ZW50OiAnZm9yZWNhc3QuanNvbicsXG4gICAgc3VidmlldzogTW9kZWxEZXRhaWxzVmlld1xuICB9XG59O1xuXG5cbnZhciBPYWZWaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9jYXRhbG9nRXZlbnQsXG4gICAgICBfcmVzb3VyY2VzLFxuICAgICAgX3N1YnZpZXdzLFxuICAgICAgX3RhYkxpc3QsXG4gICAgICBfdGFicztcblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gUHJvZHVjdFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ29hZi12aWV3Jyk7XG5cbiAgICBfY2F0YWxvZ0V2ZW50ID0gb3B0aW9ucy5jYXRhbG9nRXZlbnQ7XG5cbiAgICBfcmVzb3VyY2VzID0gVXRpbC5leHRlbmQoe30sIF9SRVNPVVJDRVMsIG9wdGlvbnMucmVzb3VyY2VzKTtcbiAgfTtcblxuXG4gIF90aGlzLmNyZWF0ZVRhYiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgY29udGVudCxcbiAgICAgICAgc3VidmlldyxcbiAgICAgICAgdGFiO1xuXG4gICAgY29udGVudCA9IF90aGlzLm1vZGVsLmdldENvbnRlbnQocGFyYW1zLmNvbnRlbnQpO1xuXG4gICAgaWYgKGNvbnRlbnQgJiYgcGFyYW1zLnN1YnZpZXcpIHtcbiAgICAgIHN1YnZpZXcgPSBwYXJhbXMuc3Vidmlldyh7XG4gICAgICAgICAgY2F0YWxvZ0V2ZW50OiBfY2F0YWxvZ0V2ZW50LFxuICAgICAgICAgIG1vZGVsOiBjb250ZW50LFxuICAgICAgICAgIHByb2R1Y3Q6IF90aGlzLm1vZGVsXG4gICAgICB9KTtcblxuICAgICAgc3Vidmlldy5vbignZm9yZWNhc3QnLCAnc2V0U3Vidmlld0ZvcmVjYXN0JywgX3RoaXMpO1xuICAgICAgX3N1YnZpZXdzLnB1c2goc3Vidmlldyk7XG5cbiAgICAgIHRhYiA9IHtcbiAgICAgICAgdGl0bGU6IHBhcmFtcy50aXRsZSxcbiAgICAgICAgY29udGVudDogc3Vidmlldy5lbCxcbiAgICAgICAgb25EZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHJ5IHsgc3Vidmlldy5kZXN0cm95KCk7IH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdWJ2aWV3LnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0YWI7XG4gIH07XG5cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSgnb2FmLXZpZXcnKTtcblxuICAgIF90aGlzLmRlc3Ryb3lUYWJMaXN0KCk7XG5cbiAgICBfcmVzb3VyY2VzID0gbnVsbDtcbiAgICBfdGFiTGlzdCA9IG51bGw7XG4gICAgX3RhYnMgPSBudWxsO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgX3RoaXMuZGVzdHJveVRhYkxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF90YWJMaXN0ICYmIF90YWJMaXN0LmRlc3Ryb3kpIHtcbiAgICAgIF90YWJMaXN0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBfc3Vidmlld3MgPSBudWxsO1xuICAgIF90YWJMaXN0ID0gbnVsbDtcbiAgICBfdGFicyA9IG51bGw7XG4gIH07XG5cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmRlc3Ryb3lUYWJMaXN0KCk7XG5cbiAgICBfdGFiTGlzdCA9IFRhYkxpc3Qoe1xuICAgICAgZWw6IF90aGlzLmVsLFxuICAgICAgdGFiczogW11cbiAgICB9KTtcblxuICAgIF9zdWJ2aWV3cyA9IFtdO1xuICAgIF90YWJzID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhfcmVzb3VyY2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBpbmZvLFxuICAgICAgICAgIHRhYjtcblxuICAgICAgaW5mbyA9IF9yZXNvdXJjZXNba2V5XTtcbiAgICAgIHRhYiA9IF90aGlzLmNyZWF0ZVRhYihpbmZvKTtcbiAgICAgIGlmICh0YWIpIHtcbiAgICAgICAgX3RhYnNba2V5XSA9IF90YWJMaXN0LmFkZFRhYih0YWIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF90aGlzLnNldFN1YnZpZXdGb3JlY2FzdCA9IGZ1bmN0aW9uIChmb3JlY2FzdCkge1xuICAgIF9zdWJ2aWV3cy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJ2aWV3KSB7XG4gICAgICBpZiAoc3VidmlldyAmJiB0eXBlb2Ygc3Vidmlldy5zZXRGb3JlY2FzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdWJ2aWV3LnNldEZvcmVjYXN0KGZvcmVjYXN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE9hZlZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIEFjY29yZGlvbiA9IHJlcXVpcmUoJ2FjY29yZGlvbi9BY2NvcmRpb24nKSxcbiAgICBBdHRyaWJ1dGlvbiA9IHJlcXVpcmUoJ2NvcmUvQXR0cmlidXRpb24nKSxcbiAgICBRdWFrZW1sVmlldyA9IHJlcXVpcmUoJ29yaWdpbi9RdWFrZW1sVmlldycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0RFRkFVTFRTID0ge1xuXG59O1xuXG4vLyBWYWx1ZSB0byBkaXNwbGF5IHdoZW4gYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWRcbnZhciBfTk9UX1JFUE9SVEVEID0gJyZuZGFzaDsnO1xuXG5cbi8qKlxuICogVmlldyBmb3IgZGlzcGxheWluZyBtYWduaXR1ZGUgaW5mb3JtYXRpb24gZm91bmQgaW4gYSBxdWFrZW1sLnhtbCB7Q29udGVudH1cbiAqIG9iamVjdC4gVGhpcyB2aWV3IHVzZXMgZXZlbnQgZGVsZWdhdGlvbiB0aHJvdWdoIGEgc2luZ2xlIHtBY2NvcmRpb259IGluc3RhbmNlXG4gKiB0byBkZWFsIHdpdGggY2xpY2sgZXZlbnRzIGFuZCBpdCBtYW51YWxseSBidWlsZHMgYWNjb3JkaW9uIG1hcmt1cCBmb3JcbiAqIGVhY2ggbWFnbml0dWRlIGl0ZW0uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgdmlldy4gU2VlIF9pbml0aWFsaXplIG1ldGhvZCBkb2N1bWVudGF0aW9uXG4gKiAgICAgZm9yIGRldGFpbHMuXG4gKi9cbnZhciBNYWduaXR1ZGVzVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfYWNjb3JkaW9uO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IFF1YWtlbWxWaWV3KG9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci4gSW5pdGlhbGl6ZXMgYSBuZXcge01hZ25pdHVkZXNWaWV3fS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogICAgIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5tb2RlbCB7Q29udGVudH1cbiAgICogICAgIFRoZSBjb250ZW50IG1vZGVsIHRvIHJlbmRlci5cbiAgICogQHBhcmFtIG9wdGlvbnMucHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIFRoZSBwcm9kdWN0IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIHtDb250ZW50fS4gVHlwaWNhbGx5IGFuIG9yaWdpblxuICAgKiAgICAgb3IgcGhhc2UtZGF0YSBwcm9kdWN0LlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoLypvcHRpb25zKi8pIHtcbiAgICBfYWNjb3JkaW9uID0gQWNjb3JkaW9uKHtcbiAgICAgIGVsOiBfdGhpcy5lbFxuICAgIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEZyZWVzIHJlc291cmNlcyBhbGxvY2F0ZWQgdG8gdGhpcyB2aWV3LlxuICAgKlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgX2FjY29yZGlvbi5kZXN0cm95KCk7XG5cbiAgICBfYWNjb3JkaW9uID0gbnVsbDtcblxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG1hcmt1cCBmb3IgdGhlIGNvbnRyaWJ1dGlvbnMgdGFibGUuIFRoaXMgaW5jbHVkZXNcbiAgICogYSBzY3JvbGxpbmcgd3JhcHBlciBmb3IgcmVzcG9uc2l2ZW5lc3MuIElmIG5vIGNvbnRyaWJ1dGlvbnMgYXJlIHByb3ZpZGVkLFxuICAgKiB0aGlzIG1hcmt1cCBjb25zaXN0cyBvZiBhbiBpbmZvcm1hdGlvbmFsIGFsZXJ0IG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBjb250cmlidXRpb25zIHtBcnJheX1cbiAgICogICAgIEFuIGFycmF5IG9mIGNvbnRyaWJ1dGlvbiBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgX3RoaXMuZ2V0Q29udHJpYnV0aW9uc01hcmt1cCA9IGZ1bmN0aW9uIChjb250cmlidXRpb25zKSB7XG4gICAgaWYgKCFjb250cmlidXRpb25zIHx8IGNvbnRyaWJ1dGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJzxwIGNsYXNzPVwiYWxlcnQgaW5mb1wiPicgK1xuICAgICAgICAgICdObyBhbXBsaXR1ZGVzIGNvbnRyaWJ1dGVkIGZvciB0aGlzIG1hZ25pdHVkZS48L3A+JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJob3Jpem9udGFsLXNjcm9sbGluZ1wiPicsXG4gICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIm1hZ25pdHVkZS1zdGF0aW9uc1wiPicsXG4gICAgICAgICAgICAnPHRoZWFkPicsXG4gICAgICAgICAgICAgIF90aGlzLmdldFN0YXRpb25UYWJsZUhlYWRlclJvdygpLFxuICAgICAgICAgICAgJzwvdGhlYWQ+JyxcbiAgICAgICAgICAgICc8dGJvZHk+JyxcbiAgICAgICAgICAgICAgY29udHJpYnV0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKG1hcmt1cCwgY29udHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWFya3VwLnB1c2goX3RoaXMuZ2V0U3RhdGlvblRhYmxlUm93KGNvbnRyaWJ1dGlvbikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgICAgICAgICAgIH0sIFtdKS5qb2luKCcnKSxcbiAgICAgICAgICAgICc8L3Rib2R5PicsXG4gICAgICAgICAgJzwvdGFibGU+JyxcbiAgICAgICAgJzwvZGl2PidcbiAgICAgIF0uam9pbignJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG1hcmt1cCBmb3IgdGhlIHRhYmxlIGhlYWRlciByb3cgZm9yIHRoZSBzdGF0aW9uIGRldGFpbHMgdGFibGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIF90aGlzLmdldFN0YXRpb25UYWJsZUhlYWRlclJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJzx0cj4nLFxuICAgICAgICAnPHRoIHNjb3BlPVwiY29sXCI+JyxcbiAgICAgICAgICAnPGFiYnIgdGl0bGU9XCJOZXR3b3JrIFN0YXRpb24gQ2hhbm5lbCBMb2NhdGlvblwiPkNoYW5uZWw8L2FiYnI+JyxcbiAgICAgICAgJzwvdGg+JyxcbiAgICAgICAgJzx0aCBzY29wZT1cImNvbFwiPlR5cGU8L3RoPicsXG4gICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj5BbXBsaXR1ZGU8L3RoPicsXG4gICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj5QZXJpb2Q8L3RoPicsXG4gICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj5TdGF0dXM8L3RoPicsXG4gICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj5NYWduaXR1ZGU8L3RoPicsXG4gICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj5XZWlnaHQ8L3RoPicsXG4gICAgICAnPC90cj4nXG4gICAgXS5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBtYXJrdXAgZm9yIGEgc2luZ2xlIHJvdyBpbiB0aGUgc3RhdGlvbiBkZXRhaWxzIHRhYmxlIGJvZHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb250cmlidXRpb24ge09iamVjdH1cbiAgICogICAgIEFuIG9iamVjdCBjb250YWluaW5nIGNvbnRyaWJ1dGlvbiBpbmZvcm1hdGlvbi4gU2VlIHtxdWFrZW1sL1F1YWtlbWx9XG4gICAqICAgICBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBfdGhpcy5nZXRTdGF0aW9uVGFibGVSb3cgPSBmdW5jdGlvbiAoY29udHJpYnV0aW9uKSB7XG4gICAgdmFyIGFtcCxcbiAgICAgICAgYW1wbGl0dWRlLFxuICAgICAgICBtYWcsXG4gICAgICAgIHBlcmlvZCxcbiAgICAgICAgc3RhdGlvbixcbiAgICAgICAgc3RhdGlvbk1hZ25pdHVkZSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICB0eXBlLFxuICAgICAgICB3ZWlnaHQ7XG5cbiAgICBzdGF0aW9uTWFnbml0dWRlID0gY29udHJpYnV0aW9uLnN0YXRpb25NYWduaXR1ZGU7XG4gICAgYW1wbGl0dWRlID0gc3RhdGlvbk1hZ25pdHVkZS5hbXBsaXR1ZGUgfHwge307XG5cbiAgICBzdGF0aW9uID0gc3RhdGlvbk1hZ25pdHVkZS53YXZlZm9ybUlEIHx8IGFtcGxpdHVkZS53YXZlZm9ybUlEO1xuXG4gICAgYW1wID0gX05PVF9SRVBPUlRFRDtcbiAgICBtYWcgPSBzdGF0aW9uTWFnbml0dWRlLm1hZy52YWx1ZSB8fCBfTk9UX1JFUE9SVEVEO1xuICAgIHBlcmlvZCA9IF9OT1RfUkVQT1JURUQ7XG4gICAgc3RhdHVzID0gYW1wbGl0dWRlLmV2YWx1YXRpb25Nb2RlIHx8IHN0YXRpb25NYWduaXR1ZGUuc3RhdHVzIHx8ICdhdXRvbWF0aWMnO1xuICAgIHR5cGUgPSBzdGF0aW9uTWFnbml0dWRlLnR5cGU7XG4gICAgd2VpZ2h0ID0gY29udHJpYnV0aW9uLndlaWdodCB8fCBfTk9UX1JFUE9SVEVEO1xuXG4gICAgaWYgKGFtcGxpdHVkZS5nZW5lcmljQW1wbGl0dWRlKSB7XG4gICAgICBhbXAgPSBhbXBsaXR1ZGUuZ2VuZXJpY0FtcGxpdHVkZS52YWx1ZSArICcmbmJzcDsnICtcbiAgICAgICAgICAoYW1wbGl0dWRlLnVuaXQgfHwgJycpO1xuICAgIH1cblxuICAgIGlmIChhbXBsaXR1ZGUucGVyaW9kKSB7XG4gICAgICBwZXJpb2QgPSBhbXBsaXR1ZGUucGVyaW9kLnZhbHVlICsgJyBzJztcbiAgICB9XG5cbiAgICBpZiAocGVyaW9kID09PSBfTk9UX1JFUE9SVEVEICYmIGFtcGxpdHVkZS51bml0ID09PSAncycpIHtcbiAgICAgIC8vIHF1YWtlbWwgcmVxdWlyZXMgYSBwZXJpb2QgdmFsdWUgdG8gYmUgcGxhY2VkIGluIHRoZSBhbXBsaXR1ZGVcbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIG90aGVyIGFtcGxpdHVkZSBpbmZvcm1hdGlvblxuICAgICAgcGVyaW9kID0gYW1wO1xuICAgICAgYW1wID0gX05PVF9SRVBPUlRFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgJzx0cj4nLFxuICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+JyxcbiAgICAgICAgICBzdGF0aW9uLm5ldHdvcmtDb2RlLFxuICAgICAgICAgICcgJywgc3RhdGlvbi5zdGF0aW9uQ29kZSxcbiAgICAgICAgICAnICcsIHN0YXRpb24uY2hhbm5lbENvZGUsXG4gICAgICAgICAgJyAnLCBzdGF0aW9uLmxvY2F0aW9uQ29kZSxcbiAgICAgICAgJzwvdGg+JyxcbiAgICAgICAgJzx0ZCBjbGFzcz1cInR5cGVcIj4nLCB0eXBlLCAnPC90ZD4nLFxuICAgICAgICAnPHRkIGNsYXNzPVwiYW1wbGl0dWRlXCI+JywgYW1wLCAnPC90ZD4nLFxuICAgICAgICAnPHRkIGNsYXNzPVwicGVyaW9kXCI+JywgcGVyaW9kLCAnPC90ZD4nLFxuICAgICAgICAnPHRkIGNsYXNzPVwic3RhdHVzXCI+Jywgc3RhdHVzLCAnPC90ZD4nLFxuICAgICAgICAnPHRkIGNsYXNzPVwibWFnbml0dWRlXCI+JywgbWFnLCAnPC90ZD4nLFxuICAgICAgICAnPHRkIGNsYXNzPVwid2VpZ2h0XCI+Jywgd2VpZ2h0LCAnPC90ZD4nLFxuICAgICAgJzwvdHI+J1xuICAgIF0uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbWFya3VwIGZvciB0aGUgbWFnbml0dWRlIGVycm9yIGxpc3QgaXRlbSBidWJibGUuXG4gICAqXG4gICAqIEBwYXJhbSBlcnJvciB7U3RyaW5nfVxuICAgKiAgICAgVGhlIGVycm9yIHZhbHVlIHRvIHJlbmRlci5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgX3RoaXMuZ2V0RXJyb3JNYXJrdXAgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJzxsaT4nLFxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJidWJibGVcIj4nLFxuICAgICAgICAgICc8c3Bhbj4nLCBlcnJvciwgJzwvc3Bhbj4nLFxuICAgICAgICAgICc8YWJiciB0aXRsZT1cIk1hZ25pdHVkZSBFcnJvclwiPkVycm9yPC9hYmJyPicsXG4gICAgICAgICc8L3NwYW4+JyxcbiAgICAgICc8L2xpPidcbiAgICBdLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG1hcmt1cCBmb3IgYSBzaW5nbGUgbWFnbml0dWRlIGZvdW5kIGluIHRoZSBxdWFrZW1sLlxuICAgKlxuICAgKiBAcGFyYW0gbWFnbml0dWRlIHtPYmplY3R9XG4gICAqICAgICBBbiBvYmplY3QgY29udGFpbmluZyBtYWdudGl1ZGUgaW5mb3JtYXRpb24gYXMgcGFyc2VkIG91dCBvZlxuICAgKiAgICAgdGhlIHF1YWtlbWwuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIF90aGlzLmdldE1hZ25pdHVkZU1hcmt1cCA9IGZ1bmN0aW9uIChtYWduaXR1ZGUpIHtcbiAgICB2YXIgY29udHJpYnV0aW9ucyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIG1hZyxcbiAgICAgICAgcHJlZmVycmVkVHlwZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzdGF0aW9ucyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmFsdWU7XG5cbiAgICBtYWduaXR1ZGUgPSBtYWduaXR1ZGUgfHwge307XG4gICAgbWFnID0gbWFnbml0dWRlLm1hZyB8fCB7fTtcblxuICAgIGlmIChtYWduaXR1ZGUuY3JlYXRpb25JbmZvKSB7XG4gICAgICBzb3VyY2UgPSBtYWduaXR1ZGUuY3JlYXRpb25JbmZvLmFnZW5jeUlEO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgPSBfdGhpcy5wcm9kdWN0LmdldCgnc291cmNlJyk7XG4gICAgfVxuXG4gICAgY29udHJpYnV0aW9ucyA9IG1hZ25pdHVkZS5jb250cmlidXRpb25zIHx8IFtdO1xuXG4gICAgdHlwZSA9IG1hZ25pdHVkZS50eXBlIHx8IF9OT1RfUkVQT1JURUQ7XG4gICAgdmFsdWUgPSBtYWcudmFsdWUgfHwgX05PVF9SRVBPUlRFRDtcbiAgICBlcnJvciA9IG1hZy51bmNlcnRhaW50eSB8fCBfTk9UX1JFUE9SVEVEO1xuICAgIHN0YXRpb25zID0gbWFnbml0dWRlLnN0YXRpb25Db3VudCB8fCBfTk9UX1JFUE9SVEVEO1xuICAgIHByZWZlcnJlZFR5cGUgPSB0aGlzLnByb2R1Y3QuZ2V0UHJvcGVydHkoJ21hZ25pdHVkZS10eXBlJykgfHwgJyc7XG5cbiAgICByZXR1cm4gW1xuICAgICAgJzxzZWN0aW9uIGNsYXNzPVwiYWNjb3JkaW9uIGFjY29yZGlvbi1jbG9zZWQgbWFnbml0dWRlLXZpZXctaXRlbVwiPicsXG4gICAgICAgIChwcmVmZXJyZWRUeXBlLnRvTG93ZXJDYXNlKCkgPT09IHR5cGUudG9Mb3dlckNhc2UoKSA/XG4gICAgICAgICAgICAnPGgzIGNsYXNzPVwicHJlZmVycmVkXCI+JzogJzxoMz4nICksXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgJzwvaDM+JyxcbiAgICAgICAgJzx1bCBjbGFzcz1cIm1hZ25pdHVkZS1zdW1tYXJ5XCI+JyxcbiAgICAgICAgICBfdGhpcy5nZXRWYWx1ZU1hcmt1cCh2YWx1ZSksXG4gICAgICAgICAgX3RoaXMuZ2V0RXJyb3JNYXJrdXAoZXJyb3IpLFxuICAgICAgICAgIF90aGlzLmdldFN0YXRpb25zTWFya3VwKHN0YXRpb25zKSxcbiAgICAgICAgICBfdGhpcy5nZXRTb3VyY2VNYXJrdXAoc291cmNlKSxcbiAgICAgICAgJzwvdWw+JyxcbiAgICAgICAgJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQobnVsbCk7XCIgY2xhc3M9XCJhY2NvcmRpb24tdG9nZ2xlXCI+RGV0YWlsczwvYT4nLFxuICAgICAgICAnPGRpdiBjbGFzcz1cImFjY29yZGlvbi1jb250ZW50XCI+JyxcbiAgICAgICAgICBfdGhpcy5nZXRDb250cmlidXRpb25zTWFya3VwKGNvbnRyaWJ1dGlvbnMpLFxuICAgICAgICAnPC9kaXY+JyxcbiAgICAgICc8L3NlY3Rpb24+J1xuICAgIF0uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbWFya3VwIGZvciBhbGwgdGhlIG1hZ25pdHVkZXMgZm91bmQgaW4gdGhlIHF1YWtlbWwuXG4gICAqXG4gICAqIEBwYXJhbSBtYWduaXR1ZGVzIHtBcnJheX1cbiAgICogICAgIEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBtYWduaXR1ZGUgaW5mb3JtYXRpb24gYXMgcGFyc2VkXG4gICAqICAgICBvdXQgb2YgdGhlIHF1YWtlbWwuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIF90aGlzLmdldE1hZ25pdHVkZXNNYXJrdXAgPSBmdW5jdGlvbiAobWFnbml0dWRlcykge1xuICAgIG1hZ25pdHVkZXMgPSBtYWduaXR1ZGVzIHx8IFtdO1xuXG4gICAgcmV0dXJuIG1hZ25pdHVkZXMucmVkdWNlKGZ1bmN0aW9uIChtYXJrdXAsIG1hZ25pdHVkZSkge1xuICAgICAgbWFya3VwLnB1c2goX3RoaXMuZ2V0TWFnbml0dWRlTWFya3VwKG1hZ25pdHVkZSkpO1xuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9LCBbXSkuam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbWFya3VwIGZvciB0aGUgbWFnbml0dWRlIHNvdXJjZSBsaXN0IGl0ZW0gYnViYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlIHtTdHJpbmd9XG4gICAqICAgICBUaGUgc291cmNlIHZhbHVlIHRvIHJlbmRlci5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgX3RoaXMuZ2V0U291cmNlTWFya3VwID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHJldHVybiBbXG4gICAgICAnPGxpPicsXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImJ1YmJsZVwiPicsXG4gICAgICAgICAgQXR0cmlidXRpb24uZ2V0Q29udHJpYnV0b3JSZWZlcmVuY2Uoc291cmNlKSxcbiAgICAgICAgICAnPGFiYnIgdGl0bGU9XCJNYWduaXR1ZGUgRGF0YSBTb3VyY2VcIj5Tb3VyY2U8L2FiYnI+JyxcbiAgICAgICAgJzwvc3Bhbj4nLFxuICAgICAgJzwvbGk+J1xuICAgIF0uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbWFya3VwIGZvciB0aGUgbWFnbml0dWRlIHN0YXRpb25zIGxpc3QgaXRlbSBidWJibGUuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0aW9ucyB7U3RyaW5nfVxuICAgKiAgICAgVGhlIHN0YXRpb25zIHZhbHVlIHRvIHJlbmRlci5cbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgX3RoaXMuZ2V0U3RhdGlvbnNNYXJrdXAgPSBmdW5jdGlvbiAoc3RhdGlvbnMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJzxsaT4nLFxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJidWJibGVcIj4nLFxuICAgICAgICAgICc8c3Bhbj4nLCBzdGF0aW9ucywgJzwvc3Bhbj4nLFxuICAgICAgICAgICc8YWJiciB0aXRsZT1cIk51bWJlciBvZiBTdGF0aW9uc1wiPlN0YXRpb25zPC9hYmJyPicsXG4gICAgICAgICc8L3NwYW4+JyxcbiAgICAgICc8L2xpPidcbiAgICBdLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG1hcmt1cCBmb3IgdGhlIG1hZ25pdHVkZSB2YWx1ZSBsaXN0IGl0ZW0gYnViYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUge1N0cmluZ31cbiAgICogICAgIFRoZSBtYWduaXR1ZGUgdmFsdWUgdG8gcmVuZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBfdGhpcy5nZXRWYWx1ZU1hcmt1cCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAnPGxpPicsXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImJ1YmJsZSBidWJibGUtYm9yZGVyXCI+JyxcbiAgICAgICAgICAnPHNwYW4+PHN0cm9uZz4nLCB2YWx1ZSwgJzwvc3Ryb25nPjwvc3Bhbj4nLFxuICAgICAgICAgICc8YWJiciB0aXRsZT1cIk1hZ25pdHVkZVwiPk1hZzwvYWJicj4nLFxuICAgICAgICAnPC9zcGFuPicsXG4gICAgICAnPC9saT4nXG4gICAgXS5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcXVha2VtbC5cbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlclF1YWtlbWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hZ25pdHVkZXM7XG5cbiAgICBpZiAoX3RoaXMucXVha2VtbCkge1xuICAgICAgLy8gQWxyZWFkeSBoYXZlIHF1YWtlbWwsIHJlbmRlciBpdFxuICAgICAgbWFnbml0dWRlcyA9IF90aGlzLnF1YWtlbWwuZ2V0TWFnbml0dWRlcygpO1xuXG4gICAgICBpZiAobWFnbml0dWRlcy5sZW5ndGgpIHtcbiAgICAgICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gX3RoaXMuZ2V0TWFnbml0dWRlc01hcmt1cChtYWduaXR1ZGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLmVsLmlubmVySFRNTCA9ICc8cCBjbGFzcz1cImFsZXJ0IGluZm9cIj4nICtcbiAgICAgICAgICAgICdObyBtYWduaXR1ZGUgZGF0YSBhdmFpbGFibGUuPC9wPic7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFnbml0dWRlc1ZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGb3JtYXR0ZXIgPSByZXF1aXJlKCdjb3JlL0Zvcm1hdHRlcicpLFxuICAgIE1vZHVsZSA9IHJlcXVpcmUoJ2NvcmUvTW9kdWxlJyksXG4gICAgT3JpZ2luVmlldyA9IHJlcXVpcmUoJ29yaWdpbi9PcmlnaW5WaWV3JyksXG4gICAgU2NpZW50aWZpY1N1bW1hcnlNb2R1bGUgPSByZXF1aXJlKCdzY2llbnRpZmljL1NjaWVudGlmaWNTdW1tYXJ5TW9kdWxlJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMsXG4gICAgX0lELFxuICAgIF9USVRMRSxcbiAgICBfVFlQRVM7XG5cblxuX0lEID0gJ29yaWdpbic7XG5fVElUTEUgPSAnT3JpZ2luJztcbl9UWVBFUyA9IFsnb3JpZ2luJywgJ3BoYXNlLWRhdGEnXTtcblxuX0RFRkFVTFRTID0ge1xuXG59O1xuXG5cbnZhciBPcmlnaW5Nb2R1bGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2Zvcm1hdHRlcixcbiAgICAgIF9vcmlnaW5WaWV3O1xuXG5cbiAgX3RoaXMgPSBNb2R1bGUob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcblxuICAgIF9mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBGb3JtYXR0ZXI7XG5cbiAgICBfdGhpcy5JRCA9IF9JRDtcbiAgICBfdGhpcy5USVRMRSA9IF9USVRMRTtcbiAgfTtcblxuXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChfb3JpZ2luVmlldyAmJiBfb3JpZ2luVmlldy5kZXN0cm95KSB7XG4gICAgICBfb3JpZ2luVmlldy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgX2Zvcm1hdHRlciA9IG51bGw7XG4gICAgX29yaWdpblZpZXcgPSBudWxsO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gIG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgcHJvcGVyIG9yaWdpbi1saWtlIHByb2R1Y3QuIEZpcnN0IHRyaWVzIHRvIGdldCBhbiBvcmlnaW4gcHJvZHVjdFxuICAgKiBpZiBzdWNjZXNzZnVsLCBjaGVja3MgaWYgYSBwaGFzZS1kYXRhIHByb2R1Y3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UsXG4gICAqIHR5cGUgYW5kIGNvZGUgZXhpc3RzLCBpZiBzbywgdXNlcyB0aGF0IHBoYXNlLWRhdGEgcHJvZHVjdCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9kdWN0fVxuICAgKi9cbiAgX3RoaXMuZ2V0T3JpZ2luUHJvZHVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXYsXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgcGhhc2UsXG4gICAgICAgIHByb2R1Y3Q7XG5cbiAgICBvcmlnaW4gPSBfdGhpcy5nZXRQcm9kdWN0KCdvcmlnaW4nKTtcblxuICAgIGlmIChvcmlnaW4pIHtcbiAgICAgIGV2ID0gX3RoaXMubW9kZWwuZ2V0KCdldmVudCcpO1xuICAgICAgcGhhc2UgPSBldi5nZXRQcm9kdWN0QnlJZCgncGhhc2UtZGF0YScsIG9yaWdpbi5nZXQoJ3NvdXJjZScpLFxuICAgICAgICAgIG9yaWdpbi5nZXQoJ2NvZGUnKSk7XG4gICAgfVxuXG4gICAgaWYgKHBoYXNlKSB7XG4gICAgICBwcm9kdWN0ID0gcGhhc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2R1Y3QgPSBvcmlnaW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2R1Y3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgaGVhZGVyLCBjb250ZW50IGFuZCBmb290ZXIuIENvbnRlbnQgcmVuZGVyaW5nIGRlbGVnYXRlZFxuICAgKiB0byB7T3JpZ2luVmlld30uXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb2R1Y3Q7XG5cbiAgICBwcm9kdWN0ID0gX3RoaXMuZ2V0T3JpZ2luUHJvZHVjdCgpO1xuXG4gICAgX3RoaXMucmVuZGVySGVhZGVyKHByb2R1Y3QpO1xuICAgIF90aGlzLnJlbmRlckNvbnRlbnQocHJvZHVjdCk7XG4gICAgX3RoaXMucmVuZGVyRm9vdGVyKHByb2R1Y3QpO1xuICB9O1xuXG4gIF90aGlzLnJlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIHZhciBjb25maWcsXG4gICAgICAgIGdlb3NlcnZlO1xuXG4gICAgaWYgKF9vcmlnaW5WaWV3ICYmIF9vcmlnaW5WaWV3LmRlc3Ryb3kpIHtcbiAgICAgIF9vcmlnaW5WaWV3LmRlc3Ryb3koKTtcbiAgICAgIF9vcmlnaW5WaWV3ID0gbnVsbDtcbiAgICAgIC8vIHJlbW92ZSBwcmV2aW91cyBfb3JpZ2luVmlldyBza2VsZXRvblxuICAgICAgVXRpbC5lbXB0eShfdGhpcy5jb250ZW50KTtcbiAgICB9XG5cbiAgICBjb25maWcgPSBfdGhpcy5tb2RlbC5nZXQoJ2NvbmZpZycpO1xuXG4gICAgaWYgKCFwcm9kdWN0KSB7XG4gICAgICBfdGhpcy5jb250ZW50LmlubmVySFRNTCA9ICc8cCBjbGFzcz1cImFsZXJ0IGVycm9yXCI+JyArXG4gICAgICAgICAgJ05vIG9yaWdpbiBmb3VuZCE8L3A+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZ2Vvc2VydmUgPSBfdGhpcy5nZXRQcm9kdWN0KCdnZW9zZXJ2ZScpO1xuICAgICAgX29yaWdpblZpZXcgPSBPcmlnaW5WaWV3KHtcbiAgICAgICAgZWw6IF90aGlzLmNvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlcjogX2Zvcm1hdHRlcixcbiAgICAgICAgbW9kZWw6IHByb2R1Y3QsXG4gICAgICAgIGdlb3NlcnZlOiBnZW9zZXJ2ZSxcbiAgICAgICAgdXJsOiAoY29uZmlnID8gY29uZmlnLkdFT1NFUlZFX1dTX1VSTCA6IG51bGwpXG4gICAgICB9KTtcblxuICAgICAgX29yaWdpblZpZXcucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBmb290ZXIgY29udGVudC4gVGhpcyBkZWxlZ2F0ZXMgdG8gdGhlIGdldFByb2R1Y3RGb290ZXIgbWV0aG9kLlxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVuZGVyRm9vdGVyID0gZnVuY3Rpb24gKHByb2R1Y3QpIHtcbiAgICB2YXIgZG93bmxvYWRzO1xuXG4gICAgVXRpbC5lbXB0eShfdGhpcy5mb290ZXIpO1xuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBkb3dubG9hZHMgPSBfdGhpcy5nZXRQcm9kdWN0Rm9vdGVyKHtcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChkb3dubG9hZHMpIHtcbiAgICAgICAgX3RoaXMuZm9vdGVyLmFwcGVuZENoaWxkKGRvd25sb2Fkcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBoZWFkZXIgY29udGVudC4gVGhpcyBkZWxlZ2F0ZXMgdG8gdGVoIGdldFByb2R1Y3RIZWFkZXIgbWV0aG9kLlxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVuZGVySGVhZGVyID0gZnVuY3Rpb24gKHByb2R1Y3QpIHtcbiAgICB2YXIgaGVhZGVyO1xuXG4gICAgVXRpbC5lbXB0eShfdGhpcy5oZWFkZXIpO1xuICAgIF90aGlzLmhlYWRlci5pbm5lckhUTUwgPSAnPGgzPicgKyBfdGhpcy5USVRMRSArICc8L2gzPic7XG5cbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgaGVhZGVyID0gX3RoaXMuZ2V0UHJvZHVjdEhlYWRlcih7XG4gICAgICAgIHByb2R1Y3Q6IHByb2R1Y3QsXG4gICAgICAgIHN1bW1hcnlNb2R1bGU6IFNjaWVudGlmaWNTdW1tYXJ5TW9kdWxlLFxuICAgICAgICB0eXBlOiAnb3JpZ2luJ1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgX3RoaXMuaGVhZGVyLmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbk9yaWdpbk1vZHVsZS5JRCA9IF9JRDtcbk9yaWdpbk1vZHVsZS5USVRMRSA9IF9USVRMRTtcbk9yaWdpbk1vZHVsZS5UWVBFUyA9IF9UWVBFUztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE9yaWdpbk1vZHVsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2ljUGluVmlldyA9IHJlcXVpcmUoJ2NvcmUvQmFzaWNQaW5WaWV3JyksXG4gICAgRm9ybWF0dGVyID0gcmVxdWlyZSgnY29yZS9Gb3JtYXR0ZXInKSxcbiAgICBPcmlnaW5Nb2R1bGUgPSByZXF1aXJlKCdvcmlnaW4vT3JpZ2luTW9kdWxlJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIG1vZHVsZTogT3JpZ2luTW9kdWxlXG59O1xuXG5cbnZhciBPcmlnaW5QaW5WaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9mb3JtYXR0ZXI7XG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IEJhc2ljUGluVmlldyhvcHRpb25zKTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuICB9O1xuXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIF9mb3JtYXR0ZXIgPSBudWxsO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgT3JpZ2luIGNvbnRlbnRcbiAgICovXG4gIF90aGlzLnJlbmRlclBpbkNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHRoLFxuICAgICAgICBtYWduaXR1ZGUsXG4gICAgICAgIG1hZ25pdHVkZVR5cGUsXG4gICAgICAgIHByb2R1Y3QsXG4gICAgICAgIHJldmlld1N0YXR1cyxcbiAgICAgICAgdGltZTtcblxuICAgIHByb2R1Y3QgPSBfdGhpcy5tb2RlbDtcblxuICAgIGRlcHRoID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnZGVwdGgnKTtcbiAgICBtYWduaXR1ZGUgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdtYWduaXR1ZGUnKTtcbiAgICBtYWduaXR1ZGVUeXBlID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnbWFnbml0dWRlLXR5cGUnKTtcbiAgICByZXZpZXdTdGF0dXMgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdyZXZpZXctc3RhdHVzJyk7XG4gICAgdGltZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2V2ZW50dGltZScpO1xuXG4gICAgZGVwdGggPSBfZm9ybWF0dGVyLmRlcHRoKGRlcHRoLCAna20nKTtcbiAgICBtYWduaXR1ZGUgPSBfZm9ybWF0dGVyLm1hZ25pdHVkZShtYWduaXR1ZGUsIG1hZ25pdHVkZVR5cGUpO1xuICAgIHJldmlld1N0YXR1cyA9IChyZXZpZXdTdGF0dXMgPT09IG51bGwpID8gJyZuZGFzaDsnIDpcbiAgICAgICAgcmV2aWV3U3RhdHVzLnRvVXBwZXJDYXNlKCk7XG4gICAgdGltZSA9ICh0aW1lID09PSBudWxsID8gJyZuZGFzaDsnIDpcbiAgICAgICAgJzx0aW1lIGRhdGV0aW1lPVwiJyArIHRpbWUgKyAnXCI+JyArXG4gICAgICAgICAgdGltZS5yZXBsYWNlKCdUJywgJzxiciAvPicpLnJlcGxhY2UoJ1onLCAnIChVVEMpJykgK1xuICAgICAgICAnPC90aW1lPicpO1xuXG4gICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPVxuICAgICAgICAnPGRsIGNsYXNzPVwibm8tc3R5bGUgb3JpZ2luLXBpbi12aWV3XCI+JyArXG4gICAgICAgICAgJzxkdD5SZXZpZXcgU3RhdHVzPC9kdD4nICtcbiAgICAgICAgICAgICc8ZGQgY2xhc3M9XCJvcmlnaW4tcGluLXJldmlldy1zdGF0dXNcIj4nICsgcmV2aWV3U3RhdHVzICsgJzwvZGQ+JyArXG4gICAgICAgICAgJzxkdD5NYWduaXR1ZGU8L2R0PicgK1xuICAgICAgICAgICAgJzxkZCBjbGFzcz1cIm9yaWdpbi1waW4tbWFnbml0dWRlXCI+JyArIG1hZ25pdHVkZSArICc8L2RkPicgK1xuICAgICAgICAgICc8ZHQ+RGVwdGg8L2R0PicgK1xuICAgICAgICAgICAgJzxkZCBjbGFzcz1cIm9yaWdpbi1waW4tZGVwdGhcIj4nICsgZGVwdGggKyAnPC9kZD4nICtcbiAgICAgICAgICAnPGR0PlRpbWU8L2R0PicgK1xuICAgICAgICAgICAgJzxkZCBjbGFzcz1cIm9yaWdpbi1waW4tdGltZVwiPicgKyB0aW1lICsgJzwvZGQ+JyArXG4gICAgICAgICc8L2RsPic7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBPcmlnaW5QaW5WaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBBdHRyaWJ1dGlvbiA9IHJlcXVpcmUoJ2NvcmUvQXR0cmlidXRpb24nKSxcbiAgICBGb3JtYXR0ZXIgPSByZXF1aXJlKCdjb3JlL0Zvcm1hdHRlcicpLFxuICAgIE1hZ25pdHVkZXNWaWV3ID0gcmVxdWlyZSgnb3JpZ2luL01hZ25pdHVkZXNWaWV3JyksXG4gICAgTW9kZWwgPSByZXF1aXJlKCdtdmMvTW9kZWwnKSxcbiAgICBQaGFzZXNWaWV3ID0gcmVxdWlyZSgnb3JpZ2luL1BoYXNlc1ZpZXcnKSxcbiAgICBQcm9kdWN0VmlldyA9IHJlcXVpcmUoJ2NvcmUvUHJvZHVjdFZpZXcnKSxcbiAgICBUYWJMaXN0ID0gcmVxdWlyZSgndGFibGlzdC9UYWJMaXN0JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuICAgIFhociA9IHJlcXVpcmUoJ3V0aWwvWGhyJyk7XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcbiAgdXJsOiAnaHR0cHM6Ly9lYXJ0aHF1YWtlLnVzZ3MuZ292L3dzL2dlb3NlcnZlLydcbn07XG52YXIgTk9UX1JFUE9SVEVEID0gJyZuZGFzaDsnO1xuXG5cbnZhciBPcmlnaW5WaWV3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2Zvcm1hdHRlcixcbiAgICAgIF9nZW9zZXJ2ZSxcbiAgICAgIF9yZWdpb24sXG4gICAgICBfbWFnbml0dWRlc1ZpZXcsXG4gICAgICBfcGhhc2VzVmlldyxcbiAgICAgIF90YWJMaXN0LFxuICAgICAgX3VybDtcblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gUHJvZHVjdFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF9mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBGb3JtYXR0ZXIoKTtcbiAgICBfZ2Vvc2VydmUgPSBvcHRpb25zLmdlb3NlcnZlIHx8IG51bGw7XG4gICAgX3VybCA9IG9wdGlvbnMudXJsO1xuXG4gICAgLy8gQmluZCB0byBnZW9zZXJ2ZSBtb2RlbCBjaGFuZ2VcbiAgICBfcmVnaW9uID0gTW9kZWwoKTtcbiAgICBfcmVnaW9uLm9uKCdjaGFuZ2U6cmVnaW9ucycsICdidWlsZEZlUmVnaW9uVmlldycsIF90aGlzKTtcbiAgfTtcblxuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBfcmVnaW9uLm9mZignY2hhbmdlOnJlZ2lvbnMnLCAnYnVpbGRGZVJlZ2lvblZpZXcnLCBfdGhpcyk7XG5cbiAgICBpZiAoX3RhYkxpc3QgJiYgX3RhYkxpc3QuZGVzdHJveSkge1xuICAgICAgX3RhYkxpc3QuZGVzdHJveSgpO1xuICAgICAgX3RhYkxpc3QgPSBudWxsO1xuICAgIH1cblxuICAgIF9mb3JtYXR0ZXIgPSBudWxsO1xuICAgIF9nZW9zZXJ2ZSA9IG51bGw7XG4gICAgX21hZ25pdHVkZXNWaWV3ID0gbnVsbDtcbiAgICBfcGhhc2VzVmlldyA9IG51bGw7XG4gICAgX3JlZ2lvbiA9IG51bGw7XG4gICAgX3VybCA9IG51bGw7XG5cbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogQnVpbGQgRmUgUmVnaW9uIHN0cmluZyBmcm9tIHRoZSBoYXpkZXYtZ2Vvc2VydmUtd3MgcHJvamVjdC5cbiAgICpcbiAgICogSWYgbm8gZGF0YSBpcyBhdmFpbGFibGUgYSBkZWZhdWx0IG1lc3NhZ2UgaXMgZGlzcGxheWVkXG4gICAqL1xuICBfdGhpcy5idWlsZEZlUmVnaW9uVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmUsXG4gICAgICAgIGZlRWxlbWVudCxcbiAgICAgICAgZmVOYW1lLFxuICAgICAgICBmZU51bWJlcjtcblxuICAgIGZlRWxlbWVudCA9IF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5mZS1pbmZvJyk7XG5cbiAgICB0cnkge1xuICAgICAgZmUgPSBfcmVnaW9uLmdldCgncmVnaW9ucycpLmZlLmZlYXR1cmVzWzBdLnByb3BlcnRpZXM7XG4gICAgICBmZU5hbWUgPSBmZS5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICBmZU51bWJlciA9IGZlLm51bWJlcjtcbiAgICAgIGZlRWxlbWVudC5pbm5lckhUTUwgPSAoZmVOdW1iZXIgPyBmZU5hbWUgKyAnICgnICsgZmVOdW1iZXIgKyAnKScgOiBmZU5hbWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGZlRWxlbWVudC5pbm5lckhUTUwgPSBOT1RfUkVQT1JURUQ7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgcHJvZHVjdCBpbnRvIGFuIGlkZW50aWZpYWJsZSBjYXRhbG9nIGFuZCBpZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9kdWN0IHtQcm9kdWN0fVxuICAgKiAgICBhIFByb2R1Y3QgbW9kZWxcbiAgICovXG4gIF90aGlzLmdldENhdGFsb2dEZXRhaWwgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIHZhciBldmVudElkLFxuICAgICAgICBldmVudFNvdXJjZSxcbiAgICAgICAgZXZlbnRTb3VyY2VDb2RlO1xuXG4gICAgZXZlbnRTb3VyY2UgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdldmVudHNvdXJjZScpO1xuICAgIGV2ZW50U291cmNlQ29kZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2V2ZW50c291cmNlY29kZScpO1xuICAgIGV2ZW50SWQgPSAnJztcblxuICAgIGlmICghZXZlbnRTb3VyY2UpIHtcbiAgICAgIHJldHVybiBOT1RfUkVQT1JURUQ7XG4gICAgfVxuXG4gICAgZXZlbnRJZCA9IChldmVudFNvdXJjZSArIGV2ZW50U291cmNlQ29kZSkudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gZXZlbnRTb3VyY2UudG9VcHBlckNhc2UoKSArICcgPHNtYWxsPignICsgZXZlbnRJZCArICcpPC9zbWFsbD4nO1xuICB9O1xuXG4vKipcbiAqIEdldCBmZSByZWdpb24gaW5mb3JtYXRpb24uXG4gKlxuICogQXR0ZW1wdHMgdG8gbG9hZCBmcm9tIGEgZ2Vvc2VydmUgcHJvZHVjdCBmaXJzdC5cbiAqIElmIG5vIHN1Y2ggcHJvZHVjdCBpcyBmb3VuZCBfZ2V0R2Vvc2VydmVGZVJlZ2lvbigpIGlzIGNhbGxlZFxuICogdG8gcmV0cmVpdmUgdGhlIGZlIHJlZ2lvbiBzdHJpbmcgZnJvbSB0aGUgZ2Vvc2VydmUgd3MuXG4gKlxuICogT25jZSBsb2FkIGlzIGNvbXBsZXRlLCBfYnVpbGRGZVJlZ2lvblZpZXcgaXMgY2FsbGVkLlxuICovXG4gIF90aGlzLmdldEZlUmVnaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW9zZXJ2ZUpzb24sXG4gICAgICAgIHRoYXQ7XG5cbiAgICB0aGF0ID0gX3RoaXM7XG5cbiAgICBpZiAoX2dlb3NlcnZlKSB7XG4gICAgICBnZW9zZXJ2ZUpzb24gPSBfZ2Vvc2VydmUuZ2V0Q29udGVudCgnZ2Vvc2VydmUuanNvbicpO1xuICAgIH1cblxuICAgIGlmIChnZW9zZXJ2ZUpzb24pIHtcbiAgICAgIC8vIGlmIGEgZ2Vvc2VydmUgcHJvZHVjdCBleGlzdHMsIHVzZSBpdFxuICAgICAgWGhyLmFqYXgoe1xuICAgICAgICB1cmw6IGdlb3NlcnZlSnNvbi5nZXQoJ3VybCcpLFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZ2Vvc2VydmUpIHtcbiAgICAgICAgICB0aGF0LmZvcm1hdEZlUmVnaW9uKGdlb3NlcnZlLmZlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LmZvcm1hdEZlUmVnaW9uKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbWFrZSBhIGdlb3NlcnZlIHJlcXVlc3RcbiAgICAgIF90aGlzLmdldEdlb3NlcnZlRmVSZWdpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBfcmVnaW9uIHdpdGggZmUgcmVnaW9uIGRhdGEgZnJvbSB0aGUgZ2Vvc2VydmUgd3NcbiAgICovXG4gIF90aGlzLmdldEdlb3NlcnZlRmVSZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGU7XG5cbiAgICAvLyBnZXQgbG9jYXRpb25cbiAgICBsYXRpdHVkZSA9IF90aGlzLm1vZGVsLmdldFByb3BlcnR5KCdsYXRpdHVkZScpO1xuICAgIGxvbmdpdHVkZSA9IF90aGlzLm1vZGVsLmdldFByb3BlcnR5KCdsb25naXR1ZGUnKTtcblxuICAgIGlmIChsYXRpdHVkZSAhPT0gbnVsbCAmJiBsb25naXR1ZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIHJlcXVlc3QgcmVnaW9uIGluZm9ybWF0aW9uXG4gICAgICBYaHIuYWpheCh7XG4gICAgICAgIHVybDogX3VybCArICdyZWdpb25zLmpzb24nLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgbGF0aXR1ZGU6IGxhdGl0dWRlLFxuICAgICAgICAgIGxvbmdpdHVkZTogbG9uZ2l0dWRlLFxuICAgICAgICAgIHR5cGU6ICdmZSdcbiAgICAgICAgfSxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBfcmVnaW9uLnNldCh7XG4gICAgICAgICAgICByZWdpb25zOiBkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZW9zZXJ2ZSB3ZWIgc2VydmljZSBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgbWFya3VwIGZvciBvcmlnaW4gZGV0YWlsIHRhYmxlXG4gICAqXG4gICAqIEBwYXJhbSBwcm9kdWN0IHtQcm9kdWN0fVxuICAgKiAgICBhIFByb2R1Y3QgbW9kZWxcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICBodG1sIG1hcmt1cCBmb3IgdGhlIG9yaWdpbiB0YWJsZVxuICAgKi9cbiAgX3RoaXMuZ2V0T3JpZ2luRGV0YWlsVGFibGUgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIHZhciBhemltdXRoYWxHYXAsXG4gICAgICAgIGJ1ZixcbiAgICAgICAgZGVwdGgsXG4gICAgICAgIGRlcHRoRXJyb3IsXG4gICAgICAgIGV2ZW50VGltZSxcbiAgICAgICAgaG9yaXpvbnRhbEVycm9yLFxuICAgICAgICBsYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlLFxuICAgICAgICBtYWduaXR1ZGUsXG4gICAgICAgIG1hZ25pdHVkZUVycm9yLFxuICAgICAgICBtYWduaXR1ZGVTb3VyY2UsXG4gICAgICAgIG1hZ25pdHVkZVR5cGUsXG4gICAgICAgIG1pbmltdW1EaXN0YW5jZSxcbiAgICAgICAgbnVtUGhhc2VzLFxuICAgICAgICBudW1TdGF0aW9ucyxcbiAgICAgICAgb3JpZ2luU291cmNlLFxuICAgICAgICByZXZpZXdTdGF0dXMsXG4gICAgICAgIHN0YW5kYXJkRXJyb3I7XG5cbiAgICBidWYgPSBbXTtcblxuICAgIC8vIHJlcXVpcmVkIGF0dHJpYnV0ZXMgZm9yIG9yaWdpbnNcbiAgICBsYXRpdHVkZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2xhdGl0dWRlJyk7XG4gICAgbG9uZ2l0dWRlID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnbG9uZ2l0dWRlJyk7XG4gICAgZXZlbnRUaW1lID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnZXZlbnR0aW1lJyk7XG5cbiAgICAvLyBvcHRpb25hbCBhdHRyaWJ1dGVzIGZvciBvcmlnaW5zXG4gICAgbWFnbml0dWRlID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnbWFnbml0dWRlJyk7XG4gICAgbWFnbml0dWRlVHlwZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ21hZ25pdHVkZS10eXBlJyk7XG4gICAgbWFnbml0dWRlRXJyb3IgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdtYWduaXR1ZGUtZXJyb3InKTtcbiAgICBob3Jpem9udGFsRXJyb3IgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdob3Jpem9udGFsLWVycm9yJyk7XG4gICAgZGVwdGggPSBwcm9kdWN0LmdldFByb3BlcnR5KCdkZXB0aCcpO1xuICAgIGRlcHRoRXJyb3IgPSBwcm9kdWN0LmdldFByb3BlcnR5KCd2ZXJ0aWNhbC1lcnJvcicpO1xuICAgIG51bVN0YXRpb25zID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnbnVtLXN0YXRpb25zLXVzZWQnKTtcbiAgICBudW1QaGFzZXMgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdudW0tcGhhc2VzLXVzZWQnKTtcbiAgICBtaW5pbXVtRGlzdGFuY2UgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdtaW5pbXVtLWRpc3RhbmNlJyk7XG4gICAgc3RhbmRhcmRFcnJvciA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ3N0YW5kYXJkLWVycm9yJyk7XG4gICAgYXppbXV0aGFsR2FwID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnYXppbXV0aGFsLWdhcCcpO1xuICAgIHJldmlld1N0YXR1cyA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ3Jldmlldy1zdGF0dXMnKSB8fCAnYXV0b21hdGljJztcbiAgICBvcmlnaW5Tb3VyY2UgPSBwcm9kdWN0LmdldFByb3BlcnR5KCdvcmlnaW4tc291cmNlJykgfHwgcHJvZHVjdC5nZXQoJ3NvdXJjZScpO1xuICAgIG1hZ25pdHVkZVNvdXJjZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ21hZ25pdHVkZS1zb3VyY2UnKSB8fCBwcm9kdWN0LmdldCgnc291cmNlJyk7XG5cblxuICAgIGJ1Zi5wdXNoKFxuICAgICAgJzxkaXYgY2xhc3M9XCJob3Jpem9udGFsLXNjcm9sbGluZ1wiPicsXG4gICAgICAnPHRhYmxlIGNsYXNzPVwib3JpZ2luLWRldGFpbFwiPjx0Ym9keT4nXG4gICAgKTtcblxuICAgIGJ1Zi5wdXNoKCc8dHI+PHRoIHNjb3BlPVwicm93XCI+TWFnbml0dWRlJyxcbiAgICAgICAgKG1hZ25pdHVkZUVycm9yID8gJzxzcGFuIGNsYXNzPVwidW5jZXJ0YWludHlcIj51bmNlcnRhaW50eTwvc3Bhbj4nIDogJycpLFxuICAgICAgICAnPC90aD48dGQ+JyxcbiAgICAgICAgX2Zvcm1hdHRlci5tYWduaXR1ZGUobWFnbml0dWRlLCBtYWduaXR1ZGVUeXBlLCBtYWduaXR1ZGVFcnJvciksXG4gICAgICAgICc8L3RkPjwvdHI+Jyk7XG5cbiAgICBidWYucHVzaCgnPHRyPjx0aCBzY29wZT1cInJvd1wiPkxvY2F0aW9uJyxcbiAgICAgICAgKGhvcml6b250YWxFcnJvciA/ICc8c3BhbiBjbGFzcz1cInVuY2VydGFpbnR5XCI+dW5jZXJ0YWludHk8L3NwYW4+JyA6ICcnKSxcbiAgICAgICAgJzwvdGg+PHRkPicsXG4gICAgICAgIF9mb3JtYXR0ZXIubG9jYXRpb24obGF0aXR1ZGUsIGxvbmdpdHVkZSksXG4gICAgICAgIF9mb3JtYXR0ZXIudW5jZXJ0YWludHkoaG9yaXpvbnRhbEVycm9yLCAxLCBOT1RfUkVQT1JURUQsICdrbScpLFxuICAgICAgICAnPC90ZD48L3RyPicpO1xuXG4gICAgYnVmLnB1c2goJzx0cj48dGggc2NvcGU9XCJyb3dcIj5EZXB0aCcsXG4gICAgICAgIChkZXB0aEVycm9yID8gJzxzcGFuIGNsYXNzPVwidW5jZXJ0YWludHlcIj51bmNlcnRhaW50eTwvc3Bhbj4nIDogJycpLFxuICAgICAgICAnPC90aD48dGQ+JyxcbiAgICAgICAgX2Zvcm1hdHRlci5kZXB0aChkZXB0aCwgJ2ttJywgZGVwdGhFcnJvcikgK1xuICAgICAgICAnPC90ZD48L3RyPicpO1xuXG4gICAgYnVmLnB1c2goJzx0cj48dGggc2NvcGU9XCJyb3dcIj5PcmlnaW4gVGltZTwvdGg+PHRkPicsXG4gICAgICAgICh0eXBlb2YgZXZlbnRUaW1lID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAnPHRpbWUgZGF0ZXRpbWU9XCInICsgZXZlbnRUaW1lICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgIGV2ZW50VGltZS5yZXBsYWNlKCdUJywgJyAnKS5yZXBsYWNlKCdaJywgJyBVVEMnKSArXG4gICAgICAgICAgICAnPC90aW1lPicgOlxuICAgICAgICAgICAgJycpLFxuICAgICAgICAnPC90ZD48L3RyPicpO1xuXG4gICAgYnVmLnB1c2goJzx0cj48dGggc2NvcGU9XCJyb3dcIj5OdW1iZXIgb2YgU3RhdGlvbnM8L3RoPjx0ZD4nLFxuICAgICAgICAobnVtU3RhdGlvbnMgPT09IG51bGwgPyBOT1RfUkVQT1JURUQgOiBudW1TdGF0aW9ucyksXG4gICAgICAgICc8L3RkPjwvdHI+Jyk7XG5cbiAgICBidWYucHVzaCgnPHRyPjx0aCBzY29wZT1cInJvd1wiPk51bWJlciBvZiBQaGFzZXM8L3RoPjx0ZD4nLFxuICAgICAgICAobnVtUGhhc2VzID09PSBudWxsID8gTk9UX1JFUE9SVEVEIDogbnVtUGhhc2VzKSxcbiAgICAgICAgJzwvdGQ+PC90cj4nKTtcblxuICAgIGJ1Zi5wdXNoKCc8dHI+PHRoIHNjb3BlPVwicm93XCI+TWluaW11bSBEaXN0YW5jZTwvdGg+PHRkPicsXG4gICAgICAgIF9mb3JtYXR0ZXIuZGlzdGFuY2UoKG1pbmltdW1EaXN0YW5jZSAqIDAuMDE3NDUzMjkyNSAqIDYzNzguMSksICdrbScpLFxuICAgICAgICAnICgnLCBfZm9ybWF0dGVyLmFuZ2xlKG1pbmltdW1EaXN0YW5jZSwgMiksICcpJyxcbiAgICAgICAgJzwvdGQ+PC90cj4nKTtcblxuICAgIGJ1Zi5wdXNoKCc8dHI+PHRoIHNjb3BlPVwicm93XCI+VHJhdmVsIFRpbWUgUmVzaWR1YWw8L3RoPjx0ZD4nLFxuICAgICAgICAoc3RhbmRhcmRFcnJvciA9PT0gbnVsbCA/IE5PVF9SRVBPUlRFRCA6IHN0YW5kYXJkRXJyb3IgKyAnIHMnKSxcbiAgICAgICAgJzwvdGQ+PC90cj4nKTtcblxuICAgIGJ1Zi5wdXNoKCc8dHI+PHRoIHNjb3BlPVwicm93XCI+QXppbXV0aGFsIEdhcDwvdGg+PHRkPicsXG4gICAgICAgIF9mb3JtYXR0ZXIuYW5nbGUoYXppbXV0aGFsR2FwKSxcbiAgICAgICAgJzwvdGQ+PC90cj4nKTtcblxuICAgIGJ1Zi5wdXNoKCc8dHI+JyxcbiAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPicsXG4gICAgICAgICAgJzxhYmJyIHRpdGxlPVwiRmxpbm4gRW5nZGFobFwiPkZFPC9hYmJyPiBSZWdpb24nLFxuICAgICAgICAnPC90aD4nLFxuICAgICAgICAnPHRkIGNsYXNzPVwiZmUtaW5mb1wiPicgKyBfdGhpcy5nZXRGZVJlZ2lvbigpICsgJzwvdGQ+PC90cj4nKTtcblxuICAgIGJ1Zi5wdXNoKCc8dHI+PHRoIHNjb3BlPVwicm93XCI+UmV2aWV3IFN0YXR1czwvdGg+PHRkPicsXG4gICAgICAgIHJldmlld1N0YXR1cy50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAnPC90ZD48L3RyPicpO1xuXG4gICAgYnVmLnB1c2goXG4gICAgICAgICc8dHI+PHRoIHNjb3BlPVwicm93XCI+Q2F0YWxvZzwvdGg+PHRkPicsXG4gICAgICAgICAgX3RoaXMuZ2V0Q2F0YWxvZ0RldGFpbChwcm9kdWN0KSxcbiAgICAgICAgJzwvdGQ+PC90cj4nLFxuICAgICAgICAnPHRyPjx0aCBzY29wZT1cInJvd1wiPkxvY2F0aW9uIFNvdXJjZTwvdGg+PHRkPicsXG4gICAgICAgICAgQXR0cmlidXRpb24uZ2V0Q29udHJpYnV0b3JSZWZlcmVuY2Uob3JpZ2luU291cmNlKSxcbiAgICAgICAgJzwvdGQ+PC90cj4nLFxuICAgICAgICAnPHRyPjx0aCBzY29wZT1cInJvd1wiPk1hZ25pdHVkZSBTb3VyY2U8L3RoPjx0ZD4nLFxuICAgICAgICAgIEF0dHJpYnV0aW9uLmdldENvbnRyaWJ1dG9yUmVmZXJlbmNlKG1hZ25pdHVkZVNvdXJjZSksXG4gICAgICAgICc8L3RkPjwvdHI+JyxcbiAgICAgICAgJzx0cj48dGggc2NvcGU9XCJyb3dcIj5Db250cmlidXRvcjwvdGg+PHRkPicsXG4gICAgICAgICAgQXR0cmlidXRpb24uZ2V0Q29udHJpYnV0b3JSZWZlcmVuY2UocHJvZHVjdC5nZXQoJ3NvdXJjZScpKSxcbiAgICAgICAgJzwvdGQ+PC90cj4nKTtcblxuICAgIGJ1Zi5wdXNoKCc8L3Rib2R5PjwvdGFibGU+PC9kaXY+Jyk7XG5cbiAgICByZXR1cm4gYnVmLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXNzYWdlIGRhdGEgZnJvbSBnZW9zZXJ2ZSBwcm9kdWN0IGludG8gdGhlIHNhbWUgbW9kZWwgb2JqZWN0XG4gICAqIHRoYXQgRmVSZWdpb25WaWV3IGV4cGVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBmZSB7T2JqZWN0fVxuICAgKiAgICAgICAgICBmZS5udW1iZXIge051bWJlcn0gZmUgcmVnaW9uIG51bWJlci5cbiAgICogICAgICAgICAgZmUubmFtZSB7U3RyaW5nfSBmZSByZWdpb24gbmFtZS5cbiAgICovXG4gIF90aGlzLmZvcm1hdEZlUmVnaW9uID0gZnVuY3Rpb24oZmUpIHtcbiAgICAvLyBvbmx5IHVwZGF0ZSBtb2RlbCBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXG4gICAgaWYgKCFmZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgKG1hc3NhZ2VkKSBmZSBvYmplY3RcbiAgICBfcmVnaW9uLnNldCh7XG4gICAgICAncmVnaW9ucyc6IHtcbiAgICAgICAgJ2ZlJzoge1xuICAgICAgICAgICdmZWF0dXJlcyc6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgJ3Byb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgJ25hbWUnOiBmZS5sb25nTmFtZSxcbiAgICAgICAgICAgICAgICAnbnVtYmVyJzogZmUubnVtYmVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRlbnQsXG4gICAgICAgIHByb2R1Y3QsXG4gICAgICAgIHF1YWtlbWw7XG5cbiAgICAvLyBEZXN0cm95IHRhYmxpc3QgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICBpZiAoX3RhYkxpc3QgJiYgX3RhYkxpc3QuZGVzdHJveSkge1xuICAgICAgX3RhYkxpc3QuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIF90YWJMaXN0ID0gVGFiTGlzdCh7XG4gICAgICBlbDogX3RoaXMuZWwsXG4gICAgICB0YWJzOiBbXVxuICAgIH0pO1xuXG4gICAgcHJvZHVjdCA9IF90aGlzLm1vZGVsO1xuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICBjb250ZW50ID0gX3RoaXMuZ2V0T3JpZ2luRGV0YWlsVGFibGUocHJvZHVjdCk7XG4gICAgICBfdGFiTGlzdC5hZGRUYWIoe1xuICAgICAgICAndGl0bGUnOiAnT3JpZ2luIERldGFpbCcsXG4gICAgICAgICdjb250ZW50JzogY29udGVudFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwcm9kdWN0LmdldCgndHlwZScpID09PSAncGhhc2UtZGF0YScpIHtcbiAgICAgICAgcXVha2VtbCA9IHByb2R1Y3QuZ2V0Q29udGVudCgncXVha2VtbC54bWwnKTtcblxuICAgICAgICBfcGhhc2VzVmlldyA9IFBoYXNlc1ZpZXcoe1xuICAgICAgICAgIGVsOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICBtb2RlbDogcXVha2VtbCxcbiAgICAgICAgICBwcm9kdWN0OiBwcm9kdWN0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90YWJMaXN0LmFkZFRhYih7XG4gICAgICAgICAgJ3RpdGxlJzogJ1BoYXNlcycsXG4gICAgICAgICAgJ2NvbnRlbnQnOiBfcGhhc2VzVmlldy5lbCxcbiAgICAgICAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9waGFzZXNWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfcGhhc2VzVmlldy5yZW5kZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9tYWduaXR1ZGVzVmlldyA9IE1hZ25pdHVkZXNWaWV3KHtcbiAgICAgICAgICBlbDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgbW9kZWw6IHF1YWtlbWwsXG4gICAgICAgICAgcHJvZHVjdDogcHJvZHVjdFxuICAgICAgICB9KTtcblxuICAgICAgICBfdGFiTGlzdC5hZGRUYWIoe1xuICAgICAgICAgICd0aXRsZSc6ICdNYWduaXR1ZGVzJyxcbiAgICAgICAgICAnY29udGVudCc6IF9tYWduaXR1ZGVzVmlldy5lbCxcbiAgICAgICAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9tYWduaXR1ZGVzVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblNlbGVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX21hZ25pdHVkZXNWaWV3LnJlbmRlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9ICc8cCBjbGFzcz1cImFsZXJ0IGVycm9yXCI+JyArXG4gICAgICAgICdObyBPcmlnaW4gcHJvZHVjdCBleGlzdHMuJyArXG4gICAgICAgICc8L3A+JztcbiAgICB9XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBPcmlnaW5WaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnbXZjL0NvbGxlY3Rpb24nKSxcbiAgICBEYXRhVGFibGUgPSByZXF1aXJlKCdtdmMvRGF0YVRhYmxlJyksXG4gICAgUXVha2VtbFZpZXcgPSByZXF1aXJlKCdvcmlnaW4vUXVha2VtbFZpZXcnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyk7XG5cblxudmFyIF9ERUZBVUxUUyxcbiAgICBfUEhBU0VfREFUQV9DT0xVTU5TLFxuICAgIF9QSEFTRV9EQVRBX1NPUlRTO1xuXG5cbl9ERUZBVUxUUyA9IHtcblxufTtcblxuLy8gY29sdW1ucyBmb3IgcGhhc2UgZGF0YSB0YWJsZVxuX1BIQVNFX0RBVEFfQ09MVU1OUyA9IFtcbiAge1xuICAgICdjbGFzc05hbWUnOiAnY2hhbm5lbCcsXG4gICAgJ3RpdGxlJzogJ0NoYW5uZWwnLFxuICAgICdmb3JtYXQnOiBmdW5jdGlvbiAoYXJyaXZhbCkge1xuICAgICAgdmFyIHN0YXRpb24gPSBhcnJpdmFsLnBpY2sud2F2ZWZvcm1JRDtcbiAgICAgIHJldHVybiBzdGF0aW9uLm5ldHdvcmtDb2RlICsgJyAnICsgc3RhdGlvbi5zdGF0aW9uQ29kZSArXG4gICAgICAgICAgKHN0YXRpb24uY2hhbm5lbENvZGUgPyAnICcgKyBzdGF0aW9uLmNoYW5uZWxDb2RlICtcbiAgICAgICAgICAgICAgKHN0YXRpb24ubG9jYXRpb25Db2RlID8gJyAnICsgc3RhdGlvbi5sb2NhdGlvbkNvZGUgOiAnJylcbiAgICAgICAgICAgICAgOiAnJyk7XG4gICAgfSxcbiAgICAnaGVhZGVyJzogdHJ1ZVxuICB9LFxuICB7XG4gICAgJ2NsYXNzTmFtZSc6ICdkaXN0YW5jZScsXG4gICAgJ3RpdGxlJzogJ0Rpc3RhbmNlJyxcbiAgICAnZm9ybWF0JzogZnVuY3Rpb24gKGFycml2YWwpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGFycml2YWwuZGlzdGFuY2UpLnRvRml4ZWQoMikgKyAnJmRlZzsnO1xuICAgIH0sXG4gICAgJ2Rvd25sb2FkRm9ybWF0JzogZnVuY3Rpb24gKGFycml2YWwpIHtcbiAgICAgIHJldHVybiBhcnJpdmFsLmRpc3RhbmNlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgICdjbGFzc05hbWUnOiAnYXppbXV0aCcsXG4gICAgJ3RpdGxlJzogJ0F6aW11dGgnLFxuICAgICdmb3JtYXQnOiBmdW5jdGlvbiAoYXJyaXZhbCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYXJyaXZhbC5hemltdXRoKS50b0ZpeGVkKDIpICsgJyZkZWc7JztcbiAgICB9LFxuICAgICdkb3dubG9hZEZvcm1hdCc6IGZ1bmN0aW9uIChhcnJpdmFsKSB7XG4gICAgICByZXR1cm4gYXJyaXZhbC5hemltdXRoO1xuICAgIH1cbiAgfSxcbiAge1xuICAgICdjbGFzc05hbWUnOiAncGhhc2UnLFxuICAgICd0aXRsZSc6ICdQaGFzZScsXG4gICAgJ2Zvcm1hdCc6IGZ1bmN0aW9uIChhcnJpdmFsKSB7XG4gICAgICByZXR1cm4gYXJyaXZhbC5waGFzZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICAnY2xhc3NOYW1lJzogJ3RpbWUnLFxuICAgICd0aXRsZSc6ICdBcnJpdmFsIFRpbWUnLFxuICAgICdmb3JtYXQnOiBmdW5jdGlvbiAoYXJyaXZhbCkge1xuICAgICAgdmFyIHBpY2sgPSBhcnJpdmFsLnBpY2ssXG4gICAgICAgICAgdGltZTtcblxuICAgICAgdGltZSA9IHBpY2sudGltZS52YWx1ZS5zcGxpdCgnVCcpWzFdLnNwbGl0KCdaJylbMF0uc3BsaXQoJzonKTtcbiAgICAgIHRpbWVbMl0gPSBwYXJzZUZsb2F0KHRpbWVbMl0pLnRvRml4ZWQoMik7XG4gICAgICBpZiAodGltZVsyXSA8IDEwKSB7XG4gICAgICAgIHRpbWVbMl0gPSAnMCcgKyB0aW1lWzJdO1xuICAgICAgfVxuICAgICAgdGltZSA9IHRpbWUuam9pbignOicpO1xuICAgICAgcmV0dXJuIHRpbWU7XG4gICAgfSxcbiAgICAnZG93bmxvYWRGb3JtYXQnOiBmdW5jdGlvbiAoYXJyaXZhbCkge1xuICAgICAgcmV0dXJuIGFycml2YWwucGljay50aW1lLnZhbHVlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgICdjbGFzc05hbWUnOiAnc3RhdHVzJyxcbiAgICAndGl0bGUnOiAnU3RhdHVzJyxcbiAgICAnZm9ybWF0JzogZnVuY3Rpb24gKGFycml2YWwpIHtcbiAgICAgIHJldHVybiBhcnJpdmFsLnBpY2suZXZhbHVhdGlvbk1vZGU7XG4gICAgfVxuICB9LFxuICB7XG4gICAgJ2NsYXNzTmFtZSc6ICdyZXNpZHVhbCcsXG4gICAgJ3RpdGxlJzogJ1Jlc2lkdWFsJyxcbiAgICAnZm9ybWF0JzogZnVuY3Rpb24gKGFycml2YWwpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGFycml2YWwudGltZVJlc2lkdWFsKS50b0ZpeGVkKDIpO1xuICAgIH0sXG4gICAgJ2Rvd25sb2FkRm9ybWF0JzogZnVuY3Rpb24gKGFycml2YWwpIHtcbiAgICAgIHJldHVybiBhcnJpdmFsLnRpbWVSZXNpZHVhbDtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICAnY2xhc3NOYW1lJzogJ3dlaWdodCcsXG4gICAgJ3RpdGxlJzogJ1dlaWdodCcsXG4gICAgJ2Zvcm1hdCc6IGZ1bmN0aW9uIChhcnJpdmFsKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChhcnJpdmFsLnRpbWVXZWlnaHQpLnRvRml4ZWQoMik7XG4gICAgfSxcbiAgICAnZG93bmxvYWRGb3JtYXQnOiBmdW5jdGlvbiAoYXJyaXZhbCkge1xuICAgICAgcmV0dXJuIGFycml2YWwudGltZVdlaWdodDtcbiAgICB9XG4gIH1cbl07XG5cbi8vIHNvcnQgb3B0aW9ucyBmb3IgcGhhc2UgZGF0YSB0YWJsZVxuX1BIQVNFX0RBVEFfU09SVFMgPSBbXG4gIHtcbiAgICAnaWQnOiAnY2hhbm5lbCcsXG4gICAgJ3RpdGxlJzogJ0NoYW5uZWwnLFxuICAgICdzb3J0QnknOiBmdW5jdGlvbiAoYXJyaXZhbCkge1xuICAgICAgdmFyIHN0YXRpb24gPSBhcnJpdmFsLnBpY2sud2F2ZWZvcm1JRDtcbiAgICAgIHJldHVybiBzdGF0aW9uLm5ldHdvcmtDb2RlICsgJyAnICsgc3RhdGlvbi5zdGF0aW9uQ29kZSArXG4gICAgICAgICAgJyAnICsgc3RhdGlvbi5jaGFubmVsQ29kZSArICcgJyArIHN0YXRpb24ubG9jYXRpb25Db2RlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICdkaXN0YW5jZScsXG4gICAgJ3RpdGxlJzogJ0Rpc3RhbmNlJyxcbiAgICAnc29ydEJ5JzogZnVuY3Rpb24gKGFycml2YWwpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGFycml2YWwuZGlzdGFuY2UpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICdhemltdXRoJyxcbiAgICAndGl0bGUnOiAnQXppbXV0aCcsXG4gICAgJ3NvcnRCeSc6IGZ1bmN0aW9uIChhcnJpdmFsKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChhcnJpdmFsLmF6aW11dGgpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICdwaGFzZScsXG4gICAgJ3RpdGxlJzogJ1BoYXNlJyxcbiAgICAnc29ydEJ5JzogZnVuY3Rpb24gKGFycml2YWwpIHtcbiAgICAgIHJldHVybiBhcnJpdmFsLnBoYXNlO1xuICAgIH1cbiAgfSxcbiAge1xuICAgICdpZCc6ICd0aW1lJyxcbiAgICAndGl0bGUnOiAnQXJyaXZhbCBUaW1lJyxcbiAgICAnc29ydEJ5JzogZnVuY3Rpb24gKGFycml2YWwpIHtcbiAgICAgIHJldHVybiBhcnJpdmFsLnBpY2sudGltZS52YWx1ZTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICAnaWQnOiAncmVzaWR1YWwnLFxuICAgICd0aXRsZSc6ICdSZXNpZHVhbCcsXG4gICAgJ3NvcnRCeSc6IGZ1bmN0aW9uIChhcnJpdmFsKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChhcnJpdmFsLnRpbWVSZXNpZHVhbCk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgJ2lkJzogJ3dlaWdodCcsXG4gICAgJ3RpdGxlJzogJ1dlaWdodCcsXG4gICAgJ3NvcnRCeSc6IGZ1bmN0aW9uIChhcnJpdmFsKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChhcnJpdmFsLnRpbWVXZWlnaHQpO1xuICAgIH1cbiAgfVxuXTtcblxuXG4vKipcbiAqIFZpZXcgZm9yIHJlbmRlcmluZyBwaGFzZSBkYXRhLlxuICpcbiAqIEBzZWUgUXVha2VtbFZpZXdcbiAqL1xudmFyIFBoYXNlc1ZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG5cbiAgICAgIF9waGFzZVRhYmxlO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IFF1YWtlbWxWaWV3KG9wdGlvbnMpO1xuXG5cbiAgLyoqXG4gICAqIEZyZWVzIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyB2aWV3LlxuICAgKlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9waGFzZVRhYmxlICYmIF9waGFzZVRhYmxlLmRlc3Ryb3kpIHtcbiAgICAgIF9waGFzZVRhYmxlLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgX3BoYXNlVGFibGUgPSBudWxsO1xuXG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogTG9vcHMgb3ZlciBhbGwgdGhlIGdpdmVuIG9yaWdpbnMgYW5kIGxvb2tzIGZvciB0aGUgcHJlZmVycmVkIG9yaWdpbi5cbiAgICpcbiAgICogQHBhcmFtIG9yaWdpbnMge0FycmF5fVxuICAgKiAgICAgQW4gYXJyYXkgb2Ygb3JpZ2luIG9iamVjdHMuXG4gICAqL1xuICBfdGhpcy5nZXRQcmVmZXJyZWRPcmlnaW4gPSBmdW5jdGlvbiAob3JpZ2lucykge1xuICAgIHZhciBwcmVmZXJyZWQ7XG5cbiAgICBvcmlnaW5zID0gb3JpZ2lucyB8fCBbXTtcbiAgICBwcmVmZXJyZWQgPSBudWxsO1xuXG4gICAgb3JpZ2lucy5zb21lKGZ1bmN0aW9uIChvcmlnaW4pIHtcbiAgICAgIGlmIChvcmlnaW4uaXNQcmVmZXJyZWQpIHtcbiAgICAgICAgcHJlZmVycmVkID0gb3JpZ2luO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcmVmZXJyZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbWFya3VwIGZvciBhbiBlcnJvciBtZXNzYWdlIHdoZW4gbm8gcGhhc2VzIGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gZWwge0RPTUVsZW1lbnR9XG4gICAqICAgICBUaGUgRE9NIGVsZW1lbnQgaW50byB3aGljaCB0byByZW5kZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIF90aGlzLnJlbmRlck5vUHJlZmVycmVkID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gJzxwIGNsYXNzPVwiZXJyb3IgYWxlcnRcIj5ObyBQaGFzZSBEYXRhIEV4aXN0czwvcD4nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgdGFibGUgZm9yIHRoZSBnaXZlbiBvcmlnaW5cbiAgICpcbiAgICogQHBhcmFtIG9yaWdpbiB7T2JqZWN0fVxuICAgKiAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3JpZ2luIGluZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0gZWwge0RPTUVsZW1lbnR9XG4gICAqICAgICBUaGUgRE9NIGVsZW1lbnQgaW50byB3aGljaCB0byByZW5kZXIuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJQcmVmZXJyZWQgPSBmdW5jdGlvbiAob3JpZ2luLCBlbCkge1xuICAgIHZhciBhcnJpdmFscztcblxuICAgIG9yaWdpbiA9IG9yaWdpbiB8fCB7fTtcblxuICAgIC8vIGFkZCBpZHMgdG8gYXJyaXZhbHNcbiAgICBhcnJpdmFscyA9IG9yaWdpbi5hcnJpdmFscztcbiAgICBhcnJpdmFscy5tYXAoZnVuY3Rpb24gKGFycml2YWwsIGluZGV4KSB7XG4gICAgICBhcnJpdmFsLmlkID0gaW5kZXg7XG4gICAgICByZXR1cm4gYXJyaXZhbDtcbiAgICB9KTtcblxuICAgIF9waGFzZVRhYmxlID0gRGF0YVRhYmxlKHtcbiAgICAgIGVsOiBlbCxcbiAgICAgIGNsYXNzTmFtZTogJ2h5cG9jZW50ZXItcGhhc2UnLFxuICAgICAgY29sbGVjdGlvbjogQ29sbGVjdGlvbihhcnJpdmFscyksXG4gICAgICBlbXB0eU1hcmt1cDogJzxwIGNsYXNzPVwiZXJyb3IgYWxlcnRcIj5ObyBQaGFzZSBEYXRhIEV4aXN0czwvcD4nLFxuICAgICAgY29sdW1uczogX1BIQVNFX0RBVEFfQ09MVU1OUyxcbiAgICAgIHNvcnRzOiBfUEhBU0VfREFUQV9TT1JUUyxcbiAgICAgIGRlZmF1bHRTb3J0OiAnZGlzdGFuY2UnXG4gICAgfSk7XG5cbiAgICBlbC5xdWVyeVNlbGVjdG9yKCcuZGF0YXRhYmxlLWRhdGEnKS5jbGFzc0xpc3QuYWRkKCdob3Jpem9udGFsLXNjcm9sbGluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBxdWFrZW1sLlxuICAgKlxuICAgKi9cbiAgX3RoaXMucmVuZGVyUXVha2VtbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YVRhYmxlRWwsXG4gICAgICAgIG9yaWdpbnMsXG4gICAgICAgIHByZWZlcnJlZDtcblxuICAgIF90aGlzLmVsLmlubmVySFRNTCA9ICc8c2VjdGlvbiBjbGFzcz1cImh5cG9jZW50ZXItcGhhc2VcIj4nICtcbiAgICAgICAgJzxoZWFkZXI+PGgzPlBoYXNlIEFycml2YWwgVGltZXM8L2gzPjwvaGVhZGVyPicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGF0YWJsZVwiPjwvZGl2PicgK1xuICAgICAgJzwvc2VjdGlvbj4nO1xuXG4gICAgZGF0YVRhYmxlRWwgPSBfdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuZGF0YXRhYmxlJyk7XG5cbiAgICBpZiAoX3RoaXMucXVha2VtbCkge1xuICAgICAgb3JpZ2lucyA9IF90aGlzLnF1YWtlbWwuZ2V0T3JpZ2lucygpO1xuXG4gICAgICBwcmVmZXJyZWQgPSBfdGhpcy5nZXRQcmVmZXJyZWRPcmlnaW4ob3JpZ2lucyk7XG5cblxuICAgICAgaWYgKCFwcmVmZXJyZWQgfHwgIXByZWZlcnJlZC5hcnJpdmFscykge1xuICAgICAgICBfdGhpcy5yZW5kZXJOb1ByZWZlcnJlZChkYXRhVGFibGVFbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5yZW5kZXJQcmVmZXJyZWQocHJlZmVycmVkLCBkYXRhVGFibGVFbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQaGFzZXNWaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBDb250ZW50VmlldyA9IHJlcXVpcmUoJ2NvcmUvQ29udGVudFZpZXcnKSxcbiAgICBQcm9kdWN0ID0gcmVxdWlyZSgncGRsL1Byb2R1Y3QnKSxcbiAgICBRdWFrZW1sID0gcmVxdWlyZSgncXVha2VtbC9RdWFrZW1sJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG5cbn07XG5cblxuLyoqXG4gKiBBYnN0cmFjdCB2aWV3IGZvciBkaXNwbGF5aW5nIHF1YWtlbWwueG1sIHtDb250ZW50fSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgdmlldy4gU2VlIF9pbml0aWFsaXplIG1ldGhvZFxuICogICAgIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbnZhciBRdWFrZW1sVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IENvbnRlbnRWaWV3KG9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rvci4gSW5pdGlhbGl6ZXMgYSBuZXcge1F1YWtlbWxWaWV3fS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogICAgIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5tb2RlbCB7Q29udGVudH1cbiAgICogICAgIFRoZSBjb250ZW50IG1vZGVsIHRvIHJlbmRlci5cbiAgICogQHBhcmFtIG9wdGlvbnMucHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIFRoZSBwcm9kdWN0IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIHtDb250ZW50fS4gVHlwaWNhbGx5IGFuIG9yaWdpblxuICAgKiAgICAgb3IgcGhhc2UtZGF0YSBwcm9kdWN0LlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF90aGlzLnByb2R1Y3QgPSBvcHRpb25zLnByb2R1Y3QgfHwgUHJvZHVjdCgpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEZyZWVzIHJlc291cmNlcyBhbGxvY2F0ZWQgdG8gdGhpcyB2aWV3LlxuICAgKlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZXhlY3V0ZWQgd2hlbiBmZXRjaERhdGEgZmFpbHMuIERpc3BsYXlzIGFuIGVycm9yIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0dXMge1N0cmluZ31cbiAgICogICAgIEFuIGVycm9yIG1lc3NhZ2UuIEN1cnJlbnRseSBpZ25vcmVkLlxuICAgKiBAcGFyYW0geGhyIHtYTUxIdHRwUmVxdWVzdH1cbiAgICogICAgIFRoZSBYSFIgb2JqZWN0IHVzZWQgdG8gZmV0Y2ggdGhlIGRhdGEuXG4gICAqL1xuICBfdGhpcy5vbkVycm9yID0gZnVuY3Rpb24gKC8qc3RhdHVzLCB4aHIqLykge1xuICAgIF90aGlzLmVsLmlubmVySFRNTCA9ICc8cCBjbGFzcz1cImFsZXJ0IGVycm9yXCI+JyArXG4gICAgICAgICdGYWlsZWQgdG8gbG9hZCBxdWFrZW1sIGRhdGEuPC9wPic7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gZmV0Y2hEYXRhIHN1Y2NlZWRzLiBQYXJzZXMgYW5kIHJlbmRlcnMgdGhlXG4gICAqIHF1YWtlbWwgZGF0YSBhbmQgdHJpZ2dlcnMgYW4gZXZlbnQgb2ZmZXJpbmcgdGhlIHBhcnNlZCBxdWFrZW1sIGJhY2tcbiAgICogc28gb3RoZXJzIGNhbiBzYXZlIHRoZSBlZmZvcnQuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHtTdHJpbmd9XG4gICAqICAgICBUaGUgcmF3IFF1YWtlTUwgWE1MIHN0cmluZyBjb250ZW50LlxuICAgKiBAcGFyYW0geGhyIHtYTUxIdHRwUmVxdWVzdH1cbiAgICogICAgIFRoZSBYSFIgb2JqZWN0IHVzZWQgdG8gZmV0Y2ggdGhlIGRhdGEuXG4gICAqXG4gICAqL1xuICBfdGhpcy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YS8qLCB4aHIqLykge1xuICAgIHRyeSB7XG4gICAgICBfdGhpcy5xdWFrZW1sID0gUXVha2VtbCh7eG1sOiBkYXRhfSk7XG5cbiAgICAgIF90aGlzLnJlbmRlcigpO1xuXG4gICAgICAvLyBMZXQgb3RoZXJzIGtub3cgYWJvdXQgb3VyIHN1Y2Nlc3Mgc28gdGhleSBkb24ndCBoYXZlIHRvIGRvd25sb2FkXG4gICAgICAvLyBhbmQgcGFyc2UgaXQgdGhlbXNlbHZlcy4uLlxuICAgICAgX3RoaXMudHJpZ2dlcigncXVha2VtbCcsIF90aGlzLnF1YWtlbWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElnbm9yZSAuLi5cbiAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmV0Y2hlcyBxdWFrZW1sIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGVsLCBvciByZW5kZXJzIGl0IGlmIHRoZSBxdWFrZW1sXG4gICAqIGlzIGFscmVhZHkgYXZhaWxhYmxlLiBEZWxlZ2F0ZXMgdG8gc3ViIG1ldGhvZHMuXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFfdGhpcy5xdWFrZW1sKSB7XG4gICAgICAvLyBEb24ndCBoYXZlIHF1YWtlbWwgeWV0LCB0cnkgdG8gZ2V0IGl0XG4gICAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSAnPHA+TG9hZGluZyBjb250ZW50JmhlbGxpcDs8L3A+JztcbiAgICAgIF90aGlzLmZldGNoRGF0YSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5yZW5kZXJRdWFrZW1sKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBxdWFrZW1sLiBUaGlzIHNob3VsZCBiZSBvdmVycmlkZW4gYnkgaW1wbGVtZW50aW5nIGNsYXNzZXMuXG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXJRdWFrZW1sID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmVsLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KF90aGlzLnF1YWtlbWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBxdWFrZW1sIHRvIHJlbmRlci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZSBzb21lIGV4dGVybmFsIHBhcnR5XG4gICAqIGFscmVhZHkgZG93bmxvYWRlZC9wYXJzZWQgdGhlIHF1YWtlbWwsIHRodXMgc2F2aW5nIHRpbWUgaW50ZXJuYWxseS5cbiAgICpcbiAgICogQHBhcmFtIHF1YWtlbWwge1F1YWtlbWx9XG4gICAqICAgICBUaGUgcGFyc2VkIFF1YWtlbWwgdG8gcmVuZGVyLlxuICAgKi9cbiAgX3RoaXMuc2V0UXVha2VtbCA9IGZ1bmN0aW9uIChxdWFrZW1sKSB7XG4gICAgX3RoaXMucXVha2VtbCA9IHF1YWtlbWw7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBRdWFrZW1sVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgUHJvZHVjdCA9IHJlcXVpcmUoJ3BkbC9Qcm9kdWN0JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIGNvbmZpZzoge31cbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgcHJvZHVjdCBtYXAgdG8gYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIG1hcCB7T2JqZWN0fVxuICogICAgICAgIGtleXMgYXJlIHByb2R1Y3QgdHlwZXMuXG4gKiAgICAgICAgdmFsdWVzIGFyZSBhcnJheXMgb2YgcHJvZHVjdHMuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgYXJyYXkgY29udGFpbmluZyBhbGwgcHJvZHVjdHMuXG4gKi9cbnZhciBfX3Byb2R1Y3RNYXBUb0xpc3QgPSBmdW5jdGlvbiAobWFwKSB7XG4gIHZhciBsaXN0ID0gW10sXG4gICAgICB0eXBlO1xuICBmb3IgKHR5cGUgaW4gbWFwKSB7XG4gICAgbGlzdC5wdXNoLmFwcGx5KGxpc3QsIG1hcFt0eXBlXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5cbi8qKlxuICogRmlsdGVyIHN1cGVyc2VkZWQgcHJvZHVjdHMgKG9sZCB2ZXJzaW9ucykgZnJvbSBhcnJheS5cbiAqXG4gKiBAcGFyYW0gbGlzdCB7QXJyYXl9XG4gKiAgICAgICAgYXJyYXkgb2YgcHJvZHVjdHMuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgYXJyYXkgd2l0aG91dCBzdXBlcnNlZGVkIHZlcnNpb25zLlxuICovXG52YXIgX19nZXRXaXRob3V0U3VwZXJzZWRlZCA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gIHZhciB1bmlxdWUgPSB7fSxcbiAgICAgIHByb2R1Y3RzO1xuICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKHByb2R1Y3QpIHtcbiAgICB2YXIga2V5LFxuICAgICAgICBtb2RpZmllZDtcblxuICAgIGtleSA9IHByb2R1Y3QuZ2V0KCdzb3VyY2UnKSArICdfJyArXG4gICAgICAgIHByb2R1Y3QuZ2V0KCd0eXBlJykgKyAnXycgK1xuICAgICAgICBwcm9kdWN0LmdldCgnY29kZScpO1xuICAgIG1vZGlmaWVkID0gLTE7XG4gICAgaWYgKHVuaXF1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBtb2RpZmllZCA9IHVuaXF1ZVtrZXldLmdldCgndXBkYXRlVGltZScpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZWQgPCBwcm9kdWN0LmdldCgndXBkYXRlVGltZScpKSB7XG4gICAgICB1bmlxdWVba2V5XSA9IHByb2R1Y3Q7XG4gICAgfVxuICB9KTtcbiAgcHJvZHVjdHMgPSBbXTtcbiAgZm9yICh2YXIgaWQgaW4gdW5pcXVlKSB7XG4gICAgcHJvZHVjdHMucHVzaCh1bmlxdWVbaWRdKTtcbiAgfVxuICByZXR1cm4gcHJvZHVjdHM7XG59O1xuXG4vKipcbiAqIEZpbHRlciBkZWxldGVkIHByb2R1Y3RzIGZyb20gYXJyYXkuXG4gKlxuICogQHBhcmFtIGxpc3Qge0FycmF5fVxuICogICAgICAgIGFycmF5IG9mIHByb2R1Y3RzLlxuICogQHJldHVybiB7QXJyYXl9XG4gKiAgICAgICAgIGFycmF5IHdpdGhvdXQgZGVsZXRlZCB2ZXJzaW9ucy5cbiAqL1xudmFyIF9fZ2V0V2l0aG91dERlbGV0ZWQgPSBmdW5jdGlvbiAobGlzdCkge1xuICB2YXIgd2l0aG91dERlbGV0ZWQgPSBbXTtcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChwcm9kdWN0KSB7XG4gICAgaWYgKCFwcm9kdWN0LmlzRGVsZXRlZCgpKSB7XG4gICAgICB3aXRob3V0RGVsZXRlZC5wdXNoKHByb2R1Y3QpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB3aXRob3V0RGVsZXRlZDtcbn07XG5cbi8qKlxuICogU29ydCBwcm9kdWN0cyBiYXNlZCBvbiBwcmVmZXJyZWQgd2VpZ2h0LlxuICpcbiAqIFdoZW4gcHJlZmVycmVkIHdlaWdodHMgYXJlIGVxdWFsLCBtb3N0IHJlY2VudCB1cGRhdGVUaW1lIGlzIHByZWZlcnJlZC5cbiAqXG4gKiBAcGFyYW0gbGlzdCB7QXJyYXl9XG4gKiAgICAgICAgYXJyYXkgb2YgcHJvZHVjdHMuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgc29ydGVkIGFycmF5LCBtb3N0IHByZWZlcnJlZCBmaXJzdC5cbiAqL1xudmFyIF9fZ2V0U29ydGVkTW9zdFByZWZlcnJlZEZpcnN0ID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIHNvcnRlZCA9IGxpc3Quc3BsaWNlKDApO1xuICBzb3J0ZWQuc29ydChmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgdmFyIGRpZmY7XG4gICAgZGlmZiA9IHAyLmdldCgncHJlZmVycmVkV2VpZ2h0JykgLSBwMS5nZXQoJ3ByZWZlcnJlZFdlaWdodCcpO1xuICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gICAgZGlmZiA9IHAyLmdldCgndXBkYXRlVGltZScpIC0gcDEuZ2V0KCd1cGRhdGVUaW1lJyk7XG4gICAgaWYgKGRpZmYgIT09IDApIHtcbiAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgICByZXR1cm4gKHAxLmlkID4gcDIuaWQgPyAxIDogLTEpO1xuICB9KTtcbiAgcmV0dXJuIHNvcnRlZDtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBwcm9kdWN0IGhhcyBvcmlnaW4gcHJvcGVydGllcy5cbiAqXG4gKiBPcmlnaW4gcHJvcGVydGllcyBpbmNsdWRlIGV2ZW50IGlkIChldmVudHNvdXJjZSwgZXZlbnRzb3VyY2Vjb2RlKSBhbmRcbiAqIGV2ZW50IGxvY2F0aW9uIChsYXRpdHVkZSwgbG9uZ2l0dWRlLCBldmVudHRpbWUpLlxuICpcbiAqIEBwYXJhbSBwcm9kdWN0IHtPYmplY3R9XG4gKiAgICAgICAgcHJvZHVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4gdHJ1ZSBpZiBwcm9kdWN0IGhhcyBhbGwgb3JpZ2luIHByb3BlcnRpZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xudmFyIF9fcHJvZHVjdEhhc09yaWdpblByb3BlcnRpZXMgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICB2YXIgcHJvcHMgPSBwcm9kdWN0LmdldCgncHJvcGVydGllcycpO1xuICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2V2ZW50c291cmNlJykgJiZcbiAgICAgIHByb3BzLmhhc093blByb3BlcnR5KCdldmVudHNvdXJjZWNvZGUnKSAmJlxuICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkoJ2xhdGl0dWRlJykgJiZcbiAgICAgIHByb3BzLmhhc093blByb3BlcnR5KCdsb25naXR1ZGUnKSAmJlxuICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkoJ2V2ZW50dGltZScpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1vc3QgcHJlZmVycmVkIHByb2R1Y3Qgd2l0aCBvcmlnaW4gcHJvcGVydGllcy5cbiAqXG4gKiBPcmlnaW4gcHJvcGVydGllcyBpbmNsdWRlIGV2ZW50IGlkIChldmVudHNvdXJjZSwgZXZlbnRzb3VyY2Vjb2RlKSBhbmRcbiAqIGV2ZW50IGxvY2F0aW9uIChsYXRpdHVkZSwgbG9uZ2l0dWRlLCBldmVudHRpbWUpLlxuICpcbiAqIFByb2R1Y3RzIGFyZSBzb3J0ZWQgdXNpbmcgX19nZXRTb3J0ZWRNb3N0UHJlZmVycmVkRmlyc3QgYmVmb3JlIGNoZWNraW5nXG4gKiBmb3IgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gbGlzdCB7QXJyYXl9XG4gKiAgICAgICAgYXJyYXkgb2YgcHJvZHVjdHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIG1vc3QgcHJlZmVycmVkIHByb2R1Y3Qgd2l0aCBvcmlnaW4gcHJvcGVydGllcy5cbiAqL1xudmFyIF9fZ2V0UHJvZHVjdFdpdGhPcmlnaW5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIGksXG4gICAgICBwcm9kdWN0O1xuICBsaXN0ID0gX19nZXRTb3J0ZWRNb3N0UHJlZmVycmVkRmlyc3QobGlzdCk7XG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvZHVjdCA9IGxpc3RbaV07XG4gICAgaWYgKF9fcHJvZHVjdEhhc09yaWdpblByb3BlcnRpZXMocHJvZHVjdCkpIHtcbiAgICAgIHJldHVybiBwcm9kdWN0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIG1vc3QgcHJlZmVycmVkIHByb2R1Y3Qgd2l0aCBldmVudCBpZCBwcm9wZXJ0aWVzLlxuICpcbiAqIEV2ZW50IElEIHByb3BlcnRpZXMgYXJlIGV2ZW50c291cmNlIGFuZCBldmVudHNvdXJjZWNvZGUuXG4gKlxuICogUHJvZHVjdHMgYXJlIHNvcnRlZCB1c2luZyBfX2dldFNvcnRlZE1vc3RQcmVmZXJyZWRGaXJzdCBiZWZvcmUgY2hlY2tpbmdcbiAqIGZvciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSBsaXN0IHtBcnJheX1cbiAqICAgICAgICBhcnJheSBvZiBwcm9kdWN0cy5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgbW9zdCBwcmVmZXJyZWQgcHJvZHVjdCB3aXRoIGV2ZW50IGlkIHByb3BlcnRpZXMuXG4gKi9cbnZhciBfX2dldFByb2R1Y3RXaXRoRXZlbnRJZFByb3BlcnRpZXMgPSBmdW5jdGlvbiAobGlzdCkge1xuICB2YXIgaSxcbiAgICAgIHByb3BzO1xuICBsaXN0ID0gX19nZXRTb3J0ZWRNb3N0UHJlZmVycmVkRmlyc3QobGlzdCk7XG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvcHMgPSBsaXN0W2ldLmdldCgncHJvcGVydGllcycpO1xuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnRzb3VyY2UnKSAmJlxuICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnRzb3VyY2Vjb2RlJykpIHtcbiAgICAgIHJldHVybiBsaXN0W2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBBbiBldmVudCBpcyBhIGNvbGxlY3Rpb24gb2YgcHJvZHVjdHMuXG4gKi9cbnZhciBDYXRhbG9nRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnREZXRhaWxzLCBvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfY29uZmlnLFxuICAgICAgX3Byb2R1Y3RzLFxuICAgICAgX3Byb3BlcnRpZXMsXG4gICAgICBfc3VtbWFyeTtcblxuICBfdGhpcyA9IE9iamVjdC5jcmVhdGUoe30pO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKGV2ZW50RGV0YWlscywgb3B0aW9ucykge1xuICAgIHZhciB0eXBlO1xuXG4gICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuXG4gICAgX2NvbmZpZyA9IG9wdGlvbnMuY29uZmlnO1xuXG4gICAgX3Byb2R1Y3RzID0ge307XG4gICAgX3Byb3BlcnRpZXMgPSB7fTtcblxuICAgIGlmIChldmVudERldGFpbHMgJiYgZXZlbnREZXRhaWxzLnByb3BlcnRpZXMpIHtcbiAgICAgIF9wcm9kdWN0cyA9IFV0aWwuZXh0ZW5kKHt9LCBldmVudERldGFpbHMucHJvcGVydGllcy5wcm9kdWN0cyk7XG4gICAgICBfcHJvcGVydGllcyA9IFV0aWwuZXh0ZW5kKHt9LCBldmVudERldGFpbHMucHJvcGVydGllcywge3Byb2R1Y3RzOm51bGx9KTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFsbCBwcm9kdWN0cyB0byBQcm9kdWN0IG9iamVjdHNcbiAgICBmb3IgKHR5cGUgaW4gX3Byb2R1Y3RzKSB7XG4gICAgICBfcHJvZHVjdHNbdHlwZV0gPSBfcHJvZHVjdHNbdHlwZV0ubWFwKFByb2R1Y3QpO1xuICAgIH1cbiAgICBfc3VtbWFyeSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHByb2R1Y3QgdG8gdGhpcyBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHByb2R1Y3Qge09iamVjdH1cbiAgICogICAgICAgIHByb2R1Y3QgdG8gYWRkLlxuICAgKi9cbiAgX3RoaXMuYWRkUHJvZHVjdCA9IGZ1bmN0aW9uIChwcm9kdWN0KSB7XG4gICAgdmFyIHR5cGU7XG5cbiAgICB0eXBlID0gcHJvZHVjdC5nZXQoJ3R5cGUnKTtcbiAgICBpZiAoIV9wcm9kdWN0cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgX3Byb2R1Y3RzW3R5cGVdID0gW107XG4gICAgfVxuICAgIF9wcm9kdWN0c1t0eXBlXS5wdXNoKHByb2R1Y3QpO1xuICAgIF9zdW1tYXJ5ID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgcHJvZHVjdCBmcm9tIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9kdWN0IHtPYmplY3R9XG4gICAqICAgICAgICBwcm9kdWN0IHRvIHJlbW92ZS5cbiAgICovXG4gIF90aGlzLnJlbW92ZVByb2R1Y3QgPSBmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgIHZhciB0eXBlLFxuICAgICAgICB0eXBlUHJvZHVjdHMsXG4gICAgICAgIGluZGV4O1xuICAgIHR5cGUgPSBwcm9kdWN0LmdldCgndHlwZScpO1xuICAgIGlmIChfcHJvZHVjdHMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgIHR5cGVQcm9kdWN0cyA9IF9wcm9kdWN0c1t0eXBlXTtcbiAgICAgIGluZGV4ID0gdHlwZVByb2R1Y3RzLmluZGV4T2YocHJvZHVjdCk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB0eXBlUHJvZHVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaWYgKHR5cGVQcm9kdWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgX3Byb2R1Y3RzW3R5cGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9wcm9kdWN0c1t0eXBlXSA9IHR5cGVQcm9kdWN0cztcbiAgICAgICAgfVxuICAgICAgICBfc3VtbWFyeSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGcmVlIHJlZmVyZW5jZXMuXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBrZXk7XG5cbiAgICBpZiAoX3RoaXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBfcHJvZHVjdHMpIHtcbiAgICAgIF9wcm9kdWN0c1trZXldLm1hcChmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF9wcm9kdWN0cyA9IG51bGw7XG4gICAgX3Byb3BlcnRpZXMgPSBudWxsO1xuICAgIF9zdW1tYXJ5ID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBldmVudCBwcm9kdWN0cy5cbiAgICovXG4gIF90aGlzLmdldFByb2R1Y3RzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZSkge1xuICAgICAgcmV0dXJuIF9wcm9kdWN0c1t0eXBlXSB8fCBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9wcm9kdWN0cztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJlZmVycmVkIHByb2R1Y3Qgb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSB7U3RyaW5nfVxuICAgKiAgICAgdHlwZSBvZiBwcm9kdWN0LlxuICAgKiBAcmV0dXJuIHtQcm9kdWN0fVxuICAgKiAgICAgcHJlZmVycmVkIHByb2R1Y3Qgb2YgdHlwZSwgb3IgbnVsbCBpZiBubyBwcm9kdWN0IG9mIHRoYXQgdHlwZSBleGlzdHMuXG4gICAqL1xuICBfdGhpcy5nZXRQcmVmZXJyZWRQcm9kdWN0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgcHJvZHVjdHM7XG4gICAgcHJvZHVjdHMgPSBfdGhpcy5nZXRQcm9kdWN0cyh0eXBlKTtcbiAgICBwcm9kdWN0cyA9IF9fZ2V0U29ydGVkTW9zdFByZWZlcnJlZEZpcnN0KFxuICAgICAgICBfX2dldFdpdGhvdXRTdXBlcnNlZGVkKHByb2R1Y3RzKSk7XG4gICAgaWYgKHByb2R1Y3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBwcm9kdWN0c1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdmVyc2lvbnMgb2YgYSBwcm9kdWN0ICh0eXBlLCBzb3VjZSwgY29kZSkuXG4gICAqL1xuICBfdGhpcy5nZXRBbGxQcm9kdWN0VmVyc2lvbnMgPSBmdW5jdGlvbiAodHlwZSwgc291cmNlLCBjb2RlKSB7XG4gICAgdmFyIHByb2R1Y3RzO1xuXG4gICAgaWYgKF9wcm9kdWN0cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgcHJvZHVjdHMgPSBfcHJvZHVjdHNbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLmdldCgnc291cmNlJykgPT09IHNvdXJjZSAmJlxuICAgICAgICAgICAgcC5nZXQoJ2NvZGUnKSA9PT0gY29kZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9kdWN0cyA9IFtdO1xuICAgIH1cbiAgICAvLyBzb3J0IG1vc3QgcmVjZW50IGZpcnN0LlxuICAgIHByb2R1Y3RzLnNvcnQoZnVuY3Rpb24gKHAxLCBwMikge1xuICAgICAgcmV0dXJuIHAyLmdldCgndXBkYXRlVGltZScpIC0gcDEuZ2V0KCd1cGRhdGVUaW1lJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2R1Y3RzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgcHJvZHVjdCBiYXNlZCBvbiB0aGUgcHJvZHVjdElkIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9XG4gICAqICAgICBUaGUgdHlwZSBvZiB0aGUgcHJvZHVjdCB0byBnZXRcbiAgICogQHBhcmFtIHNvdXJjZSB7U3RyaW5nfVxuICAgKiAgICAgVGhlIHNvdXJjZSBvZiB0aGUgcHJvZHVjdCB0byBnZXRcbiAgICogQHBhcmFtIGNvZGUge1N0cmluZ31cbiAgICogICAgIFRoZSBjb2RlIG9mIHRoZSBwcm9kdWN0IHRvIGdldFxuICAgKiBAcGFyYW0gdXBkYXRlVGltZSB7TnVtYmVyfSBPcHRpb25hbC5cbiAgICogICAgIFRoZSB1cGRhdGVUaW1lIG9mIHRoZSBwcm9kdWN0IHRvIGdldFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9kdWN0fVxuICAgKiAgICAgVGhlIHByb2R1Y3QgbWF0Y2hpbmcgdGhlIGdpdmVuIHR5cGUsIHNvdXJjZSwgY29kZSwgYW5kIHVwZGF0ZVRpbWUuIElmXG4gICAqICAgICBubyB1cGRhdGVUaW1lIGlzIHNwZWNpZmllZCwgdGhlIG1vc3QgcmVjZW50bHkgdXBkYXRlZCBwcm9kdWN0IG1hdGNoaW5nXG4gICAqICAgICB0eXBlLCBzb3VyY2UgYW5kIGNvZGUgaXMgcmV0dXJuZWQgaW5zdGVhZC5cbiAgICovXG4gIF90aGlzLmdldFByb2R1Y3RCeUlkID0gZnVuY3Rpb24gKHR5cGUsIHNvdXJjZSwgY29kZSwgdXBkYXRlVGltZSkge1xuICAgIHZhciBpLFxuICAgICAgICBsZW4sXG4gICAgICAgIHByb2R1Y3QsXG4gICAgICAgIHByb2R1Y3RzO1xuXG4gICAgcHJvZHVjdCA9IG51bGw7XG4gICAgcHJvZHVjdHMgPSBfdGhpcy5nZXRBbGxQcm9kdWN0VmVyc2lvbnModHlwZSwgc291cmNlLCBjb2RlKTtcbiAgICBsZW4gPSBwcm9kdWN0cy5sZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIHVwZGF0ZVRpbWUgIT09ICd1bmRlZmluZWQnICYmIHVwZGF0ZVRpbWUgIT09IG51bGwpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAocHJvZHVjdHNbaV0uZ2V0KCd1cGRhdGVUaW1lJykgPT09IHVwZGF0ZVRpbWUpIHtcbiAgICAgICAgICBwcm9kdWN0ID0gcHJvZHVjdHNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlbikge1xuICAgICAgLy8gTm8gdXBkYXRlVGltZSBzcGVjaWZpZWQsIG1vc3QgcmVjZW50bHkgdXBkYXRlZCBwcm9kdWN0XG4gICAgICBwcm9kdWN0ID0gcHJvZHVjdHNbMF07IC8vIFByb2R1Y3RzIGFyZSBzb3J0ZWQsIHNvIGZpcnN0IGlzIG1vc3QgcmVjZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2R1Y3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJlZmVycmVkIGV2ZW50IGlkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICAgICAgdGhlIHByZWZlcnJlZCBldmVudCBpZCwgb3IgbnVsbCBpZiBub25lLlxuICAgKi9cbiAgX3RoaXMuZ2V0RXZlbnRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZHVjdCA9IF90aGlzLmdldEV2ZW50SWRQcm9kdWN0KCksXG4gICAgICAgIHByb3BzO1xuICAgIGlmIChwcm9kdWN0ICE9PSBudWxsKSB7XG4gICAgICBwcm9wcyA9IHByb2R1Y3QuZ2V0KCdwcm9wZXJ0aWVzJyk7XG4gICAgICByZXR1cm4gcHJvcHMuZXZlbnRzb3VyY2UgKyBwcm9wcy5ldmVudHNvdXJjZWNvZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZWZlcnJlZCBldmVudCBzb3VyY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgICAgICB0aGUgcHJlZmVycmVkIGV2ZW50IHNvdXJjZSwgb3IgbnVsbCBpZiBub25lLlxuICAgKi9cbiAgX3RoaXMuZ2V0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9kdWN0ID0gX3RoaXMuZ2V0RXZlbnRJZFByb2R1Y3QoKTtcbiAgICBpZiAocHJvZHVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2V2ZW50c291cmNlJyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZWZlcnJlZCBldmVudCBjb2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICAgICAgdGhlIHByZWZlcnJlZCBldmVudCBjb2RlLCBvciBudWxsIGlmIG5vbmUuXG4gICAqL1xuICBfdGhpcy5nZXRTb3VyY2VDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9kdWN0ID0gX3RoaXMuZ2V0RXZlbnRJZFByb2R1Y3QoKTtcbiAgICBpZiAocHJvZHVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2V2ZW50c291cmNlY29kZScpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwcmVmZXJyZWQgZXZlbnQgdGltZS5cbiAgICpcbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICogICAgICAgICB0aGUgcHJlZmVycmVkIG9yaWdpbiB0aW1lIGZvciB0aGlzIGV2ZW50LCBvciBudWxsIGlmIG5vbmUuXG4gICAqL1xuICBfdGhpcy5nZXRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9kdWN0ID0gX3RoaXMuZ2V0UHJvZHVjdFdpdGhPcmlnaW5Qcm9wZXJ0aWVzKCk7XG4gICAgaWYgKHByb2R1Y3QgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShwcm9kdWN0LmdldFByb3BlcnR5KCdldmVudHRpbWUnKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZWZlcnJlZCBldmVudCBsYXRpdHVkZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgICAgICAgIHRoZSBwcmVmZXJyZWQgbGF0aXR1ZGUgZm9yIHRoaXMgZXZlbnQsIG9yIG51bGwgaWYgbm9uZS5cbiAgICovXG4gIF90aGlzLmdldExhdGl0dWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9kdWN0ID0gX3RoaXMuZ2V0UHJvZHVjdFdpdGhPcmlnaW5Qcm9wZXJ0aWVzKCk7XG4gICAgaWYgKHByb2R1Y3QgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOdW1iZXIocHJvZHVjdC5nZXRQcm9wZXJ0eSgnbGF0aXR1ZGUnKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZWZlcnJlZCBldmVudCBsb25naXR1ZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogICAgICAgICB0aGUgcHJlZmVycmVkIGxvbmdpdHVkZSBmb3IgdGhpcyBldmVudCwgb3IgbnVsbCBpZiBub25lLlxuICAgKi9cbiAgX3RoaXMuZ2V0TG9uZ2l0dWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9kdWN0ID0gX3RoaXMuZ2V0UHJvZHVjdFdpdGhPcmlnaW5Qcm9wZXJ0aWVzKCk7XG4gICAgaWYgKHByb2R1Y3QgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBOdW1iZXIocHJvZHVjdC5nZXRQcm9wZXJ0eSgnbG9uZ2l0dWRlJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwcmVmZXJyZWQgZXZlbnQgZGVwdGguXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogICAgICAgICB0aGUgcHJlZmVycmVkIGRlcHRoIGZvciB0aGlzIGV2ZW50LCBvciBudWxsIGlmIG5vbmUuXG4gICAqL1xuICBfdGhpcy5nZXREZXB0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZHVjdCA9IF90aGlzLmdldFByb2R1Y3RXaXRoT3JpZ2luUHJvcGVydGllcygpLFxuICAgICAgICBwcm9wcztcbiAgICBpZiAocHJvZHVjdCAhPT0gbnVsbCkge1xuICAgICAgcHJvcHMgPSBwcm9kdWN0LmdldCgncHJvcGVydGllcycpO1xuICAgICAgcmV0dXJuIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVwdGgnKSA/IE51bWJlcihwcm9wcy5kZXB0aCkgOiBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJlZmVycmVkIGV2ZW50IG1hZ25pdHVkZS5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgICAgICAgIHRoZSBwcmVmZXJyZWQgbWFnbml0dWRlIGZvciB0aGlzIGV2ZW50LCBvciBudWxsIGlmIG5vbmUuXG4gICAqL1xuICBfdGhpcy5nZXRNYWduaXR1ZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb2R1Y3QgPSBfdGhpcy5nZXRQcmVmZXJyZWRNYWduaXR1ZGVQcm9kdWN0KCksXG4gICAgICAgIHByb3BzO1xuICAgIGlmIChwcm9kdWN0ID09PSBudWxsKSB7XG4gICAgICBwcm9kdWN0ID0gX3RoaXMuZ2V0UHJvZHVjdFdpdGhPcmlnaW5Qcm9wZXJ0aWVzKCk7XG4gICAgfVxuICAgIGlmIChwcm9kdWN0ICE9PSBudWxsKSB7XG4gICAgICBwcm9wcyA9IHByb2R1Y3QuZ2V0KCdwcm9wZXJ0aWVzJyk7XG4gICAgICByZXR1cm4gKHByb3BzLmhhc093blByb3BlcnR5KCdtYWduaXR1ZGUnKSA/XG4gICAgICAgICAgTnVtYmVyKHByb3BzLm1hZ25pdHVkZSkgOiBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgZXZlbnQgaXMgZGVsZXRlZC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogICAgICAgICB0cnVlIGlmIGRlbGV0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIF90aGlzLmlzRGVsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvZHVjdCA9IF90aGlzLmdldFByZWZlcnJlZE9yaWdpblByb2R1Y3QoKTtcbiAgICBpZiAocHJvZHVjdCAhPT0gbnVsbCAmJlxuICAgICAgICAhcHJvZHVjdC5pc0RlbGV0ZWQoKSAmJlxuICAgICAgICBfX3Byb2R1Y3RIYXNPcmlnaW5Qcm9wZXJ0aWVzKHByb2R1Y3QpKSB7XG4gICAgICAvLyBoYXZlIFwib3JpZ2luXCIgcHJvZHVjdCwgdGhhdCBpc24ndCBkZWxldGVkLCBhbmQgaGFzIG9yaWdpbiBwcm9wZXJ0aWVzLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UsIGRlbGV0ZWRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwcm9kdWN0IHdpdGggZXZlbnQgaWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyBtYXkgYmUgYSBzdXBlcnNlZGVkIG9yIGRlbGV0ZWQgcHJvZHVjdC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgICAgICAgIHRoZSBwcmVmZXJyZWQgbGF0aXR1ZGUgZm9yIHRoaXMgZXZlbnQsIG9yIG51bGwgaWYgbm9uZS5cbiAgICovXG4gIF90aGlzLmdldEV2ZW50SWRQcm9kdWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9kdWN0ID0gX3RoaXMuZ2V0UHJlZmVycmVkT3JpZ2luUHJvZHVjdCgpO1xuICAgIGlmIChwcm9kdWN0ID09PSBudWxsKSB7XG4gICAgICBwcm9kdWN0ID0gX3RoaXMuZ2V0UHJvZHVjdFdpdGhPcmlnaW5Qcm9wZXJ0aWVzKCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9kdWN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByb2R1Y3Qgd2l0aCBvcmlnaW4gcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyBtYXkgYmUgYSBzdXBlcnNlZGVkIG9yIGRlbGV0ZWQgcHJvZHVjdC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgICAgICAgIHRoZSBwcm9kdWN0IHdpdGggb3JpZ2luIHByb3BlcnRpZXMgdGhpcyBldmVudCwgb3IgbnVsbCBpZiBub25lLlxuICAgKi9cbiAgX3RoaXMuZ2V0UHJvZHVjdFdpdGhPcmlnaW5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmlnaW5UeXBlLFxuICAgICAgICBwcm9kdWN0O1xuXG4gICAgb3JpZ2luVHlwZSA9IFByb2R1Y3QuZ2V0RnVsbFR5cGUoJ29yaWdpbicsIF9jb25maWcpO1xuXG4gICAgaWYgKF9wcm9kdWN0cy5oYXNPd25Qcm9wZXJ0eShvcmlnaW5UeXBlKSkge1xuICAgICAgLy8gb3JpZ2luIHByb2R1Y3RzIG5vdCBzdXBlcnNlZGVkIG9yIGRlbGV0ZWRcbiAgICAgIHByb2R1Y3QgPSBfX2dldFByb2R1Y3RXaXRoT3JpZ2luUHJvcGVydGllcyhcbiAgICAgICAgICBfX2dldFdpdGhvdXREZWxldGVkKF9fZ2V0V2l0aG91dFN1cGVyc2VkZWQoXG4gICAgICAgICAgICAgIF9wcm9kdWN0c1tvcmlnaW5UeXBlXSkpKTtcblxuICAgICAgaWYgKHByb2R1Y3QgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XG4gICAgICB9XG5cbiAgICAgIC8vIG9yaWdpbiBwcm9kdWN0cyBzdXBlcnNlZGVkIGJ5IGEgZGVsZXRlXG4gICAgICBwcm9kdWN0ID0gX19nZXRQcm9kdWN0V2l0aE9yaWdpblByb3BlcnRpZXMoXG4gICAgICAgICAgX19nZXRXaXRob3V0U3VwZXJzZWRlZChfX2dldFdpdGhvdXREZWxldGVkKFxuICAgICAgICAgICAgICBfcHJvZHVjdHNbb3JpZ2luVHlwZV0pKSk7XG5cbiAgICAgIGlmIChwcm9kdWN0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwcm9kdWN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHByb2R1Y3RzIG5vdCBzdXBlcnNlZGVkIG9yIGRlbGV0ZWRcbiAgICBwcm9kdWN0ID0gX19nZXRQcm9kdWN0V2l0aE9yaWdpblByb3BlcnRpZXMoXG4gICAgICAgIF9fZ2V0V2l0aG91dERlbGV0ZWQoX19nZXRXaXRob3V0U3VwZXJzZWRlZChcbiAgICAgICAgICAgIF9fcHJvZHVjdE1hcFRvTGlzdChfcHJvZHVjdHMpKSkpO1xuXG4gICAgaWYgKHByb2R1Y3QgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBwcm9kdWN0O1xuICAgIH1cblxuICAgIC8vIHByb2R1Y3RzIHN1cGVyc2VkZWQgYnkgYSBkZWxldGVcbiAgICBwcm9kdWN0ID0gX19nZXRQcm9kdWN0V2l0aE9yaWdpblByb3BlcnRpZXMoXG4gICAgICAgIF9fZ2V0V2l0aG91dFN1cGVyc2VkZWQoX19nZXRXaXRob3V0RGVsZXRlZChcbiAgICAgICAgICAgIF9fcHJvZHVjdE1hcFRvTGlzdChfcHJvZHVjdHMpKSkpO1xuICAgIHJldHVybiBwcm9kdWN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZWZlcnJlZCBwcm9kdWN0IHdpdGggb3JpZ2luIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIElmIG5vIHByZWZlcnJlZCBwcm9kdWN0IGhhcyBvcmlnaW4gcHJvcGVydGllcyxcbiAgICogbG9vayBmb3IgcHJlZmVycmVkIHByb2R1Y3Qgd2l0aCBldmVudCBpZC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgICAgICAgIHRoZSBwcmVmZXJyZWQgcHJvZHVjdCB3aXRoIG9yaWdpbiBwcm9wZXJ0aWVzIHRoaXMgZXZlbnQsIG9yIG51bGwuXG4gICAqL1xuICBfdGhpcy5nZXRQcmVmZXJyZWRPcmlnaW5Qcm9kdWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmlnaW5UeXBlLFxuICAgICAgICBwcm9kdWN0O1xuXG4gICAgb3JpZ2luVHlwZSA9IFByb2R1Y3QuZ2V0RnVsbFR5cGUoJ29yaWdpbicsIF9jb25maWcpO1xuXG4gICAgaWYgKF9wcm9kdWN0cy5oYXNPd25Qcm9wZXJ0eShvcmlnaW5UeXBlKSkge1xuICAgICAgLy8gb3JpZ2luIHByb2R1Y3RzIG5vdCBzdXBlcnNlZGVkIG9yIGRlbGV0ZWRcbiAgICAgIHByb2R1Y3QgPSBfX2dldFByb2R1Y3RXaXRoT3JpZ2luUHJvcGVydGllcyhcbiAgICAgICAgICBfX2dldFdpdGhvdXREZWxldGVkKF9fZ2V0V2l0aG91dFN1cGVyc2VkZWQoXG4gICAgICAgICAgICAgIF9wcm9kdWN0c1tvcmlnaW5UeXBlXSkpKTtcblxuICAgICAgaWYgKHByb2R1Y3QgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XG4gICAgICB9XG5cbiAgICAgIC8vIG9yaWdpbiBwcm9kdWN0cyBub3Qgc3VwZXJzZWRlZCB0aGF0IGhhdmUgZXZlbnQgaWRcbiAgICAgIHByb2R1Y3QgPSBfX2dldFByb2R1Y3RXaXRoRXZlbnRJZFByb3BlcnRpZXMoXG4gICAgICAgICAgX19nZXRXaXRob3V0U3VwZXJzZWRlZChfcHJvZHVjdHNbb3JpZ2luVHlwZV0pKTtcblxuICAgICAgaWYgKHByb2R1Y3QgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XG4gICAgICB9XG5cbiAgICAgIC8vIG9yaWdpbiBleGlzdHMsIGJ1dCBpcyBpbmNvbXBsZXRlXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBwcm9kdWN0cyBub3Qgc3VwZXJzZWRlZCBvciBkZWxldGVkXG4gICAgcHJvZHVjdCA9IF9fZ2V0UHJvZHVjdFdpdGhPcmlnaW5Qcm9wZXJ0aWVzKFxuICAgICAgICBfX2dldFdpdGhvdXREZWxldGVkKF9fZ2V0V2l0aG91dFN1cGVyc2VkZWQoXG4gICAgICAgICAgICBfX3Byb2R1Y3RNYXBUb0xpc3QoX3Byb2R1Y3RzKSkpKTtcblxuICAgIGlmIChwcm9kdWN0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICB9XG5cbiAgICAvLyBwcm9kdWN0cyBub3Qgc3VwZXJzZWRlZCB0aGF0IGhhdmUgZXZlbnRpZC5cbiAgICBwcm9kdWN0ID0gX19nZXRQcm9kdWN0V2l0aEV2ZW50SWRQcm9wZXJ0aWVzKFxuICAgICAgICBfX2dldFdpdGhvdXRTdXBlcnNlZGVkKF9fcHJvZHVjdE1hcFRvTGlzdChfcHJvZHVjdHMpKSk7XG5cbiAgICBpZiAocHJvZHVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHByb2R1Y3Q7XG4gICAgfVxuXG4gICAgLy8gcHJvZHVjdHMgc3VwZXJzZWRlZCBieSBhIGRlbGV0ZSB0aGF0IGhhdmUgZXZlbnRpZFxuICAgIHByb2R1Y3QgPSBfX2dldFByb2R1Y3RXaXRoRXZlbnRJZFByb3BlcnRpZXMoXG4gICAgICAgIF9fZ2V0V2l0aG91dFN1cGVyc2VkZWQoX19nZXRXaXRob3V0RGVsZXRlZChcbiAgICAgICAgICBfX3Byb2R1Y3RNYXBUb0xpc3QoX3Byb2R1Y3RzKSkpKTtcbiAgICByZXR1cm4gcHJvZHVjdDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZWZlcnJlZCBtYWduaXR1ZGUgcHJvZHVjdC5cbiAgICpcbiAgICogQ3VycmVudCBjYWxscyBnZXRQcmVmZXJyZWRPcmlnaW5Qcm9kdWN0LiAgTWV0aG9kIGlzIGEgcGxhY2Vob2xkZXIgaW4gY2FzZVxuICAgKiBtb21lbnQtdGVuc29yIG9yIG90aGVyIHByb2R1Y3RzIGJlY29tZSBwcmVmZXJyZWQgc291cmNlIG9mIG1hZ25pdHVkZS5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIHRoZSBwcm9kdWN0IHRoYXQgZGVmaW5lcyB0aGUgbWFnbml0dWRlIGZvciB0aGUgZXZlbnQsIG9yIG51bGwuXG4gICAqL1xuICBfdGhpcy5nZXRQcmVmZXJyZWRNYWduaXR1ZGVQcm9kdWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5nZXRQcmVmZXJyZWRPcmlnaW5Qcm9kdWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJyZWFrIHRoaXMgZXZlbnQgaW50byBldmVudHMgYnkgY29udHJpYnV0b3IuXG4gICAqXG4gICAqIEFsbCBwcm9kdWN0cyB0aGF0IGRvIG5vdCBpbmNsdWRlIGFuIGV2ZW50IGlkIGFyZSBpbmNsdWRlZCB3aXRoIHRoZVxuICAgKiBwcmVmZXJyZWQgc3ViIGV2ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAga2V5cyBhcmUgZXZlbnQgaWRzLlxuICAgKiAgICAgICAgIHZhbHVlcyBhcmUgQ2F0YWxvZ0V2ZW50cy5cbiAgICovXG4gIF90aGlzLmdldFN1YkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJlZmVycmVkRXZlbnQsXG4gICAgICAgIHByZWZlcnJlZEV2ZW50SWQsXG4gICAgICAgIHByb2R1Y3RFdmVudHMsXG4gICAgICAgIHN1YkV2ZW50cyxcbiAgICAgICAgd2l0aG91dFN1cGVyc2VkZWQ7XG5cbiAgICBwcmVmZXJyZWRFdmVudElkID0gX3RoaXMuZ2V0RXZlbnRJZCgpO1xuICAgIHByZWZlcnJlZEV2ZW50ID0gQ2F0YWxvZ0V2ZW50KCk7XG4gICAgcHJvZHVjdEV2ZW50cyA9IHt9O1xuICAgIHN1YkV2ZW50cyA9IHt9O1xuICAgIHN1YkV2ZW50c1twcmVmZXJyZWRFdmVudElkXSA9IHByZWZlcnJlZEV2ZW50O1xuXG4gICAgd2l0aG91dFN1cGVyc2VkZWQgPSBfX2dldFdpdGhvdXRTdXBlcnNlZGVkKFxuICAgICAgICBfX3Byb2R1Y3RNYXBUb0xpc3QoX3Byb2R1Y3RzKSk7XG4gICAgd2l0aG91dFN1cGVyc2VkZWQuZm9yRWFjaChmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgICAgdmFyIGtleSxcbiAgICAgICAgICBldmVudENvZGUsXG4gICAgICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICAgICAgc3ViRXZlbnQsXG4gICAgICAgICAgc3ViRXZlbnRJZDtcbiAgICAgIGtleSA9IHByb2R1Y3QuZ2V0KCdzb3VyY2UnKSArICdfJyArXG4gICAgICAgICAgcHJvZHVjdC5nZXQoJ3R5cGUnKSArICdfJyArXG4gICAgICAgICAgcHJvZHVjdC5nZXQoJ2NvZGUnKTtcbiAgICAgIGV2ZW50U291cmNlID0gcHJvZHVjdC5nZXRQcm9wZXJ0eSgnZXZlbnRzb3VyY2UnKTtcbiAgICAgIGV2ZW50Q29kZSA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2V2ZW50c291cmNlY29kZScpO1xuICAgICAgaWYgKGV2ZW50U291cmNlID09PSBudWxsIHx8IGV2ZW50Q29kZSA9PT0gbnVsbCkge1xuICAgICAgICBzdWJFdmVudCA9IHByZWZlcnJlZEV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ViRXZlbnRJZCA9IGV2ZW50U291cmNlICsgZXZlbnRDb2RlO1xuICAgICAgICBpZiAoIXN1YkV2ZW50cy5oYXNPd25Qcm9wZXJ0eShzdWJFdmVudElkKSkge1xuICAgICAgICAgIHN1YkV2ZW50c1tzdWJFdmVudElkXSA9IENhdGFsb2dFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHN1YkV2ZW50ID0gc3ViRXZlbnRzW3N1YkV2ZW50SWRdO1xuICAgICAgfVxuICAgICAgc3ViRXZlbnQuYWRkUHJvZHVjdChwcm9kdWN0KTtcbiAgICAgIHByb2R1Y3RFdmVudHNba2V5XSA9IHN1YkV2ZW50O1xuICAgIH0pO1xuXG4gICAgX19wcm9kdWN0TWFwVG9MaXN0KF9wcm9kdWN0cykuZm9yRWFjaChmdW5jdGlvbiAocHJvZHVjdCkge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGlmICh3aXRob3V0U3VwZXJzZWRlZC5pbmRleE9mKHByb2R1Y3QpICE9PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBrZXkgPSBwcm9kdWN0LmdldCgnc291cmNlJykgKyAnXycgK1xuICAgICAgICAgIHByb2R1Y3QuZ2V0KCd0eXBlJykgKyAnXycgK1xuICAgICAgICAgIHByb2R1Y3QuZ2V0KCdjb2RlJyk7XG4gICAgICBwcm9kdWN0RXZlbnRzW2tleV0uYWRkUHJvZHVjdChwcm9kdWN0KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzdWJFdmVudHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG1hcCBvZiBhbGwgZXZlbnQgaWRzIGFzc29jaWF0ZWQgdG8gdGhpcyBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGluY2x1ZGVEZWxldGVkIHtCb29sZWFufVxuICAgKiAgICAgICAgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2UuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBrZXlzIGFyZSBldmVudCBzb3VyY2VzLlxuICAgKiAgICAgICAgIHZhbHVlcyBhcmUgYXJyYXkgb2YgY29kZXMgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBzb3VyY2UuXG4gICAqL1xuICBfdGhpcy5nZXRBbGxFdmVudENvZGVzID0gZnVuY3Rpb24gKGluY2x1ZGVEZWxldGVkKSB7XG4gICAgdmFyIGFsbEV2ZW50Q29kZXMgPSB7fSxcbiAgICAgICAgY29kZXMsXG4gICAgICAgIGlkLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHNvdXJjZUNvZGUsXG4gICAgICAgIHN1YkV2ZW50cyxcbiAgICAgICAgc3ViRXZlbnQ7XG5cbiAgICBzdWJFdmVudHMgPSBfdGhpcy5nZXRTdWJFdmVudHMoKTtcbiAgICBmb3IgKGlkIGluIHN1YkV2ZW50cykge1xuICAgICAgc3ViRXZlbnQgPSBzdWJFdmVudHNbaWRdO1xuICAgICAgLy8gc2tpcCB0aGUgZGVsZXRlZCBzdWJFdmVudFxuICAgICAgaWYgKCFpbmNsdWRlRGVsZXRlZCAmJiBzdWJFdmVudC5pc0RlbGV0ZWQoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc291cmNlID0gc3ViRXZlbnQuZ2V0U291cmNlKCk7XG4gICAgICBzb3VyY2VDb2RlID0gc3ViRXZlbnQuZ2V0U291cmNlQ29kZSgpO1xuICAgICAgaWYgKCEoc291cmNlIGluIGFsbEV2ZW50Q29kZXMpKSB7XG4gICAgICAgIGFsbEV2ZW50Q29kZXNbc291cmNlXSA9IFtdO1xuICAgICAgfVxuICAgICAgY29kZXMgPSBhbGxFdmVudENvZGVzW3NvdXJjZV07XG4gICAgICBpZiAoY29kZXMuaW5kZXhPZihzb3VyY2VDb2RlKSA9PT0gLTEpIHtcbiAgICAgICAgY29kZXMucHVzaChzb3VyY2VDb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbEV2ZW50Q29kZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBldmVudCBzdW1tYXJ5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgZXZlbnQgc3VtbWFyeS5cbiAgICovXG4gIF90aGlzLmdldFN1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50SWRQcm9kdWN0LFxuICAgICAgICBvcmlnaW5Qcm9kdWN0LFxuICAgICAgICBtYWduaXR1ZGVQcm9kdWN0LFxuICAgICAgICBwcm9wcztcblxuICAgIGlmIChfc3VtbWFyeSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF9zdW1tYXJ5O1xuICAgIH1cblxuICAgIF9zdW1tYXJ5ID0ge1xuICAgICAgZGVwdGg6IG51bGwsXG4gICAgICBldmVudENvZGVzOiBudWxsLFxuICAgICAgaWQ6IG51bGwsXG4gICAgICBpc0RlbGV0ZWQ6IG51bGwsXG4gICAgICBsYXRpdHVkZTogbnVsbCxcbiAgICAgIGxvbmdpdHVkZTogbnVsbCxcbiAgICAgIG1hZ25pdHVkZTogbnVsbCxcbiAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBzb3VyY2VDb2RlOiBudWxsLFxuICAgICAgdGltZTogbnVsbCxcbiAgICAgIC8vIHByb2R1Y3RzIGZvciBhYm92ZSBpbmZvcm1hdGlvblxuICAgICAgZXZlbnRJZFByb2R1Y3Q6IG51bGwsXG4gICAgICBvcmlnaW5Qcm9kdWN0OiBudWxsLFxuICAgICAgbWFnbml0dWRlUHJvZHVjdDogbnVsbFxuICAgIH07XG4gICAgX3N1bW1hcnkuaXNEZWxldGVkID0gX3RoaXMuaXNEZWxldGVkKCk7XG5cbiAgICBldmVudElkUHJvZHVjdCA9IF90aGlzLmdldEV2ZW50SWRQcm9kdWN0KCk7XG4gICAgaWYgKGV2ZW50SWRQcm9kdWN0ICE9PSBudWxsKSB7XG4gICAgICBwcm9wcyA9IGV2ZW50SWRQcm9kdWN0LmdldCgncHJvcGVydGllcycpO1xuICAgICAgX3N1bW1hcnkuaWQgPSBwcm9wcy5ldmVudHNvdXJjZSArIHByb3BzLmV2ZW50c291cmNlY29kZTtcbiAgICAgIF9zdW1tYXJ5LnNvdXJjZSA9IHByb3BzLmV2ZW50c291cmNlO1xuICAgICAgX3N1bW1hcnkuc291cmNlQ29kZSA9IHByb3BzLmV2ZW50c291cmNlY29kZTtcbiAgICAgIF9zdW1tYXJ5LmV2ZW50SWRQcm9kdWN0ID0gZXZlbnRJZFByb2R1Y3Q7XG4gICAgfVxuXG4gICAgb3JpZ2luUHJvZHVjdCA9IF90aGlzLmdldFByb2R1Y3RXaXRoT3JpZ2luUHJvcGVydGllcygpO1xuICAgIGlmIChvcmlnaW5Qcm9kdWN0ICE9PSBudWxsKSB7XG4gICAgICBwcm9wcyA9IG9yaWdpblByb2R1Y3QuZ2V0KCdwcm9wZXJ0aWVzJyk7XG4gICAgICBfc3VtbWFyeS5kZXB0aCA9IE51bWJlcihwcm9wcy5kZXB0aCk7XG4gICAgICBfc3VtbWFyeS5sYXRpdHVkZSA9IE51bWJlcihwcm9wcy5sYXRpdHVkZSk7XG4gICAgICBfc3VtbWFyeS5sb25naXR1ZGUgPSBOdW1iZXIocHJvcHMubG9uZ2l0dWRlKTtcbiAgICAgIF9zdW1tYXJ5LnRpbWUgPSBuZXcgRGF0ZShwcm9wcy5ldmVudHRpbWUpO1xuICAgICAgX3N1bW1hcnkub3JpZ2luUHJvZHVjdCA9IG9yaWdpblByb2R1Y3Q7XG4gICAgfVxuXG4gICAgbWFnbml0dWRlUHJvZHVjdCA9IF90aGlzLmdldFByZWZlcnJlZE1hZ25pdHVkZVByb2R1Y3QoKTtcbiAgICBpZiAobWFnbml0dWRlUHJvZHVjdCAhPT0gbnVsbCkge1xuICAgICAgX3N1bW1hcnkubWFnbml0dWRlID0gTnVtYmVyKG1hZ25pdHVkZVByb2R1Y3QuZ2V0UHJvcGVydHkoJ21hZ25pdHVkZScpKTtcbiAgICAgIF9zdW1tYXJ5Lm1hZ25pdHVkZVByb2R1Y3QgPSBtYWduaXR1ZGVQcm9kdWN0O1xuICAgIH1cblxuICAgIF9zdW1tYXJ5LmV2ZW50Q29kZXMgPSBfdGhpcy5nZXRBbGxFdmVudENvZGVzKCk7XG4gICAgX3N1bW1hcnkucHJvcGVydGllcyA9IF9wcm9wZXJ0aWVzO1xuXG4gICAgcmV0dXJuIF9zdW1tYXJ5O1xuICB9O1xuXG5cbiAgX2luaXRpYWxpemUoZXZlbnREZXRhaWxzLCBvcHRpb25zKTtcbiAgZXZlbnREZXRhaWxzID0gbnVsbDtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuLy8gYWRkIHN0YXRpYyBtZXRob2RzXG5DYXRhbG9nRXZlbnQucHJvZHVjdE1hcFRvTGlzdCA9IF9fcHJvZHVjdE1hcFRvTGlzdDtcbkNhdGFsb2dFdmVudC5nZXRXaXRob3V0RGVsZXRlZCA9IF9fZ2V0V2l0aG91dERlbGV0ZWQ7XG5DYXRhbG9nRXZlbnQuZ2V0V2l0aG91dFN1cGVyc2VkZWQgPSBfX2dldFdpdGhvdXRTdXBlcnNlZGVkO1xuQ2F0YWxvZ0V2ZW50LmdldFNvcnRlZE1vc3RQcmVmZXJyZWRGaXJzdCA9IF9fZ2V0U29ydGVkTW9zdFByZWZlcnJlZEZpcnN0O1xuQ2F0YWxvZ0V2ZW50LnByb2R1Y3RIYXNPcmlnaW5Qcm9wZXJ0aWVzID0gX19wcm9kdWN0SGFzT3JpZ2luUHJvcGVydGllcztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENhdGFsb2dFdmVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1vZGVsID0gcmVxdWlyZSgnbXZjL01vZGVsJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgYXR0cmlidXRlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSBhdHRycyB7T2JqZWN0fVxuICogICAgIG9iamVjdCB3aXRoIGtleXMvdmFsdWVzLlxuICogQHBhcmFtIGF0dHIge1N0cmluZ31cbiAqICAgICBhdHRyaWJ1dGUgbmFtZS5cbiAqIEByZXR1cm5cbiAqICAgICB0cnVlLCB3aGVuIGBhdHRyc2AgaHNhIGEgcHJvcGVydHkgbmFtZWQgYGF0dHJgXG4gKiAgICAgd2l0aCBhIHZhbHVlIHRoYXQgaXMgbm90IHVuZGVmaW5lZDsgZmFsc2UsIG90aGVyd2lzZS5cbiAqL1xudmFyIF9fYXR0cklzVmFsaWQgPSBmdW5jdGlvbiAoYXR0cnMsIGF0dHIpIHtcbiAgdmFyIHZhbHVlO1xuXG4gIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgIHZhbHVlID0gYXR0cnNbYXR0cl07XG5cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBQcm9kdWN0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqIEBwYXJhbSBvcHRpb25zLmJ5dGVzIHtTdHJpbmd9XG4gKiAgICAgY29udGVudCBhcyBhIHN0cmluZy5cbiAqICAgICBDb250ZW50IHNob3VsZCBoYXZlIGB1cmxgIG9yIGBieXRlc2AsIGJ1dCBub3QgYm90aC5cbiAqIEBwYXJhbSBvcHRpb25zLmNvbnRlbnRUeXBlIHtTdHJpbmd9XG4gKiAgICAgbWltZSB0eXBlLCBkZWZhdWx0ICd0ZXh0L3BsYWluJy5cbiAqIEBwYXJhbSBvcHRpb25zLmlkIHtTdHJpbmd9XG4gKiAgICAgdW5pcXVlIGlkZW50aWZpZXIsIGRlZmF1bHQgbnVsbC5cbiAqIEBwYXJhbSBvcHRpb25zLmxhc3RNb2RpZmllZCB7TnVtYmVyfVxuICogICAgIG1pbGxpc2Vjb25kIGVwb2NoIHRpbWUgc3RhbXAsIGRlZmF1bHQgbmV3IERhdGUoKS5nZXRUaW1lKCkuXG4gKiBAcGFyYW0gb3B0aW9ucy5sZW5ndGgge1N0cmluZ31cbiAqICAgICByZXBvcnRlZCBsZW5ndGggb2YgY29udGVudC5cbiAqIEBwYXJhbSBvcHRpb25zLnVybCB7U3RyaW5nfVxuICogICAgIHVybCB3aGVyZSBjb250ZW50IGlzIGF2YWlsYWJsZS5cbiAqICAgICBDb250ZW50IHNob3VsZCBoYXZlIGB1cmxgIG9yIGBieXRlc2AsIGJ1dCBub3QgYm90aC5cbiAqL1xudmFyIENvbnRlbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZTtcblxuXG4gIF90aGlzID0gTW9kZWwoVXRpbC5leHRlbmQoe1xuICAgIGJ5dGVzOiBudWxsLFxuICAgIGNvbnRlbnRUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgaWQ6IG51bGwsXG4gICAgbGFzdE1vZGlmaWVkOiAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgIGxlbmd0aDogMCxcbiAgICB1cmw6IG51bGxcbiAgfSwgb3B0aW9ucykpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKC8qb3B0aW9ucyovKSB7XG4gICAgdmFyIGJ5dGVzID0gX3RoaXMuZ2V0KCdieXRlcycpLFxuICAgICAgICB1cmwgPSBfdGhpcy5nZXQoJ3VybCcpO1xuXG4gICAgaWYgKGJ5dGVzID09PSBudWxsICYmIHVybCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByb2R1Y3QgY29udGVudHMuIE11c3QgaGF2ZSBvbmUgb2YgYnl0ZXMgb3IgJyArXG4gICAgICAgICAgJ3VybC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZXMgIT09IG51bGwgJiYgYnl0ZXMubGVuZ3RoICE9PSBfdGhpcy5nZXQoJ2xlbmd0aCcpKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBwcm9kdWN0IGNvbnRlbnRzLiBBY3R1YWwgbGVuZ3RoIGFuZCBjbGFpbWVkICcgK1xuICAgICAgICAgICdsZW5ndGggZGlmZmVyLicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgc2V0IG1ldGhvZCB0byBlbnN1cmUgb25seSBvbmUgb2YgYHVybGAgb3IgYGJ5dGVzYCBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIHtPYmplY3R9XG4gICAqICAgICBhdHRyaWJ1dGVzIHRvIHNldC5cbiAgICovXG4gIF90aGlzLnNldCA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgIHZhciBoYXNCeXRlcyxcbiAgICAgICAgaGFzVXJsO1xuXG4gICAgaGFzQnl0ZXMgPSBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCdieXRlcycpO1xuICAgIGhhc1VybCA9IGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoJ3VybCcpO1xuXG4gICAgLy8gQ29udGVudCBoYXMgZWl0aGVyIGJ5dGVzLCBvciB1cmwsIGJ1dCBub3QgYm90aC4gSWYgb25lIGlzIHNldCxcbiAgICAvLyBjbGVhciB0aGUgb3RoZXIuLi5cbiAgICBpZiAoaGFzVXJsICYmIGF0dHJpYnV0ZXMudXJsICE9PSBudWxsKSB7XG4gICAgICBhdHRyaWJ1dGVzLmJ5dGVzID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGhhc0J5dGVzICYmIGF0dHJpYnV0ZXMuYnl0ZXMgIT09IG51bGwpIHtcbiAgICAgIGF0dHJpYnV0ZXMudXJsID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfSwgX3RoaXMuc2V0KTtcblxuICAvKipcbiAgICogVmFsaWRhdGUgY29udGVudCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBDaGVja3MgdGhhdCBjb250ZW50IGhhcyBhbiBgaWRgIGFuZCBvbmUgb2YgYHVybGAgb3IgYGJ5dGVzYCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICogICAgIHdoZW4gY29udGVudCBpcyBpbnZhbGlkXG4gICAqL1xuICBfdGhpcy52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXR0cnM7XG5cbiAgICBhdHRycyA9IF90aGlzLmdldCgpO1xuXG4gICAgaWYgKCFfX2F0dHJJc1ZhbGlkKGF0dHJzLCAnaWQnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9kdWN0IGNvbnRlbnQgbXVzdCBoYXZlIGEgdmFsaWQgaWQnKTtcbiAgICB9IGVsc2UgaWYgKCFfX2F0dHJJc1ZhbGlkKGF0dHJzLCAndXJsJykgJiYgIV9fYXR0cklzVmFsaWQoYXR0cnMsICdieXRlcycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2R1Y3QgY29udGVudCBtdXN0IGhhdmUgY29udGVudCcpO1xuICAgIH1cbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnbXZjL0NvbGxlY3Rpb24nKSxcbiAgICBDb250ZW50ID0gcmVxdWlyZSgncGRsL0NvbnRlbnQnKSxcbiAgICBNb2RlbCA9IHJlcXVpcmUoJ212Yy9Nb2RlbCcpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX1NUQVRVU19VUERBVEUgPSAnVVBEQVRFJyxcbiAgICBfU1RBVFVTX0RFTEVURSA9ICdERUxFVEUnO1xuXG52YXIgX2dldEJhc2VUeXBlLFxuICAgIF9nZXRGdWxsVHlwZTtcblxuLyoqXG4gKiBSZW1vdmUgXCJpbnRlcm5hbC1cIiBwcmVmaXggYW5kIFwiLXNjZW5hcmlvXCIgc3VmZml4IGZyb20gcHJvZHVjdCBcInR5cGVcIi5cbiAqXG4gKiBAcGFyYW0gdHlwZSB7U3RyaW5nfVxuICogICAgIFRoZSBpbml0aWFsIHByb2R1Y3QgdHlwZS5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiAgICAgVGhlIGJhc2UgcHJvZHVjdCB0eXBlIHdpdGhvdXQgYW55IGtub3duIHByZWZpeCBvciBzdWZmaXguXG4gKi9cbl9nZXRCYXNlVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBiYXNlO1xuXG4gIGJhc2UgPSB0eXBlO1xuXG4gIGlmIChiYXNlICYmIGJhc2UubWF0Y2goL15pbnRlcm5hbC0vKSkge1xuICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UoJ2ludGVybmFsLScsICcnKTtcbiAgfVxuXG4gIGlmIChiYXNlICYmIGJhc2UubWF0Y2goLy1zY2VuYXJpbyQvKSkge1xuICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UoJy1zY2VuYXJpbycsICcnKTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufTtcblxuLyoqXG4gKiBBZGQgXCJpbnRlcm5hbC1cIiBwcmVmaXggb3IgXCItc2NlbmFyaW9cIiBzdWZmaXggdG8gcHJvZHVjdCBcInR5cGVcIi5cbiAqXG4gKiBAcGFyYW0gdHlwZSB7U3RyaW5nfVxuICogICAgIFRoZSBiYXNlIHByb2R1Y3QgdHlwZS5cbiAqIEBwYXJhbSBjb25maWcge09iamVjdH1cbiAqICAgICBDb25maWd1cmF0aW9uIG9iamVjdCBjb250YWluaW5nIElOVEVSTkFMX01PREUgYW5kL29yIFNDRU5BUklPX01PREUgZmxhZ3NcbiAqICAgICBhcyBhcHByb3ByaWF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiAgICAgVGhlIGFjdHVhbCBwcm9kdWN0IHR5cGUgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXG4gKi9cbl9nZXRGdWxsVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcpIHtcbiAgdmFyIGZ1bGxUeXBlO1xuXG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgZnVsbFR5cGUgPSB0eXBlO1xuXG4gIGlmIChjb25maWcuSU5URVJOQUxfTU9ERSkge1xuICAgIGZ1bGxUeXBlID0gJ2ludGVybmFsLScgKyBmdWxsVHlwZTtcbiAgfVxuXG4gIGlmIChjb25maWcuU0NFTkFSSU9fTU9ERSkge1xuICAgIGZ1bGxUeXBlICs9ICctc2NlbmFyaW8nO1xuICB9XG5cbiAgcmV0dXJuIGZ1bGxUeXBlO1xufTtcblxuXG4vKipcbiAqIEEgcHJvZHVjdCBvYmplY3QuXG4gKlxuICogVHlwaWNhbGx5IGNyZWF0ZWQgZnJvbSBhbiBldmVudCBkZXRhaWwgZmVlZC5cbiAqIENyZWF0ZWQgbWFudWFsbHkgZm9yIG5ldyBwcm9kdWN0cy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgICAgIGEgcHJvZHVjdCBvYmplY3QgZnJvbSBhbiBldmVudCBkZXRhaWwgZmVlZC5cbiAqIEBwYXJhbSBvcHRpb25zLmNvZGUge1N0cmluZ31cbiAqICAgICAgICBwcm9kdWN0IGNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucy5jb250ZW50cyB7Q29sbGVjdGlvbjxDb250ZW50Pn0uXG4gKiBAcGFyYW0gb3B0aW9ucy5pZCB7U3RyaW5nfVxuICogICAgICAgIHByb2R1Y3QgaWQgVVJOLCB1bmlxdWUgcGVyIHByb2R1Y3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5pbmRleGlkIHtTdHJpbmd9XG4gKiAgICAgICAgc2VydmVyIGlkIGZvciBwcm9kdWN0LCBtYXkgdmFyeSBiZXR3ZWVuIHNlcnZlcnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5pbmRleFRpbWUge051bWJlcn1cbiAqICAgICAgICBtaWxsaXNlY29uZCBlcG9jaCB0aW1lc3RhbXAgd2hlbiBwcm9kdWN0IHdhcyBpbmRleGVkIG9uIHNlcnZlci5cbiAqIEBwYXJhbSBvcHRpb25zLmxpbmtzIHtPYmplY3R9XG4gKiAgICAgICAga2V5cyBhcmUgbGluayByZWxhdGlvbiBuYW1lcy5cbiAqICAgICAgICB2YWx1ZXMgYXJlIGFycmF5cyBvZiB1cmkgU3RyaW5ncyBmb3IgcmVsYXRpb24uXG4gKiBAcGFyYW0gb3B0aW9ucy5wcmVmZXJyZWRXZWlnaHQge051bWJlcn1cbiAqICAgICAgICBvcHRpb25hbCwgY3VycmVudCBwcmVmZXJyZWQgd2VpZ2h0IG9mIHByb2R1Y3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcm9wZXJ0aWVzIHtPYmplY3R9XG4gKiAgICAgICAga2V5cyBhcmUgcHJvcGVydHkgbmFtZXMuXG4gKiAgICAgICAgdmFsdWVzIG11c3QgYmUgc3RyaW5ncy5cbiAqIEBwYXJhbSBvcHRpb25zLnNvdXJjZSB7U3RyaW5nfVxuICogICAgICAgIHByb2R1Y3Qgc291cmNlLlxuICogQHBhcmFtIG9wdGlvbnMuc3RhdHVzIHtTdHJpbmd9XG4gKiAgICAgICAgcHJvZHVjdCBzdGF0dXMuXG4gKiAgICAgICAgZGVmYXVsdCBQcm9kdWN0LlNUQVRVU19VUERBVEUsXG4gKiAgICAgICAgdXNlIFByb2R1Y3QuU1RBVFVTX0RFTEVURSBmb3IgZGVsZXRlcy5cbiAqIEBwYXJhbSBvcHRpb25zLnR5cGUge1N0cmluZ31cbiAqICAgICAgICBwcm9kdWN0IHR5cGUuXG4gKiBAcGFyYW0gb3B0aW9ucy51cGRhdGVUaW1lIHtOdW1iZXJ9XG4gKiAgICAgICAgcHJvZHVjdCB1cGRhdGUgdGltZS5cbiAqL1xudmFyIFByb2R1Y3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZTtcblxuXG4gIF90aGlzID0gTW9kZWwoVXRpbC5leHRlbmQoe1xuICAgIGNvZGU6IG51bGwsXG4gICAgY29udGVudHM6IG51bGwsXG4gICAgaWQ6IG51bGwsXG4gICAgaW5kZXhpZDogbnVsbCxcbiAgICBpbmRleFRpbWU6IG51bGwsXG4gICAgbGlua3M6IHt9LFxuICAgIHByZWZlcnJlZFdlaWdodDogbnVsbCxcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBzb3VyY2U6IG51bGwsXG4gICAgc3RhdHVzOiBfU1RBVFVTX1VQREFURSxcbiAgICB0eXBlOiBudWxsLFxuICAgIHVwZGF0ZVRpbWU6IG51bGxcbiAgfSwgb3B0aW9ucykpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKC8qb3B0aW9ucyovKSB7XG4gICAgdmFyIGNvbnRlbnRzLFxuICAgICAgICBwcm9wZXJ0aWVzO1xuXG4gICAgLy8gbWFrZSBzdXJlIGNvbnRlbnRzIGFuZCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkXG4gICAgY29udGVudHMgPSBfdGhpcy5nZXQoJ2NvbnRlbnRzJykgfHwgW107XG4gICAgcHJvcGVydGllcyA9IF90aGlzLmdldCgncHJvcGVydGllcycpIHx8IFtdO1xuXG4gICAgLy8gbWFrZSBzdXJlIGNvbnRlbnRzIGFyZSBDb250ZW50IG9iamVjdHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50cykpIHtcbiAgICAgIC8vIEhhbmRsZSBjYXNlIGlmIGdpdmVuIGFuIGFycmF5XG4gICAgICBjb250ZW50cyA9IGNvbnRlbnRzLm1hcChmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICBpZiAoIWNvbnRlbnQuZ2V0KSB7XG4gICAgICAgICAgY29udGVudCA9IENvbnRlbnQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9KTtcbiAgICAgIGNvbnRlbnRzID0gQ29sbGVjdGlvbihjb250ZW50cyk7XG4gICAgfSBlbHNlIGlmICghY29udGVudHMuaGFzT3duUHJvcGVydHkoJ2dldCcpIHx8XG4gICAgICAgICFjb250ZW50cy5oYXNPd25Qcm9wZXJ0eSgnYWRkJykpIHtcbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gZ2l2ZW4gYW4gb2JqZWN0IG1hcCAobGlrZSBmcm9tIGRhdGEgZmVlZClcbiAgICAgIGNvbnRlbnRzID0gT2JqZWN0LmtleXMoY29udGVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBDb250ZW50KFV0aWwuZXh0ZW5kKHsnaWQnOiBrZXl9LCBjb250ZW50c1trZXldKSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnRlbnRzID0gQ29sbGVjdGlvbihjb250ZW50cyk7XG4gICAgfVxuXG4gICAgX3RoaXMuc2V0KHtcbiAgICAgICdjb250ZW50cyc6IGNvbnRlbnRzLFxuICAgICAgJ3Byb3BlcnRpZXMnOiBwcm9wZXJ0aWVzXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhY2Nlc3MgcHJvZHVjdCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCB7U3RyaW5nfVxuICAgKiAgICAgY29udGVudCBwYXRoLlxuICAgKiBAcmV0dXJuIHtDb250ZW50fVxuICAgKiAgICAgY29udGVudCBvYmplY3QsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgX3RoaXMuZ2V0Q29udGVudCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIGNvbnRlbnRzO1xuICAgIGNvbnRlbnRzID0gX3RoaXMuZ2V0KCdjb250ZW50cycpO1xuICAgIHJldHVybiBjb250ZW50cy5nZXQocGF0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhY2Nlc3MgcHJvZHVjdCBwcm9wZXJ0eS4uXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIHtTdHJpbmd9XG4gICAqICAgICBwcm9wZXJ0eSBuYW1lLlxuICAgKiBAcmV0dXJuIHtDb250ZW50fVxuICAgKiAgICAgcHJvcGVydHkgdmFsdWUsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgX3RoaXMuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBwcm9wZXJ0aWVzO1xuICAgIHByb3BlcnRpZXMgPSBfdGhpcy5nZXQoJ3Byb3BlcnRpZXMnKTtcbiAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHByb2R1Y3QgaXMgZGVsZXRlZC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogICAgIHRydWUsIGlmIHByb2R1Y3Qgc3RhdHVzIGlzIFByb2R1Y3QuU1RBVFVTX0RFTEVURS5cbiAgICogICAgIGZhbHNlLCBvdGhlcndpc2UuXG4gICAqL1xuICBfdGhpcy5pc0RlbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXR1cztcbiAgICBzdGF0dXMgPSB0aGlzLmdldCgnc3RhdHVzJykudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoc3RhdHVzID09PSBQcm9kdWN0LlNUQVRVU19ERUxFVEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgcHJvZHVjdCBpcyByZXZpZXdlZC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogICAgdHJ1ZSwgaWYgcHJvZHVjdCByZXZpZXctc3RhdHVzIHByb3BlcnR5IGlzIGByZXZpZXdlZGAsXG4gICAqICAgIGZhbHNlLCBpZiBwcm9kdWN0IHJldmlldy1zdGF0dXMgcHJvcGVydHkgaXMgYW55IG90aGVyIHZhbHVlLFxuICAgKiAgICBudWxsLCBpZiBwcm9kdWN0IGRvZXMgbm90IGhhdmUgYSByZXZpZXctc3RhdHVzIHByb3BlcnR5LlxuICAgKi9cbiAgX3RoaXMuaXNSZXZpZXdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV2aWV3ZWQ7XG4gICAgcmV2aWV3ZWQgPSBfdGhpcy5nZXRQcm9wZXJ0eSgncmV2aWV3LXN0YXR1cycpO1xuICAgIGlmIChyZXZpZXdlZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIChyZXZpZXdlZC50b1VwcGVyQ2FzZSgpID09PSAnUkVWSUVXRUQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3RoaXMuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGNoYW5nZXMsXG4gICAgICAgIHByb3BlcnRpZXM7XG5cbiAgICBwcm9wZXJ0aWVzID0gX3RoaXMuZ2V0KCdwcm9wZXJ0aWVzJyk7XG4gICAgY2hhbmdlcyA9IFtdO1xuXG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICB2YWx1ZSA9IG9ialtwcm9wZXJ0eV07XG5cbiAgICAgIGlmIChwcm9wZXJ0aWVzW3Byb3BlcnR5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgcHJvcGVydGllc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICBfdGhpcy50cmlnZ2VyKCdjaGFuZ2U6cHJvcGVydHk6JyArIGNoYW5nZSk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy50cmlnZ2VyKCdjaGFuZ2U6cHJvcGVydHknKTtcbiAgICBfdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdG9KU09OIG1ldGhvZCBzbyBjb250ZW50cyBhcmUgb3V0cHV0IGFzIG9iamVjdCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBqc29uIHtPYmplY3R9XG4gICAqICAgICBKU09OaWZpZWQgb2JqZWN0IGZyb20gTW9kZWwudG9KU09OLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICBvYmplY3QsIHdpdGggY29udGVudHMgYXMgYW4gb2JqZWN0IHdpdGggY29udGVudCBwYXRocyBhcyBrZXlzLlxuICAgKi9cbiAgX3RoaXMudG9KU09OID0gVXRpbC5jb21wb3NlKF90aGlzLnRvSlNPTiwgZnVuY3Rpb24gKGpzb24pIHtcbiAgICB2YXIgb2JqZWN0Q29udGVudHMgPSB7fTtcblxuICAgIGpzb24uY29udGVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgdmFyIGlkO1xuXG4gICAgICBpZCA9IGNvbnRlbnQuaWQ7XG5cbiAgICAgIG9iamVjdENvbnRlbnRzW2lkXSA9IHtcbiAgICAgICAgY29udGVudFR5cGU6IGNvbnRlbnQuY29udGVudFR5cGUsXG4gICAgICAgIGxlbmd0aDogY29udGVudC5sZW5ndGgsXG4gICAgICAgIGxhc3RNb2RpZmllZDogY29udGVudC5sYXN0TW9kaWZpZWRcbiAgICAgIH07XG5cbiAgICAgIGlmIChjb250ZW50Lmhhc093blByb3BlcnR5KCd1cmwnKSAmJiBjb250ZW50LnVybCAhPT0gbnVsbCkge1xuICAgICAgICBvYmplY3RDb250ZW50c1tpZF0udXJsID0gY29udGVudC51cmw7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnQuaGFzT3duUHJvcGVydHkoJ2J5dGVzJykgJiYgY29udGVudC5ieXRlcyAhPT0gbnVsbCkge1xuICAgICAgICBvYmplY3RDb250ZW50c1tpZF0uYnl0ZXMgPSBjb250ZW50LmJ5dGVzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAganNvbi5jb250ZW50cyA9IG9iamVjdENvbnRlbnRzO1xuXG4gICAgcmV0dXJuIGpzb247XG4gIH0pO1xuXG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cblByb2R1Y3QuZ2V0QmFzZVR5cGUgPSBfZ2V0QmFzZVR5cGU7XG5Qcm9kdWN0LmdldEZ1bGxUeXBlID0gX2dldEZ1bGxUeXBlO1xuXG5Qcm9kdWN0LlNUQVRVU19VUERBVEUgPSBfU1RBVFVTX1VQREFURTtcblByb2R1Y3QuU1RBVFVTX0RFTEVURSA9IF9TVEFUVVNfREVMRVRFO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZHVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgQXR0cmlidXRpb24gPSByZXF1aXJlKCdjb3JlL0F0dHJpYnV0aW9uJyksXG4gICAgQmVhY2hCYWxsVmlldyA9IHJlcXVpcmUoJ21vbWVudC10ZW5zb3IvQmVhY2hCYWxsVmlldycpLFxuICAgIEZvcm1hdHRlciA9IHJlcXVpcmUoJ2NvcmUvRm9ybWF0dGVyJyksXG4gICAgUHJvZHVjdCA9IHJlcXVpcmUoJ3BkbC9Qcm9kdWN0JyksXG4gICAgU3VtbWFyeU1vZHVsZSA9IHJlcXVpcmUoJ2NvcmUvU3VtbWFyeU1vZHVsZScpLFxuICAgIFRlbnNvciA9IHJlcXVpcmUoJ21vbWVudC10ZW5zb3IvVGVuc29yJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpLFxuXG4gICAgLy8gdGhlc2UgbW9kdWxlcyBjcmVhdGUgYSBjaXJjdWxhciBkZXBlbmRlbmN5LFxuICAgIC8vIHJlcXVpcmUgdGhlbSBpbiBpbml0aWFsaXplXG4gICAgRmluaXRlRmF1bHRNb2R1bGUsXG4gICAgRm9jYWxNZWNoYW5pc21Nb2R1bGUsXG4gICAgTW9tZW50VGVuc29yTW9kdWxlLFxuICAgIE9yaWdpbk1vZHVsZTtcblxuXG5cbnZhciBfREVGQVVMVFMsXG4gICAgX0lELFxuICAgIF9USVRMRSxcbiAgICBfVFlQRVM7XG5cblxuX0lEID0gJ3NjaWVudGlmaWMnO1xuX1RJVExFID0gJ1RlY2huaWNhbCc7XG5fVFlQRVMgPSBbXG4gICdvcmlnaW4nLFxuICAncGhhc2UtZGF0YScsXG4gICdtb21lbnQtdGVuc29yJyxcbiAgJ2ZvY2FsLW1lY2hhbmlzbScsXG4gICdmaW5pdGUtZmF1bHQnLFxuICAnc2NpdGVjaC1saW5rJ1xuXTtcblxuX0RFRkFVTFRTID0ge1xuICBtdEZpbGxDb2xvcjogJyM2ZWE4ZmYnLFxuICBmbUZpbGxDb2xvcjogJyNmZmFhNjknXG59O1xuXG5cbi8qKlxuICogTW9kdWxlIGZvciB0aGUgc2NpZW50aWZpYyBzdW1tYXJ5IHBhZ2UuIFRoaXMgbW9kdWxlIHJlbmRlcnMgYSB0YWJsZS1saWtlXG4gKiBzZXQgb2Ygc3VtbWFyeS1sZXZlbCBkYXRhIGZvciB0aGUgcHJvZHVjdHMgY29udGFpbmVkIHdpdGhpbiB0aGUgXCJzY2llbnRpZmljXCJcbiAqIHNlY3Rpb24gb2YgdGhlIGV2ZW50IHBhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqICAgICBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgbW9kdWxlLiBTZWUgaW5pdGlhbGl6ZSBkb2N1bWVudGF0aW9uIGZvclxuICogICAgIGRldGFpbHMuXG4gKi9cbnZhciBTY2llbnRpZmljU3VtbWFyeU1vZHVsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfZm1GaWxsQ29sb3IsXG4gICAgICBfZm9ybWF0dGVyLFxuICAgICAgX210RmlsbENvbG9yO1xuXG5cbiAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBfdGhpcyA9IFN1bW1hcnlNb2R1bGUob3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yLiBJbml0aWFsaXplcyBhIG5ldyB7U2NpZW50aWZpY1N1bW1hcnlNb2R1bGV9LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICAgKiAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgbW9kdWxlLiBTcGVjaWZpY2FsbHkuLi5cbiAgICogQHBhcmFtIG9wdGlvbnMubXRGaWxsQ29sb3Ige1N0cmluZ31cbiAgICogICAgIEEgaGV4YWRlY2ltYWwgY29sb3IgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBtb21lbnQgdGVuc29ycy5cbiAgICogQHBhcmFtIG9wdGlvbnMuZm1GaWxsQ29sb3Ige1N0cmluZ31cbiAgICogICAgIEEgaGV4YWRlY2ltYWwgY29sb3IgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBmb2NhbCBtZWNoYW5pc21zLlxuICAgKi9cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIF90aGlzLklEID0gX0lEO1xuICAgIF90aGlzLlRJVExFID0gX1RJVExFO1xuXG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuICAgIF9tdEZpbGxDb2xvciA9IG9wdGlvbnMubXRGaWxsQ29sb3I7XG4gICAgX2ZtRmlsbENvbG9yID0gb3B0aW9ucy5mbUZpbGxDb2xvcjtcblxuICAgIC8vIHRoZXNlIG1vZHVsZXMgY3JlYXRlIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSxcbiAgICAvLyByZXF1aXJlIHRoZW0gZmlyc3QgdGltZSBpbml0aWFsaXplIGlzIGNhbGxlZFxuICAgIEZpbml0ZUZhdWx0TW9kdWxlID0gRmluaXRlRmF1bHRNb2R1bGUgfHxcbiAgICAgICAgcmVxdWlyZSgnZmluaXRlLWZhdWx0L0Zpbml0ZUZhdWx0TW9kdWxlJyk7XG4gICAgRm9jYWxNZWNoYW5pc21Nb2R1bGUgPSBGb2NhbE1lY2hhbmlzbU1vZHVsZSB8fFxuICAgICAgICByZXF1aXJlKCdmb2NhbC1tZWNoYW5pc20vRm9jYWxNZWNoYW5pc21Nb2R1bGUnKTtcbiAgICBNb21lbnRUZW5zb3JNb2R1bGUgPSBNb21lbnRUZW5zb3JNb2R1bGUgfHxcbiAgICAgICAgcmVxdWlyZSgnbW9tZW50LXRlbnNvci9Nb21lbnRUZW5zb3JNb2R1bGUnKTtcbiAgICBPcmlnaW5Nb2R1bGUgPSBPcmlnaW5Nb2R1bGUgfHxcbiAgICAgICAgcmVxdWlyZSgnb3JpZ2luL09yaWdpbk1vZHVsZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGcmVlcyByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbW9kdWxlLlxuICAgKlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgX2ZtRmlsbENvbG9yID0gbnVsbDtcbiAgICBfZm9ybWF0dGVyID0gbnVsbDtcbiAgICBfbXRGaWxsQ29sb3IgPSBudWxsO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHN1bW1hcnkgc2VjdGlvbiBmb3IgdGhlIGZpbml0ZSBmYXVsdCBwcm9kdWN0KHMpLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdHMge0FycmF5fVxuICAgKiAgICAgQW4gYXJyYXkgb2YgcHJvZHVjdHMgdG8gc3VtbWFyaXplLlxuICAgKlxuICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICAgKiAgICAgQSAocG90ZW50aWFsbHkgZW1wdHkpIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIHN1bW1hcnkgZm9yXG4gICAqICAgICB0aGUgZ2l2ZW4gc2V0IG9mIHByb2R1Y3RzLlxuICAgKi9cbiAgX3RoaXMuZ2V0RmluaXRlRmF1bHRTdW1tYXJ5ID0gZnVuY3Rpb24gKHByb2R1Y3RzKSB7XG4gICAgcmV0dXJuIF90aGlzLmNyZWF0ZVN1bW1hcnkocHJvZHVjdHMsICdGaW5pdGUgRmF1bHQnLCBbXG4gICAgICAgICdDYXRhbG9nJyxcbiAgICAgICAgJ1ByZXZpZXcnLFxuICAgICAgICAnU291cmNlJ1xuICAgICAgXSxcbiAgICAgIF90aGlzLmdldEZpbml0ZUZhdWx0Um93XG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJvdyB3aXRoIHN1bW1hcnkgaW5mb3JtYXRpb24gZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxuICAgKlxuICAgKiBAcGFyYW0gcHJvZHVjdCB7UHJvZHVjdH1cbiAgICogICAgIFRoZSBwcm9kdWN0IHRvIHN1bW1hcml6ZVxuICAgKiBAcGFyYW0gaW5kZXgge051bWJlcn1cbiAgICogICAgIFRoZSBwbGFjZSBpbiB3aGljaCB0aGlzIHByb2R1Y3QgcmFua3MgYW1vbmcgb3RoZXIgcHJvZHVjdHMgb2YgdGhlXG4gICAqICAgICBzYW1lIHR5cGUgd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBjdXJyZW50IGV2ZW50LiAwID0gbW9zdCBwcmVmZXJyZWRcbiAgICpcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH1cbiAgICogICAgIEEgVFIgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBfdGhpcy5nZXRGaW5pdGVGYXVsdFJvdyA9IGZ1bmN0aW9uIChwcm9kdWN0LCBpbmRleCkge1xuICAgIHZhciBtYXAsXG4gICAgICAgIHByZWZlcnJlZCxcbiAgICAgICAgcm93O1xuXG4gICAgbWFwID0gcHJvZHVjdC5nZXRDb250ZW50KCdiYXNlbWFwLnBuZycpO1xuICAgIHByZWZlcnJlZCA9IChpbmRleCA9PT0gMCk7XG4gICAgcm93ID0gX3RoaXMuY3JlYXRlUm93KHByZWZlcnJlZCk7XG5cbiAgICByb3cuaW5uZXJIVE1MID0gW1xuICAgICAgJzx0aCBzY29wZT1cInJvd1wiPicsXG4gICAgICAgIF90aGlzLmdldENhdGFsb2dNYXJrdXAoRmluaXRlRmF1bHRNb2R1bGUsIHByb2R1Y3QsIHByZWZlcnJlZCksXG4gICAgICAnPC90aD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICAnPGltZyBzcmM9XCInLCBtYXAuZ2V0KCd1cmwnKSwgJ1wiIGNsYXNzPVwiaW1hZ2VcIiBhbHQ9XCJGaW5pdGUgRmF1bHRcIi8+JyxcbiAgICAgICc8L3RkPicsXG4gICAgICAnPHRkPicsXG4gICAgICAgIEF0dHJpYnV0aW9uLmdldFByb2R1Y3RBdHRyaWJ1dGlvbihwcm9kdWN0KSxcbiAgICAgICc8L3RkPidcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgcmV0dXJuIHJvdztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgc3VtbWFyeSBzZWN0aW9uIGZvciB0aGUgZm9jYWwgbWVjaGFuaXNtIHByb2R1Y3QocykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9kdWN0cyB7QXJyYXl9XG4gICAqICAgICBBbiBhcnJheSBvZiBwcm9kdWN0cyB0byBzdW1tYXJpemUuXG4gICAqXG4gICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gICAqICAgICBBIChwb3RlbnRpYWxseSBlbXB0eSkgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgc3VtbWFyeSBmb3JcbiAgICogICAgIHRoZSBnaXZlbiBzZXQgb2YgcHJvZHVjdHMuXG4gICAqL1xuICBfdGhpcy5nZXRGb2NhbE1lY2hhbmlzbVN1bW1hcnkgPSBmdW5jdGlvbiAocHJvZHVjdHMpIHtcbiAgICByZXR1cm4gX3RoaXMuY3JlYXRlU3VtbWFyeShwcm9kdWN0cywgJ0ZvY2FsIE1lY2hhbmlzbScsIFtcbiAgICAgICAgJ0NhdGFsb2cnLFxuICAgICAgICAnTWVjaGFuaXNtJyxcbiAgICAgICAgJ05vZGFsIFBsYW4gMTxici8+PHNtYWxsPlN0cmlrZSwgRGlwLCBSYWtlPC9zbWFsbD4nLFxuICAgICAgICAnTm9kYWwgUGxhbiAxPGJyLz48c21hbGw+U3RyaWtlLCBEaXAsIFJha2U8L3NtYWxsPicsXG4gICAgICAgICdTb3VyY2UnXG4gICAgICBdLFxuICAgICAgX3RoaXMuZ2V0Rm9jYWxNZWNoYW5pc21Sb3cpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcm93IHdpdGggc3VtbWFyeSBpbmZvcm1hdGlvbiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9kdWN0IHtQcm9kdWN0fVxuICAgKiAgICAgVGhlIHByb2R1Y3QgdG8gc3VtbWFyaXplXG4gICAqIEBwYXJhbSBpbmRleCB7TnVtYmVyfVxuICAgKiAgICAgVGhlIHBsYWNlIGluIHdoaWNoIHRoaXMgcHJvZHVjdCByYW5rcyBhbW9uZyBvdGhlciBwcm9kdWN0cyBvZiB0aGVcbiAgICogICAgIHNhbWUgdHlwZSB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgZXZlbnQuIDAgPSBtb3N0IHByZWZlcnJlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fVxuICAgKiAgICAgQSBUUiBET00gZWxlbWVudC5cbiAgICovXG4gIF90aGlzLmdldEZvY2FsTWVjaGFuaXNtUm93ID0gZnVuY3Rpb24gKHByb2R1Y3QsIGluZGV4KSB7XG4gICAgdmFyIGJlYWNoYmFsbCxcbiAgICAgICAgbnAxLFxuICAgICAgICBucDIsXG4gICAgICAgIHByZWZlcnJlZCxcbiAgICAgICAgcm93LFxuICAgICAgICB0ZW5zb3I7XG5cbiAgICBwcmVmZXJyZWQgPSAoaW5kZXggPT09IDApO1xuICAgIHJvdyA9IF90aGlzLmNyZWF0ZVJvdyhwcmVmZXJyZWQpO1xuXG4gICAgdGVuc29yID0gVGVuc29yLmZyb21Qcm9kdWN0KHByb2R1Y3QpO1xuICAgIG5wMSA9IHRlbnNvci5OUDE7XG4gICAgbnAyID0gdGVuc29yLk5QMjtcblxuICAgIHJvdy5pbm5lckhUTUwgPSBbXG4gICAgICAnPHRoIHNjb3BlPVwicm93XCI+JyxcbiAgICAgICAgX3RoaXMuZ2V0Q2F0YWxvZ01hcmt1cChGb2NhbE1lY2hhbmlzbU1vZHVsZSwgcHJvZHVjdCwgcHJlZmVycmVkKSxcbiAgICAgICc8L3RoPicsXG4gICAgICAnPHRkIGNsYXNzPVwiYmVhY2hiYWxsXCI+PC90ZD4nLFxuICAgICAgJzx0ZD4oJyxcbiAgICAgICAgX2Zvcm1hdHRlci5hbmdsZShucDEuc3RyaWtlKSwgJywgJyxcbiAgICAgICAgX2Zvcm1hdHRlci5hbmdsZShucDEuZGlwKSwgJywgJyxcbiAgICAgICAgX2Zvcm1hdHRlci5hbmdsZShucDEucmFrZSksXG4gICAgICAnKTwvdGQ+JyxcbiAgICAgICc8dGQ+KCcsXG4gICAgICAgIF9mb3JtYXR0ZXIuYW5nbGUobnAyLnN0cmlrZSksICcsICcsXG4gICAgICAgIF9mb3JtYXR0ZXIuYW5nbGUobnAyLmRpcCksICcsICcsXG4gICAgICAgIF9mb3JtYXR0ZXIuYW5nbGUobnAyLnJha2UpLFxuICAgICAgJyk8L3RkPicsXG4gICAgICAnPHRkPicsXG4gICAgICAgIEF0dHJpYnV0aW9uLmdldFByb2R1Y3RBdHRyaWJ1dGlvbihwcm9kdWN0KSxcbiAgICAgICc8L3RkPidcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgYmVhY2hiYWxsID0gQmVhY2hCYWxsVmlldyh7XG4gICAgICBlbDogcm93LnF1ZXJ5U2VsZWN0b3IoJy5iZWFjaGJhbGwnKSxcbiAgICAgIGZpbGxDb2xvcjogX2ZtRmlsbENvbG9yLFxuICAgICAgbGFiZWxBeGVzOiBmYWxzZSxcbiAgICAgIGxhYmVsUGxhbmVzOiBmYWxzZSxcbiAgICAgIHNpemU6IDMwLFxuICAgICAgdGVuc29yOiB0ZW5zb3JcbiAgICB9KTtcblxuICAgIGJlYWNoYmFsbC5yZW5kZXIoKTtcbiAgICBiZWFjaGJhbGwuZGVzdHJveSgpO1xuICAgIGJlYWNoYmFsbCA9IG51bGw7XG5cbiAgICByZXR1cm4gcm93O1xuICB9O1xuXG4gIF90aGlzLmdldExpbmtzSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoZWFkZXI7XG5cbiAgICBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xuICAgIGhlYWRlci5pbm5lckhUTUwgPSAnU2NpZW50aWZpYyBhbmQgVGVjaG5pY2FsIExpbmtzJztcblxuICAgIHJldHVybiBoZWFkZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHN1bW1hcnkgc2VjdGlvbiBmb3IgdGhlIG1vbWVudCB0ZW5zb3IgcHJvZHVjdChzKS5cbiAgICpcbiAgICogQHBhcmFtIHByb2R1Y3RzIHtBcnJheX1cbiAgICogICAgIEFuIGFycmF5IG9mIHByb2R1Y3RzIHRvIHN1bW1hcml6ZS5cbiAgICpcbiAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICogICAgIEEgKHBvdGVudGlhbGx5IGVtcHR5KSBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHRoZSBzdW1tYXJ5IGZvclxuICAgKiAgICAgdGhlIGdpdmVuIHNldCBvZiBwcm9kdWN0cy5cbiAgICovXG4gIF90aGlzLmdldE1vbWVudFRlbnNvclN1bW1hcnkgPSBmdW5jdGlvbiAocHJvZHVjdHMpIHtcbiAgICByZXR1cm4gX3RoaXMuY3JlYXRlU3VtbWFyeShwcm9kdWN0cywgJ01vbWVudCBUZW5zb3InLCBbXG4gICAgICAgICdDYXRhbG9nJyxcbiAgICAgICAgJ1RlbnNvcicsXG4gICAgICAgICdNYWduaXR1ZGUnLFxuICAgICAgICAnRGVwdGgnLFxuICAgICAgICAnJSA8YWJiciB0aXRsZT1cIkRvdWJsZSBDb3VwbGVcIj5EQzwvYWJicj4nLFxuICAgICAgICAnU291cmNlJ1xuICAgICAgXSxcbiAgICAgIF90aGlzLmdldE1vbWVudFRlbnNvclJvd1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByb3cgd2l0aCBzdW1tYXJ5IGluZm9ybWF0aW9uIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cbiAgICpcbiAgICogQHBhcmFtIHByb2R1Y3Qge1Byb2R1Y3R9XG4gICAqICAgICBUaGUgcHJvZHVjdCB0byBzdW1tYXJpemVcbiAgICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9XG4gICAqICAgICBUaGUgcGxhY2UgaW4gd2hpY2ggdGhpcyBwcm9kdWN0IHJhbmtzIGFtb25nIG90aGVyIHByb2R1Y3RzIG9mIHRoZVxuICAgKiAgICAgc2FtZSB0eXBlIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgY3VycmVudCBldmVudC4gMCA9IG1vc3QgcHJlZmVycmVkXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG4gICAqICAgICBBIFRSIERPTSBlbGVtZW50LlxuICAgKi9cbiAgX3RoaXMuZ2V0TW9tZW50VGVuc29yUm93ID0gZnVuY3Rpb24gKHByb2R1Y3QsIGluZGV4KSB7XG4gICAgdmFyIGJlYWNoYmFsbCxcbiAgICAgICAgcHJlZmVycmVkLFxuICAgICAgICByb3csXG4gICAgICAgIHRlbnNvcjtcblxuICAgIHRlbnNvciA9IFRlbnNvci5mcm9tUHJvZHVjdChwcm9kdWN0KTtcbiAgICBwcmVmZXJyZWQgPSAoaW5kZXggPT09IDApO1xuICAgIHJvdyA9IF90aGlzLmNyZWF0ZVJvdyhwcmVmZXJyZWQpO1xuXG4gICAgcm93LmlubmVySFRNTCA9IFtcbiAgICAgICc8dGggc2NvcGU9XCJyb3dcIj4nLFxuICAgICAgICBfdGhpcy5nZXRDYXRhbG9nTWFya3VwKE1vbWVudFRlbnNvck1vZHVsZSwgcHJvZHVjdCwgcHJlZmVycmVkKSxcbiAgICAgICc8L3RoPicsXG4gICAgICAnPHRkIGNsYXNzPVwiYmVhY2hiYWxsXCI+PC90ZD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICBfZm9ybWF0dGVyLm1hZ25pdHVkZShcbiAgICAgICAgICB0ZW5zb3IubWFnbml0dWRlLFxuICAgICAgICAgIHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2Rlcml2ZWQtbWFnbml0dWRlLXR5cGUnKSB8fCAnTXcnXG4gICAgICAgICksXG4gICAgICAnPC90ZD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICBfZm9ybWF0dGVyLmRlcHRoKHRlbnNvci5kZXB0aCwgJ2ttJyksXG4gICAgICAnPC90ZD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICBNYXRoLnJvdW5kKHRlbnNvci5wZXJjZW50REMgKiAxMDApICsgJyAlJyxcbiAgICAgICc8L3RkPicsXG4gICAgICAnPHRkPicsXG4gICAgICAgIEF0dHJpYnV0aW9uLmdldFByb2R1Y3RBdHRyaWJ1dGlvbihwcm9kdWN0KSxcbiAgICAgICc8L3RkPidcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgYmVhY2hiYWxsID0gQmVhY2hCYWxsVmlldyh7XG4gICAgICBlbDogcm93LnF1ZXJ5U2VsZWN0b3IoJy5iZWFjaGJhbGwnKSxcbiAgICAgIGZpbGxDb2xvcjogX210RmlsbENvbG9yLFxuICAgICAgbGFiZWxBeGVzOiBmYWxzZSxcbiAgICAgIGxhYmVsUGxhbmVzOiBmYWxzZSxcbiAgICAgIHNpemU6IDMwLFxuICAgICAgdGVuc29yOiB0ZW5zb3JcbiAgICB9KTtcblxuICAgIGJlYWNoYmFsbC5yZW5kZXIoKTtcbiAgICBiZWFjaGJhbGwuZGVzdHJveSgpO1xuICAgIGJlYWNoYmFsbCA9IG51bGw7XG5cbiAgICByZXR1cm4gcm93O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgb3JpZ2luIGFuZCBwaGFzZS1kYXRhIHR5cGUgcHJvZHVjdHMgb24gdGhlIGdpdmVuIGV2ZW50LiBQcmVmZXJzXG4gICAqIHBoYXNlLWRhdGEgZnJvbSB0aGUgc2FtZSBzb3VyY2UgYW5kIGNvZGUgdW5sZXNzIHRoZXJlIGlzIGEgbmV3ZXJcbiAgICogY29ycmVzcG9uZGluZyBvcmlnaW4uXG4gICAqXG4gICAqIEBwYXJhbSBldiB7Q2F0YWxvZ0V2ZW50fVxuICAgKiAgICAgVGhlIGV2ZW50IHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgIEFuIGFycmF5IG9mIHtQcm9kdWN0fXMgb2YgZWl0aGVyIG9yaWdpbiBvciBwaGFzZS1kYXRhIHR5cGUuIE1vc3RcbiAgICogICAgIHByZWZlcnJlZCBwcm9kdWN0IGZpcnN0LlxuICAgKi9cbiAgX3RoaXMuZ2V0T3JpZ2luUHJvZHVjdHMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICB2YXIgY29uZmlnLFxuICAgICAgICBwcm9kdWN0cztcblxuICAgIGNvbmZpZyA9IF90aGlzLm1vZGVsLmdldCgnY29uZmlnJyk7XG5cbiAgICBpZiAoZXYpIHtcbiAgICAgIHByb2R1Y3RzID0gZXYuZ2V0UHJvZHVjdHMoUHJvZHVjdC5nZXRGdWxsVHlwZSgnb3JpZ2luJywgY29uZmlnKSkubWFwKFxuICAgICAgZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICB2YXIgcGhhc2U7XG5cbiAgICAgICAgLy8gRmluZCBhIGNvcnJlc3BvbmRpbmcgcGhhc2UtZGF0YSBwcm9kdWN0XG4gICAgICAgIHBoYXNlID0gZXYuZ2V0UHJvZHVjdEJ5SWQoUHJvZHVjdC5nZXRGdWxsVHlwZSgncGhhc2UtZGF0YScsIGNvbmZpZyksXG4gICAgICAgICAgICBvcmlnaW4uZ2V0KCdzb3VyY2UnKSwgb3JpZ2luLmdldCgnY29kZScpKTtcblxuICAgICAgICAvLyBQcmVmZXIgdGhlIHBoYXNlLWRhdGEgcHJvZHVjdCBpZiBpdCBpcyBhdCBsZWFzdCBhcyBuZXcgYXMgdGhlIG9yaWdpblxuICAgICAgICBpZiAocGhhc2UgJiYgcGhhc2UuZ2V0KCd1cGRhdGVUaW1lJykgPj0gb3JpZ2luLmdldCgndXBkYXRlVGltZScpKSB7XG4gICAgICAgICAgcmV0dXJuIHBoYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9kdWN0cyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9kdWN0cztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgc3VtbWFyeSBzZWN0aW9uIGZvciB0aGUgb3JpZ2luIHByb2R1Y3QocykuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9kdWN0cyB7QXJyYXl9XG4gICAqICAgICBBbiBhcnJheSBvZiBwcm9kdWN0cyB0byBzdW1tYXJpemUuXG4gICAqXG4gICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gICAqICAgICBBIChwb3RlbnRpYWxseSBlbXB0eSkgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgc3VtbWFyeSBmb3JcbiAgICogICAgIHRoZSBnaXZlbiBzZXQgb2YgcHJvZHVjdHMuXG4gICAqL1xuICBfdGhpcy5nZXRPcmlnaW5TdW1tYXJ5ID0gZnVuY3Rpb24gKHByb2R1Y3RzKSB7XG4gICAgcmV0dXJuIF90aGlzLmNyZWF0ZVN1bW1hcnkocHJvZHVjdHMsICdPcmlnaW4nLCBbXG4gICAgICAgICdDYXRhbG9nJyxcbiAgICAgICAgJzxhYmJyIHRpdGxlPVwiTWFnbml0dWRlXCI+TWFnPC9hYmJyPicsXG4gICAgICAgICdUaW1lJyxcbiAgICAgICAgJ0RlcHRoJyxcbiAgICAgICAgJ1JldmlldyBTdGF0dXMnLFxuICAgICAgICAnTG9jYXRpb24nLFxuICAgICAgICAnU291cmNlJ1xuICAgICAgXSxcbiAgICAgIF90aGlzLmdldE9yaWdpblJvd1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByb3cgd2l0aCBzdW1tYXJ5IGluZm9ybWF0aW9uIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cbiAgICpcbiAgICogQHBhcmFtIHByb2R1Y3Qge1Byb2R1Y3R9XG4gICAqICAgICBUaGUgcHJvZHVjdCB0byBzdW1tYXJpemVcbiAgICogQHBhcmFtIGluZGV4IHtOdW1iZXJ9XG4gICAqICAgICBUaGUgcGxhY2UgaW4gd2hpY2ggdGhpcyBwcm9kdWN0IHJhbmtzIGFtb25nIG90aGVyIHByb2R1Y3RzIG9mIHRoZVxuICAgKiAgICAgc2FtZSB0eXBlIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgY3VycmVudCBldmVudC4gMCA9IG1vc3QgcHJlZmVycmVkXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9XG4gICAqICAgICBBIFRSIERPTSBlbGVtZW50LlxuICAgKi9cbiAgX3RoaXMuZ2V0T3JpZ2luUm93ID0gZnVuY3Rpb24gKHByb2R1Y3QsIGluZGV4KSB7XG4gICAgdmFyIGV2ZW50VGltZSxcbiAgICAgICAgcHJlZmVycmVkLFxuICAgICAgICByZXZpZXdTdGF0dXMsXG4gICAgICAgIHJvdztcblxuICAgIGV2ZW50VGltZSA9IG5ldyBEYXRlKHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2V2ZW50dGltZScpKTtcbiAgICBwcmVmZXJyZWQgPSAoaW5kZXggPT09IDApO1xuICAgIHJvdyA9IF90aGlzLmNyZWF0ZVJvdyhwcmVmZXJyZWQpO1xuICAgIHJldmlld1N0YXR1cyA9IHByb2R1Y3QuZ2V0UHJvcGVydHkoJ3Jldmlldy1zdGF0dXMnKSB8fCAnYXV0b21hdGljJztcblxuICAgIHJvdy5pbm5lckhUTUwgPSBbXG4gICAgICAnPHRoIHNjb3BlPVwicm93XCI+JyxcbiAgICAgICAgX3RoaXMuZ2V0Q2F0YWxvZ01hcmt1cChPcmlnaW5Nb2R1bGUsIHByb2R1Y3QsIHByZWZlcnJlZCksXG4gICAgICAnPC90aD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICBfZm9ybWF0dGVyLm1hZ25pdHVkZShcbiAgICAgICAgICBwcm9kdWN0LmdldFByb3BlcnR5KCdtYWduaXR1ZGUnKSxcbiAgICAgICAgICBwcm9kdWN0LmdldFByb3BlcnR5KCdtYWduaXR1ZGUtdHlwZScpXG4gICAgICAgICksXG4gICAgICAnPC90ZD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICAnPGFiYnIgdGl0bGU9XCInLCBfZm9ybWF0dGVyLmRhdGV0aW1lKGV2ZW50VGltZSwgMCksICdcIj4nLFxuICAgICAgICAgIF9mb3JtYXR0ZXIudGltZShldmVudFRpbWUpLFxuICAgICAgICAnPC9hYmJyPicsXG4gICAgICAnPC90ZD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICBfZm9ybWF0dGVyLmRlcHRoKHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2RlcHRoJykpLFxuICAgICAgJzwvdGQ+JyxcbiAgICAgICc8dGQ+JyxcbiAgICAgICAgcmV2aWV3U3RhdHVzLnRvVXBwZXJDYXNlKCksXG4gICAgICAnPC90ZD4nLFxuICAgICAgJzx0ZD4nLFxuICAgICAgICBfZm9ybWF0dGVyLmxvY2F0aW9uKFxuICAgICAgICAgIHByb2R1Y3QuZ2V0UHJvcGVydHkoJ2xhdGl0dWRlJyksXG4gICAgICAgICAgcHJvZHVjdC5nZXRQcm9wZXJ0eSgnbG9uZ2l0dWRlJylcbiAgICAgICAgKSxcbiAgICAgICc8L3RkPicsXG4gICAgICAnPHRkPicsXG4gICAgICAgIEF0dHJpYnV0aW9uLmdldFByb2R1Y3RBdHRyaWJ1dGlvbihwcm9kdWN0KSxcbiAgICAgICc8L3RkPidcbiAgICBdLmpvaW4oJycpO1xuXG4gICAgcmV0dXJuIHJvdztcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbW9kdWxlIGhlYWRlciwgY29udGVudCwgYW5kIGZvb3Rlci5cbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmF1bHRzLFxuICAgICAgICBmcmFnbWVudCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgbGlua3MsXG4gICAgICAgIG1lY2hzLFxuICAgICAgICBvcmlnaW5zLFxuICAgICAgICB0ZW5zb3JzLFxuICAgICAgICB0ZXh0cztcblxuICAgIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgX3RoaXMuY2xlYXJMaW5rcyh0cnVlKTtcbiAgICBfdGhpcy5jbGVhclRleHRzKHRydWUpO1xuXG4gICAgZmF1bHRzID0gX3RoaXMuZ2V0UHJvZHVjdHMoJ2Zpbml0ZS1mYXVsdCcpO1xuICAgIGhlYWRlcnMgPSBfdGhpcy5nZXRQcm9kdWN0cygnc2NpdGVjaC1oZWFkZXInKTtcbiAgICBsaW5rcyA9IF90aGlzLmdldFByb2R1Y3RzKCdzY2l0ZWNoLWxpbmsnKTtcbiAgICBtZWNocyA9IF90aGlzLmdldFByb2R1Y3RzKCdmb2NhbC1tZWNoYW5pc20nKTtcbiAgICBvcmlnaW5zID0gX3RoaXMuZ2V0T3JpZ2luUHJvZHVjdHMoX3RoaXMubW9kZWwuZ2V0KCdldmVudCcpKTtcbiAgICB0ZW5zb3JzID0gX3RoaXMuZ2V0UHJvZHVjdHMoJ21vbWVudC10ZW5zb3InKTtcbiAgICB0ZXh0cyA9IF90aGlzLmdldFByb2R1Y3RzKCdzY2l0ZWNoLXRleHQnKTtcblxuICAgIFV0aWwuZW1wdHkoX3RoaXMuaGVhZGVyKTtcbiAgICBfdGhpcy5oZWFkZXIuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0VGV4dHMoaGVhZGVycykpO1xuXG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0T3JpZ2luU3VtbWFyeShvcmlnaW5zKSk7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0TW9tZW50VGVuc29yU3VtbWFyeSh0ZW5zb3JzKSk7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0RmluaXRlRmF1bHRTdW1tYXJ5KGZhdWx0cykpO1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKF90aGlzLmdldEZvY2FsTWVjaGFuaXNtU3VtbWFyeShtZWNocykpO1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKF90aGlzLmdldFRleHRzKHRleHRzKSk7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoX3RoaXMuZ2V0TGlua3MobGlua3MpKTtcblxuICAgIFV0aWwuZW1wdHkoX3RoaXMuY29udGVudCk7XG4gICAgX3RoaXMuY29udGVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cbiAgICBfdGhpcy5mb290ZXIuaW5uZXJIVE1MID0gJyc7XG4gIH07XG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cblNjaWVudGlmaWNTdW1tYXJ5TW9kdWxlLklEID0gX0lEO1xuU2NpZW50aWZpY1N1bW1hcnlNb2R1bGUuVElUTEUgPSBfVElUTEU7XG5TY2llbnRpZmljU3VtbWFyeU1vZHVsZS5UWVBFUyA9IF9UWVBFUztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaWVudGlmaWNTdW1tYXJ5TW9kdWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBDb250ZW50VmlldyA9IHJlcXVpcmUoJ2NvcmUvQ29udGVudFZpZXcnKSxcbiAgICBGb3JtYXR0ZXIgPSByZXF1aXJlKCdjb3JlL0Zvcm1hdHRlcicpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0RFRkFVTFRTID0ge1xuICBlbXB0eTogJyZuZGFzaDsnLFxuICBmb3JtYXR0ZXI6IG51bGxcbn07XG5cblxuLyoqXG4gKiBWaWV3IGZvciBTaGFrZU1hcCBpbmZvLmpzb24gY29udGVudC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogQHBhcmFtIG9wdGlvbnMuZW1wdHkge1N0cmluZ31cbiAqICAgICB2YWx1ZSB0byBkaXNwbGF5IGlmIGEgZmllbGQgaXMgbWlzc2luZyBvciBlbXB0eS5cbiAqICAgICBkZWZhdWx0ICcmbmRhc2g7Jy5cbiAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdHRlciB7Rm9ybWF0dGVyfVxuICogICAgIGZvcm1hdHRpbmcgb2JqZWN0LlxuICovXG52YXIgU2hha2VNYXBJbmZvVmlldyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfZW1wdHksXG4gICAgICBfZm9ybWF0dGVyO1xuXG5cbiAgX3RoaXMgPSBDb250ZW50VmlldyhvcHRpb25zKTtcblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBfREVGQVVMVFMsIG9wdGlvbnMpO1xuICAgIF9lbXB0eSA9IG9wdGlvbnMuZW1wdHk7XG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEZvcm1hdCBvbmUgZ3JvdW5kIG1vdGlvbiByb3cuXG4gICAqXG4gICAqIEBwYXJhbSBnbSB7T2JqZWN0fVxuICAgKiAgICAgZ3JvdW5kIG1vdGlvbiBvYmplY3QuXG4gICAqIEBwYXJhbSBsYWJlbCB7U3RyaW5nfVxuICAgKiAgICAgbWFya3VwIGZvciBgdGhgIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgIG1hcmt1cCBmb3IgdGFibGUgcm93LlxuICAgKi9cbiAgX3RoaXMuZm9ybWF0R3JvdW5kTW90aW9uID0gZnVuY3Rpb24gKGdtLCBsYWJlbCkge1xuICAgIHZhciB1bml0cztcblxuICAgIHVuaXRzID0gZ20udW5pdHM7XG5cbiAgICByZXR1cm4gJzx0cj4nICtcbiAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPicgKyBsYWJlbCArICc8L3RoPicgK1xuICAgICAgICAnPHRkPicgKyBnbS5tYXhfZ3JpZCArICcgJyArIHVuaXRzICsgJzwvdGQ+JyArXG4gICAgICAgICc8dGQ+JyArIGdtLm1heCArICcgJyArIHVuaXRzICsgJzwvdGQ+JyArXG4gICAgICAgICc8dGQ+JyArIGdtLmJpYXMgKyAnPC90ZD4nICtcbiAgICAgICAgJzwvdHI+JztcbiAgfTtcblxuICAvKipcbiAgICogRm9ybWF0IHRoZSBvdXRwdXQgZ3JvdW5kIG1vdGlvbnMgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSBncm91bmRNb3Rpb25zIHtPYmplY3R9XG4gICAqICAgICB0aGUgb3V0cHV0IGdyb3VuZCBtb3Rpb25zIHNlY3Rpb24gb2YgaW5mby5qc29uLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICBtYXJrdXAgZm9yIG91dHB1dCBncm91bmQgbW90aW9ucyB0YWJsZS5cbiAgICovXG4gIF90aGlzLmZvcm1hdE91dHB1dEdyb3VuZE1vdGlvbnMgPSBmdW5jdGlvbiAoZ3JvdW5kTW90aW9ucykge1xuICAgIHZhciBidWYsXG4gICAgICAgIGhlYWRlcnM7XG5cbiAgICBidWYgPSBbXTtcbiAgICBidWYucHVzaCgnPGgzPkdyb3VuZCBNb3Rpb24vSW50ZW5zaXR5IEluZm9ybWF0aW9uPC9oMz4nKTtcblxuICAgIGJ1Zi5wdXNoKFxuICAgICAgICAnPGRpdiBjbGFzcz1cImhvcml6b250YWwtc2Nyb2xsaW5nXCI+JyArXG4gICAgICAgICc8dGFibGU+JyArXG4gICAgICAgICc8dGhlYWQ+JyArXG4gICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj5UeXBlPC90aD4nICtcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj5NYXggdmFsdWUgaW4gZ3JpZDwvdGg+JyArXG4gICAgICAgICAgICAnPHRoIHNjb3BlPVwiY29sXCI+TWF4IHZhbHVlIG9uIGxhbmQ8L3RoPicgK1xuICAgICAgICAgICAgJzx0aCBzY29wZT1cImNvbFwiPkJpYXM8L3RoPicgK1xuICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAnPC90aGVhZD4nICtcbiAgICAgICAgJzx0Ym9keT4nKTtcblxuICAgIGhlYWRlcnMgPSB7XG4gICAgICAnaW50ZW5zaXR5JzogJ0ludGVuc2l0eScsXG4gICAgICAncGdhJzogJzxhYmJyIHRpdGxlPVwiUGVhayBHcm91bmQgQWNjZWxlcmF0aW9uXCI+UEdBPC9hYmJyPicsXG4gICAgICAncGd2JzogJzxhYmJyIHRpdGxlPVwiUGVhayBHcm91bmQgVmVsb2NpdHlcIj5QR1Y8L2FiYnI+JyxcbiAgICAgICdwc2EwMyc6ICc8YWJiciB0aXRsZT1cIlBzZXVkbyBTcGVjdHJhbCBBY2NlbGVyYXRpb24gMC4zIHNcIj4nICtcbiAgICAgICAgICAnUFNBMDM8L2FiYnI+JyxcbiAgICAgICdwc2ExMCc6ICc8YWJiciB0aXRsZT1cIlBzZXVkbyBTcGVjdHJhbCBBY2NlbGVyYXRpb24gMS4wIHNcIj4nICtcbiAgICAgICAgICAnUFNBMTA8L2FiYnI+JyxcbiAgICAgICdwc2EzMCc6ICc8YWJiciB0aXRsZT1cIlBzZXVkbyBTcGVjdHJhbCBBY2NlbGVyYXRpb24gMy4wIHNcIj4nICtcbiAgICAgICAgICAnUFNBMzA8L2FiYnI+J1xuICAgIH07XG5cbiAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gZ3JvdW5kTW90aW9ucykge1xuICAgICAgICBidWYucHVzaChfdGhpcy5mb3JtYXRHcm91bmRNb3Rpb24oZ3JvdW5kTW90aW9uc1trZXldLCBoZWFkZXJzW2tleV0pKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKGdyb3VuZE1vdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCEoa2V5IGluIGhlYWRlcnMpKSB7XG4gICAgICAgIC8vIHVua25vd24gZ3JvdW5kTW90aW9uXG4gICAgICAgIGJ1Zi5wdXNoKF90aGlzLmZvcm1hdEdyb3VuZE1vdGlvbihncm91bmRNb3Rpb25zW2tleV0sIGtleSkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYnVmLnB1c2goXG4gICAgICAgICc8L3Rib2R5PicgK1xuICAgICAgICAnPC90YWJsZT4nICtcbiAgICAgICAgJzwvZGl2PicpO1xuXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogRm9ybWF0IHRoZSBvdXRwdXQgbWFwIGluZm9ybWF0aW9uIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gbWFwSW5mb3JtYXRpb24ge09iamVjdH1cbiAgICogICAgIHRoZSBvdXRwdXQgbWFwIGluZm9ybWF0aW9uIHNlY3Rpb24gb2YgaW5mby5qc29uLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICBtYXJrdXAgZm9yIHRoZSBtYXAgaW5mb3JtYXRpb24gdGFibGUuXG4gICAqL1xuICBfdGhpcy5mb3JtYXRPdXRwdXRNYXBJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uIChtYXBJbmZvcm1hdGlvbikge1xuICAgIHZhciBncmlkUG9pbnRzLFxuICAgICAgICBncmlkU3BhbixcbiAgICAgICAgZ3JpZFNwYWNpbmcsXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluO1xuXG4gICAgZ3JpZFBvaW50cyA9IG1hcEluZm9ybWF0aW9uLmdyaWRfcG9pbnRzO1xuICAgIGdyaWRTcGFuID0gbWFwSW5mb3JtYXRpb24uZ3JpZF9zcGFuO1xuICAgIGdyaWRTcGFjaW5nID0gbWFwSW5mb3JtYXRpb24uZ3JpZF9zcGFjaW5nO1xuICAgIG1heCA9IG1hcEluZm9ybWF0aW9uLm1heDtcbiAgICBtaW4gPSBtYXBJbmZvcm1hdGlvbi5taW47XG5cbiAgICByZXR1cm4gJzxoMz5NYXAgSW5mb3JtYXRpb248L2gzPicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cImhvcml6b250YWwtc2Nyb2xsaW5nXCI+JyArXG4gICAgICAgICc8dGFibGU+JyArXG4gICAgICAgICAgJzx0aGVhZD4nICtcbiAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgJzx0aCBzY29wZT1cImNvbFwiPlR5cGU8L3RoPicgK1xuICAgICAgICAgICAgJzx0aCBzY29wZT1cImNvbFwiPkxhdGl0dWRlPC90aD4nICtcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj5Mb25naXR1ZGU8L3RoPicgK1xuICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICc8L3RoZWFkPicgK1xuICAgICAgICAgICc8dGJvZHk+JyArXG4gICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5TcGFuPC90aD4nICtcbiAgICAgICAgICAgICc8dGQ+JyArIGdyaWRTcGFuLmxhdGl0dWRlICsgJyZkZWc7PC90ZD4nICtcbiAgICAgICAgICAgICc8dGQ+JyArIGdyaWRTcGFuLmxvbmdpdHVkZSArICcmZGVnOzwvdGQ+JyArXG4gICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5HcmlkIFNwYWNpbmc8L3RoPicgK1xuICAgICAgICAgICAgJzx0ZD4nICsgZ3JpZFNwYWNpbmcubGF0aXR1ZGUgKyAnIGttPC90ZD4nICtcbiAgICAgICAgICAgICc8dGQ+JyArIGdyaWRTcGFjaW5nLmxvbmdpdHVkZSArICcga208L3RkPicgK1xuICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TnVtYmVyIG9mIHBvaW50czwvdGg+JyArXG4gICAgICAgICAgICAnPHRkPicgKyBncmlkUG9pbnRzLmxhdGl0dWRlICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAnPHRkPicgKyBncmlkUG9pbnRzLmxvbmdpdHVkZSArICc8L3RkPicgK1xuICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TWluPC90aD4nICtcbiAgICAgICAgICAgICc8dGQ+JyArIF9mb3JtYXR0ZXIubGF0aXR1ZGUobWluLmxhdGl0dWRlKSArICc8L3RkPicgK1xuICAgICAgICAgICAgJzx0ZD4nICsgX2Zvcm1hdHRlci5sb25naXR1ZGUobWluLmxvbmdpdHVkZSkgKyAnPC90ZD4nICtcbiAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk1heDwvdGg+JyArXG4gICAgICAgICAgICAnPHRkPicgKyBfZm9ybWF0dGVyLmxhdGl0dWRlKG1heC5sYXRpdHVkZSkgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8dGQ+JyArIF9mb3JtYXR0ZXIubG9uZ2l0dWRlKG1heC5sb25naXR1ZGUpICsgJzwvdGQ+JyArXG4gICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgJzwvdGJvZHk+JyArXG4gICAgICAgICc8L3RhYmxlPicgK1xuICAgICAgICAnPC9kaXY+JztcbiAgfTtcblxuICAvKipcbiAgICogRm9ybWF0IHRoZSBwcm9jZXNzaW5nIGdyb3VuZCBtb3Rpb25zIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gZ3JvdW5kTW90aW9ucyB7T2JqZWN0fVxuICAgKiAgICAgdGhlIHByb2Nlc3NpbmcgZ3JvdW5kIG1vdGlvbnMgc2VjdGlvbiBvZiBpbmZvLmpzb24uXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICogICAgIG1hcmt1cCBmb3IgcHJvY2Vzc2luZyBncm91bmQgbW90aW9ucyB0YWJsZS5cbiAgICovXG4gIF90aGlzLmZvcm1hdFByb2Nlc3NpbmdHcm91bmRNb3Rpb25zID0gZnVuY3Rpb24gKGdyb3VuZE1vdGlvbnMpIHtcbiAgICB2YXIgYnVmLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBmb3JtYXRHcm91bmRNb3Rpb247XG5cbiAgICBidWYgPSBbXTtcbiAgICBidWYucHVzaCgnPGgzPkdyb3VuZCBNb3Rpb24vSW50ZW5zaXR5IEluZm9ybWF0aW9uPC9oMz4nKTtcblxuICAgIGJ1Zi5wdXNoKFxuICAgICAgICAnPGRpdiBjbGFzcz1cImhvcml6b250YWwtc2Nyb2xsaW5nXCI+JyArXG4gICAgICAgICc8dGFibGU+JyArXG4gICAgICAgICAgJzx0aGVhZD4nICtcbiAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAnPHRoIHNjb3BlPVwiY29sXCI+VHlwZTwvdGg+JyArXG4gICAgICAgICAgICAnPHRoIHNjb3BlPVwiY29sXCI+TW9kdWxlPC90aD4nICtcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIj5SZWZlcmVuY2U8L3RoPicgK1xuICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgJzwvdGhlYWQ+JyArXG4gICAgICAgICAgJzx0Ym9keT4nKTtcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBvbmUgZ3JvdW5kIG1vdGlvbiByb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ20ge09iamVjdH1cbiAgICAgKiAgICAgZ3JvdW5kIG1vdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIGxhYmVsIHtTdHJpbmd9XG4gICAgICogICAgIG1hcmt1cCBmb3IgYHRoYCBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiAgICAgbWFya3VwIGZvciB0YWJsZSByb3cuXG4gICAgICovXG4gICAgZm9ybWF0R3JvdW5kTW90aW9uID0gZnVuY3Rpb24gKGdtLCBsYWJlbCkge1xuICAgICAgdmFyIHVuaXRzO1xuXG4gICAgICB1bml0cyA9IGdtLnVuaXRzO1xuXG4gICAgICByZXR1cm4gJzx0cj4nICtcbiAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+JyArIGxhYmVsICsgJzwvdGg+JyArXG4gICAgICAgICAgJzx0ZD4nICsgZ20ubW9kdWxlICsgJzwvdGQ+JyArXG4gICAgICAgICAgJzx0ZD4nICsgZ20ucmVmZXJlbmNlICsgJzwvdGQ+JyArXG4gICAgICAgICc8L3RyPic7XG4gICAgfTtcblxuICAgIGhlYWRlcnMgPSB7XG4gICAgICAnZ21wZSc6ICc8YWJiciB0aXRsZT1cIkdyb3VuZCBNb3Rpb24gUHJlZGljdGlvbiBFcXVhdGlvblwiPkdNUEU8L2FiYnI+JyxcbiAgICAgICdpcGUnOiAnPGFiYnIgdGl0bGU9XCJJbnRlbnNpdHkgUHJlZGljdGlvbiBFcXVhdGlvblwiPklQRTwvYWJicj4nLFxuICAgICAgJ21pMnBnbSc6ICc8YWJiciB0aXRsZT1cIkdyb3VuZCBNb3Rpb24gSW50ZW5zaXR5IENvbnZlcnNpb24gRXF1YXRpb25cIj4nICtcbiAgICAgICAgICAnR01JQ0U8L2FiYnI+JyxcbiAgICAgICdwZ20ybWknOlxuICAgICAgICAgICc8YWJiciB0aXRsZT1cIkludmVyc2UgR3JvdW5kIE1vdGlvbiBJbnRlbnNpdHkgQ29udmVyc2lvbiBFcXVhdGlvblwiPicgK1xuICAgICAgICAgICdJR01JQ0U8L2FiYnI+JyxcbiAgICAgICdkaXJlY3Rpdml0eSc6ICdEaXJlY3Rpdml0eScsXG4gICAgICAnYmFzaW5fY29ycmVjdGlvbic6ICdCYXNpbidcbiAgICB9O1xuXG4gICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoa2V5IGluIGdyb3VuZE1vdGlvbnMpIHtcbiAgICAgICAgYnVmLnB1c2goZm9ybWF0R3JvdW5kTW90aW9uKGdyb3VuZE1vdGlvbnNba2V5XSwgaGVhZGVyc1trZXldKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMoZ3JvdW5kTW90aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIShrZXkgaW4gaGVhZGVycykpIHtcbiAgICAgICAgLy8gdW5rbm93biBncm91bmRNb3Rpb25cbiAgICAgICAgYnVmLnB1c2goZm9ybWF0R3JvdW5kTW90aW9uKGdyb3VuZE1vdGlvbnNba2V5XSwga2V5KSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBidWYucHVzaCgnPC90Ym9keT4nICtcbiAgICAgICAgJzwvdGFibGU+JyArXG4gICAgICAnPC9kaXY+Jyk7XG5cbiAgICByZXR1cm4gYnVmLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JtYXQgdGhlIHByb2Nlc3NpbmcgZ3JvdW5kIG1vdGlvbnMgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSByb2lzIHtPYmplY3R9XG4gICAqICAgICB0aGUgcHJvY2Vzc2luZyByb2lzIHNlY3Rpb24gb2YgaW5mby5qc29uLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqICAgICBtYXJrdXAgZm9yIHByb2Nlc3Npbmcgcm9pcyB0YWJsZS5cbiAgICovXG4gIF90aGlzLmZvcm1hdFByb2Nlc3NpbmdSb2lzID0gZnVuY3Rpb24gKHJvaXMpIHtcbiAgICB2YXIgZ3JvdW5kTW90aW9uLFxuICAgICAgICBpbnRlbnNpdHk7XG5cbiAgICBncm91bmRNb3Rpb24gPSByb2lzLmdtO1xuICAgIGludGVuc2l0eSA9IHJvaXMuaW50ZW5zaXR5O1xuXG4gICAgcmV0dXJuICc8aDM+Uk9JPC9oMz4nICtcbiAgICAgICc8ZGl2IGNsYXNzPVwiaG9yaXpvbnRhbC1zY3JvbGxpbmdcIj4nICtcbiAgICAgICAgJzx0YWJsZT4nICtcbiAgICAgICAgICAnPHRoZWFkPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cImNvbFwiPlR5cGU8L3RoPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwiY29sXCI+Uk9JPC90aD4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cImNvbFwiPk9ic2VydmF0aW9uIERlY2F5PC90aD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICc8L3RoZWFkPicgK1xuICAgICAgICAgICc8dGJvZHk+JyArXG4gICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+R3JvdW5kIE1vdGlvbjwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIGdyb3VuZE1vdGlvbi5yb2kgKyAnIGttPC90ZD4nICtcbiAgICAgICAgICAgICAgJzx0ZD4nICsgZ3JvdW5kTW90aW9uLmRlY2F5ICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5JbnRlbnNpdHk8L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyBpbnRlbnNpdHkucm9pICsgJyBrbTwvdGQ+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIGludGVuc2l0eS5kZWNheSArICc8L3RkPicgK1xuICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgJzwvdGJvZHk+JyArXG4gICAgICAgICc8L3RhYmxlPicgK1xuICAgICAgJzwvZGl2Pic7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVycm9yIGNhbGxiYWNrIGlmIHVuYWJsZSB0byBsb2FkIGluZm8uanNvbi5cbiAgICovXG4gIF90aGlzLm9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gJzxwIGNsYXNzPVwiYWxlcnQgZXJyb3JcIj4nICtcbiAgICAgICAgJ1VuYWJsZSB0byBsb2FkIFNoYWtlTWFwIGluZm9ybWF0aW9uJyArXG4gICAgICAnPC9wPic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN1Y2Nlc3MgY2FsbGJhY2ssIG9uY2UgaW5mby5qc29uIGhhcyBsb2FkZWQuXG4gICAqL1xuICBfdGhpcy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciBlbCA9IF90aGlzLmVsO1xuXG4gICAgZWwuaW5uZXJIVE1MID1cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJyb3dcIj4nICtcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cIm9uZS1vZi10d28gY29sdW1uIHNoYWtlbWFwaW5mby1pbnB1dFwiPjwvZGl2PicgK1xuICAgICAgICAgICc8ZGl2IGNsYXNzPVwib25lLW9mLXR3byBjb2x1bW4gc2hha2VtYXBpbmZvLW91dHB1dFwiPjwvZGl2PicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwic2hha2VtYXBpbmZvLXByb2Nlc3NpbmdcIj48L2Rpdj4nO1xuXG4gICAgX3RoaXMucmVuZGVySW5wdXQoanNvbiwgZWwucXVlcnlTZWxlY3RvcignLnNoYWtlbWFwaW5mby1pbnB1dCcpKTtcbiAgICBfdGhpcy5yZW5kZXJQcm9jZXNzaW5nKGpzb24sIGVsLnF1ZXJ5U2VsZWN0b3IoJy5zaGFrZW1hcGluZm8tcHJvY2Vzc2luZycpKTtcbiAgICBfdGhpcy5yZW5kZXJPdXRwdXQoanNvbiwgZWwucXVlcnlTZWxlY3RvcignLnNoYWtlbWFwaW5mby1vdXRwdXQnKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgaW5wdXQgc2VjdGlvbiBvZiBpbmZvLmpzb24uXG4gICAqXG4gICAqIEBwYXJhbSBlbCB7RE9NRWxlbWVudH1cbiAgICogICAgICAgIGVsZW1lbnQgd2hlcmUgY29udGVudCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJJbnB1dCA9IGZ1bmN0aW9uIChqc29uLCBlbCkge1xuICAgIHZhciBidWYsXG4gICAgICAgIGluZm8sXG4gICAgICAgIGlucHV0O1xuXG4gICAgaW5wdXQgPSBqc29uLmlucHV0O1xuXG4gICAgYnVmID0gW107XG4gICAgYnVmLnB1c2goJzxoMj5JbnB1dDwvaDI+Jyk7XG5cbiAgICBpbmZvID0gaW5wdXQuZXZlbnRfaW5mb3JtYXRpb247XG4gICAgYnVmLnB1c2goJzxoMz5FdmVudCBJbmZvcm1hdGlvbjwvaDM+JyArXG4gICAgICAnPGRpdiBjbGFzcz1cImhvcml6b250YWwtc2Nyb2xsaW5nXCI+JyArXG4gICAgICAgICc8dGFibGU+JyArXG4gICAgICAgICAgJzx0Ym9keT4nICtcbiAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5EZXNjcmlwdGlvbjwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIGluZm8uZXZlbnRfZGVzY3JpcHRpb24gKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPklEPC90aD4nICtcbiAgICAgICAgICAgICAgJzx0ZD4nICsgaW5mby5ldmVudF9pZCArICc8L3RkPicgK1xuICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TWFnbml0dWRlPC90aD4nICtcbiAgICAgICAgICAgICAgJzx0ZD4nICsgX2Zvcm1hdHRlci5tYWduaXR1ZGUoaW5mby5tYWduaXR1ZGUpICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5EZXB0aDwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIF9mb3JtYXR0ZXIuZGVwdGgoaW5mby5kZXB0aCwgJ2ttJykgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkxvbmdpdHVkZTwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIF9mb3JtYXR0ZXIubG9uZ2l0dWRlKGluZm8ubG9uZ2l0dWRlKSArICc8L3RkPicgK1xuICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TGF0aXR1ZGU8L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyBfZm9ybWF0dGVyLmxhdGl0dWRlKGluZm8ubGF0aXR1ZGUpICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5PcmlnaW4gVGltZTwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIGluZm8ub3JpZ2luX3RpbWUgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk1lY2hhbmlzbTwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIChpbmZvLnNyY19tZWNoIHx8IF9lbXB0eSkgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk1lY2hhbmlzbSBzb3VyY2U8L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyAoaW5mby5tZWNoX3NyYyB8fCBfZW1wdHkpICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5Mb2NhdGlvbjwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIGluZm8ubG9jYXRpb24gKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkZsaW5uIEVuZ2RhaGwgcmVnaW9uPC90aD4nICtcbiAgICAgICAgICAgICAgJzx0ZD4nICsgaW5mby5mZXJlZ2lvbiArICc8L3RkPicgK1xuICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+RmF1bHQgZmlsZShzKTwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIChpbmZvLmZhdWx0ZmlsZXMgfHwgX2VtcHR5KSArICc8L3RkPicgK1xuICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+RmF1bHQgcmVmZXJlbmNlKHMpPC90aD4nICtcbiAgICAgICAgICAgICAgJzx0ZD4nICsgKGluZm8uZmF1bHRfcmVmIHx8IF9lbXB0eSkgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPlRlY3RvbmljIHJlZ2ltZTwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIChpbmZvLnRlY3RvbmljX3JlZ2ltZSB8fCBfZW1wdHkpICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5OdW1iZXIgb2Ygc2Vpc21pYyBzdGF0aW9uczwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIGluZm8uc2Vpc21pY19zdGF0aW9ucyArICc8L3RkPicgK1xuICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TnVtYmVyIG9mIERZRkkgc3RhdGlvbnM8L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyBpbmZvLmludGVuc2l0eV9vYnNlcnZhdGlvbnMgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICc8L3Rib2R5PicgK1xuICAgICAgICAnPC90YWJsZT4nICtcbiAgICAgICc8L2Rpdj4nKTtcblxuICAgIGVsLmlubmVySFRNTCA9IGJ1Zi5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBvdXRwdXQgc2VjdGlvbiBvZiBpbmZvLmpzb24uXG4gICAqXG4gICAqIEBwYXJhbSBqc29uIHtPYmplY3R9XG4gICAqICAgICAgICBwYXJzZWQgaW5mby5qc29uIGNvbnRlbnQuXG4gICAqIEBwYXJhbSBlbCB7RE9NRWxlbWVudH1cbiAgICogICAgICAgIGVsZW1lbnQgd2hlcmUgY29udGVudCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAqL1xuICBfdGhpcy5yZW5kZXJPdXRwdXQgPSBmdW5jdGlvbiAoanNvbiwgZWwpIHtcbiAgICB2YXIgYnVmLFxuICAgICAgICBvdXRwdXQsXG4gICAgICAgIHVuY2VydGFpbnR5O1xuXG4gICAgb3V0cHV0ID0ganNvbi5vdXRwdXQ7XG5cbiAgICBidWYgPSBbXTtcbiAgICBidWYucHVzaCgnPGgyPk91dHB1dDwvaDI+Jyk7XG4gICAgYnVmLnB1c2goX3RoaXMuZm9ybWF0T3V0cHV0R3JvdW5kTW90aW9ucyhvdXRwdXQuZ3JvdW5kX21vdGlvbnMpKTtcbiAgICBidWYucHVzaChfdGhpcy5mb3JtYXRPdXRwdXRNYXBJbmZvcm1hdGlvbihvdXRwdXQubWFwX2luZm9ybWF0aW9uKSk7XG5cbiAgICB1bmNlcnRhaW50eSA9IG91dHB1dC51bmNlcnRhaW50eTtcbiAgICBidWYucHVzaCgnPGgzPlVuY2VydGFpbnR5PC9oMz4nICtcbiAgICAgICc8ZGl2IGNsYXNzPVwiaG9yaXpvbnRhbC1zY3JvbGxpbmdcIj4nICtcbiAgICAgICAgJzx0YWJsZT4nICtcbiAgICAgICAgICAnPHRib2R5PicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk1lYW4gb2YgbWFwIHVuY2VydGFpbnR5PC90aD4nICtcbiAgICAgICAgICAgICAgJzx0ZD4nICsgdW5jZXJ0YWludHkubWVhbl91bmNlcnRhaW50eV9yYXRpbyArICc8L3RkPicgK1xuICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+RW1wZXJpY2FsIFNoYWtlTWFwIGdyYWRlPC90aD4nICtcbiAgICAgICAgICAgICAgJzx0ZD4nICsgdW5jZXJ0YWludHkuZ3JhZGUgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkZsYWdnZWQgc2Vpc21pYyBzdGF0aW9uczwvdGg+JyArXG4gICAgICAgICAgICAgICc8dGQ+JyArIHVuY2VydGFpbnR5LnRvdGFsX2ZsYWdnZWRfcGdtICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5GbGFnZ2VkIERZRkkgc3RhdGlvbnM8L3RoPicgK1xuICAgICAgICAgICAgICAnPHRkPicgKyB1bmNlcnRhaW50eS50b3RhbF9mbGFnZ2VkX21pICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAnPC90Ym9keT4nICtcbiAgICAgICAgJzwvdGFibGU+JyArXG4gICAgICAnPC9kaXY+Jyk7XG5cbiAgICBlbC5pbm5lckhUTUwgPSBidWYuam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgcHJvY2Vzc2luZyBzZWN0aW9uIG9mIGluZm8uanNvbi5cbiAgICpcbiAgICogQHBhcmFtIGpzb24ge09iamVjdH1cbiAgICogICAgICAgIHBhcnNlZCBpbmZvLmpzb24gY29udGVudC5cbiAgICogQHBhcmFtIGVsIHtET01FbGVtZW50fVxuICAgKiAgICAgICAgZWxlbWVudCB3aGVyZSBjb250ZW50IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICovXG4gIF90aGlzLnJlbmRlclByb2Nlc3NpbmcgPSBmdW5jdGlvbiAoanNvbiwgZWwpIHtcbiAgICB2YXIgYnVmLFxuICAgICAgICBtaXNjLFxuICAgICAgICBwcm9jZXNzaW5nLFxuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgdmVyc2lvbnM7XG5cbiAgICBwcm9jZXNzaW5nID0ganNvbi5wcm9jZXNzaW5nO1xuXG4gICAgYnVmID0gW107XG4gICAgYnVmLnB1c2goJzxoMj5Qcm9jZXNzaW5nPC9oMj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJyb3dcIj4nKTtcblxuICAgIGJ1Zi5wdXNoKCc8ZGl2IGNsYXNzPVwib25lLW9mLXR3byBjb2x1bW5cIj4nICtcbiAgICAgICAgX3RoaXMuZm9ybWF0UHJvY2Vzc2luZ0dyb3VuZE1vdGlvbnMocHJvY2Vzc2luZy5ncm91bmRfbW90aW9uX21vZHVsZXMpICtcbiAgICAgICc8L2Rpdj4nKTtcblxuICAgIG1pc2MgPSBwcm9jZXNzaW5nLm1pc2NlbGxhbmVvdXM7XG4gICAgYnVmLnB1c2goXG4gICAgICAnPGRpdiBjbGFzcz1cIm9uZS1vZi10d28gY29sdW1uXCI+JyArXG4gICAgICAgICc8aDM+TWlzY2VsbGFuZW91czwvaDM+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiaG9yaXpvbnRhbC1zY3JvbGxpbmdcIj4nICtcbiAgICAgICAgICAnPHRhYmxlPicgK1xuICAgICAgICAgICAgJzx0Ym9keT4nICtcbiAgICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+VXNlZCBsb2cgYW1wIHRvIGNvbXB1dGUgYmlhcz88L3RoPicgK1xuICAgICAgICAgICAgICAgICc8dGQ+JyArIG1pc2MuYmlhc19sb2dfYW1wICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj4nICtcbiAgICAgICAgICAgICAgICAgICdNYXhpbXVtIGRpc3RhbmNlIHRvIGluY2x1ZGUgc3RhdGlvbiBpbiBiaWFzJyArXG4gICAgICAgICAgICAgICAgJzwvdGg+JyArXG4gICAgICAgICAgICAgICAgJzx0ZD4nICtcbiAgICAgICAgICAgICAgICAgIF9mb3JtYXR0ZXIuZGlzdGFuY2UobWlzYy5iaWFzX21heF9yYW5nZSwgJ2ttJykgK1xuICAgICAgICAgICAgICAgICc8L3RkPicgK1xuICAgICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TWF4IG1hZ25pdHVkZSB0byBjb21wdXRlIGJpYXM8L3RoPicgK1xuICAgICAgICAgICAgICAgICc8dGQ+JyArIF9mb3JtYXR0ZXIubWFnbml0dWRlKG1pc2MuYmlhc19tYXhfbWFnKSArICc8L3RkPicgK1xuICAgICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TWluIGFsbG93ZWQgYmlhczwvdGg+JyArXG4gICAgICAgICAgICAgICAgJzx0ZD4nICsgKG1pc2MuYmlhc19taW5fYmlhcyB8fCBfZW1wdHkpICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5NYXhpbXVtIG1hZ25pdHVkZSB0byBmbGFnIG91dGxpZXJzPC90aD4nICtcbiAgICAgICAgICAgICAgICAnPHRkPicgKyBfZm9ybWF0dGVyLm1hZ25pdHVkZShtaXNjLm91dGxpZXJfbWF4X21hZykgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPk5vcm0gb2YgdGhlIGJpYXM8L3RoPicgK1xuICAgICAgICAgICAgICAgICc8dGQ+JyArIChtaXNjLmJpYXNfbm9ybSB8fCBfZW1wdHkpICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj4nICtcbiAgICAgICAgICAgICAgICAgICdNaW4gIyBvZiBzdGF0aW9ucyBuZWNlc3NhcnkgdG8gY29tcHV0ZSBiaWFzJyArXG4gICAgICAgICAgICAgICAgJzwvdGg+JyArXG4gICAgICAgICAgICAgICAgJzx0ZD4nICsgKG1pc2MuYmlhc19taW5fc3RhdGlvbnMgfHwgX2VtcHR5KSArICc8L3RkPicgK1xuICAgICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+TWF4IGFsbG93ZWQgYmlhczwvdGg+JyArXG4gICAgICAgICAgICAgICAgJzx0ZD4nICsgKG1pc2MuYmlhc19tYXhfYmlhcyB8fCBfZW1wdHkpICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5PdXRsaWVyIGxldmVsICgjIG9mIHN0ZCBkZXYpPC90aD4nICtcbiAgICAgICAgICAgICAgICAnPHRkPicgKyAobWlzYy5vdXRsaWVyX2RldmlhdGlvbl9sZXZlbCB8fCBfZW1wdHkpICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5NZWRpYW4gZGlzdGFuY2UgdXNlZDwvdGg+JyArXG4gICAgICAgICAgICAgICAgJzx0ZD4nICsgbWlzYy5tZWRpYW5fZGlzdCArICc8L3RkPicgK1xuICAgICAgICAgICAgICAnPC90cj4nICtcbiAgICAgICAgICAgICc8L3Rib2R5PicgK1xuICAgICAgICAgICc8L3RhYmxlPicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAnPC9kaXY+Jyk7XG5cbiAgICB2ZXJzaW9ucyA9IHByb2Nlc3Npbmcuc2hha2VtYXBfdmVyc2lvbnM7XG4gICAgYnVmLnB1c2goXG4gICAgICAnPGRpdiBjbGFzcz1cIm9uZS1vZi10d28gY29sdW1uXCI+JyArXG4gICAgICAgICc8aDM+U2hha2VNYXAgVmVyc2lvbnM8L2gzPicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cImhvcml6b250YWwtc2Nyb2xsaW5nXCI+JyArXG4gICAgICAgICAgJzx0YWJsZT4nICtcbiAgICAgICAgICAgICc8dGJvZHk+JyArXG4gICAgICAgICAgICAgICc8dHI+JyArXG4gICAgICAgICAgICAgICAgJzx0aCBzY29wZT1cInJvd1wiPkNvZGU8L3RoPicgK1xuICAgICAgICAgICAgICAgICc8dGQ+JyArIHZlcnNpb25zLnNoYWtlbWFwX3JldmlzaW9uICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5NYXA8L3RoPicgK1xuICAgICAgICAgICAgICAgICc8dGQ+JyArIHZlcnNpb25zLm1hcF92ZXJzaW9uICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5EYXRlPC90aD4nICtcbiAgICAgICAgICAgICAgICAnPHRkPicgKyB2ZXJzaW9ucy5wcm9jZXNzX3RpbWUgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICAgJzwvdHI+JyArXG4gICAgICAgICAgICAnPC90Ym9keT4nICtcbiAgICAgICAgICAnPC90YWJsZT4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgJzwvZGl2PicpO1xuXG4gICAgcmVzcG9uc2UgPSBwcm9jZXNzaW5nLnNpdGVfcmVzcG9uc2U7XG4gICAgYnVmLnB1c2goXG4gICAgICAnPGRpdiBjbGFzcz1cIm9uZS1vZi10d28gY29sdW1uXCI+JyArXG4gICAgICAgICc8aDM+U2l0ZSBSZXNwb25zZTwvaDM+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiaG9yaXpvbnRhbC1zY3JvbGxpbmdcIj4nICtcbiAgICAgICAgICAnPHRhYmxlPicgK1xuICAgICAgICAgICAgJzx0Ym9keT4nICtcbiAgICAgICAgICAgICAgJzx0cj4nICtcbiAgICAgICAgICAgICAgICAnPHRoIHNjb3BlPVwicm93XCI+UmVmZXJlbmNlIHJvY2sgVnMzMDwvdGg+JyArXG4gICAgICAgICAgICAgICAgJzx0ZD4nICsgcmVzcG9uc2UudnMzMGRlZmF1bHQgKyAnIG0vczwvdGQ+JyArXG4gICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgICAnPHRyPicgK1xuICAgICAgICAgICAgICAgICc8dGggc2NvcGU9XCJyb3dcIj5TaXRlIGNvcnJlY3Rpb24gYXBwbGllZDwvdGg+JyArXG4gICAgICAgICAgICAgICAgJzx0ZD4nICsgcmVzcG9uc2Uuc2l0ZV9jb3JyZWN0aW9uICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICc8L3RyPicgK1xuICAgICAgICAgICAgJzwvdGJvZHk+JyArXG4gICAgICAgICAgJzwvdGFibGU+JyArXG4gICAgICAgICc8L2Rpdj4nICtcbiAgICAgICc8L2Rpdj4nKTtcblxuICAgIGJ1Zi5wdXNoKFxuICAgICAgJzxkaXYgY2xhc3M9XCJvbmUtb2YtdHdvIGNvbHVtblwiPicgK1xuICAgICAgICBfdGhpcy5mb3JtYXRQcm9jZXNzaW5nUm9pcyhwcm9jZXNzaW5nLnJvaSkgK1xuICAgICAgJzwvZGl2PicpO1xuXG4gICAgYnVmLnB1c2goJzwvZGl2PicpO1xuICAgIGVsLmlubmVySFRNTCA9IGJ1Zi5qb2luKCcnKTtcbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYWtlTWFwSW5mb1ZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBJbXBhY3RTdW1tYXJ5TW9kdWxlID0gcmVxdWlyZSgnaW1wYWN0L0ltcGFjdFN1bW1hcnlNb2R1bGUnKSxcbiAgICBNb2R1bGUgPSByZXF1aXJlKCdjb3JlL01vZHVsZScpLFxuICAgIFNoYWtlTWFwVmlldyA9IHJlcXVpcmUoJ3NoYWtlbWFwL1NoYWtlTWFwVmlldycpLFxuICAgIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcblxuXG52YXIgX0lELFxuICAgIF9USVRMRSxcbiAgICBfVFlQRVM7XG5cblxuLy8gTm90ZTogVGhlc2Ugc2hvdWxkIGJlIG92ZXJyaWRkZW4gYnkgZWFjaCBpbXBsZW1lbnRpbmcgc3ViLWNsYXNzLlxuX0lEID0gJ3NoYWtlbWFwJztcbl9USVRMRSA9ICdTaGFrZU1hcCc7XG5fVFlQRVMgPSBbJ3NoYWtlbWFwJ107XG5cblxudmFyIF9ERUZBVUxUUyA9IHtcblxufTtcblxuXG4vKipcbiAqIEJyaWRnZXMgdGhlIGV2ZW50IHBhZ2UgZnJhbWV3b3JrIHdpdGggdGhlIHByb2R1Y3QgcmVuZGVyaW5nLlxuICpcbiAqL1xudmFyIFNoYWtlTWFwTW9kdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9zaGFrZU1hcFZpZXc7XG5cblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIF90aGlzID0gTW9kdWxlKG9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbmV3IG1vZHVsZS5cbiAgICpcbiAgICogQHNlZSBNb2R1bGUjX2luaXRpYWxpemVcbiAgICovXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKC8qb3B0aW9ucyovKSB7XG4gICAgX3RoaXMuSUQgPSBfSUQ7XG4gICAgX3RoaXMuVElUTEUgPSBfVElUTEU7XG4gIH07XG5cblxuICAvKipcbiAgICogRGVzdHJveSB0aGlzIG1vZHVsZSBhbmQgc3ViLXZpZXcocykuXG4gICAqXG4gICAqL1xuICBfdGhpcy5kZXN0cm95ID0gVXRpbC5jb21wb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3NoYWtlTWFwVmlldykge1xuICAgICAgX3NoYWtlTWFwVmlldy5kZXN0cm95KCk7XG4gICAgfVxuICAgIF9zaGFrZU1hcFZpZXcgPSBudWxsO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGRldGFpbHMgZm9yIHRoaXMgbW9kdWxlLiBEZWZlcnMgYnVsayBvZiBoZWFkZXIgSW5mb3JtYXRpb25cbiAgICogdG8gZ2VuZXJhbGl6ZWQgaGVhZGVyIHJlbmRlcmluZy4gVXNlcyB7U2hha2VNYXBWaWV3fSBmb3IgYnVsayBvZiBjb250ZW50XG4gICAqIHJlbmRlcmluZy5cbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWRkaXRpb25hbEZvb3RlcixcbiAgICAgICAgcHJvZHVjdDtcblxuXG4gICAgX3RoaXMuaGVhZGVyLmlubmVySFRNTCA9ICc8aDM+U2hha2VNYXA8L2gzPic7XG5cbiAgICBwcm9kdWN0ID0gX3RoaXMuZ2V0UHJvZHVjdCgnc2hha2VtYXAnKTtcbiAgICBpZiAoIXByb2R1Y3QpIHtcbiAgICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID1cbiAgICAgICAgICAnPHAgY2xhc3M9XCJhbGVydCB3YXJuaW5nXCI+Tm8gU2hha2VNYXAgRm91bmQ8L3A+JztcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuaGVhZGVyLmFwcGVuZENoaWxkKF90aGlzLmdldFByb2R1Y3RIZWFkZXIoe1xuICAgICAgICBwcm9kdWN0OiBwcm9kdWN0LFxuICAgICAgICBzdW1tYXJ5TW9kdWxlOiBJbXBhY3RTdW1tYXJ5TW9kdWxlXG4gICAgICB9KSk7XG5cbiAgICAgIGFkZGl0aW9uYWxGb290ZXIgPSBfdGhpcy5nZXRQcm9kdWN0Rm9vdGVyKHtcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdFxuICAgICAgfSk7XG5cbiAgICAgIC8vIExvYWQgY29udGVudCBmcm9tIFNoYWtlTWFwVmlld1xuICAgICAgX3NoYWtlTWFwVmlldyA9IFNoYWtlTWFwVmlldyh7XG4gICAgICAgIGVsOiBfdGhpcy5jb250ZW50LFxuICAgICAgICBtb2RlbDogcHJvZHVjdFxuICAgICAgfSk7XG5cbiAgICAgIF9zaGFrZU1hcFZpZXcucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgX3RoaXMuZm9vdGVyLmlubmVySFRNTCA9XG4gICAgICAnPGgzPkZvciBNb3JlIEluZm9ybWF0aW9uPC9oMz4nICtcbiAgICAgICc8dWw+JyArXG4gICAgICAgICc8bGk+JyArXG4gICAgICAgICAgJzxhIGhyZWY9XCJodHRwczovL3VzZ3MuZ2l0aHViLmlvL3NoYWtlbWFwXCI+U2hha2VNYXAgTWFudWFsPC9hPicgK1xuICAgICAgICAnPC9saT4nICtcbiAgICAgICc8L3VsPic7XG5cbiAgICBpZiAoYWRkaXRpb25hbEZvb3Rlcikge1xuICAgICAgX3RoaXMuZm9vdGVyLmFwcGVuZENoaWxkKGFkZGl0aW9uYWxGb290ZXIpO1xuICAgIH1cbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKG9wdGlvbnMpO1xuICBvcHRpb25zID0gbnVsbDtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG5TaGFrZU1hcE1vZHVsZS5JRCA9IF9JRDtcblNoYWtlTWFwTW9kdWxlLlRJVExFID0gX1RJVExFO1xuU2hha2VNYXBNb2R1bGUuVFlQRVMgPSBfVFlQRVM7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFrZU1hcE1vZHVsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2ljUGluVmlldyA9IHJlcXVpcmUoJ2NvcmUvQmFzaWNQaW5WaWV3JyksXG4gICAgRm9ybWF0dGVyID0gcmVxdWlyZSgnY29yZS9Gb3JtYXR0ZXInKSxcbiAgICBTaGFrZU1hcE1vZHVsZSA9IHJlcXVpcmUoJ3NoYWtlbWFwL1NoYWtlTWFwTW9kdWxlJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBfREVGQVVMVFMgPSB7XG4gIG1vZHVsZTogU2hha2VNYXBNb2R1bGVcbn07XG5cbnZhciBTaGFrZU1hcFBpblZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2Zvcm1hdHRlcjtcblxuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgX3RoaXMgPSBCYXNpY1BpblZpZXcob3B0aW9ucyk7XG5cblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgX2Zvcm1hdHRlciA9IG9wdGlvbnMuZm9ybWF0dGVyIHx8IEZvcm1hdHRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGcmVlcyByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdmlldy5cbiAgICpcbiAgICovXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIF9mb3JtYXR0ZXIgPSBudWxsO1xuXG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgY29udGVudCBmb3IgU2hha2VNYXBQaW5WaWV3XG4gICAqXG4gICAqL1xuICBfdGhpcy5yZW5kZXJQaW5Db250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbWcsXG4gICAgICAgIG1hcmt1cDtcblxuICAgIGltZyA9IF90aGlzLm1vZGVsLmdldENvbnRlbnQoJ3Bpbi10aHVtYm5haWwucG5nJyk7XG4gICAgaWYgKCFpbWcpIHtcbiAgICAgIGltZyA9IF90aGlzLm1vZGVsLmdldENvbnRlbnQoJ2Rvd25sb2FkL3R2bWFwLmpwZycpO1xuICAgIH1cblxuICAgIGlmIChpbWcpIHtcbiAgICAgIG1hcmt1cCA9ICc8ZGl2IGNsYXNzPVwic2hha2VtYXAtdHZtYXBcIj4nICtcbiAgICAgICAgICAnPGltZyBzcmM9XCInICsgaW1nLmdldCgndXJsJykgKyAnXCIgYWx0PVwiSW50ZW5zaXR5IE1hcFwiLz4nICtcbiAgICAgICAgICAnPC9kaXY+JztcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gJzxwIGNsYXNzPVwiYWxlcnQgd2FybmluZ1wiPk1hcCBub3QgYXZhaWxhYmxlPC9wPic7XG4gICAgfVxuXG4gICAgX3RoaXMuY29udGVudC5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBoZWFkZXIgZm9yIFNoYWtlTWFwUGluVmlldyB3aXRoIGltcGFjdCBidWJibGVcbiAgICpcbiAgICovXG4gIF90aGlzLnJlbmRlclBpbkhlYWRlciA9IFV0aWwuY29tcG9zZShfdGhpcy5yZW5kZXJQaW5IZWFkZXIsIGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5oZWFkZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLFxuICAgICAgICBfZm9ybWF0dGVyLmludGVuc2l0eShfdGhpcy5tb2RlbC5nZXRQcm9wZXJ0eSgnbWF4bW1pJyksIG51bGwpKTtcbiAgfSk7XG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2hha2VNYXBQaW5WaWV3O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWNjb3JkaW9uID0gcmVxdWlyZSgnYWNjb3JkaW9uL0FjY29yZGlvbicpLFxuICAgIENvbnRlbnRWaWV3ID0gcmVxdWlyZSgnY29yZS9Db250ZW50VmlldycpLFxuICAgIEZvcm1hdHRlciA9IHJlcXVpcmUoJ2NvcmUvRm9ybWF0dGVyJyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG52YXIgX05PX0NPTlRFTlRfTUVTU0FHRSA9ICdObyBzdGF0aW9ucyBsaXN0IGF2YWlsYWJsZS4nO1xuXG52YXIgRkxBR19ERVNDUklQVElPTlMgPSB7XG4gICdNJzogJ01hbnVhbGx5IGZsYWdnZWQnLFxuICAnVCc6ICdPdXRsaWVyJyxcbiAgJ0cnOiAnR2xpdGNoIChjbGlwcGVkIG9yIGJlbG93IG5vaXNlKScsXG4gICdJJzogJ0luY29tcGxldGUgdGltZSBzZXJpZXMnLFxuICAnTic6ICdOb3QgaW4gbGlzdCBvZiBrbm93biBzdGF0aW9ucydcbn07XG5cblxuLyoqXG4gKiBWaWV3IGZvciBhIFN0YXRpb24gTGlzdC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICpcbiAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdHRlciB7Rm9ybWF0dGVyfVxuICogICAgIFRoZSBmb3JtYXR0ZXIgb2JqZWN0IHRvIHVzZSBmb3IgZm9ybWF0dGluZyBpbnRyaW5zaWMgdmFsdWVzLlxuICovXG52YXIgU2hha2VNYXBTdGF0aW9uTGlzdFZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2FjY29yZGlvbixcbiAgICAgIF9mb3JtYXR0ZXI7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIF90aGlzID0gQ29udGVudFZpZXcob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnc2hha2VtYXAtc3RhdGlvbnMnKTtcbiAgICBfZm9ybWF0dGVyID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgRm9ybWF0dGVyKCk7XG4gIH07XG5cblxuICAvKipcbiAgICogR2VuZXJhdGUgc3VtbWFyeSBtYXJrdXAgZm9yIHN0YXRpb24gbGlzdC5cbiAgICpcbiAgICogQHBhcmFtICBkYXRhIHthcnJheX0sXG4gICAqICAgICAgICAgbGlzdCBvZiBzdGF0aW9uIG9iamVjdHMuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBIVE1MIG1hcmt1cC5cbiAgICovXG4gIF90aGlzLmJ1aWxkU3RhdGlvbkxpc3QgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaXN0YW5jZSxcbiAgICAgICAgaSxcbiAgICAgICAgcGdhLFxuICAgICAgICBwZ3YsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBzdGF0aW9ucyxcbiAgICAgICAgc3RhdGlvbixcbiAgICAgICAgdGl0bGU7XG5cbiAgICBkYXRhID0gZGF0YS5mZWF0dXJlcztcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnPHA+Tm8gc3RhdGlvbiBkYXRhIGF2YWlsYWJsZSBhdCB0aGlzIHRpbWUuPC9wPic7XG4gICAgfVxuXG4gICAgZGF0YS5zb3J0KF90aGlzLnNvcnRCeURpc3RhbmNlKTtcbiAgICBzdGF0aW9ucyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0aW9uID0gZGF0YVtpXTtcbiAgICAgIHByb3BzID0gc3RhdGlvbi5wcm9wZXJ0aWVzO1xuXG4gICAgICBwZ2EgPSBwcm9wcy5wZ2E7XG4gICAgICBwZ3YgPSBwcm9wcy5wZ3Y7XG5cbiAgICAgIHBndiA9IF9mb3JtYXR0ZXIubnVtYmVyKHBndiwgMyk7XG4gICAgICBwZ2EgPSBfZm9ybWF0dGVyLm51bWJlcihwZ2EsIDMpO1xuXG4gICAgICBkaXN0YW5jZSA9IF9mb3JtYXR0ZXIubnVtYmVyKHByb3BzLmRpc3RhbmNlLCAxKTtcblxuICAgICAgLy8gRG8gbm90IHJlcGVhdCB0aGUgemlwIGNvZGUgaWYgaXQncyBhbHJlYWR5IHBhcnQgb2YgdGhlIG5hbWVcbiAgICAgIGlmIChwcm9wcy5uYW1lLmluZGV4T2YoJ1pJUCBDb2RlJykgPT09IC0xKSB7XG4gICAgICAgIHRpdGxlID0gcHJvcHMuY29kZSArICc8c21hbGw+JyArIHByb3BzLm5hbWUgKyAnPC9zbWFsbD4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGUgPSBwcm9wcy5uYW1lO1xuICAgICAgfVxuXG4gICAgICBzdGF0aW9ucy5wdXNoKFtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJhY2NvcmRpb24gYWNjb3JkaW9uLXNlY3Rpb24gYWNjb3JkaW9uLWNsb3NlZCBzdGF0aW9uXCI+JyxcbiAgICAgICAgICAnPGgzPicsIHRpdGxlLCAnPC9oMz4nLFxuICAgICAgICAgICc8dWwgY2xhc3M9XCJzdGF0aW9uLXN1bW1hcnlcIj4nLFxuICAgICAgICAgICAgJzxsaT4nLFxuICAgICAgICAgICAgICBfZm9ybWF0dGVyLmludGVuc2l0eShwcm9wcy5pbnRlbnNpdHksXG4gICAgICAgICAgICAgICAgICAnPGFiYnIgdGl0bGU9XCJNb2RpZmllZCBNZXJjYWxsaSBJbnRlbnNpdHlcIj5tbWk8L2FiYnI+JyksXG4gICAgICAgICAgICAnPC9saT4nLFxuICAgICAgICAgICAgJzxsaT4nLFxuICAgICAgICAgICAgICAnPHNwYW4+JywgcGdhICwnICVnPC9zcGFuPicsXG4gICAgICAgICAgICAgICc8YWJiciB0aXRsZT1cIk1heGltdW0gSG9yaXpvbnRhbCBQZWFrIEdyb3VuZCBBY2NlbGVyYXRpb25cIj4nLFxuICAgICAgICAgICAgICAgICdwZ2EnLFxuICAgICAgICAgICAgICAnPC9hYmJyPicsXG4gICAgICAgICAgICAnPC9saT4nLFxuICAgICAgICAgICAgJzxsaT4nLFxuICAgICAgICAgICAgICAnPHNwYW4+JywgcGd2ICwnIGNtL3M8L3NwYW4+JyxcbiAgICAgICAgICAgICAgJzxhYmJyIHRpdGxlPVwiTWF4aW11bSBIb3Jpem9udGFsIFBlYWsgR3JvdW5kIFZlbG9jaXR5XCI+JyxcbiAgICAgICAgICAgICAgICAncGd2JyxcbiAgICAgICAgICAgICAgJzwvYWJicj4nLFxuICAgICAgICAgICAgJzwvbGk+JyxcbiAgICAgICAgICAgICc8bGk+JyxcbiAgICAgICAgICAgICAgJzxzcGFuPicsIGRpc3RhbmNlICwgJyBrbScsJzwvc3Bhbj4nLFxuICAgICAgICAgICAgICAnPGFiYnIgdGl0bGU9XCJEaXN0YW5jZSAoa20pXCI+ZGlzdDwvYWJicj4nLFxuICAgICAgICAgICAgJzwvbGk+JyxcbiAgICAgICAgICAnPC91bD4nLFxuICAgICAgICAgICc8YSBjbGFzcz1cImFjY29yZGlvbi10b2dnbGVcIiBkYXRhLWlkPVwiJywgaSAsJ1wiPkRldGFpbHM8L2E+JyxcbiAgICAgICAgICBfdGhpcy5idWlsZFN0YXRpb25EZXRhaWxzKHN0YXRpb24pLFxuICAgICAgICAnPC9kaXY+J1xuICAgICAgXS5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRpb25zLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBkZXRhaWxzIG1hcmt1cCBmb3Igc3RhdGlvbiBkZXRhaWxzLiBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gICAqIHdoZW4gYSBzdGF0aW9uIGRldGFpbHMgc2VjdGlvbiBpcyBleHBhbmRlZC5cbiAgICpcbiAgICogQHBhcmFtICBpbmRleCB7c3RyaW5nfSxcbiAgICogICAgICAgICBhIGRhdGEtaWQgdmFsdWUgdGhhdCBpZGVudGlmaWVzIHRoZSBzdGF0aW9uIGRldGFpbHNcbiAgICogICAgICAgICBzZWN0aW9uIHRoYXQgaXMgZXhwYW5kZWQgb24gYSBjbGljayBldmVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEhUTUwgbWFya3VwLlxuICAgKi9cbiAgX3RoaXMuYnVpbGRTdGF0aW9uRGV0YWlscyA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgdmFyIHByb3BzO1xuXG4gICAgcHJvcHMgPSBmZWF0dXJlLnByb3BlcnRpZXM7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICAnPGRpdiBjbGFzcz1cImFjY29yZGlvbi1jb250ZW50XCI+JyxcbiAgICAgICAgICAnPGRsIGNsYXNzPVwic3RhdGlvbi1tZXRhZGF0YSB2ZXJ0aWNhbFwiPicsXG4gICAgICAgICAgICAnPGR0IGNsYXNzPVwic3RhdGlvbi1tZXRhZGF0YS10eXBlXCI+VHlwZTwvZHQ+JyxcbiAgICAgICAgICAgICAgJzxkZCBjbGFzcz1cInN0YXRpb24tbWV0YWRhdGEtdHlwZVwiPicsXG4gICAgICAgICAgICAgICAgKHByb3BzLmluc3RydW1lbnRUeXBlfHwnJm5kYXNoOycpLFxuICAgICAgICAgICAgICAnPC9kZD4nLFxuICAgICAgICAgICAgJzxkdCBjbGFzcz1cInN0YXRpb24tbWV0YWRhdGEtbG9jYXRpb25cIj5Mb2NhdGlvbjwvZHQ+JyxcbiAgICAgICAgICAgICAgJzxkZCBjbGFzcz1cInN0YXRpb24tbWV0YWRhdGEtbG9jYXRpb25cIj4nLFxuICAgICAgICAgICAgICAgIF90aGlzLmZvcm1hdExvY2F0aW9uKGZlYXR1cmUpLFxuICAgICAgICAgICAgICAnPC9kZD4nLFxuICAgICAgICAgICAgJzxkdCBjbGFzcz1cInN0YXRpb24tbWV0YWRhdGEtc291cmNlXCI+U291cmNlPC9kdD4nLFxuICAgICAgICAgICAgICAnPGRkIGNsYXNzPVwic3RhdGlvbi1tZXRhZGF0YS1zb3VyY2VcIj4nLFxuICAgICAgICAgICAgICAgICAgKHByb3BzLnNvdXJjZSB8fCAnJm5kYXNoOycpLCAnPC9kZD4nLFxuICAgICAgICAgICAgJzxkdCBjbGFzcz1cInN0YXRpb24tbWV0YWRhdGEtaW50ZW5zaXR5XCI+SW50ZW5zaXR5PC9kdD4nLFxuICAgICAgICAgICAgICAnPGRkIGNsYXNzPVwic3RhdGlvbi1tZXRhZGF0YS1pbnRlbnNpdHlcIj4nLFxuICAgICAgICAgICAgICAgIF9mb3JtYXR0ZXIubnVtYmVyKHByb3BzLmludGVuc2l0eSwgMSwgJyZuZGFzaDsnKSxcbiAgICAgICAgICAgICAgJzwvZGQ+JyxcbiAgICAgICAgICAnPC9kbD4nLFxuICAgICAgICAgIF90aGlzLmNyZWF0ZUNoYW5uZWxUYWJsZShwcm9wcy5jaGFubmVscyksXG4gICAgICAgICc8L2Rpdj4nXG4gICAgICBdLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlcyBhbiBhcnJheSBvZiBhbXBsaXR1ZGUgb2JqZWN0cyBmcm9tIGEgY2hhbm5lbCwgYW5kIGNyZWF0ZXNcbiAgICogICAgYSBtb3JlIHVzZXIgZnJpZW5kbHkgYW1wbGl0dWRlIG9iamVjdC5cbiAgICogQHBhcmFtIFtvYmplY3RzXSBhbXBsaXR1ZGVzXG4gICAqICAgIEFuIGFycmF5IG9mIGFtcGxpdHVkZSBvYmplY3RzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqICAgIGFuIG9iamVjdCB3aXRoIGEga2V5IG9iamVjdCBwYWlyLCB3aGVyZSB0aGUga2V5IGlzIHRoZSBhbXBsaXR1ZGUgbmFtZS5cbiAgICovXG4gIF90aGlzLmNyZWF0ZUFtcGxpdHVkZXNPYmplY3QgPSBmdW5jdGlvbiAoYW1wbGl0dWRlcykge1xuICAgIHZhciBhbXAsXG4gICAgICAgIGFtcGxpdHVkZSxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuO1xuXG4gICAgYW1wID0ge307XG4gICAgbGVuID0gYW1wbGl0dWRlcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhbXBsaXR1ZGUgPSBhbXBsaXR1ZGVzW2ldO1xuICAgICAgYW1wW2FtcGxpdHVkZS5uYW1lXSA9IGFtcGxpdHVkZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW1wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgdGhlIG1hcmt1cCBmb3IgYSBjaGFubmVsIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW1zIFtvYmplY3RzXSBjaGFubmVsc1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgSFRNTCBtYXJrdXAuXG4gICAqL1xuICBfdGhpcy5jcmVhdGVDaGFubmVsVGFibGUgPSBmdW5jdGlvbiAoY2hhbm5lbHMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbnVtQ2hhbm5lbHM7XG5cbiAgICB2YXIgbWFya3VwID0gW1xuICAgICAgJzxkaXYgY2xhc3M9XCJob3Jpem9udGFsLXNjcm9sbGluZ1wiPicsXG4gICAgICAnPHRhYmxlIGNsYXNzPVwic3RhdGlvbi1jaGFubmVscy1saXN0XCI+JyxcbiAgICAgICAgJzx0aGVhZD4nLFxuICAgICAgICAgICc8dHI+JyxcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIiBjbGFzcz1cInN0YXRpb24tY2hhbm5lbHMtbGlzdC1uYW1lXCI+bmFtZTwvdGg+JyxcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIiBjbGFzcz1cInN0YXRpb24tY2hhbm5lbHMtbGlzdC1wZ2FcIj5wZ2E8L3RoPicsXG4gICAgICAgICAgICAnPHRoIHNjb3BlPVwiY29sXCIgY2xhc3M9XCJzdGF0aW9uLWNoYW5uZWxzLWxpc3QtcGd2XCI+cGd2PC90aD4nLFxuICAgICAgICAgICAgJzx0aCBzY29wZT1cImNvbFwiIGNsYXNzPVwic3RhdGlvbi1jaGFubmVscy1saXN0LXBzYTAzXCI+cHNhMDM8L3RoPicsXG4gICAgICAgICAgICAnPHRoIHNjb3BlPVwiY29sXCIgY2xhc3M9XCJzdGF0aW9uLWNoYW5uZWxzLWxpc3QtcHNhMTBcIj5wc2ExMDwvdGg+JyxcbiAgICAgICAgICAgICc8dGggc2NvcGU9XCJjb2xcIiBjbGFzcz1cInN0YXRpb24tY2hhbm5lbHMtbGlzdC1wc2EzMFwiPnBzYTMwPC90aD4nLFxuICAgICAgICAgICc8L3RyPicsXG4gICAgICAgICc8L3RoZWFkPicsXG4gICAgICAgICc8dGJvZHk+J1xuICAgIF07XG5cbiAgICBudW1DaGFubmVscyA9IGNoYW5uZWxzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ2hhbm5lbHM7IGkrKykge1xuICAgICAgbWFya3VwLnB1c2goX3RoaXMuY3JlYXRlQ2hhbm5lbFJvdyhjaGFubmVsc1tpXSkpO1xuICAgIH1cblxuICAgIG1hcmt1cC5wdXNoKCc8L3Rib2R5PjwvdGFibGU+PC9kaXY+Jyk7XG5cbiAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIGNyZWF0ZSB0aGUgbWFya3VwIGZvciBhIGNoYW5uZWwgcm93XG4gICAqXG4gICAqIEBwYXJhbXMge29iamVjdHN9IGNoYW5uZWxcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEhUTUwgbWFya3VwLlxuICAgKi9cbiAgX3RoaXMuY3JlYXRlQ2hhbm5lbFJvdyA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgdmFyIGFtcGxpdHVkZTtcblxuICAgIGFtcGxpdHVkZSA9IF90aGlzLmNyZWF0ZUFtcGxpdHVkZXNPYmplY3QoY2hhbm5lbC5hbXBsaXR1ZGVzKTtcblxuICAgIHJldHVybiBbXG4gICAgICAnPHRyPicsXG4gICAgICAgICc8dGggc2NvcGU9XCJyb3dcIiBjbGFzcz1cInN0YXRpb24tY2hhbm5lbC1uYW1lXCI+JyxcbiAgICAgICAgICBjaGFubmVsLm5hbWUsXG4gICAgICAgICc8L3RoPicsXG4gICAgICAgICc8dGQgY2xhc3M9XCJzdGF0aW9uLWNoYW5uZWwtcGdhXCI+JyxcbiAgICAgICAgICBfdGhpcy5mb3JtYXRDb21wb25lbnQoYW1wbGl0dWRlLnBnYSksXG4gICAgICAgICc8L3RkPicsXG4gICAgICAgICc8dGQgY2xhc3M9XCJzdGF0aW9uLWNoYW5uZWwtcGd2XCI+JyxcbiAgICAgICAgICBfdGhpcy5mb3JtYXRDb21wb25lbnQoYW1wbGl0dWRlLnBndiksXG4gICAgICAgICc8L3RkPicsXG4gICAgICAgICc8dGQgY2xhc3M9XCJzdGF0aW9uLWNoYW5uZWwtcHNhMDNcIj4nLFxuICAgICAgICAgIF90aGlzLmZvcm1hdENvbXBvbmVudChhbXBsaXR1ZGUucHNhMDMpLFxuICAgICAgICAnPC90ZD4nLFxuICAgICAgICAnPHRkIGNsYXNzPVwic3RhdGlvbi1jaGFubmVsLXBzYTEwXCI+JyxcbiAgICAgICAgICBfdGhpcy5mb3JtYXRDb21wb25lbnQoYW1wbGl0dWRlLnBzYTEwKSxcbiAgICAgICAgJzwvdGQ+JyxcbiAgICAgICAgJzx0ZCBjbGFzcz1cInN0YXRpb24tY2hhbm5lbC1wc2EzMFwiPicsXG4gICAgICAgICAgX3RoaXMuZm9ybWF0Q29tcG9uZW50KGFtcGxpdHVkZS5wc2EzMCksXG4gICAgICAgICc8L3RkPicsXG4gICAgICAnPC90cj4nXG4gICAgXS5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogRnJlZSByZWZlcmVuY2VzLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9hY2NvcmRpb24pIHtcbiAgICAgIF9hY2NvcmRpb24uZGVzdHJveSgpO1xuICAgIH1cbiAgICBfYWNjb3JkaW9uID0gbnVsbDtcbiAgICBfZm9ybWF0dGVyID0gbnVsbDtcbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9LCBfdGhpcy5kZXN0cm95KTtcblxuICAvKipcbiAgICogZm9ybWF0IHRoZSBjb21wb25lbnQgb2YgYSBjZWxsIGZvciBhIGNoYW5uZWwgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbXMge29iamVjdH0gZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiAgICAgICAgIEhUTUwgbWFya3VwLlxuICAgKi9cbiAgX3RoaXMuZm9ybWF0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgY29udGVudCxcbiAgICAgICAgZmxhZyxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHVuaXRzO1xuXG4gICAgY29udGVudCA9IFtdO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBmbGFnID0gZGF0YS5mbGFnO1xuICAgICAgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgdW5pdHMgPSBkYXRhLnVuaXRzO1xuXG4gICAgICAvLyBBZGQgZmxhZyBjbGFzcyBmb3IgYWxsIG5vbi16ZXJvIGZsYWdzXG4gICAgICBpZiAoZmxhZyAmJiBmbGFnICE9PSAnMCcpIHtcbiAgICAgICAgY29udGVudC5wdXNoKCc8c3BhbiBjbGFzcz1cInN0YXRpb24tZmxhZ1wiPicpO1xuICAgICAgICBjb250ZW50LnB1c2gocGFyc2VGbG9hdCh2YWx1ZSwgMTApLnRvRml4ZWQoMykpO1xuXG4gICAgICAgIC8vIGRpc3BsYXkgZmxhZyB3aXRoIHRpdGxlIHRleHRcbiAgICAgICAgaWYgKEZMQUdfREVTQ1JJUFRJT05TLmhhc093blByb3BlcnR5KGZsYWcpKSB7XG4gICAgICAgICAgY29udGVudC5wdXNoKCc8YWJiciB0aXRsZT1cIicgKyBGTEFHX0RFU0NSSVBUSU9OU1tmbGFnXSArICdcIj4oJyArXG4gICAgICAgICAgICAgIGZsYWcgKyAnKTwvYWJicj4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50LnB1c2goJygnICsgZmxhZyArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudC5wdXNoKCc8L3NwYW4+Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50LnB1c2goJzxzcGFuPicpO1xuICAgICAgICBjb250ZW50LnB1c2gocGFyc2VGbG9hdCh2YWx1ZSwgMTApLnRvRml4ZWQoMykpO1xuICAgICAgICBjb250ZW50LnB1c2goJyZuYnNwOycrIHVuaXRzKTtcbiAgICAgICAgY29udGVudC5wdXNoKCc8L3NwYW4+Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQucHVzaCgnPHNwYW4+Jm5kYXNoOzwvc3Bhbj4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudC5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBMYXQsIExvbmc7IHN3YXAgcG9zaXRpb24gYW5kIGVuY2Fwc3VsYXRlIGluIHBhcmVucy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGZlYXR1cmVcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEhUTUwgbWFya3VwLlxuICAgKi9cbiAgX3RoaXMuZm9ybWF0TG9jYXRpb24gPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgIHZhciBsYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlO1xuXG4gICAgbGF0aXR1ZGUgPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdO1xuICAgIGxvbmdpdHVkZSA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XG5cbiAgICByZXR1cm4gKChmZWF0dXJlLnByb3BlcnRpZXMubG9jYXRpb24pID9cbiAgICAgICAgKGZlYXR1cmUucHJvcGVydGllcy5sb2NhdGlvbiArICc8YnIvPicpIDogJycpICtcbiAgICAgICAgX2Zvcm1hdHRlci5sb2NhdGlvbihsYXRpdHVkZSwgbG9uZ2l0dWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZGVmYXVsdCBlcnJvciBtZXNzYWdlLiBDYWxsZWQgaWYgYW4gZXJyb3Igb2NjdXJzIGR1cmluZyB0aGVcbiAgICogZGF0YSBmZXRjaC5cbiAgICpcbiAgICovXG4gIF90aGlzLm9uRXJyb3IgPSBmdW5jdGlvbiAoLypzdGF0dXMsIHhociovKSB7XG4gICAgX3RoaXMuZWwuaW5uZXJIVE1MID0gX05PX0NPTlRFTlRfTUVTU0FHRTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbGlzdCBvZiBzdGF0aW9ucy4gQ2FsbGVkIHdoZW4gZGF0YSBpcyBzdWNjZXNzZnVsbHkgZmV0Y2hlZC5cbiAgICpcbiAgICovXG4gIF90aGlzLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChyZXNwb25zZVRleHQvKiwgeGhyKi8pIHtcbiAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSBfdGhpcy5idWlsZFN0YXRpb25MaXN0KHJlc3BvbnNlVGV4dCk7XG4gICAgX2FjY29yZGlvbiA9IEFjY29yZGlvbih7XG4gICAgICBlbDpfdGhpcy5lbFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTb3J0IGJ5IERpc3RhbmNlXG4gICAqICAgIFVzZWQgYnkgc29ydCByb3V0aW5lcyB0byBkZXRlcm1pbmUgd2hpY2ggZGlzdGFuY2UgaXMgZ3JlYXRlci5cbiAgICpcbiAgICogQHBhcmFtcyBhIHtvYmplY3R9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggZGlzdGFuY2UgaW4gYSBwcm9wZXJ0aWVzIHN1YiBvYmplY3QuXG4gICAqIEBwYXJhbXMgYSB7b2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIGRpc3RhbmNlIGluIGEgcHJvcGVydGllcyBzdWIgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiAgICAgICAgICBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gZGlzdGFuY2VzLlxuICAgKi9cbiAgX3RoaXMuc29ydEJ5RGlzdGFuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGEucHJvcGVydGllcy5kaXN0YW5jZSkgLSBwYXJzZUZsb2F0KGIucHJvcGVydGllcy5kaXN0YW5jZSk7XG4gIH07XG5cblxuICBfaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG51bGw7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuU2hha2VNYXBTdGF0aW9uTGlzdFZpZXcuTk9fQ09OVEVOVF9NRVNTQUdFID0gX05PX0NPTlRFTlRfTUVTU0FHRTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaGFrZU1hcFN0YXRpb25MaXN0VmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEludGVyYWN0aXZlTWFwVmlldyA9IHJlcXVpcmUoJ21hcC9JbnRlcmFjdGl2ZU1hcFZpZXcnKSxcbiAgICBQcm9kdWN0VmlldyA9IHJlcXVpcmUoJ2NvcmUvUHJvZHVjdFZpZXcnKSxcbiAgICBTaGFrZU1hcEluZm9WaWV3ID0gcmVxdWlyZSgnc2hha2VtYXAvU2hha2VNYXBJbmZvVmlldycpLFxuICAgIFNoYWtlTWFwU3RhdGlvbkxpc3RWaWV3ID0gcmVxdWlyZSgnc2hha2VtYXAvU2hha2VNYXBTdGF0aW9uTGlzdFZpZXcnKSxcbiAgICBUYWJMaXN0ID0gcmVxdWlyZSgndGFibGlzdC9UYWJMaXN0JyksXG4gICAgVXRpbCA9IHJlcXVpcmUoJ3V0aWwvVXRpbCcpO1xuXG5cbnZhciBTaGFrZU1hcFZpZXcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX3NoYWtlTWFwSW5mb1ZpZXcsXG4gICAgICBfc2hha2VNYXBTdGF0aW9uTGlzdFZpZXcsXG4gICAgICBfdGFibGlzdDtcblxuICBfdGhpcyA9IFByb2R1Y3RWaWV3KG9wdGlvbnMpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3NoYWtlbWFwJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0YWIgY29udGVudCBmb3IgYWxsIFBTQSBpbWFnZXMgKFBTQSAwLjMsIDEuMCwgMy4wKVxuICAgKlxuICAgKiBAcGFyYW0gIHtQcm9kdWN0fSBzaGFrZW1hcFxuICAgKiAgICBzaGFrZW1hcCBwcm9kdWN0IHdpdGggUFNBIGltYWdlIGNvbnRlbnRzXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gbWFya3VwXG4gICAqICAgIEhUTUwgbWFya3VwIGZvciBQU0EgdGFiIGNvbnRlbnRzXG4gICoqL1xuICBfdGhpcy5jcmVhdGVQU0FUYWJMaXN0SW1hZ2VzID0gZnVuY3Rpb24gKHNoYWtlbWFwKSB7XG4gICAgdmFyIGhlYWRlcixcbiAgICAgICAgbWFya3VwLFxuICAgICAgICBwc2EwMyxcbiAgICAgICAgcHNhMTAsXG4gICAgICAgIHBzYTMwO1xuXG4gICAgaGVhZGVyID0gW107XG4gICAgbWFya3VwID0gW107XG4gICAgcHNhMDMgPSBzaGFrZW1hcC5nZXRDb250ZW50KCdkb3dubG9hZC9wc2EwMy5qcGcnKTtcbiAgICBwc2ExMCA9IHNoYWtlbWFwLmdldENvbnRlbnQoJ2Rvd25sb2FkL3BzYTEwLmpwZycpO1xuICAgIHBzYTMwID0gc2hha2VtYXAuZ2V0Q29udGVudCgnZG93bmxvYWQvcHNhMzAuanBnJyk7XG5cbiAgICBpZiAocHNhMDMpIHtcbiAgICAgIGhlYWRlci5wdXNoKCcwLjMgcycpO1xuICAgICAgbWFya3VwLnB1c2goX3RoaXMuY3JlYXRlVGFiTGlzdEltYWdlKHBzYTAzLFxuICAgICAgICAgICdTaGFrZU1hcCBQZWFrIFNwZWN0cmFsIEFjY2VsZXJhdGlvbiAwLjMgcyBpbWFnZScpKTtcbiAgICB9XG5cbiAgICBpZiAocHNhMTApIHtcbiAgICAgIGhlYWRlci5wdXNoKCcxLjAgcycpO1xuICAgICAgbWFya3VwLnB1c2goX3RoaXMuY3JlYXRlVGFiTGlzdEltYWdlKHBzYTEwLFxuICAgICAgICAgICdTaGFrZU1hcCBQZWFrIFNwZWN0cmFsIEFjY2VsZXJhdGlvbiAxLjAgcyBpbWFnZScpKTtcbiAgICB9XG5cbiAgICBpZiAocHNhMzApIHtcbiAgICAgIGhlYWRlci5wdXNoKCczLjAgcycpO1xuICAgICAgbWFya3VwLnB1c2goX3RoaXMuY3JlYXRlVGFiTGlzdEltYWdlKHBzYTMwLFxuICAgICAgICAgICdTaGFrZU1hcCBQZWFrIFNwZWN0cmFsIEFjY2VsZXJhdGlvbiAzLjAgcyBpbWFnZScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJzxoMz4nICtcbiAgICAgICAgJ1BlYWsgU3BlY3RyYWwgQWNjZWxlcmF0aW9uICglZykgZm9yICcgKyBoZWFkZXIuam9pbignLCAnKSArXG4gICAgICAgICc8L2gzPicgK1xuICAgICAgICBtYXJrdXAuam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHRhYiBjb250ZW50cyBmb3IgdGFibGlzdFxuICAgKlxuICAgKiBAcGFyYW0gIHtQcm9kdWN0fSBzaGFrZW1hcCxcbiAgICogICAgICAgICBzaGFrZW1hcCBwcm9kdWN0IHdpdGggY29udGVudHNcbiAgICovXG4gIF90aGlzLmNyZWF0ZVRhYkxpc3REYXRhID0gZnVuY3Rpb24gKHNoYWtlbWFwKSB7XG4gICAgdmFyIGludGVuc2l0eUNvbnRlbnQsXG4gICAgICAgIHBnYUNvbnRlbnQsXG4gICAgICAgIHBndkNvbnRlbnQsXG4gICAgICAgIHNoYWtlTWFwSW5mb0NvbnRlbnQsXG4gICAgICAgIHN0YXRpb25MaXN0Q29udGVudCxcbiAgICAgICAgdW5jZXJ0YWludHlDb250ZW50O1xuXG4gICAgLy8gSW50ZXNpdHkgSW1hZ2VcbiAgICBpbnRlbnNpdHlDb250ZW50ID0gc2hha2VtYXAuZ2V0Q29udGVudCgnZG93bmxvYWQvaW50ZW5zaXR5LmpwZycpO1xuICAgIGlmIChpbnRlbnNpdHlDb250ZW50KSB7XG4gICAgICBfdGFibGlzdC5hZGRUYWIoe1xuICAgICAgICB0aXRsZTogJ0ludGVuc2l0eScsXG4gICAgICAgIGNvbnRlbnQ6IF90aGlzLmNyZWF0ZVRhYkxpc3RJbWFnZShpbnRlbnNpdHlDb250ZW50LFxuICAgICAgICAgICAgJ1NoYWtlTWFwIEludGVuc2l0eSBpbWFnZScpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQR0EgSW1hZ2VcbiAgICBwZ2FDb250ZW50ID0gc2hha2VtYXAuZ2V0Q29udGVudCgnZG93bmxvYWQvcGdhLmpwZycpO1xuICAgIGlmIChwZ2FDb250ZW50KSB7XG4gICAgICBfdGFibGlzdC5hZGRUYWIoe1xuICAgICAgICB0aXRsZTogJzxhYmJyIHRpdGxlPVwiUGVhayBHcm91bmQgQWNjZWxlcmF0aW9uXCI+UEdBPC9hYmJyPicsXG4gICAgICAgIGNvbnRlbnQ6IF90aGlzLmNyZWF0ZVRhYkxpc3RJbWFnZShwZ2FDb250ZW50LFxuICAgICAgICAgICAgJ1NoYWtlTWFwIFBlYWsgR3JvdW5kIEFjY2VsZXJhdGlvbiBpbWFnZScpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQR1YgSW1hZ2VcbiAgICBwZ3ZDb250ZW50ID0gc2hha2VtYXAuZ2V0Q29udGVudCgnZG93bmxvYWQvcGd2LmpwZycpO1xuICAgIGlmIChwZ3ZDb250ZW50KSB7XG4gICAgICBfdGFibGlzdC5hZGRUYWIoe1xuICAgICAgICB0aXRsZTogJzxhYmJyIHRpdGxlPVwiUGVhayBHcm91bmQgVmVsb2NpdHlcIj5QR1Y8L2FiYnI+JyxcbiAgICAgICAgY29udGVudDogX3RoaXMuY3JlYXRlVGFiTGlzdEltYWdlKHBndkNvbnRlbnQsXG4gICAgICAgICAgICAnU2hha2VNYXAgUGVhayBHcm91bmQgVmVsb2NpdHkgaW1hZ2UnKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGlvbkxpc3RcbiAgICBzdGF0aW9uTGlzdENvbnRlbnQgPSBzaGFrZW1hcC5nZXRDb250ZW50KCdkb3dubG9hZC9zdGF0aW9ubGlzdC5qc29uJyk7XG4gICAgaWYgKHN0YXRpb25MaXN0Q29udGVudCkge1xuICAgICAgX3NoYWtlTWFwU3RhdGlvbkxpc3RWaWV3ID0gU2hha2VNYXBTdGF0aW9uTGlzdFZpZXcoe1xuICAgICAgICAgICAgZWw6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgbW9kZWw6IHN0YXRpb25MaXN0Q29udGVudFxuICAgICAgICAgIH0pO1xuICAgICAgX3RhYmxpc3QuYWRkVGFiKHtcbiAgICAgICAgdGl0bGU6ICdTdGF0aW9uIExpc3QnLFxuICAgICAgICBjb250ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3NoYWtlTWFwU3RhdGlvbkxpc3RWaWV3LnJlbmRlcigpO1xuICAgICAgICAgIHJldHVybiBfc2hha2VNYXBTdGF0aW9uTGlzdFZpZXcuZWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEluZm9cbiAgICBzaGFrZU1hcEluZm9Db250ZW50ID0gc2hha2VtYXAuZ2V0Q29udGVudCgnZG93bmxvYWQvaW5mby5qc29uJyk7XG4gICAgaWYgKHNoYWtlTWFwSW5mb0NvbnRlbnQpIHtcbiAgICAgIF9zaGFrZU1hcEluZm9WaWV3ID0gU2hha2VNYXBJbmZvVmlldyh7XG4gICAgICAgIGVsOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgbW9kZWw6IHNoYWtlTWFwSW5mb0NvbnRlbnRcbiAgICAgIH0pO1xuICAgICAgX3RhYmxpc3QuYWRkVGFiKHtcbiAgICAgICAgdGl0bGU6ICdNZXRhZGF0YScsXG4gICAgICAgIGNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfc2hha2VNYXBJbmZvVmlldy5yZW5kZXIoKTtcbiAgICAgICAgICByZXR1cm4gX3NoYWtlTWFwSW5mb1ZpZXcuZWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVuY2VydGFpbnR5IEltYWdlXG4gICAgdW5jZXJ0YWludHlDb250ZW50ID0gc2hha2VtYXAuZ2V0Q29udGVudCgnZG93bmxvYWQvc2QuanBnJyk7XG4gICAgaWYgKHVuY2VydGFpbnR5Q29udGVudCkge1xuICAgICAgX3RhYmxpc3QuYWRkVGFiKHtcbiAgICAgICAgdGl0bGU6ICdVbmNlcnRhaW50eScsXG4gICAgICAgIGNvbnRlbnQ6IF90aGlzLmNyZWF0ZVRhYkxpc3RJbWFnZSh1bmNlcnRhaW50eUNvbnRlbnQsXG4gICAgICAgICAgICAnU2hha2VNYXAgVW5jZXJ0YWludHkgaW1hZ2UnKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUFNBIEltYWdlc1xuICAgIGlmIChzaGFrZW1hcC5nZXRDb250ZW50KCdkb3dubG9hZC9wc2EwMy5qcGcnKSB8fFxuICAgICAgICBzaGFrZW1hcC5nZXRDb250ZW50KCdkb3dubG9hZC9wc2ExMC5qcGcnKSB8fFxuICAgICAgICBzaGFrZW1hcC5nZXRDb250ZW50KCdkb3dubG9hZC9wc2EzMC5qcGcnKSkge1xuICAgICAgX3RhYmxpc3QuYWRkVGFiKHtcbiAgICAgICAgdGl0bGU6ICc8YWJiciB0aXRsZT1cIlBlYWsgU3BlY3RyYWwgQWNjZWxlcmF0aW9uXCI+UFNBPC9hYmJyPicsXG4gICAgICAgIGNvbnRlbnQ6IF90aGlzLmNyZWF0ZVBTQVRhYkxpc3RJbWFnZXMoc2hha2VtYXApXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjb21iaW5lZCBsaW5rL2ltYWdlIGZvciB0YWJsaXN0IGltYWdlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtDb250ZW50fSBjb250ZW50XG4gICAqICAgICAgICAgc2hha2VtYXAgQ29udGVudCBvYmplY3Qgd2l0aCBhbiB1cmwgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBsaW5rXG4gICAqICAgICAgICAgaW1hZ2UgbGluayB0byBpbnRlcmFjdGl2ZSBtYXAuXG4gICoqL1xuICBfdGhpcy5jcmVhdGVUYWJMaXN0SW1hZ2UgPSBmdW5jdGlvbiAoY29udGVudCwgYWx0KSB7XG4gICAgdmFyIGxpbms7XG5cbiAgICBpZiAoIWNvbnRlbnQuZ2V0KCd1cmwnKSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIEluIGFkZGl0aW9uIHRvIGNvbnRvdXJzIChkZWZhdWx0KSwgZW5hYmxlIHN0YXRpb25zXG4gICAgbGluayA9XG4gICAgICAnPGEgaHJlZj1cIiNtYXA/JyArIEludGVyYWN0aXZlTWFwVmlldy5TSEFLRU1BUF9TVEFUSU9OUyArICc9dHJ1ZScgK1xuICAgICAgICAgICcmc2hha2VtYXBTb3VyY2U9JyArIF90aGlzLm1vZGVsLmdldCgnc291cmNlJykgK1xuICAgICAgICAgICcmc2hha2VtYXBDb2RlPScgKyBfdGhpcy5tb2RlbC5nZXQoJ2NvZGUnKSArICdcIj4nICtcbiAgICAgICAgJzxpbWcnICtcbiAgICAgICAgICAnIGNsYXNzPVwic2hha2VtYXAtdGFibGlzdC1pbWFnZVwiICcgK1xuICAgICAgICAgICcgc3JjPVwiJyArIGNvbnRlbnQuZ2V0KCd1cmwnKSArICdcIicgK1xuICAgICAgICAgICcgYWx0PVwiJyArIGFsdCArICdcIicgK1xuICAgICAgICAnLz4nICtcbiAgICAgICc8L2E+JztcblxuICAgIHJldHVybiBsaW5rO1xuICB9O1xuXG4gIF90aGlzLmRlc3Ryb3kgPSBVdGlsLmNvbXBvc2UoZnVuY3Rpb24gKCkge1xuICAgIC8vIERlc3Ryb3kgdGFibGlzdFxuICAgIGlmIChfdGFibGlzdCkge1xuICAgICAgX3RhYmxpc3QuZGVzdHJveSgpO1xuICAgICAgX3RhYmxpc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChfc2hha2VNYXBJbmZvVmlldykge1xuICAgICAgX3NoYWtlTWFwSW5mb1ZpZXcuZGVzdHJveSgpO1xuICAgICAgX3NoYWtlTWFwSW5mb1ZpZXcgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIERlc3Ryb3AgU2hha2VNYXBTdGF0aW9uTGlzdFxuICAgIGlmIChfc2hha2VNYXBTdGF0aW9uTGlzdFZpZXcpIHtcbiAgICAgIF9zaGFrZU1hcFN0YXRpb25MaXN0Vmlldy5kZXN0cm95KCk7XG4gICAgICBfc2hha2VNYXBTdGF0aW9uTGlzdFZpZXcgPSBudWxsO1xuICAgIH1cblxuICAgIF9pbml0aWFsaXplID0gbnVsbDtcbiAgICBfdGhpcyA9IG51bGw7XG4gIH0sIF90aGlzLmRlc3Ryb3kpO1xuXG4gIF90aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwsXG4gICAgICAgIHNoYWtlbWFwO1xuXG4gICAgZWwgPSBfdGhpcy5lbDtcbiAgICBzaGFrZW1hcCA9IF90aGlzLm1vZGVsO1xuXG4gICAgaWYgKHNoYWtlbWFwLmlzRGVsZXRlZCgpKSB7XG4gICAgICBlbC5pbm5lckhUTUwgPSAnPHAgY2xhc3M9XCJhbGVydCBpbmZvXCI+UHJvZHVjdCBEZWxldGVkPC9wPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ1aWxkIFRhYkxpc3Qgd2l0aCBhbGwgb2YgdGhlIHNoYWtlbWFwIGltYWdlc1xuICAgICAgX3RhYmxpc3QgPSBuZXcgVGFiTGlzdCh7XG4gICAgICAgIGVsOiBlbCxcbiAgICAgICAgdGFiUG9zaXRpb246ICd0b3AnLFxuICAgICAgICB0YWJzOiBbXVxuICAgICAgfSk7XG4gICAgICBfdGhpcy5jcmVhdGVUYWJMaXN0RGF0YShzaGFrZW1hcCk7XG4gICAgfVxuICB9O1xuXG4gIF9pbml0aWFsaXplKCk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYWtlTWFwVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXcgPSByZXF1aXJlKCdtdmMvVmlldycpO1xudmFyIFV0aWwgPSByZXF1aXJlKCd1dGlsL1V0aWwnKTtcbnZhciBYaHIgPSByZXF1aXJlKCd1dGlsL1hocicpO1xuXG5cbnZhciBERUZBVUxUUyA9IHtcbiAgLy8gY29udGFpbmVyIGVsZW1lbnRcbiAgZWw6IG51bGwsXG4gIC8vIGltYWdlIHVybFxuICBpbWFnZVVybDogbnVsbCxcbiAgLy8gaW1hZ2UgYWx0LFxuICBpbWFnZUFsdDogJycsXG4gIC8vIGltYWdlbWFwIHVybFxuICBtYXBVcmw6IG51bGwsXG4gIC8vIGltYWdlbWFwIG5hbWUgKG9wdGlvbmFsKVxuICBtYXBOYW1lOiBudWxsLFxuICAvLyBpZiBpbWFnZW1hcCBpcyBhbHJlYWR5IGFzIHN2Z1xuICBzdmdVcmw6IG51bGwsXG4gIC8vIHdpZHRoIG9mIGltYWdlbWFwXG4gIHdpZHRoOiBudWxsLFxuICAvLyBoZWlnaHQgb2YgaW1hZ2VtYXBcbiAgaGVpZ2h0OiBudWxsLFxuICAvLyBhcmVhcyBvZiBpbWFnZW1hcFxuICBhcmVhczogbnVsbFxufTtcblxuXG5cbi8qKlxuICogUGFyc2UgYW4gaW1hZ2UgbWFwIGZyb20gYW4gSFRNTCBzdHJpbmcuXG4gKlxuICogQ2FsbHMgc2V0QXJlYXMoKSB3aXRoIHBhcnNlZCBhcmVhIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSBodG1sIHtTdHJpbmd9XG4gKiAgICAgICAgaHRtbCBzdHJpbmcgY29udGFpbmluZyBpbWFnZW1hcC5cbiAqIEBwYXJhbSBtYXBOYW1lIHtTdHJpbmd9XG4gKiAgICAgICAgb3B0aW9uYWwsIHZhbHVlIG9mIG5hbWUgYXR0cmlidXRlLlxuICogICAgICAgIGJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBpbWFnZW1hcCBpbiBodG1sIGlzIHBhcnNlZC5cbiAqIEByZXR1cm5cbiAqL1xudmFyIHBhcnNlTWFwID0gZnVuY3Rpb24oaHRtbCwgbWFwTmFtZSkge1xuICB2YXIgcGFyc2VkID0gW10sXG4gICAgICBzZWxlY3RvciA9ICdtYXAnLFxuICAgICAgcGFyc2VFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgZWwsIGFyZWFzLCBpLCBsZW47XG5cbiAgLy8gaW5zZXJ0IGludG8gZWxlbWVudCB0byBwYXJzZS5cbiAgcGFyc2VFbC5pbm5lckhUTUwgPSBodG1sO1xuICAvLyBmaW5kIGltYWdlbWFwXG4gIGlmIChtYXBOYW1lKSB7XG4gICAgc2VsZWN0b3IgKz0gJ1tuYW1lPVxcJycgKyBtYXBOYW1lICsgJ1xcJ10nO1xuICB9XG4gIGVsID0gcGFyc2VFbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgaWYgKGVsKSB7XG4gICAgLy8gZmluZCBhcmVhc1xuICAgIGFyZWFzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnYXJlYScpO1xuICAgIGZvciAoaT0wLCBsZW49YXJlYXMubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICBlbCA9IGFyZWFzW2ldO1xuICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAnc2hhcGUnOiBlbC5nZXRBdHRyaWJ1dGUoJ3NoYXBlJyksXG4gICAgICAgICdjb29yZHMnOiBlbC5nZXRBdHRyaWJ1dGUoJ2Nvb3JkcycpLnNwbGl0KCcsJyksXG4gICAgICAgICd0aXRsZSc6IGVsLmdldEF0dHJpYnV0ZSgndGl0bGUnKSxcbiAgICAgICAgJ2hyZWYnOiBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGFyZWFzID0gbnVsbDtcbiAgfVxuICBwYXJzZUVsID0gbnVsbDtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIGFyZWEgb2JqZWN0IHRvIGEgc3ZnIHBhdGggZWxlbWVudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGFyZWEge09iamVjdH1cbiAqIEBwYXJhbSBhcmVhLnNoYXBlIHtTdHJpbmd9XG4gKiAgICAgICAgJ2NpcmNsZScsICdyZWN0JywgYW5kICdwb2x5JyBhcmUgc3VwcG9ydGVkLlxuICogQHBhcmFtIGFyZWEuY29vcmRzIHtBcnJheTxTdHJpbmc+fVxuICogICAgICAgIGFuIGFycmF5IG9mIGNvb3JkaW5hdGVzLCBtZWFuaW5nIGRlcGVuZHMgb24gc2hhcGVcbiAqIEBwYXJhbSBhcmVhLnRpdGxlIHtTdHJpbmd9XG4gKiAgICAgICAgb3B0aW9uYWwuICB0aXRsZSBmb3IgYXJlYSwgc2hvd24gb24gbW91c2VvdmVyLlxuICogQHBhcmFtIGFyZWEuaHJlZiB7U3RyaW5nfVxuICogICAgICAgIG9wdGlvbmFsLiAgbGluayBmb3IgYXJlYSwgYWN0aXZhdGVkIG9uIGNsaWNrLlxuICogQHJldHVybiB7U3RyaW5nfSBzdmcgY2lyY2xlLCByZWN0LCBvciBwYXRoLCBtYXJrdXAgYXMgc3RyaW5nLlxuICovXG52YXIgZ2V0UGF0aCA9IGZ1bmN0aW9uIChhcmVhKSB7XG4gIHZhciBidWYgPSBbXSxcbiAgICAgIHNoYXBlID0gYXJlYS5zaGFwZSxcbiAgICAgIGNvb3JkcyA9IGFyZWEuY29vcmRzLFxuICAgICAgdGl0bGUgPSBhcmVhLnRpdGxlLFxuICAgICAgaHJlZiA9IGFyZWEuaHJlZjtcblxuICAvLyBocmVmIGFuZCB0aXRsZSBhcmUgb3B0aW9uYWwsIGJ1dCB3b3JrIHRoZSBzYW1lIGZvciBldmVyeSBzaGFwZVxuICBocmVmID0gKGhyZWYgPT09IG51bGwgPyAnJyA6ICcgeGxpbms6aHJlZj1cIicgKyBocmVmICsgJ1wiJyk7XG4gIHRpdGxlID0gKHRpdGxlID09PSBudWxsID8gJycgOiAnPHRpdGxlPicgKyB0aXRsZSArICc8L3RpdGxlPicpO1xuXG4gIGlmIChzaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAvLyBjaXJjbGUgY29vcmRzIGFyZSB4LHkscmFkaXVzXG4gICAgYnVmLnB1c2goXG4gICAgICAgICc8Y2lyY2xlJyxcbiAgICAgICAgJyBjeD1cIicsIGNvb3Jkc1swXSwgJ1wiJyxcbiAgICAgICAgJyBjeT1cIicsIGNvb3Jkc1sxXSwgJ1wiJyxcbiAgICAgICAgJyByPVwiJywgY29vcmRzWzJdLCAnXCInLFxuICAgICAgICBocmVmLFxuICAgICAgICAnPicsIHRpdGxlLCAnPC9jaXJjbGU+Jyk7XG4gIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdyZWN0Jykge1xuICAgIC8vIHJlY3RhbmdsZSBjb29yZHMgYXJlIHgxLHkxLHgyLHkyXG4gICAgYnVmLnB1c2goXG4gICAgICAgICc8cmVjdCcsXG4gICAgICAgICcgeD1cIicsIGNvb3Jkc1swXSwgJ1wiJyxcbiAgICAgICAgJyB5PVwiJywgY29vcmRzWzFdLCAnXCInLFxuICAgICAgICAnIHdpZHRoPVwiJywgY29vcmRzWzJdLWNvb3Jkc1swXSwgJ1wiJyxcbiAgICAgICAgJyBoZWlnaHQ9XCInLCBjb29yZHNbM10tY29vcmRzWzFdLCAnXCInLFxuICAgICAgICBocmVmLFxuICAgICAgICAnPicsIHRpdGxlLCAnPC9yZWN0PicpO1xuICB9IGVsc2UgaWYgKHNoYXBlID09PSAncG9seScpIHtcbiAgICAvLyBwb2x5IGNvb3JkcyBhcmUgeDEseTEseDIseTIsLi4ueE4seU5cbiAgICAvLyBjb252ZXJ0IGFyZWEgY29vcmRpbmF0ZSBsaXN0IHRvIHN2ZyBwYXRoXG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGk9MCwgbGVuPWNvb3Jkcy5sZW5ndGg7IGk8bGVuOyBpKz0yKSB7XG4gICAgICAvLyBzdmcgXCJNXCIgaXMgbW92ZSB0bywgXCJMXCIgaXMgbGluZSB0b1xuICAgICAgcG9pbnRzLnB1c2goKGkgPT09IDAgPyAnTScgOiAnTCcpLCBjb29yZHNbaV0sICcsJywgY29vcmRzW2krMV0pO1xuICAgIH1cbiAgICAvLyBzdmcgXCJaXCIgaXMgY2xvc2UgcGF0aFxuICAgIHBvaW50cy5wdXNoKCdaJyk7XG4gICAgYnVmLnB1c2goXG4gICAgICAgICc8cGF0aCcsXG4gICAgICAgICcgZD1cIicsIHBvaW50cy5qb2luKCcnKSwgJ1wiJyxcbiAgICAgICAgaHJlZixcbiAgICAgICAgJz4nLCB0aXRsZSwgJzwvcGF0aD4nKTtcbiAgfVxuXG4gIHJldHVybiBidWYuam9pbignJyk7XG59O1xuXG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgU3ZnSW1hZ2VNYXAuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqIEBwYXJhbSBvcHRpb25zLmltYWdlVXJsIHtTdHJpbmd9XG4gKiAgICAgICAgdXJsIHRvIGltYWdlXG4gKiBAcGFyYW0gb3B0aW9ucy5pbWFnZUFsdCB7U3RyaW5nfVxuICogICAgICAgIGFsdCBhdHRyaWJ1dGUgZm9yIGltYWdlLlxuICogQHBhcmFtIG9wdGlvbnMuY2xhc3NOYW1lIHtTdHJpbmd9XG4gKiAgICAgICAgY2xhc3NuYW1lIGZvciB3cmFwcGVyIGVsZW1lbnQuXG4gKlxuICogT3RoZXIgcGFyYW1ldGVycyBjb25maWd1cmUgaG93IHRvIGxvYWQgdGhlIGltYWdlIG1hcDpcbiAqXG4gKiAtIEZyb20gYW4gZXhpc3RpbmcgU1ZHIEZpbGU6XG4gKlxuICogQHBhcmFtIG9wdGlvbnMuc3ZnVXJsIHtTdHJpbmd9XG4gKiAgICAgICAgb3B0aW9uYSwgdXJsIHRvIHN2ZyBpbWFnZW1hcC5cbiAqXG4gKiAtIFByb2dyYW1hdGljYWxseSwgZWl0aGVyIGF0IGNvbnN0cnVjdGlvbiBvciB2aWEgc2V0QXJlYXMoKTpcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucy5hcmVhcyB7QXJyYXk8QXJlYT59XG4gKiAgICAgICAgYXJlYXMgZm9yIGltYWdlbWFwLlxuICpcbiAqIC0gRnJvbSBhbiBleGlzdGluZyBIVE1MIGltYWdlbWFwOlxuICpcbiAqIEBwYXJhbSBvcHRpb25zLm1hcFVybCB7U3RyaW5nfVxuICogICAgICAgIHVybCB0byBodG1sIHdpdGggaW1hZ2VtYXBcbiAqIEBwYXJhbSBvcHRpb25zLm1hcE5hbWUge1N0cmluZ31cbiAqICAgICAgICBvcHRpb25hbCwgc3BlY2lmeSB0aGUgaW1hZ2VtYXAgbmFtZSBpbiBjYXNlIHRoZXJlIGFyZSBtYW55LlxuICovXG52YXIgU3ZnSW1hZ2VNYXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMsXG4gICAgICBfaW5pdGlhbGl6ZSxcblxuICAgICAgX2FyZWFzLFxuICAgICAgX2NsYXNzTmFtZSxcbiAgICAgIF9lbCxcbiAgICAgIF9oZWlnaHQsXG4gICAgICBfaW1hZ2VBbHQsXG4gICAgICBfaW1hZ2VVcmwsXG4gICAgICBfbWFwTmFtZSxcbiAgICAgIF9tYXBVcmwsXG4gICAgICBfc3ZnVXJsLFxuICAgICAgX3dpZHRoLFxuXG4gICAgICBfcGFyZW50RGVzdHJveSxcbiAgICAgIF9zZXRTdmc7XG5cbiAgX3RoaXMgPSBPYmplY3QuY3JlYXRlKFZpZXcob3B0aW9ucykpO1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbWFnZSxcbiAgICAgICAgaW1hZ2VPbkxvYWQ7XG4gICAgLy8gcGFyc2Ugb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgREVGQVVMVFMsIG9wdGlvbnMpO1xuICAgIF9hcmVhcyA9IG9wdGlvbnMuYXJlYXMgfHwgW107XG4gICAgX2NsYXNzTmFtZSA9IG9wdGlvbnMuY2xhc3NOYW1lO1xuICAgIF9oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICBfaW1hZ2VBbHQgPSBvcHRpb25zLmltYWdlQWx0O1xuICAgIF9pbWFnZVVybCA9IG9wdGlvbnMuaW1hZ2VVcmw7XG4gICAgX21hcE5hbWUgPSBvcHRpb25zLm1hcE5hbWU7XG4gICAgX21hcFVybCA9IG9wdGlvbnMubWFwVXJsO1xuICAgIF9zdmdVcmwgPSBvcHRpb25zLnN2Z1VybDtcbiAgICBfd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgIC8vIGNvbnRhaW5lciBlbGVtZW50IGNsYXNzZXNcbiAgICBfZWwgPSBfdGhpcy5lbDtcbiAgICBfZWwuY2xhc3NMaXN0LmFkZCgnc3ZnaW1hZ2VtYXAnKTtcbiAgICBpZiAoX2NsYXNzTmFtZSkge1xuICAgICAgX2VsLmNsYXNzTGlzdC5hZGQoX2NsYXNzTmFtZSk7XG4gICAgfVxuICAgIC8vIGxvYWQgaW1hZ2VcbiAgICBpbWFnZU9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFNpemUoaW1hZ2UubmF0dXJhbFdpZHRoLCBpbWFnZS5uYXR1cmFsSGVpZ2h0KTtcbiAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBpbWFnZU9uTG9hZCk7XG4gICAgICBpbWFnZU9uTG9hZCA9IG51bGw7XG4gICAgfTtcbiAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBpbWFnZU9uTG9hZCk7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKCdhbHQnLCBfaW1hZ2VBbHQpO1xuICAgIGltYWdlLnNyYyA9IF9pbWFnZVVybDtcbiAgICBfZWwuYXBwZW5kQ2hpbGQoaW1hZ2UpO1xuICAgIC8vIGxvYWQgaW1hZ2VtYXBcbiAgICBpZiAoX3N2Z1VybCkge1xuICAgICAgWGhyLmFqYXgoe1xuICAgICAgICB1cmw6IF9zdmdVcmwsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZS8qLCB4aHIqLykge1xuICAgICAgICAgIF90aGlzLnNldFN2ZyhyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoX21hcFVybCkge1xuICAgICAgWGhyLmFqYXgoe1xuICAgICAgICB1cmw6IF9tYXBVcmwsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZS8qLCB4aHIqLykge1xuICAgICAgICAgIF90aGlzLnNldEFyZWFzKHBhcnNlTWFwKHJlc3BvbnNlLCBfbWFwTmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2xlYXIgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9O1xuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIHBhcmVudCBkZXN0cm95IG1ldGhvZFxuICBfcGFyZW50RGVzdHJveSA9IF90aGlzLmRlc3Ryb3k7XG4gIF90aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2FyZWFzID0gbnVsbDtcbiAgICBfY2xhc3NOYW1lID0gbnVsbDtcbiAgICBfZWwgPSBudWxsO1xuICAgIF9oZWlnaHQgPSBudWxsO1xuICAgIF9tYXBVcmwgPSBudWxsO1xuICAgIF9tYXBOYW1lID0gbnVsbDtcbiAgICBfc3ZnVXJsID0gbnVsbDtcbiAgICBfd2lkdGggPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBfcGFyZW50RGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX3BhcmVudERlc3Ryb3koKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgYXJlYXMgYXJyYXkuXG4gICAqL1xuICBfdGhpcy5nZXRBcmVhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FyZWFzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGltYWdlIG1hcCBhcmVhcy5cbiAgICpcbiAgICogQ2FsbHMgcmVuZGVyKCkgYWZ0ZXIgc2V0dGluZyBhcmVhcy5cbiAgICpcbiAgICogQHBhcmFtIGFyZWFzIHtBcnJheTxBcmVhPn1cbiAgICovXG4gIF90aGlzLnNldEFyZWFzID0gZnVuY3Rpb24gKGFyZWFzKSB7XG4gICAgX2FyZWFzID0gYXJlYXM7XG4gICAgLy8gcmVkcmF3IHN2Z1xuICAgIF90aGlzLnJlbmRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGltYWdlIG1hcCBzaXplLlxuICAgKlxuICAgKiBDYWxscyByZW5kZXIoKSBhZnRlciBzZXR0aW5nIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSB3aWR0aCB3aWR0aCBvZiBpbWFnZS5cbiAgICogQHBhcmFtIGhlaWdodCBoZWlnaHQgb2YgaW1hZ2UuXG4gICAqL1xuICBfdGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBzYXZlIGZvciBzdmdcbiAgICBfd2lkdGggPSB3aWR0aDtcbiAgICBfaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGlmIChfZWwgJiYgd2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAvLyBzZXQgZWxlbWVudCBzaXplXG4gICAgICBfZWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcbiAgICAgIF9lbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfVxuICAgIC8vIHJlZHJhdyBzdmdcbiAgICBfdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSByZW5kZXJlZCBpbWFnZW1hcCBiYXNlZCBvbiB3aWR0aCwgaGVpZ2h0LCBhbmQgYXJlYXMuXG4gICAqL1xuICBfdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1ZixcbiAgICAgICAgaSxcbiAgICAgICAgbGVuO1xuXG4gICAgaWYgKCFfd2lkdGggfHwgIV9oZWlnaHQgfHwgIV9hcmVhcyB8fCBfYXJlYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgc3ZnXG4gICAgYnVmID0gW107XG4gICAgLy8gb3BlbiBzdmcgZWxlbWVudFxuICAgIGJ1Zi5wdXNoKCc8c3ZnJyxcbiAgICAgICAgJyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCInLFxuICAgICAgICAnIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiJyxcbiAgICAgICAgJyB3aWR0aD1cIicsIF93aWR0aCwgJ1wiJyxcbiAgICAgICAgJyBoZWlnaHQ9XCInLCBfaGVpZ2h0LCAnXCInLFxuICAgICAgICAnIHZpZXdCb3g9XCIwLDAsJywgX3dpZHRoLCAnLCcsIF9oZWlnaHQsICdcIicsXG4gICAgICAgICcgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaW5ZTWluXCInLFxuICAgICAgICAnPicpO1xuICAgIC8vIGFkZCBpbWFnZW1hcCBhcmVhc1xuICAgIGxlbiA9IF9hcmVhcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBidWYucHVzaChnZXRQYXRoKF9hcmVhc1tpXSkpO1xuICAgIH1cbiAgICAvLyBjbG9zZSBzdmcgZWxlbWVudFxuICAgIGJ1Zi5wdXNoKCc8L3N2Zz4nKTtcbiAgICBfc2V0U3ZnKGJ1Zi5qb2luKCcnKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbnkgZXhpc3Rpbmcgc3ZnIGVsZW1lbnQsIGFuZCBpbnNlcnQgYW4gc3ZnIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBzdmcge1N0cmluZ3xFbGVtZW50fVxuICAgKiAgICAgICAgdGhlIHN2ZyB0byBpbnNlcnQuXG4gICAqICAgICAgICBpZiBhIFN0cmluZywgY29udmVydGVkIHRvIGFuIEVsZW1lbnQgYmVmb3JlIGluc2VydGlvbi5cbiAgICovXG4gIF9zZXRTdmcgPSBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgdmFyIG9sZFN2ZyxcbiAgICAgICAgcGFyc2VFbDtcblxuICAgIGlmIChfZWwpIHtcbiAgICAgIC8vIHJlbW92ZSBhbnkgZXhpc3Rpbmcgc3ZnXG4gICAgICBvbGRTdmcgPSBfZWwucXVlcnlTZWxlY3Rvcignc3ZnJyk7XG4gICAgICBpZiAob2xkU3ZnKSB7XG4gICAgICAgIF9lbC5yZW1vdmVDaGlsZChvbGRTdmcpO1xuICAgICAgfVxuICAgICAgLy8gY29udmVydCBzdmcgc3RyaW5nIHRvIHN2ZyBlbGVtZW50XG4gICAgICBpZiAodHlwZW9mIHN2ZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyc2VFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwYXJzZUVsLmlubmVySFRNTCA9IHN2ZztcbiAgICAgICAgc3ZnID0gcGFyc2VFbC5jaGlsZHJlblswXTtcbiAgICAgICAgcGFyc2VFbCA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBpbnNlcnQgc3ZnXG4gICAgICBpZiAoc3ZnKSB7XG4gICAgICAgIF9lbC5hcHBlbmRDaGlsZChzdmcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIF9pbml0aWFsaXplKCk7XG4gIHJldHVybiBfdGhpcztcbn07XG5cblxuU3ZnSW1hZ2VNYXAuZ2V0UGF0aCA9IGdldFBhdGg7XG5TdmdJbWFnZU1hcC5wYXJzZU1hcCA9IHBhcnNlTWFwO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3ZnSW1hZ2VNYXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIHNlcXVlbmNlIGZvciBhc3NpZ25pbmcgdW5pcXVlIGVsZW1lbnQgaWRzLCBmb3IgYXJpYSByb2xlc1xudmFyIElEX1NFUVVFTkNFID0gMDtcblxuXG4vKipcbiAqIEZvcm1hdCB0YWIgKHN1bW1hcnkpIGNvbnRlbnQgZm9yIGEgbGlzdCBpdGVtLlxuICpcbiAqIEBwYXJhbSBvYmoge09iamVjdH1cbiAqICAgICAgICBvYmplY3QgYmVpbmcgYWRkZWQgdG8gdGhlIGxpc3QuXG4gKiBAcmV0dXJuIHtTdHJpbmd8RE9NRWxlbWVudH1cbiAqICAgICAgICAgVGhpcyBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIG9iai50aXRsZS5cbiAqL1xudmFyIF9fZ2V0VGFiQ29udGVudCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqLnRpdGxlO1xufTtcblxuXG4vKipcbiAqIEZvcm1hdCBwYW5lbCAoZGV0YWlsKSBjb250ZW50IGZvciBhIGxpc3QgaXRlbS5cbiAqXG4gKiBAcGFyYW0gb2JqIHtPYmplY3R9XG4gKiAgICAgICAgb2JqZWN0IGJlaW5nIGFkZGVkIHRvIHRoZSBsaXN0LlxuICogQHJldHVybiB7U3RyaW5nfERPTUVsZW1lbnR9XG4gKiAgICAgICAgIElmIG9iai5jb250ZW50IGlzIGEgZnVuY3Rpb24sIGl0cyByZXR1cm4gdmFsdWUgaXMgcmV0dXJuZWQuXG4gKiAgICAgICAgIE90aGVyd2lzZSwgdGhpcyBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIG9iai5jb250ZW50LlxuICovXG52YXIgX19nZXRQYW5lbENvbnRlbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmouY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvYmouY29udGVudChvYmopO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmouY29udGVudDtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbnN0cnVjdCBhIG5ldyBJdGVtTGlzdC5cbiAqXG4gKiBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhlIG1ldGhvZHMgX19nZXRUYWJDb250ZW50KCkgYW5kXG4gKiBnZXRQYW5lbENvbnRlbnQoKSB0byBjaGFuZ2UgbGlzdCBmb3JtYXR0aW5nLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gKiBAcGFyYW0gb3B0aW9ucy5lbCB7RE9NRWxlbWVudH1cbiAqICAgICAgICBPcHRpb25hbCwgZGVmYXVsdCBpcyBuZXcgc2VjdGlvbiBlbGVtZW50LlxuICogQHBhcmFtIG9wdGlvbnMuaGVhZGVyIHtTdHJpbmd9XG4gKiAgICAgICAgT3B0aW9uYWwsIG1hcmt1cCBwbGFjZWQgaW4gaGVhZGVyIGZvciB0YWIgbGlzdC5cbiAqIEBwYXJhbSBvcHRpb25zLnRhYnMge0FycmF5PE9iamVjdD59XG4gKiAgICAgICAgT3B0aW9uYWwsIGFueSBpdGVtcyBhcmUgcGFzc2VkIHRvIGFkZEl0ZW0oKS5cbiAqL1xudmFyIFRhYkxpc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gIHZhciBfdGhpcyxcbiAgICAgIF9pbml0aWFsaXplLFxuXG4gICAgICBfYmFja3dhcmQsXG4gICAgICBfY29udGFpbmVyLFxuICAgICAgX2VuZFBvc2l0aW9uLFxuICAgICAgX2hlYWRlcixcbiAgICAgIF9mb3J3YXJkLFxuICAgICAgX25hdixcbiAgICAgIF9uYXZQb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbkNoYW5nZSxcbiAgICAgIF9zZWxlY3RlZCxcbiAgICAgIF9zdGFydFBvc2l0aW9uLFxuICAgICAgX2RvbnRTZWxlY3QsXG4gICAgICBfdGFicyxcblxuICAgICAgX2NlbnRlclNlbGVjdGVkVGFiLFxuICAgICAgX2NoZWNrVmFsdWVCZWZvcmVTY3JvbGxpbmcsXG4gICAgICBfZW5zdXJlU2VsZWN0ZWQsXG4gICAgICBfb25EcmFnRW5kLFxuICAgICAgX29uRHJhZ1Njcm9sbCxcbiAgICAgIF9vbkRyYWdTdGFydCxcbiAgICAgIF9vbktleVByZXNzLFxuICAgICAgX3NlbGVjdFRhYixcbiAgICAgIF9zZXRUcmFuc2xhdGUsXG4gICAgICBfc2hvd1RhYlBvc2l0aW9uLFxuICAgICAgX3VwZGF0ZVRhYkluZGV4O1xuXG4gIF90aGlzID0gT2JqZWN0LmNyZWF0ZSh7fSk7XG5cblxuICBfaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbCA9IG9wdGlvbnMuZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3RhYmxpc3QnKTtcblxuICAgIC8vIGFkZCBoZWFkZXJcbiAgICBpZiAob3B0aW9ucy5oZWFkZXIpIHtcbiAgICAgIF9oZWFkZXIgPSBfdGhpcy5lbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoZWFkZXInKSk7XG4gICAgICBfaGVhZGVyLmlubmVySFRNTCA9IG9wdGlvbnMuaGVhZGVyO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0YWIgY29udGFpbmVyXG4gICAgX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF9jb250YWluZXIuY2xhc3NOYW1lID0gJ3RhYmxpc3QtY29udGFpbmVyJztcblxuICAgIC8vIGNyZWF0ZSB0YWIgbGlzdFxuICAgIF9uYXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCduYXYnKTtcbiAgICBfbmF2LnNldEF0dHJpYnV0ZSgncm9sZScsICd0YWJsaXN0Jyk7XG4gICAgX25hdi5jbGFzc0xpc3QuYWRkKCdzbW9vdGgnKTtcbiAgICBfbmF2UG9zaXRpb24gPSAwO1xuICAgIF9wb3NpdGlvbkNoYW5nZSA9IDA7XG5cbiAgICAvLyBhZGQgdGFiIGJhY2svbmV4dCBidXR0b25zXG4gICAgX2JhY2t3YXJkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX2JhY2t3YXJkLmNsYXNzTmFtZSA9ICd0YWJsaXN0LWJhY2t3YXJkLWJ1dHRvbic7XG4gICAgX2JhY2t3YXJkLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5jaGV2cm9uX2xlZnQ8L2Rpdj4nO1xuXG4gICAgX2ZvcndhcmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfZm9yd2FyZC5jbGFzc05hbWUgPSAndGFibGlzdC1mb3J3YXJkLWJ1dHRvbic7XG4gICAgX2ZvcndhcmQuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmNoZXZyb25fcmlnaHQ8L2Rpdj4nO1xuXG4gICAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZChfbmF2KTtcbiAgICBfdGhpcy5lbC5hcHBlbmRDaGlsZChfYmFja3dhcmQpO1xuICAgIF90aGlzLmVsLmFwcGVuZENoaWxkKF9jb250YWluZXIpO1xuICAgIF90aGlzLmVsLmFwcGVuZENoaWxkKF9mb3J3YXJkKTtcblxuICAgIC8vIG1vdXNlIChkZXNrdG9wKSBpbnRlcmFjdGlvbnNcbiAgICBfYmFja3dhcmQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5zZWxlY3RQcmV2aW91c1RhYik7XG4gICAgX2ZvcndhcmQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5zZWxlY3ROZXh0VGFiKTtcbiAgICBfbmF2LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF9vbkRyYWdTdGFydCk7XG5cbiAgICAvLyB0b3VjaCAobW9iaWxlKSBpbnRlcmFjdGlvbnNcbiAgICBfbmF2LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBfb25EcmFnU3RhcnQpO1xuXG4gICAgLy8ga2V5Ym9hcmQgaW50ZXJhY3Rpb25zXG4gICAgX25hdi5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgX29uS2V5UHJlc3MpO1xuICAgIF9uYXYuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBfb25LZXlQcmVzcyk7XG5cbiAgICAvLyBhcnJheSBvZiB0YWIgb2JqZWN0c1xuICAgIF90YWJzID0gW107XG5cbiAgICAvLyBhZGQgYW55IGl0ZW1zIHByb3ZpZGVkIHdoZW4gY29uc3RydWN0aW5nXG4gICAgaWYgKG9wdGlvbnMudGFicykge1xuICAgICAgZm9yICh2YXIgaT0wLCBsZW49b3B0aW9ucy50YWJzLmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgICBfdGhpcy5hZGRUYWIob3B0aW9ucy50YWJzW2ldLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIF9lbnN1cmVTZWxlY3RlZCgpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gXCJrZXlwcmVzc1wiLCBoYW5kbGVzIGNoYW5naW5nIHRoZSBzZWxlY3RlZCB0YWIgZnJvbSB0aGVcbiAgICogdGFibGlzdC10YWIgbmF2aWdhdGlvbiB3aGVuIGEgZW50ZXIgaXMgY2xpY2tlZCBvbiBhIHRhYiB3aXRoIGZvY3VzLFxuICAgKiBvciB0aGUgbGVmdC9yaWdodCBkaXJlY3Rpb25hbCBwYWQgaXMgY2xpY2tlZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBlLFxuICAgKiAgICAgICAgIFwia2V5cHJlc3NcIiBldmVudFxuICAgKi9cbiAgX29uS2V5UHJlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuXG5cbiAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgIC8vIHByZXZlbnQgc2Nyb2xsaW5nIHRoZSB3aW5kb3dcbiAgICAgIGlmIChrZXlDb2RlID09PSAzOCB8fCBrZXlDb2RlID09PSA0MCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleUNvZGUgPT09IDM3IHx8IGtleUNvZGUgPT09IDM4KSB7XG4gICAgICAvLyBkLXBhZCBsZWZ0L3VwIGtleVxuICAgICAgX3RoaXMuc2VsZWN0UHJldmlvdXNUYWIoKTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IDM5IHx8IGtleUNvZGUgPT09IDQwKSB7XG4gICAgICAvLyBkLXBhZCByaWdodC9kb3duIGtleVxuICAgICAgX3RoaXMuc2VsZWN0TmV4dFRhYigpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gXCJ0b3VjaHN0YXJ0XCIgb3IgXCJtb3VzZWRvd25cIiwgdHJhY2tzIHRoZSBkcmFnIHN0YXJ0IHBvc2l0aW9uXG4gICAqIGFuZCBhZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgbW91c2UgZXZlbnRzIG9yIHRvdWNoIGV2ZW50cyB0aGF0IHVwZGF0ZVxuICAgKiB0aGUgcG9zaXRpb24gb2YgdGhlIHRhYmxpc3QtdGFiIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gZSxcbiAgICogICAgICAgICBcIm1vdXNlZG93blwiIGV2ZW50IE9SIFwidG91Y2hzdGFydFwiIGV2ZW50XG4gICAqL1xuICBfb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIC8vIGRvIG5vdCBhbmltYXRlIGEgY2xpY2svdG91Y2ggZHJhZyBldmVudFxuICAgIF9uYXYuY2xhc3NMaXN0LnJlbW92ZSgnc21vb3RoJyk7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgX3N0YXJ0UG9zaXRpb24gPSBlLmNsaWVudFg7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfb25EcmFnU2Nyb2xsKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfb25EcmFnRW5kKTtcbiAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAvLyBrZWVwcyBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRlbGl2ZXJlZCBvbiB0b3VjaCBldmVudHNcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF9zdGFydFBvc2l0aW9uID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfb25EcmFnU2Nyb2xsKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX29uRHJhZ0VuZCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF9vbkRyYWdFbmQpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gXCJ0b3VjaGVuZFwiIG9yIFwibW91c2V1cFwiLCByZW1vdmVzIGV2ZW50IGxpc3RlbmVyc1xuICAgKiBmb3IgbW91c2UgZXZlbnRzIG9yIHRvdWNoIGV2ZW50cyB0aGF0IHVwZGF0ZSB0aGUgcG9zaXRpb25cbiAgICogb2YgdGhlIHRhYmxpc3QtdGFiIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gZSxcbiAgICogICAgICAgICBcIm1vdXNldXBcIiBldmVudCBPUiBcInRvdWNoZW5kXCIgZXZlbnRcbiAgICovXG4gIF9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNldXAnKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfb25EcmFnU2Nyb2xsKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfb25EcmFnRW5kKTtcbiAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ3RvdWNoZW5kJyB8fCBlLnR5cGUgPT09ICd0b3VjaGNhbmNlbCcpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9vbkRyYWdTY3JvbGwpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfb25EcmFnRW5kKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX29uRHJhZ0VuZCk7XG4gICAgfVxuXG4gICAgX2NoZWNrVmFsdWVCZWZvcmVTY3JvbGxpbmcoX25hdlBvc2l0aW9uICsgX3Bvc2l0aW9uQ2hhbmdlKTtcblxuICAgIF9wb3NpdGlvbkNoYW5nZSA9IDA7XG5cbiAgICAvLyBhZGQgYmFjayB0aGUgY2xhc3MgdGhhdCBhbmltYXRlcyBuYXYgc2xpZGluZ1xuICAgIF9uYXYuY2xhc3NMaXN0LmFkZCgnc21vb3RoJyk7XG4gIH07XG5cblxuICAvKipcbiAgICogY2VudGVyIHRoZSBzZWxlY3RlZCB0YWIgb24gdGhlIG5hdmlnYXRpb24gc2xpZGZyLlxuICAgKi9cbiAgX2NlbnRlclNlbGVjdGVkVGFiID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YWIgPSBfc2VsZWN0ZWQudGFiRWwsXG4gICAgICAgIHBvc2l0aW9uO1xuXG4gICAgLy8gc2xpZGUgYWxsIHRoZSB3YXkgdG8gbGVmdCBlZGdlXG4gICAgcG9zaXRpb24gPSAodGFiLm9mZnNldExlZnQgKiAtMSk7XG4gICAgLy8gcHVzaCB0YWIgKGxlZnQtZWRnZSBvZiB0YWIpIHRvIHRoZSBtaWRkbGVcbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICsgKF9uYXYuY2xpZW50V2lkdGggLyAyKTtcbiAgICAvLyBjZW50ZXIgdGhlIHRhYiwgYnkgYWRqdXN0aW5nIGhhbGYgb2YgdGhlIHdpZHRoIHJpZ2h0XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiAtICh0YWIuY2xpZW50V2lkdGggLyAyKTtcbiAgICAvLyBkb24ndCBsZWF2ZSBoYWxmIG9mIGEgcHhcbiAgICBwb3NpdGlvbiA9IE1hdGgucm91bmQocG9zaXRpb24pO1xuXG4gICAgX2NoZWNrVmFsdWVCZWZvcmVTY3JvbGxpbmcocG9zaXRpb24pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgdHJhbnNsYXRlIHZhbHVlIGJlZm9yZSBpdCBpcyBhcHBsaWVkIHRvIGVuc3VyZSB0aGF0XG4gICAqIHRhYiBzbGlkZXIgaXMgbm90IHNjcm9sbGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZSB0byBtYWtlXG4gICAqIHRoZSBzZWxlY3RlZCB0YWIgdmlzaWJsZS5cbiAgICovXG4gIF9jaGVja1ZhbHVlQmVmb3JlU2Nyb2xsaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG1heFNjcm9sbCA9IDAsXG4gICAgICAgIG1pblNjcm9sbCA9IF9uYXYuY2xpZW50V2lkdGggLSBfbmF2LnNjcm9sbFdpZHRoO1xuXG4gICAgLy8gc2FuaXRpemUgdmFsdWVcbiAgICBpZiAodmFsdWUgPCBtaW5TY3JvbGwpIHtcbiAgICAgIHZhbHVlID0gbWluU2Nyb2xsO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXhTY3JvbGwpIHtcbiAgICAgIHZhbHVlID0gbWF4U2Nyb2xsO1xuICAgIH1cblxuICAgIC8vIHNjcm9sbCBuYXYgc2xpZGVyXG4gICAgX3NldFRyYW5zbGF0ZSh2YWx1ZSk7XG5cbiAgICAvLyB1cGRhdGUgdHJhY2tpbmcgb2YgbmF2UG9zaXRpb25cbiAgICBfbmF2UG9zaXRpb24gPSB2YWx1ZTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gXCJtb3VzZW1vdmVcIiwgdXBkYXRlcyB0aGUgc2Nyb2xsTGVmdCBwb3NpdGlvblxuICAgKiBvbiB0aGUgbmF2IHNsaWRlciB0aGF0IGNvbnRhaW5zIHRoZSB0YWIgZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gZSxcbiAgICogICAgICAgICBcIm1vdXNlbW92ZVwiIGV2ZW50XG4gICAqL1xuICBfb25EcmFnU2Nyb2xsID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcG9zaXRpb24sXG4gICAgICAgIHBvc2l0aW9uQ2hhbmdlLFxuICAgICAgICB0eXBlO1xuXG4gICAgdHlwZSA9IGUudHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgcG9zaXRpb24gPSBlLmNsaWVudFg7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgcG9zaXRpb24gPSBlLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICB9XG5cbiAgICBwb3NpdGlvbkNoYW5nZSA9IHBvc2l0aW9uIC0gX3N0YXJ0UG9zaXRpb247XG4gICAgX3Bvc2l0aW9uQ2hhbmdlID0gcG9zaXRpb25DaGFuZ2U7XG4gICAgX3NldFRyYW5zbGF0ZShfbmF2UG9zaXRpb24gKyBwb3NpdGlvbkNoYW5nZSk7XG5cbiAgICBpZiAoTWF0aC5hYnMocG9zaXRpb25DaGFuZ2UpID49IDUpIHtcbiAgICAgX2RvbnRTZWxlY3QgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBuYXYgc2xpZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24sXG4gICAqICAgICAgICB0aGUgeC1wb3NpdGlvbiBvZiB0aGUgc2xpZGVyXG4gICAqL1xuICBfc2V0VHJhbnNsYXRlID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG5cbiAgICBfbmF2LnN0eWxlWyctd2Via2l0LXRyYW5zZm9ybSddID1cbiAgICAgICAgJ3RyYW5zbGF0ZTNkKCcgKyBwb3NpdGlvbiArICdweCwgMHB4LCAwcHgpJztcbiAgICBfbmF2LnN0eWxlWyctbW96LXRyYW5zZm9ybSddID1cbiAgICAgICAgJ3RyYW5zbGF0ZTNkKCcgKyBwb3NpdGlvbiArICdweCwgMHB4LCAwcHgpJztcbiAgICBfbmF2LnN0eWxlWyctbXMtdHJhbnNmb3JtJ10gPVxuICAgICAgICAndHJhbnNsYXRlM2QoJyArIHBvc2l0aW9uICsgJ3B4LCAwcHgsIDBweCknO1xuICAgIF9uYXYuc3R5bGVbJy1vLXRyYW5zZm9ybSddID1cbiAgICAgICAgJ3RyYW5zbGF0ZTNkKCcgKyBwb3NpdGlvbiArICdweCwgMHB4LCAwcHgpJztcbiAgICBfbmF2LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgcG9zaXRpb24gKyAncHgsIDBweCwgMHB4KSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMvIFVwZGF0ZXMgdGhlIHNwYW4gdGhhdCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgdGFiIHBvc2l0aW9uLFxuICAgKiBhdXRvbWF0aWNhbGx5IGZhZGVzIHRoZSB0YWIgcG9zaXRpb24gdXNpbmcgdGhlICdmYWRlJyBjbGFzcy5cbiAgICovXG4gIF9zaG93VGFiUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNwYW4gPSBfdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcudGFiLXBvc2l0aW9uLWluZGljYXRvcicpLFxuICAgICAgICBjdXJyZW50VGFiTnVtYmVyID0gX3RhYnMuaW5kZXhPZihfc2VsZWN0ZWQpICsgMSxcbiAgICAgICAgdG90YWxUYWJOdW1iZXIgPSBfdGFicy5sZW5ndGg7XG5cbiAgICBpZiAoIXNwYW4pIHtcbiAgICAgIC8vIGNyZWF0ZSBuZXcgc3BhblxuICAgICAgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIF90aGlzLmVsLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0ZXh0XG4gICAgc3Bhbi5jbGFzc05hbWUgPSAndGFiLXBvc2l0aW9uLWluZGljYXRvcic7XG4gICAgc3Bhbi5pbm5lckhUTUwgPSBjdXJyZW50VGFiTnVtYmVyICsgJyBvZiAnICsgdG90YWxUYWJOdW1iZXI7XG5cbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ2ZhZGUnKTtcbiAgICB9LCA1MDApO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIENoYW5nZSB0YWJpbmRleCB0byAtMSBvbiBhbGwgdGFicy4gQ2hhbmdlIHRhYmluZGV4IG9uXG4gICAqIHNlbGVjdGVkIHRhYiB0byAwLlxuICAgKi9cbiAgX3VwZGF0ZVRhYkluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YWI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YWIgPSBfdGFic1tpXS50YWJFbDtcbiAgICAgIGlmICh0YWIuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICE9PSAtMSkge1xuICAgICAgICB0YWIuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICAgICAgdGFiLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2VsZWN0ZWQudGFiRWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgIF9zZWxlY3RlZC50YWJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIHRhYiBpbiB0aGlzIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSAgdG9TZWxlY3Qge09iamVjdH1cbiAgICogICAgICAgICB0aGUgdGFiIHRvIHNlbGVjdCwgYXMgcmV0dXJuZWQgYnkgYWRkVGFiKCkuXG4gICAqL1xuICBfc2VsZWN0VGFiID0gZnVuY3Rpb24gKHRvU2VsZWN0KSB7XG4gICAgdmFyIHByZXZpb3VzbHlTZWxlY3RlZCA9IF9zZWxlY3RlZDtcblxuICAgIGZvciAodmFyIGk9MCwgbGVuPV90YWJzLmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgICAgdmFyIHRhYiA9IF90YWJzW2ldLFxuICAgICAgICAgIG9wdGlvbnMgPSB0YWIub3B0aW9ucyxcbiAgICAgICAgICB0YWJFbCA9IHRhYi50YWJFbCxcbiAgICAgICAgICBwYW5lbEVsID0gdGFiLnBhbmVsRWw7XG4gICAgICBpZiAodGFiID09PSB0b1NlbGVjdCkge1xuICAgICAgICAvLyBsb2FkIHRhYiBjb250ZW50LCBpZiBuZWVkZWQuLi5cbiAgICAgICAgaWYgKCF0YWIuY29udGVudFJlYWR5KSB7XG4gICAgICAgICAgdmFyIHBhbmVsQ29udGVudCA9IF9fZ2V0UGFuZWxDb250ZW50KG9wdGlvbnMpO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFuZWxDb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGFiLnBhbmVsRWwuaW5uZXJIVE1MID0gcGFuZWxDb250ZW50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWIucGFuZWxFbC5hcHBlbmRDaGlsZChwYW5lbENvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWIuY29udGVudFJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgc3RhdGUgY2xhc3Nlc1xuICAgICAgICB0YWJFbC5jbGFzc0xpc3QuYWRkKCd0YWJsaXN0LXRhYi1zZWxlY3RlZCcpO1xuICAgICAgICBwYW5lbEVsLmNsYXNzTGlzdC5hZGQoJ3RhYmxpc3QtcGFuZWwtc2VsZWN0ZWQnKTtcbiAgICAgICAgLy8gbm90aWZ5IHRhYiBpdCBpcyB2aXNpYmxlLCBpZiBuZWVkZWQuLi5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9uU2VsZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb3B0aW9ucy5vblNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBzZWxlY3RlZCB0YWJcbiAgICAgICAgX3NlbGVjdGVkID0gdGFiO1xuICAgICAgICBfdXBkYXRlVGFiSW5kZXgoKTtcbiAgICAgICAgX2NlbnRlclNlbGVjdGVkVGFiKCk7XG4gICAgICAgIHRhYi50YWJFbC5mb2N1cygpO1xuICAgICAgICBfc2hvd1RhYlBvc2l0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJFbC5jbGFzc0xpc3QucmVtb3ZlKCd0YWJsaXN0LXRhYi1zZWxlY3RlZCcpO1xuICAgICAgICBwYW5lbEVsLmNsYXNzTGlzdC5yZW1vdmUoJ3RhYmxpc3QtcGFuZWwtc2VsZWN0ZWQnKTtcbiAgICAgICAgLy8gbm90aWZ5IHRhYiBpdCBpcyBoaWRkZW4sIGlmIG5lZWRlZC4uLlxuICAgICAgICBpZiAodGFiID09PSBwcmV2aW91c2x5U2VsZWN0ZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLm9uRGVzZWxlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvcHRpb25zLm9uRGVzZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIF9lbnN1cmVTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZWN0ZWRQYW5lbCA9IF90aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy50YWJsaXN0LXBhbmVsLXNlbGVjdGVkJyksXG4gICAgICAgIHRhYnM7XG4gICAgaWYgKHNlbGVjdGVkUGFuZWwgPT09IG51bGwpIHtcbiAgICAgIHRhYnMgPSBfdGFicztcbiAgICAgIGlmICh0YWJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gc2VsZWN0IGZpcnN0IHRhYiBieSBkZWZhdWx0XG4gICAgICAgIHRhYnNbMF0uc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEFkZCBhbiBpdGVtIHRvIHRoaXMgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogICAgICAgIGl0ZW0gYmVpbmcgYWRkZWQgdG8gbGlzdC5cbiAgICogQHBhcmFtIG9wdGlvbnMub25TZWxlY3Qge0Z1bmN0aW9ufVxuICAgKiAgICAgICAgT3B0aW9uYWwuXG4gICAqICAgICAgICBDYWxsZWQgd2hlbiB0YWIgaXMgc2VsZWN0ZWQuXG4gICAqIEBzZWUgX19nZXRUYWJDb250ZW50KCksIF9fZ2V0UGFuZWxDb250ZW50KClcbiAgICogICAgICB0aGVzZSBtZXRob2RzIGZvcm1hdCBjb250ZW50IHNob3duIGluIHRhYnMgYW5kIHBhbmVscyxcbiAgICogICAgICBhbmQgdXNlIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVycyBieSBkZWZhdWx0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy50aXRsZSB7U3RyaW5nfERPTUVsZW1lbnR9XG4gICAqICAgICAgICBVc2VkIGJ5IF9fZ2V0VGFiQ29udGVudCgpIHRvIGdlbmVyYXRlIHRhYiBjb250ZW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb250ZW50IHtTdHJpbmd8RE9NRWxlbWVudHxGdW5jdGlvbn1cbiAgICogICAgICAgIFVzZWQgYnkgX19nZXRQYW5lbENvbnRlbnQoKSB0byBnZW5lcmF0ZSBwYW5lbCBjb250ZW50LlxuICAgKiBAcmV0dXJuIG9iamVjdCB3aXRoIHNlbGVjdCgpIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNob3cgdGhlIHRhYi5cbiAgICovXG4gIF90aGlzLmFkZFRhYiA9IGZ1bmN0aW9uIChvcHRpb25zLCBkb250RW5zdXJlU2VsZWN0ZWQpIHtcbiAgICAvLyBhc3NpZ24gdW5pcXVlIGlkcyB0byB0aGlzIGl0ZW1zIGVsZW1lbnRzXG4gICAgdmFyIGlkID0gKytJRF9TRVFVRU5DRTtcbiAgICB2YXIgdGFiSWQgPSAndGFibGlzdC10YWItJyArIGlkO1xuICAgIHZhciBwYW5lbElkID0gJ3RhYmxpc3QtcGFuZWwtJyArIGlkO1xuXG4gICAgLy8gc3VtbWFyeSBlbGVtZW50XG4gICAgdmFyIHRhYkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuICAgIHRhYkVsLmlkID0gdGFiSWQ7XG4gICAgdGFiRWwuY2xhc3NOYW1lID0gJ3RhYmxpc3QtdGFiJztcbiAgICB0YWJFbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndGFiJyk7XG4gICAgdGFiRWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICB0YWJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnLCBwYW5lbElkKTtcbiAgICB2YXIgdGFiQ29udGVudCA9IF9fZ2V0VGFiQ29udGVudChvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIHRhYkNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0YWJFbC5pbm5lckhUTUwgPSB0YWJDb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJFbC5hcHBlbmRDaGlsZCh0YWJDb250ZW50KTtcbiAgICB9XG5cbiAgICAvLyBkZXRhaWwgZWxlbWVudFxuICAgIHZhciBwYW5lbEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuICAgIHBhbmVsRWwuaWQgPSBwYW5lbElkO1xuICAgIHBhbmVsRWwuY2xhc3NOYW1lID0gJ3RhYmxpc3QtcGFuZWwnO1xuICAgIHBhbmVsRWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RhYnBhbmVsJyk7XG4gICAgcGFuZWxFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScsIHRhYklkKTtcbiAgICAvLyBjb250ZW50IGFkZGVkIGJ5IF9zZWxlY3RUYWIoKVxuXG4gICAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gdGFiIGFuZCBlbGVtZW50c1xuICAgIHZhciB0YWIgPSB7XG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgdGFiRWw6IHRhYkVsLFxuICAgICAgcGFuZWxFbDogcGFuZWxFbCxcbiAgICAgIHNlbGVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX2RvbnRTZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgICBfZG9udFNlbGVjdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zZWxlY3RUYWIodGFiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgdG91Y2hlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX25hdi5jbGFzc0xpc3QuYWRkKCdzbW9vdGgnKTtcbiAgICAgICAgdGFiLnNlbGVjdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgY29udGVudFJlYWR5OiBmYWxzZVxuICAgIH07XG5cbiAgICBfdGFicy5wdXNoKHRhYik7XG5cbiAgICAvLyBjbGljayBoYW5kbGVyIGZvciB0YWJcbiAgICB0YWJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRhYi5zZWxlY3QpO1xuICAgIHRhYkVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGFiLnRvdWNoZW5kKTtcblxuICAgIC8vIHNlbGVjdCB0aGUgZmlyc3QsIG9yIHNwZWNpZmllZCBpdGVtXG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgIHRhYi5zZWxlY3QoKTtcbiAgICB9IGVsc2UgaWYgKGRvbnRFbnN1cmVTZWxlY3RlZCAhPT0gdHJ1ZSkge1xuICAgICAgX2Vuc3VyZVNlbGVjdGVkKCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGVsZW1lbnRzIHRvIGRvbVxuICAgIF9uYXYuYXBwZW5kQ2hpbGQodGFiRWwpO1xuICAgIF90aGlzLmVsLmFwcGVuZENoaWxkKHBhbmVsRWwpO1xuXG4gICAgLy8gcmV0dXJuIHJlZmVyZW5jZSB0byB0YWIgZm9yIHNlbGVjdGluZ1xuICAgIHJldHVybiB0YWI7XG4gIH07XG5cbiAgX3RoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGFiO1xuXG4gICAgLy8gZXZlbnQgYmluZGluZ3NcbiAgICBfbmF2LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF9vbkRyYWdTdGFydCk7XG4gICAgX25hdi5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgX29uRHJhZ1N0YXJ0KTtcbiAgICBfbmF2LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgX29uS2V5UHJlc3MpO1xuICAgIF9iYWNrd2FyZC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzLnNlbGVjdFByZXZpb3VzVGFiKTtcbiAgICBfZm9yd2FyZC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzLnNlbGVjdE5leHRUYWIpO1xuXG4gICAgLy8gcmVtb3ZlIHRhYkVsIGJpbmRpbmdzXG4gICAgaWYgKF90YWJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhYiA9IF90YWJzW2ldO1xuXG4gICAgICAgIC8vIGlmIHRhYiBoYXMgb25EZXN0cm95IG1ldGhvZCwgY2FsbCBvbkRlc3Ryb3koKVxuICAgICAgICBpZiAodHlwZW9mIHRhYi5vcHRpb25zLm9uRGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRhYi5vcHRpb25zLm9uRGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNsaWNrL3RhcCBldmVudCBiaW5kaW5nc1xuICAgICAgICB0YWIudGFiRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0YWIuc2VsZWN0KTtcbiAgICAgICAgdGFiLnRhYkVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGFiLnRvdWNoZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtZXRob2RzIGJvdW5kIHRvICd0aGlzJ1xuICAgIF9vbkRyYWdTY3JvbGwgPSBudWxsO1xuICAgIF9vbkRyYWdTdGFydCA9IG51bGw7XG4gICAgX29uRHJhZ0VuZCA9IG51bGw7XG4gICAgX29uS2V5UHJlc3MgPSBudWxsO1xuXG4gICAgLy8gRE9NIGVsZW1lbnRzXG4gICAgX3RoaXMuZWwgPSBudWxsO1xuICAgIF9oZWFkZXIgPSBudWxsO1xuICAgIF9jb250YWluZXIgPSBudWxsO1xuICAgIF9uYXYgPSBudWxsO1xuICAgIF9mb3J3YXJkID0gbnVsbDtcbiAgICBfYmFja3dhcmQgPSBudWxsO1xuXG4gICAgLy8gUG9zaXRpb24gdmFyaWFibGVzXG4gICAgX25hdlBvc2l0aW9uID0gbnVsbDtcbiAgICBfcG9zaXRpb25DaGFuZ2UgPSBudWxsO1xuICAgIF9zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICBfZW5kUG9zaXRpb24gPSBudWxsO1xuXG4gICAgLy8gdGFiIG9iamVjdHNcbiAgICBfc2VsZWN0ZWQgPSBudWxsO1xuICAgIF90YWJzID0gbnVsbDtcbiAgfTtcblxuICAvKlxuICAgKiBDYWxsZWQgb24gJ2JhY2t3YXJkJyBidXR0b24gY2xpY2ssIGFuZCBhbHNvIGNhbGxlZCBvblxuICAgKiAndXAnLydsZWZ0JyBkLXBhZCBrZXlib2FyZCBjbGljay4gU2VsZWN0cyB0aGUgYXBwcm9wcm9wcmlhdGUgdGFiXG4gICAqIGluIHRoZSBsaXN0LiBUaGlzIGluY2x1ZGVzIHdyYXBwaW5nIGZyb20gdGhlIGxhc3QgdGFiIGluIHRoZSBsaXN0XG4gICAqIHRvIHRoZSBmaXJzdC5cbiAgICovXG4gIF90aGlzLnNlbGVjdE5leHRUYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluY3JlbWVudCA9IDEsXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IF90YWJzLmluZGV4T2YoX3NlbGVjdGVkKSArIGluY3JlbWVudCxcbiAgICAgICAgbWF4VGFiSW5kZXggPSBfdGFicy5sZW5ndGggLSAxLFxuICAgICAgICBtaW5UYWJJbmRleCA9IDA7XG5cbiAgICAvLyBpZiBhdCB0aGUgZW5kIG9mIHRoZSB0YWJsaXN0LCBqdW1wIHRvIHN0YXJ0XG4gICAgaWYgKGN1cnJlbnRJbmRleCA+IG1heFRhYkluZGV4KSB7XG4gICAgICBjdXJyZW50SW5kZXggPSBtaW5UYWJJbmRleDtcbiAgICB9XG5cbiAgICBfdGFic1tjdXJyZW50SW5kZXhdLnNlbGVjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gJ2ZvcndhcmQnIGJ1dHRvbiBjbGljaywgYW5kIGFsc28gY2FsbGVkIG9uXG4gICAqICdkb3duJy8ncmlnaHQnIGQtcGFkIGtleWJvYXJkIGNsaWNrLiBTZWxlY3RzIHRoZSBhcHByb3Byb3ByaWF0ZSB0YWJcbiAgICogaW4gdGhlIGxpc3QuIFRoaXMgaW5jbHVkZXMgd3JhcHBpbmcgZnJvbSB0aGUgZmlyc3QgdGFiIGluIHRoZSBsaXN0XG4gICAqIHRvIHRoZSBsYXN0LlxuICAgKi9cbiAgX3RoaXMuc2VsZWN0UHJldmlvdXNUYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluY3JlbWVudCA9IC0xLFxuICAgICAgICBjdXJyZW50SW5kZXggPSBfdGFicy5pbmRleE9mKF9zZWxlY3RlZCkgKyBpbmNyZW1lbnQsXG4gICAgICAgIG1heFRhYkluZGV4ID0gX3RhYnMubGVuZ3RoIC0gMSxcbiAgICAgICAgbWluVGFiSW5kZXggPSAwO1xuXG4gICAgLy8gaWYgYXQgdGhlIHN0YXJ0IG9mIHRoZSB0YWJsaXN0LCBqdW1wIHRvIGVuZFxuICAgIGlmIChjdXJyZW50SW5kZXggPCBtaW5UYWJJbmRleCkge1xuICAgICAgY3VycmVudEluZGV4ID0gbWF4VGFiSW5kZXg7XG4gICAgICAvLyBidWcgd2l0aCB0cmFuc2xhdGUgcG9zaXRpb24sIHJlbW92ZSBjbGFzcyB0aGF0IGFuaW1hdGVzXG4gICAgICBfbmF2LmNsYXNzTGlzdC5yZW1vdmUoJ3Ntb290aCcpO1xuICAgICAgX3RhYnNbY3VycmVudEluZGV4XS5zZWxlY3QoKTtcbiAgICAgIF9uYXYuY2xhc3NMaXN0LmFkZCgnc21vb3RoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90YWJzW2N1cnJlbnRJbmRleF0uc2VsZWN0KCk7XG4gICAgfVxuICB9O1xuXG5cbiAgX2luaXRpYWxpemUoKTtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuXG52YXIgdGFiYmlmeU9uZSA9IGZ1bmN0aW9uIChlbCkge1xuICB2YXIgdGFicyA9IFtdLFxuICAgICAgcGFuZWxzLFxuICAgICAgcGFuZWwsXG4gICAgICBpLCBsZW4sXG4gICAgICB0YWJsaXN0O1xuXG4gIHBhbmVscyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5wYW5lbCcpO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBwYW5lbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwYW5lbCA9IHBhbmVsc1tpXTtcbiAgICB0YWJzLnB1c2goe1xuICAgICAgJ3RpdGxlJzogcGFuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJykgfHxcbiAgICAgICAgICBwYW5lbC5xdWVyeVNlbGVjdG9yKCdoZWFkZXInKS5pbm5lckhUTUwsXG4gICAgICAnY29udGVudCc6IHBhbmVsLFxuICAgICAgJ3NlbGVjdGVkJzogcGFuZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNlbGVjdGVkJykgPT09ICd0cnVlJ1xuICAgIH0pO1xuICB9XG5cbiAgdGFibGlzdCA9IFRhYkxpc3Qoe1xuICAgICd0YWJzJzogdGFic1xuICB9KTtcblxuICBlbC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0YWJsaXN0LmVsLCBlbCk7XG59O1xuXG52YXIgdGFiYmlmeUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxpc3RzLFxuICAgICAgaTtcbiAgbGlzdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudGFibGlzdCcpO1xuICBmb3IgKGkgPSBsaXN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIFRhYkxpc3QudGFiYmlmeU9uZShsaXN0c1tpXSk7XG4gIH1cbn07XG5cblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzXG5UYWJMaXN0LnRhYmJpZnlBbGwgPSB0YWJiaWZ5QWxsO1xuVGFiTGlzdC50YWJiaWZ5T25lID0gdGFiYmlmeU9uZTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWJMaXN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX19JTlNUQU5DRV9fID0gbnVsbDtcblxuXG52YXIgX19pc19zdHJpbmcgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgb2JqIGluc3RhbmNlb2YgU3RyaW5nKTtcbn07XG5cblxudmFyIEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9saXN0ZW5lcnM7XG5cblxuICBfdGhpcyA9IHt9O1xuXG4gIF9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIG1hcCBvZiBsaXN0ZW5lcnMgYnkgZXZlbnQgdHlwZVxuICAgIF9saXN0ZW5lcnMgPSB7fTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBGcmVlIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgX3RoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfaW5pdGlhbGl6ZSA9IG51bGw7XG4gICAgX2xpc3RlbmVycyA9IG51bGw7XG4gICAgX3RoaXMgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICpcbiAgICogT21pdHRpbmcgY2FsbGJhY2sgY2xlYXJzIGFsbCBsaXN0ZW5lcnMgZm9yIGdpdmVuIGV2ZW50LlxuICAgKiBPbWl0dGluZyBldmVudCBjbGVhcnMgYWxsIGxpc3RlbmVycyBmb3IgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IHtTdHJpbmd9XG4gICAqICAgICAgZXZlbnQgbmFtZSB0byB1bmJpbmQuXG4gICAqIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb259XG4gICAqICAgICAgY2FsbGJhY2sgdG8gdW5iaW5kLlxuICAgKiBAcGFyYW0gY29udGV4dCB7T2JqZWN0fVxuICAgKiAgICAgIGNvbnRleHQgZm9yIFwidGhpc1wiIHdoZW4gY2FsbGJhY2sgaXMgY2FsbGVkXG4gICAqL1xuICBfdGhpcy5vZmYgPSBmdW5jdGlvbiAoZXZ0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHR5cGVvZiBldnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyByZW1vdmluZyBhbGwgbGlzdGVuZXJzIG9uIHRoaXMgb2JqZWN0XG4gICAgICBfbGlzdGVuZXJzID0gbnVsbDtcbiAgICAgIF9saXN0ZW5lcnMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKCFfbGlzdGVuZXJzLmhhc093blByb3BlcnR5KGV2dCkpIHtcbiAgICAgIC8vIG5vIGxpc3RlbmVycywgbm90aGluZyB0byBkb1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gcmVtb3ZpbmcgYWxsIGxpc3RlbmVycyBmb3IgdGhpcyBldmVudFxuICAgICAgZGVsZXRlIF9saXN0ZW5lcnNbZXZ0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbnVsbDtcblxuICAgICAgLy8gc2VhcmNoIGZvciBjYWxsYmFjayB0byByZW1vdmVcbiAgICAgIGZvciAoaSA9IF9saXN0ZW5lcnNbZXZ0XS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsaXN0ZW5lciA9IF9saXN0ZW5lcnNbZXZ0XVtpXTtcblxuICAgICAgICBpZiAobGlzdGVuZXIuY2FsbGJhY2sgPT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXIuY29udGV4dCA9PT0gY29udGV4dCkpIHtcblxuICAgICAgICAgIC8vIGZvdW5kIGNhbGxiYWNrLCByZW1vdmVcbiAgICAgICAgICBfbGlzdGVuZXJzW2V2dF0uc3BsaWNlKGksMSk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgLy8gZm91bmQgY2FsbGJhY2sgd2l0aCBjb250ZXh0LCBzdG9wIHNlYXJjaGluZ1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFudXAgaWYgbGFzdCBjYWxsYmFjayBvZiB0aGlzIHR5cGVcbiAgICAgIGlmIChfbGlzdGVuZXJzW2V2dF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBfbGlzdGVuZXJzW2V2dF07XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lclxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQge1N0cmluZ31cbiAgICogICAgICBldmVudCBuYW1lIChzaW5ndWxhcikuICBFLmcuICdyZXNldCdcbiAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn1cbiAgICogICAgICBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgKiBAcGFyYW0gY29udGV4dCB7T2JqZWN0fVxuICAgKiAgICAgIGNvbnRleHQgZm9yIFwidGhpc1wiIHdoZW4gY2FsbGJhY2sgaXMgY2FsbGVkXG4gICAqL1xuICBfdGhpcy5vbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAoISgoY2FsbGJhY2sgfHwgIWNhbGxiYWNrLmFwcGx5KSB8fFxuICAgICAgICAoY29udGV4dCAmJiBfX2lzX3N0cmluZyhjYWxsYmFjaykgJiYgY29udGV4dFtjYWxsYmFja10uYXBwbHkpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayBwYXJhbWV0ZXIgaXMgbm90IGNhbGxhYmxlLicpO1xuICAgIH1cblxuICAgIGlmICghX2xpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3RlbmVyIGZvciBldmVudCB0eXBlXG4gICAgICBfbGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgIH1cblxuICAgIC8vIGFkZCBsaXN0ZW5lclxuICAgIF9saXN0ZW5lcnNbZXZlbnRdLnB1c2goe1xuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFuIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSBldmVudCB7U3RyaW5nfVxuICAgKiAgICAgIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBhcmdzIHvigKZ9XG4gICAqICAgICAgdmFyaWFibGUgbGVuZ3RoIGFyZ3VtZW50cyBhZnRlciBldmVudCBhcmUgcGFzc2VkIHRvIGxpc3RlbmVycy5cbiAgICovXG4gIF90aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgYXJncyxcbiAgICAgICAgaSxcbiAgICAgICAgbGVuLFxuICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgbGlzdGVuZXJzO1xuXG4gICAgaWYgKF9saXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG5cbiAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgbGlzdGVuZXJzID0gX2xpc3RlbmVyc1tldmVudF0uc2xpY2UoMCk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgICAvLyBOT1RFOiBpZiBsaXN0ZW5lciB0aHJvd3MgZXhjZXB0aW9uLCB0aGlzIHdpbGwgc3RvcC4uLlxuICAgICAgICBpZiAoX19pc19zdHJpbmcobGlzdGVuZXIuY2FsbGJhY2spKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY29udGV4dFtsaXN0ZW5lci5jYWxsYmFja10uYXBwbHkobGlzdGVuZXIuY29udGV4dCwgYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2suYXBwbHkobGlzdGVuZXIuY29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX2luaXRpYWxpemUoKTtcbiAgcmV0dXJuIF90aGlzO1xufTtcblxuLy8gbWFrZSBFdmVudHMgYSBnbG9iYWwgZXZlbnQgc291cmNlXG5fX0lOU1RBTkNFX18gPSBFdmVudHMoKTtcbkV2ZW50cy5vbiA9IGZ1bmN0aW9uIF9ldmVudHNfb24gKCkge1xuICByZXR1cm4gX19JTlNUQU5DRV9fLm9uLmFwcGx5KF9fSU5TVEFOQ0VfXywgYXJndW1lbnRzKTtcbn07XG5FdmVudHMub2ZmID0gZnVuY3Rpb24gX2V2ZW50c19vZmYgKCkge1xuICByZXR1cm4gX19JTlNUQU5DRV9fLm9mZi5hcHBseShfX0lOU1RBTkNFX18sIGFyZ3VtZW50cyk7XG59O1xuRXZlbnRzLnRyaWdnZXIgPSBmdW5jdGlvbiBfZXZlbnRzX3RyaWdnZXIgKCkge1xuICByZXR1cm4gX19JTlNUQU5DRV9fLnRyaWdnZXIuYXBwbHkoX19JTlNUQU5DRV9fLCBhcmd1bWVudHMpO1xufTtcblxuLy8gaW50ZXJjZXB0IHdpbmRvdy5vbmhhc2hjaGFuZ2UgZXZlbnRzLCBvciBzaW11bGF0ZSBpZiBicm93c2VyIGRvZXNuJ3Rcbi8vIHN1cHBvcnQsIGFuZCBzZW5kIHRvIGdsb2JhbCBFdmVudHMgb2JqZWN0XG52YXIgX29uSGFzaENoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gIEV2ZW50cy50cmlnZ2VyKCdoYXNoY2hhbmdlJywgZSk7XG59O1xuXG4vLyBjb3VydGVzeSBvZjpcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTMzOTg2NS9nZXQtdGhlLWhhc2hjaGFuZ2UtZXZlbnQtdG8td29yay1pbi1hbGwtYnJvd3NlcnMtaW5jbHVkaW5nLWllN1xuaWYgKCEoJ29uaGFzaGNoYW5nZScgaW4gd2luZG93KSkge1xuICB2YXIgb2xkSHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2g7XG5cbiAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgIGlmIChvbGRIcmVmICE9PSBkb2N1bWVudC5sb2NhdGlvbi5oYXNoKSB7XG4gICAgICBvbGRIcmVmID0gZG9jdW1lbnQubG9jYXRpb24uaGFzaDtcbiAgICAgIF9vbkhhc2hDaGFuZ2Uoe1xuICAgICAgICAndHlwZSc6ICdoYXNoY2hhbmdlJyxcbiAgICAgICAgJ25ld1VSTCc6IGRvY3VtZW50LmxvY2F0aW9uLmhhc2gsXG4gICAgICAgICdvbGRVUkwnOiBvbGRIcmVmXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIDMwMCk7XG5cbn0gZWxzZSBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBfb25IYXNoQ2hhbmdlLCBmYWxzZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyB0aGVzZSBjaGVja3Mgb25jZSwgaW5zdGVhZCBvZiBvbmNlIHBlciBjYWxsXG52YXIgaXNNb2JpbGUgPSBmYWxzZSxcbiAgICBzdXBwb3J0c0RhdGVJbnB1dCA9IGZhbHNlO1xuXG5cbi8vIHN0YXRpYyBvYmplY3Qgd2l0aCB1dGlsaXR5IG1ldGhvZHNcbnZhciBVdGlsID0gZnVuY3Rpb24gKCkge1xufTtcblxuXG5VdGlsLmlzTW9iaWxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNNb2JpbGU7XG59O1xuXG5VdGlsLnN1cHBvcnRzRGF0ZUlucHV0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc3VwcG9ydHNEYXRlSW5wdXQ7XG59O1xuXG4vKipcbiAqIE1lcmdlIHByb3BlcnRpZXMgZnJvbSBhIHNlcmllcyBvZiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBkc3Qge09iamVjdH1cbiAqICAgICAgdGFyZ2V0IHdoZXJlIG1lcmdlZCBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgdG8uXG4gKiBAcGFyYW0gPHZhcmlhYmxlPiB7T2JqZWN0fVxuICogICAgICBzb3VyY2Ugb2JqZWN0cyBmb3IgcHJvcGVydGllcy4gV2hlbiBhIHNvdXJjZSBpcyBub24gbnVsbCwgaXQnc1xuICogICAgICBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQgdG8gdGhlIGRzdCBvYmplY3QuIFByb3BlcnRpZXMgYXJlIGNvcGllZCBpblxuICogICAgICB0aGUgb3JkZXIgb2YgYXJndW1lbnRzOiBhIHByb3BlcnR5IG9uIGEgbGF0ZXIgYXJndW1lbnQgb3ZlcnJpZGVzIGFcbiAqICAgICAgcHJvcGVydHkgb24gYW4gZWFybGllciBhcmd1bWVudC5cbiAqL1xuVXRpbC5leHRlbmQgPSBmdW5jdGlvbiAoZHN0KSB7XG4gIHZhciBpLCBsZW4sIHNyYywgcHJvcDtcblxuICAvLyBpdGVyYXRlIG92ZXIgc291cmNlcyB3aGVyZSBwcm9wZXJ0aWVzIGFyZSByZWFkXG4gIGZvciAoaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNyYyA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoc3JjKSB7XG4gICAgICBmb3IgKHByb3AgaW4gc3JjKSB7XG4gICAgICAgIGRzdFtwcm9wXSA9IHNyY1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm4gdXBkYXRlZCBvYmplY3RcbiAgcmV0dXJuIGRzdDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIG9iamVjdHMgYXJlIGVxdWFsLlxuICpcbiAqIEBwYXJhbSBhIHtPYmplY3R9XG4gKiAgICAgIE9iamVjdCBhLlxuICogQHBhcmFtIGIge09iamVjdH1cbiAqICAgICAgT2JqZWN0IGIuXG4gKi9cblV0aWwuZXF1YWxzID0gZnVuY3Rpb24gKG9iakEsIG9iakIpIHtcbiAgdmFyIGtleWEsIGtleWI7XG5cbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICAvLyBpZiA9PT0gdGhlbiA9PT0sIG5vIHF1ZXN0aW9uIGFib3V0IHRoYXQuLi5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChvYmpBID09PSBudWxsIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICAvLyBmdW5ueSwgdHlwZW9mIG51bGwgPT09ICdvYmplY3QnLCBzbyAuLi4gaG1waCFcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iakEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmpCID09PSAnb2JqZWN0Jykge1xuICAgIC8vIHJlY3Vyc2l2ZWx5IGNoZWNrIG9iamVjdHNcbiAgICBmb3IgKGtleWEgaW4gb2JqQSkge1xuICAgICAgaWYgKG9iakEuaGFzT3duUHJvcGVydHkoa2V5YSkpIHtcbiAgICAgICAgaWYgKCFvYmpCLmhhc093blByb3BlcnR5KGtleWEpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvYmpCIGlzIG1pc3NpbmcgYSBrZXkgZnJvbSBvYmpBXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGtleWIgaW4gb2JqQikge1xuICAgICAgaWYgKG9iakIuaGFzT3duUHJvcGVydHkoa2V5YikpIHtcbiAgICAgICAgaWYgKCFvYmpBLmhhc093blByb3BlcnR5KGtleWIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvYmpBIGlzIG1pc3NpbmcgYSBrZXkgZnJvbSBvYmpCXG4gICAgICAgIH0gZWxzZSBpZiAoIVV0aWwuZXF1YWxzKG9iakFba2V5Yl0sIG9iakJba2V5Yl0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvYmpBW2tleV0gIT09IG9iakJba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7IC8vIFJlY3Vyc2l2ZWx5IGVxdWFsLCBzbyBlcXVhbFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpBID09PSBvYmpCOyAvLyBVc2UgYmFrZWQgaW4gPT09IGZvciBwcmltaXRpdmVzXG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGFuIGV2ZW50IG9iamVjdCBmb3IgYW4gZXZlbnQgaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0gZSB0aGUgZXZlbnQgdGhhdCB3YXMgcmVjZWl2ZWQgYnkgdGhlIGV2ZW50IGhhbmRsZXIuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgIHdpdGggdHdvIHByb3BlcnRpZXM6XG4gKiAgICAgIHRhcmdldFxuICogICAgICAgICAgIHRoZSBlbGVtZW50IHdoZXJlIHRoZSBldmVudCBvY2N1cnJlZC5cbiAqICAgICAgb3JpZ2luYWxFdmVudFxuICogICAgICAgICAgIHRoZSBldmVudCBvYmplY3QsIGVpdGhlciBwYXJhbWV0ZXIgZSBvciB3aW5kb3cuZXZlbnQgKGluIElFKS5cbiAqL1xuVXRpbC5nZXRFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gIHZhciB0YXJnO1xuXG4gIGlmICghZSkge1xuICAgIC8vIGllIHB1dHMgZXZlbnQgaW4gZ2xvYmFsXG4gICAgZSA9IHdpbmRvdy5ldmVudDtcbiAgfVxuXG4gIC8vIGZpbmQgdGFyZ2V0XG4gIGlmIChlLnRhcmdldCkge1xuICAgIHRhcmcgPSBlLnRhcmdldDtcbiAgfSBlbHNlIGlmIChlLnNyY0VsZW1lbnQpIHtcbiAgICB0YXJnID0gZS5zcmNFbGVtZW50O1xuICB9XG5cbiAgLy8gaGFuZGxlIHNhZmFyaSBidWdcbiAgaWYgKHRhcmcubm9kZVR5cGUgPT09IDMpIHtcbiAgICB0YXJnID0gdGFyZy5wYXJlbnROb2RlO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRhcmdldCBhbmQgZXZlbnRcbiAgcmV0dXJuIHtcbiAgICB0YXJnZXQ6IHRhcmcsXG4gICAgb3JpZ2luYWxFdmVudDogZVxuICB9O1xufTtcblxuLyoqXG4gKiBHZXQgYSBwYXJlbnQgbm9kZSBiYXNlZCBvbiBpdCdzIG5vZGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0gZWwge0RPTUVsZW1lbnR9XG4gKiAgICAgIGVsZW1lbnQgdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0gbm9kZU5hbWUge1N0cmluZ31cbiAqICAgICAgbm9kZSBuYW1lIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0gbWF4UGFyZW50IHtET01FbGVtZW50fVxuICogICAgICBlbGVtZW50IHRvIHN0b3Agc2VhcmNoaW5nLlxuICogQHJldHVybiB7RE9NRWxlbWVudH1cbiAqICAgICAgbWF0Y2hpbmcgZWxlbWVudCwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gKi9cblV0aWwuZ2V0UGFyZW50Tm9kZSA9IGZ1bmN0aW9uIChlbCwgbm9kZU5hbWUsIG1heFBhcmVudCkge1xuICB2YXIgY3VyUGFyZW50ID0gZWw7XG5cbiAgd2hpbGUgKGN1clBhcmVudCAmJiBjdXJQYXJlbnQgIT09IG1heFBhcmVudCAmJlxuICAgICAgY3VyUGFyZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09IG5vZGVOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICBjdXJQYXJlbnQgPSBjdXJQYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuICBpZiAoY3VyUGFyZW50ICYmICdub2RlTmFtZScgaW4gY3VyUGFyZW50ICYmXG4gICAgICBjdXJQYXJlbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgIC8vIGZvdW5kIHRoZSBkZXNpcmVkIG5vZGVcbiAgICByZXR1cm4gY3VyUGFyZW50O1xuICB9XG5cbiAgLy8gZGlkbid0IGZpbmQgdGhlIGRlc2lyZWQgbm9kZVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIHJlbW92ZSBhbiBlbGVtZW50cyBjaGlsZCBub2Rlc1xuVXRpbC5lbXB0eSA9IGZ1bmN0aW9uIChlbCkge1xuICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG59O1xuXG4vLyBkZXRhY2ggYW4gZWxlbWVudCBmcm9tIGl0cyBwYXJlbnRcblV0aWwuZGV0YWNoID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gIH1cbn07XG5cblV0aWwuZ2V0V2luZG93U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRpbWVuc2lvbnMgPSB7d2lkdGg6bnVsbCxoZWlnaHQ6bnVsbH07XG5cbiAgaWYgKCdpbm5lcldpZHRoJyBpbiB3aW5kb3cgJiYgJ2lubmVySGVpZ2h0JyBpbiB3aW5kb3cpIHtcbiAgICBkaW1lbnNpb25zID0ge1xuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHByb2JhYmx5IElFPD04XG4gICAgdmFyIGVsZW0gPSAnZG9jdW1lbnRFbGVtZW50JyBpbiBkb2N1bWVudCA/XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGRvY3VtZW50LmJvZHk7XG5cbiAgICBkaW1lbnNpb25zID0ge1xuICAgICAgd2lkdGg6IGVsZW0ub2Zmc2V0V2lkdGgsXG4gICAgICBoZWlnaHQ6IGVsZW0ub2Zmc2V0SGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBkaW1lbnNpb25zO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBhIGNvbXBvc2l0aW9uIG9mIG90aGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqICAgICAgYShiKGMoeCkpKSA9PT0gY29tcG9zZShjLCBiLCBhKSh4KTtcbiAqXG4gKiBFYWNoIGZ1bmN0aW9uIHNob3VsZCBhY2NlcHQgYXMgYW4gYXJndW1lbnQsIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzXG4gKiBmdW5jdGlvbiBjYWxsIGluIHRoZSBjaGFpbi4gSXQgaXMgYWxsb3dhYmxlIGZvciBhbGwgZnVuY3Rpb25zIHRvIGhhdmUgbm9cbiAqIHJldHVybiB2YWx1ZSBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSAuLi4ge0Z1bmN0aW9ufSBBIHZhcmlhYmxlIHNldCBvZiBmdW5jdGlvbnMgdG8gY2FsbCwgaW4gb3JkZXIuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjb21wb3NpdGlvbiBvZiB0aGUgZnVuY3Rpb25zIHByb3ZpZGVkIGFzIGFyZ3VtZW50cy5cbiAqL1xuVXRpbC5jb21wb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZm5zID0gYXJndW1lbnRzO1xuXG4gIHJldHVybiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIGksXG4gICAgICAgIGZuLFxuICAgICAgICBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBmbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZuID0gZm5zW2ldO1xuXG4gICAgICBpZiAoZm4gJiYgZm4uY2FsbCkge1xuICAgICAgICByZXN1bHQgPSBmbi5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoZSBlbGVtZW50cyBvZiBhIGxvb2tpbmcgZm9yIGIuIGIgaXMgYXNzdW1lZCB0byBiZSBmb3VuZCBpZiBmb3JcbiAqIHNvbWUgb2JqZWN0IGluIGEgKGFbaV0pLCBhW2ldID09PSBiLiBOb3RlIHN0cmljdCBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0gYSB7QXJyYXl9XG4gKiAgICAgIEFuIGFycmF5IHRvIHNlYXJjaFxuICogQHBhcmFtIGIge01peGVkfVxuICogICAgICBBIHZhbHVlIHRvIHNlYXJjaCBmb3JcbiAqXG4gKiBAcmV0dXJuXG4gKiAgICAgIHRydWUgaWYgYXJyYXkgYSBjb250YWlucyBiXG4gKi9cblV0aWwuY29udGFpbnMgPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgaSwgbGVuO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYiA9PT0gYVtpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuXG4gKiAgICAgIHRydWUgaWYgb2JqZWN0IGlzIGFuIGFycmF5XG4gKi9cblV0aWwuaXNBcnJheSA9IGZ1bmN0aW9uIChhKSB7XG5cbiAgaWYgKHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfVxuXG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHNjcmlwdCBhc3luY2hyb25vdXNseS5cbiAqXG4gKiBAcGFyYW0gdXJsIHtTdHJpbmd9XG4gKiAgICAgICAgc2NyaXB0IHRvIGxvYWQuXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fVxuICogICAgICAgIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLnN1Y2Nlc3Mge0Z1bmN0aW9ufSBvcHRpb25hbC5cbiAqICAgICAgICBjYWxsZWQgYWZ0ZXIgc2NyaXB0IGxvYWRzIHN1Y2Nlc3NmdWxseS5cbiAqIEBwYXJhbSBvcHRpb25zLmVycm9yIHtGdW5jdGlvbn0gb3B0aW9uYWwuXG4gKiAgICAgICAgY2FsbGVkIGFmdGVyIHNjcmlwdCBmYWlscyB0byBsb2FkLlxuICogQHBhcmFtIG9wdGlvbnMuZG9uZSB7RnVuY3Rpb259IG9wdGlvbmFsXG4gKiAgICAgICAgY2FsbGVkIGFmdGVyIGxvYWRTY3JpcHQgaXMgY29tcGxldGUsXG4gKiAgICAgICAgYWZ0ZXIgY2FsbGluZyBzdWNjZXNzIG9yIGVycm9yLlxuICovXG5VdGlsLmxvYWRTY3JpcHQgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIC8vIGxvYWQgc2Vjb25kYXJ5IHNjcmlwdFxuICB2YXIgY2xlYW51cCxcbiAgICAgIGRvbmUsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25Mb2FkLFxuICAgICAgc2NyaXB0O1xuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwge1xuICAgIHN1Y2Nlc3M6IG51bGwsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgZG9uZTogbnVsbFxuICB9LCBvcHRpb25zKTtcblxuICBjbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIHNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIGNsZWFudXAgPSBudWxsO1xuICAgIG9uTG9hZCA9IG51bGw7XG4gICAgb25FcnJvciA9IG51bGw7XG4gICAgc2NyaXB0ID0gbnVsbDtcbiAgfTtcblxuICBkb25lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRpb25zLmRvbmUgIT09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZG9uZSgpO1xuICAgIH1cbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfTtcblxuICBvbkVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAob3B0aW9ucy5lcnJvciAhPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5lcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBkb25lKCk7XG4gIH07XG5cbiAgb25Mb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAob3B0aW9ucy5zdWNjZXNzICE9PSBudWxsKSB7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgZG9uZSgpO1xuICB9O1xuXG4gIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICBzY3JpcHQuc3JjID0gdXJsO1xuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHQnKS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHNjcmlwdCk7XG59O1xuXG5cbi8vIERvIHRoZXNlIGNoZWNrcyBvbmNlIGFuZCBjYWNoZSB0aGUgcmVzdWx0c1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciB0ZXN0SW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICB2YXIgc3RyID0gbmF2aWdhdG9yLnVzZXJBZ2VudHx8bmF2aWdhdG9yLnZlbmRvcnx8d2luZG93Lm9wZXJhO1xuXG4gIGlzTW9iaWxlID0gc3RyLm1hdGNoKC8oQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8V2luZG93cyBQaG9uZSkvaSk7XG4gIHRlc3RJbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZGF0ZScpO1xuICBzdXBwb3J0c0RhdGVJbnB1dCA9ICh0ZXN0SW5wdXQudHlwZSAhPT0gJ3RleHQnKTtcblxuICAvLyBjbGVhbiB1cCB0ZXN0aW5nIGVsZW1lbnRcbiAgdGVzdEVsID0gbnVsbDtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbDsiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFV0aWwgPSByZXF1aXJlKCcuL1V0aWwnKTtcblxuXG52YXIgX0NBTExCQUNLX1NFUVVFTkNFID0gMDtcblxuLy8gZGVmYXVsdHMgZm9yIGpzb25wIG1ldGhvZFxudmFyIF9ERUZBVUxUX0pTT05QX09QVElPTlMgPSB7XG4gIHVybDogbnVsbCxcbiAgc3VjY2VzczogbnVsbCxcbiAgZXJyb3I6IG51bGwsXG4gIGRvbmU6IG51bGwsXG4gIGRhdGE6IG51bGwsXG4gIGNhbGxiYWNrTmFtZTogbnVsbCxcbiAgY2FsbGJhY2tQYXJhbWV0ZXI6ICdjYWxsYmFjaydcbn07XG5cbi8vIGRlZmF1bHRzIGZvciBhamF4IG1ldGhvZFxudmFyIF9ERUZBVUxUX0FKQVhfT1BUSU9OUyA9IHtcbiAgdXJsOiBudWxsLFxuICBzdWNjZXNzOiBudWxsLFxuICBlcnJvcjogbnVsbCxcbiAgZG9uZTogbnVsbCxcbiAgbWV0aG9kOiAnR0VUJyxcbiAgaGVhZGVyczogbnVsbCxcbiAgZGF0YTogbnVsbCxcbiAgcmF3ZGF0YTogbnVsbFxufTtcblxuLy8gQVBJIE1ldGhvZCBEZWNsYXJhdGlvbnNcblxudmFyIGFqYXgsXG4gICAgZ2V0Q2FsbGJhY2tOYW1lLFxuICAgIGpzb25wLFxuICAgIHJlc3RyaWN0T3JpZ2luLFxuICAgIHVybEVuY29kZTtcblxuXG4vLyBBUEkgTWV0aG9kIERlZmluaXRpb25zXG5cbi8qKlxuICogTWFrZSBhbiBBSkFYIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMudXJsIHtTdHJpbmd9XG4gKiAgICAgIHRoZSB1cmwgdG8gcmVxdWVzdC5cbiAqIEBwYXJhbSBvcHRpb25zLnN1Y2Nlc3Mge0Z1bmN0aW9ufVxuICogICAgICBjYWxsZWQgd2l0aCBkYXRhIGxvYWRlZCBieSBzY3JpcHRcbiAqIEBwYXJhbSBvcHRpb25zLmVycm9yIHtGdW5jdGlvbn0gb3B0aW9uYWxcbiAqICAgICAgY2FsbGVkIHdoZW4gc2NyaXB0IGZhaWxzIHRvIGxvYWRcbiAqIEBwYXJhbSBvcHRpb25zLmRvbmUge0Z1bmN0aW9ufVxuICogICAgICAgIGNhbGxlZCB3aGVuIGFqYXggaXMgY29tcGxldGUsIGFmdGVyIHN1Y2Nlc3Mgb3IgZXJyb3IuXG4gKiBAcGFyYW0gb3B0aW9ucy5tZXRob2Qge1N0cmluZ31cbiAqICAgICAgcmVxdWVzdCBtZXRob2QsIGRlZmF1bHQgaXMgJ0dFVCdcbiAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMge09iamVjdH1cbiAqICAgICAgcmVxdWVzdCBoZWFkZXIgbmFtZSBhcyBrZXksIHZhbHVlIGFzIHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSB7T2JqZWN0fVxuICogICAgICByZXF1ZXN0IGRhdGEsIHNlbnQgdXNpbmcgY29udGVudCB0eXBlXG4gKiAgICAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLlxuICogQHBhcmFtIG9wdGlvbnMucmF3ZGF0YSB7P31cbiAqICAgICAgcGFzc2VkIGRpcmVjdGx5IHRvIHNlbmQgbWV0aG9kLCB3aGVuIG9wdGlvbnMuZGF0YSBpcyBudWxsLlxuICogICAgICBDb250ZW50LXR5cGUgaGVhZGVyIG11c3QgYWxzbyBiZSBzcGVjaWZpZWQuIERlZmF1bHQgaXMgbnVsbC5cbiAqL1xuYWpheCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBoLFxuICAgICAgcG9zdGRhdGEsXG4gICAgICBxdWVyeVN0cmluZyxcbiAgICAgIHVybCxcbiAgICAgIHhocjtcblxuICBvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIF9ERUZBVUxUX0FKQVhfT1BUSU9OUywgb3B0aW9ucyk7XG4gIHVybCA9IG9wdGlvbnMudXJsO1xuXG4gIGlmIChvcHRpb25zLnJlc3RyaWN0T3JpZ2luKSB7XG4gICAgdXJsID0gcmVzdHJpY3RPcmlnaW4odXJsKTtcbiAgfVxuICBwb3N0ZGF0YSA9IG9wdGlvbnMucmF3ZGF0YTtcblxuICBpZiAob3B0aW9ucy5kYXRhICE9PSBudWxsKSB7XG4gICAgcXVlcnlTdHJpbmcgPSB1cmxFbmNvZGUob3B0aW9ucy5kYXRhKTtcbiAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAvLyBhcHBlbmQgdG8gdXJsXG4gICAgICB1cmwgPSB1cmwgKyAnPycgKyBxdWVyeVN0cmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIHNlbmQgYXMgcmVxdWVzdCBib2R5XG4gICAgICBwb3N0ZGF0YSA9IHF1ZXJ5U3RyaW5nO1xuICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyA9PT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCByZXF1ZXN0IGNvbnRlbnQgdHlwZVxuICAgICAgb3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgIH1cbiAgfVxuXG4gIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gIC8vIHNldHVwIGNhbGxiYWNrXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEsIGNvbnRlbnRUeXBlO1xuXG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MgIT09IG51bGwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKCdqc29uJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKGRhdGEsIHhocik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcihlLCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgICBvcHRpb25zLmVycm9yKHhoci5zdGF0dXMsIHhocik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmRvbmUgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5kb25lKHhocik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIG9wZW4gcmVxdWVzdFxuICB4aHIub3BlbihvcHRpb25zLm1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAvLyBzZW5kIGhlYWRlcnNcbiAgaWYgKG9wdGlvbnMuaGVhZGVycyAhPT0gbnVsbCkge1xuICAgIGZvciAoaCBpbiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGgsIG9wdGlvbnMuaGVhZGVyc1toXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2VuZCBkYXRhXG4gIHhoci5zZW5kKHBvc3RkYXRhKTtcblxuICByZXR1cm4geGhyO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHVuaXF1ZSBjYWxsYmFjayBuYW1lLlxuICpcbiAqIEByZXR1cm4gYSB1bmlxdWUgY2FsbGJhY2sgbmFtZS5cbiAqL1xuZ2V0Q2FsbGJhY2tOYW1lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ194aHJfY2FsbGJhY2tfJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpICtcbiAgICAgICdfJyArICgrK19DQUxMQkFDS19TRVFVRU5DRSk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBKU09OUCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zLnVybCB7U3RyaW5nfVxuICogICAgICB1cmwgdG8gbG9hZFxuICogQHBhcmFtIG9wdGlvbnMuc3VjY2VzcyB7RnVuY3Rpb259XG4gKiAgICAgIGNhbGxlZCB3aXRoIGRhdGEgbG9hZGVkIGJ5IHNjcmlwdFxuICogQHBhcmFtIG9wdGlvbnMuZXJyb3Ige0Z1bmN0aW9ufSBvcHRpb25hbFxuICogICAgICBjYWxsZWQgd2hlbiBzY3JpcHQgZmFpbHMgdG8gbG9hZFxuICogQHBhcmFtIG9wdGlvbnMuZG9uZSB7RnVuY3Rpb259IG9wdGlvbmFsXG4gKiAgICAgICAgY2FsbGVkIHdoZW4ganNvbnAgaXMgY29tcGxldGUsIGFmdGVyIHN1Y2Nlc3Mgb3IgZXJyb3IuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIHtPYmplY3R9IG9wdGlvbmFsXG4gKiAgICAgIHJlcXVlc3QgcGFyYW1ldGVycyB0byBhZGQgdG8gdXJsXG4gKlxuICogQHBhcmFtIG9wdGlvbnMuY2FsbGJhY2tOYW1lIHtTdHJpbmd9IG9wdGlvbmFsXG4gKiBAcGFyYW0gb3B0aW9ucy5jYWxsYmFja1BhcmFtZXRlciB7U3RyaW5nfSBvcHRpb25hbFxuICogICAgICBkZWZhdWx0IGlzICdjYWxsYmFjaydcbiAqL1xuanNvbnAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgZGF0YSxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgdXJsO1xuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRfSlNPTlBfT1BUSU9OUywgb3B0aW9ucyk7XG4gIHVybCA9IG9wdGlvbnMudXJsO1xuICBkYXRhID0gVXRpbC5leHRlbmQoe30sIG9wdGlvbnMuZGF0YSk7XG4gIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFja05hbWUgfHwgZ2V0Q2FsbGJhY2tOYW1lKCk7XG5cbiAgLy8gYWRkIGRhdGEgYW5kIGNhbGxiYWNrIHRvIHVybFxuICBkYXRhW29wdGlvbnMuY2FsbGJhY2tQYXJhbWV0ZXJdID0gY2FsbGJhY2s7XG4gIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgdXJsRW5jb2RlKGRhdGEpO1xuXG4gIC8vIHNldHVwIGdsb2JhbCBjYWxsYmFjayBjYWxsZWQgYnkgc2NyaXB0XG4gIHdpbmRvd1tjYWxsYmFja10gPSBmdW5jdGlvbiAoKSB7XG4gICAgb3B0aW9ucy5zdWNjZXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgVXRpbC5sb2FkU2NyaXB0KHVybCwge1xuICAgIGVycm9yOiBvcHRpb25zLmVycm9yLFxuICAgIGRvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdpbmRvd1tjYWxsYmFja10gPSBudWxsO1xuICAgICAgZGVsZXRlIHdpbmRvd1tjYWxsYmFja107XG5cbiAgICAgIGlmIChvcHRpb25zLmRvbmUgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5kb25lKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnJlc3RyaWN0T3JpZ2luID0gZnVuY3Rpb24gKHVybCkge1xuICB2YXIgYSxcbiAgICAgIHJlc3RyaWN0ZWRVcmw7XG5cbiAgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTsgLy8gSGFjayB0byBwYXJzZSBvbmx5IHRoZSBwYXRobmFtZVxuICBhLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gIHJlc3RyaWN0ZWRVcmwgPSBhLnBhdGhuYW1lO1xuXG4gIC8vIE5lZWRlZCBmb3IgSUUsIHdoaWNoIG9taXRzIGxlYWRpbmcgc2xhc2guXG4gIGlmICgodXJsLmluZGV4T2YoJ2h0dHAnKSA9PT0gMCB8fCB1cmwuaW5kZXhPZignLycpID09PSAwKSAmJlxuICAgICAgcmVzdHJpY3RlZFVybC5pbmRleE9mKCcvJykgIT09IDApIHtcbiAgICByZXN0cmljdGVkVXJsID0gJy8nICsgcmVzdHJpY3RlZFVybDtcbiAgfVxuXG4gIHJldHVybiByZXN0cmljdGVkVXJsO1xufTtcblxuLyoqXG4gKiBVUkwgZW5jb2RlIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHtPYmplY3R9XG4gKiAgICAgIG9iamVjdCB0byBlbmNvZGVcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiAgICAgIHVybCBlbmNvZGVkIG9iamVjdFxuICovXG51cmxFbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBkYXRhLCBrZXksIGVuY29kZWRLZXksIHZhbHVlLCBpLCBsZW47XG5cbiAgZGF0YSA9IFtdO1xuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBlbmNvZGVkS2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSk7XG4gICAgdmFsdWUgPSBvYmpba2V5XTtcblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAvLyBBZGQgZWFjaCB2YWx1ZSBpbiBhcnJheSBzZXBlcmF0ZWx5XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBkYXRhLnB1c2goZW5jb2RlZEtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtpXSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnB1c2goZW5jb2RlZEtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YS5qb2luKCcmJyk7XG59O1xuXG5cbi8vIGV4cG9zZSB0aGUgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWpheDogYWpheCxcbiAgZ2V0Q2FsbGJhY2tOYW1lOiBnZXRDYWxsYmFja05hbWUsXG4gIGpzb25wOiBqc29ucCxcbiAgcmVzdHJpY3RPcmlnaW46IHJlc3RyaWN0T3JpZ2luLFxuICB1cmxFbmNvZGU6IHVybEVuY29kZSxcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kdWxlID0gcmVxdWlyZSgnY29yZS9Nb2R1bGUnKSxcbiAgICBTY2llbnRpZmljU3VtbWFyeU1vZHVsZSA9IHJlcXVpcmUoJ3NjaWVudGlmaWMvU2NpZW50aWZpY1N1bW1hcnlNb2R1bGUnKSxcbiAgICBVdGlsID0gcmVxdWlyZSgndXRpbC9VdGlsJyksXG4gICAgWGhyID0gcmVxdWlyZSgndXRpbC9YaHInKTtcblxudmFyIF9ERUZBVUxUUyxcbiAgICBfSUQsXG4gICAgX1RJVExFLFxuXG4gICAgX2hhc0NvbnRlbnQ7XG5cblxuX0RFRkFVTFRTID0ge1xuICBpcmlzU2VydmljZVVybDogJ2h0dHBzOi8vc2VydmljZS5pcmlzLmVkdS9mZHNud3MvZXZlbnQvMS9xdWVyeScsXG4gIGlyaXNTcHVkVXJsOidodHRwczovL3d3dy5pcmlzLmVkdS9zcHVkL2V2ZW50LycsXG4gIGlyaXNXaWxiZXJVcmw6J2h0dHBzOi8vd3d3LmlyaXMuZWR1L3dpbGJlcjMvZmluZF9zdGF0aW9ucy8nLFxuICBlcnJvck1lc3NhZ2U6ICc8cCBjbGFzcz1cImFsZXJ0IGVycm9yXCI+RXJyb3IgZmluZGluZyB3YXZlZm9ybSBkYXRhPC9wPidcbn07XG5fSUQgPSAnd2F2ZWZvcm0nO1xuX1RJVExFID0gJ1dhdmVmb3Jtcyc7XG5cblxuX2hhc0NvbnRlbnQgPSBmdW5jdGlvbiAoZXZlbnRQYWdlTW9kZWwpIHtcbiAgdmFyIGNvbmZpZztcblxuICBjb25maWcgPSBldmVudFBhZ2VNb2RlbC5nZXQoJ2NvbmZpZycpO1xuICByZXR1cm4gY29uZmlnLmhhc093blByb3BlcnR5KCdTQ0VOQVJJT19NT0RFJykgP1xuICAgICAgIWNvbmZpZy5TQ0VOQVJJT19NT0RFIDogdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBXYXZlZm9ybSBtb2R1bGVcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fVxuICogICAgdXJsIG9wdGlvbnNcbiAqL1xudmFyIFdhdmVmb3JtTW9kdWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzLFxuICAgICAgX2luaXRpYWxpemUsXG5cbiAgICAgIF9lcnJvck1lc3NhZ2UsXG4gICAgICBfZXZlbnRJZCxcbiAgICAgIF9pcmlzU2VydmljZVVybCxcbiAgICAgIF9pcmlzU3B1ZFVybCxcbiAgICAgIF9pcmlzV2lsYmVyVXJsLFxuICAgICAgX3dhdmVmb3JtQ29udGVudEVsO1xuXG4gIG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgX0RFRkFVTFRTLCBvcHRpb25zKTtcbiAgX3RoaXMgPSBNb2R1bGUob3B0aW9ucyk7XG5cbiAgX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuSUQgPSBfSUQ7XG4gICAgX3RoaXMuVElUTEUgPSBfVElUTEU7XG5cbiAgICBfZXJyb3JNZXNzYWdlID0gb3B0aW9ucy5lcnJvck1lc3NhZ2U7XG4gICAgX2lyaXNTZXJ2aWNlVXJsID0gb3B0aW9ucy5pcmlzU2VydmljZVVybDtcbiAgICBfaXJpc1NwdWRVcmwgPSBvcHRpb25zLmlyaXNTcHVkVXJsO1xuICAgIF9pcmlzV2lsYmVyVXJsID0gb3B0aW9ucy5pcmlzV2lsYmVyVXJsO1xuXG4gICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnd2F2ZS1mb3JtJyk7XG4gIH07XG5cbiAgX3RoaXMuZGVzdHJveSA9IFV0aWwuY29tcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgX2luaXRpYWxpemUgPSBudWxsO1xuICAgIF90aGlzID0gbnVsbDtcblxuICAgIF93YXZlZm9ybUNvbnRlbnRFbCA9IG51bGw7XG4gICAgX2lyaXNXaWxiZXJVcmw9IG51bGw7XG4gICAgX2lyaXNTcHVkVXJsID0gbnVsbDtcbiAgICBfaXJpc1NlcnZpY2VVcmwgPSBudWxsO1xuICAgIF9ldmVudElkID0gbnVsbDtcbiAgICBfZXJyb3JNZXNzYWdlID0gbnVsbDtcbiAgfSwgX3RoaXMuZGVzdHJveSk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRhdGEuXG4gICAqIEBwYXJhbSBzZWFyY2gge29iamVjdH1cbiAgICogICAgU2VhcmNoIHBhcmFtZXRlcnMuXG4gICAqL1xuICBfdGhpcy5mZXRjaERhdGEgPSBmdW5jdGlvbiAoc2VhcmNoKSB7XG4gICAgWGhyLmFqYXgoe1xuICAgICAgdXJsOiBfaXJpc1NlcnZpY2VVcmwsXG4gICAgICBkYXRhOiBzZWFyY2gsXG4gICAgICBzdWNjZXNzOiBfdGhpcy5vblN1Y2Nlc3MsXG4gICAgICBlcnJvcjogX3RoaXMub25FcnJvcixcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBzZWFyY2ggcGFyYW1ldGVycyBmcm9tIHRoZSBtb2RlbCBhbmQgY3JlYXRlcyBzZWFyY2ggb2JqZWN0XG4gICAqL1xuICBfdGhpcy5nZXRTZWFyY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2LFxuICAgICAgICBsYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlLFxuICAgICAgICBzZWFyY2gsXG4gICAgICAgIHN1bW1hcnksXG4gICAgICAgIHRpbWU7XG5cbiAgICBldiA9IF90aGlzLm1vZGVsLmdldCgnZXZlbnQnKTtcbiAgICBzZWFyY2ggPSBudWxsO1xuXG4gICAgaWYgKGV2KSB7XG4gICAgICBzdW1tYXJ5ID0gZXYuZ2V0U3VtbWFyeSgpO1xuICAgICAgbGF0aXR1ZGUgPSBzdW1tYXJ5LmxhdGl0dWRlO1xuICAgICAgbG9uZ2l0dWRlID0gc3VtbWFyeS5sb25naXR1ZGU7XG4gICAgICB0aW1lID0gTnVtYmVyKHN1bW1hcnkudGltZS5nZXRUaW1lKCkpO1xuICAgICAgLy8gc2VhcmNoIHBhcmFtZXRlcnNcbiAgICAgIHNlYXJjaCA9IHtcbiAgICAgICAgJ3N0YXJ0dGltZSc6IG5ldyBEYXRlKHRpbWUgLSAxNjAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgJycpLFxuICAgICAgICAnZW5kdGltZSc6IG5ldyBEYXRlKHRpbWUgKyAxNjAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgJycpLFxuICAgICAgICAnbGF0aXR1ZGUnOiBsYXRpdHVkZSxcbiAgICAgICAgJ2xvbmdpdHVkZSc6IGxvbmdpdHVkZSxcbiAgICAgICAgJ21heHJhZGl1cyc6IDEsXG4gICAgICAgICdmb3JtYXQnOiAndGV4dCdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlYXJjaDtcbiAgfTtcblxuICAvKipcbiAgICogU2hvd3MgZGVmYXVsdCBlcnJvciBtZXNzYWdlIHdoaWNoIGNhbiBiZSBjaGFuZ2VkLlxuICAgKi9cbiAgX3RoaXMub25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5lbC5pbm5lckhUTUwgPSBfZXJyb3JNZXNzYWdlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBvblN1Y2Nlc3MgaXMgY2FsbGVkIHdoZW4gWGhyIGlzIHN1Y2Nlc3NmdWwgYW5kIGNhbGxzIGV2ZW50SWQgaWYgbm8gZXZlbnRcbiAgICogaXMgZm91bmQuIElmIGFuIGV2ZW50IGlzIGZvdW5kIGl0IGNhbGxzIHJlbmRlckNvbnRlbnQuXG4gICAqIEBwYXJhbSBkYXRhIHtzdHJpbmd9XG4gICAqICAgIGRhdGEgaW4gc3RyaW5nIGZvcm1hdC5cbiAgICovXG4gIF90aGlzLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGV2ZW50SWQ7XG5cbiAgICBldmVudElkID0gX3RoaXMucGFyc2VJcmlzRXZlbnRJZChkYXRhKTtcblxuICAgIGlmICghZXZlbnRJZCkge1xuICAgICAgX3RoaXMub25FcnJvcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF90aGlzLnJlbmRlckNvbnRlbnQoZXZlbnRJZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgZXZlbnRJZCBmcm9tIGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9XG4gICAqICAgIGRhdGEgaW4gc3RyaW5nIGZvcm1hdC5cbiAgICovXG4gIF90aGlzLnBhcnNlSXJpc0V2ZW50SWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnNwbGl0KCdcXG4nKVsxXS5zcGxpdCgnfCcpWzBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgbW9kZWwgY2hhbmdlc1xuICAgKi9cbiAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWFyY2g7XG5cbiAgICBfdGhpcy5oZWFkZXIuaW5uZXJIVE1MID0gJzxoMz5XYXZlZm9ybXM8L2gzPicgK1xuICAgICAgICAnPGEgY2xhc3M9XCJiYWNrLXRvLXN1bW1hcnktbGlua1wiJyArXG4gICAgICAgICcgaHJlZj1cIiMnICsgU2NpZW50aWZpY1N1bW1hcnlNb2R1bGUuSUQgKyAnXCI+QmFjayB0byAnICtcbiAgICAgICAgU2NpZW50aWZpY1N1bW1hcnlNb2R1bGUuVElUTEUgKyAnPC9hPic7XG5cbiAgICBzZWFyY2ggPSBfdGhpcy5nZXRTZWFyY2goKTtcblxuICAgIGlmIChzZWFyY2ggPT09IG51bGwpIHtcbiAgICAgIF90aGlzLm9uRXJyb3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuZmV0Y2hEYXRhKHNlYXJjaCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIG1haW4gY29udGVudCBhbmQgYWRkcyB1cmxzLlxuICAgKiBAcGFyYW0gZXZlbnRJZCB7c3RyaW5nfVxuICAgKiAgICBUaGUgZXZlbnQgaWQgcGFyc2VkIGZyb20gZGF0YS5cbiAgICovXG4gIF90aGlzLnJlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiAoZXZlbnRJZCkge1xuICAgIF90aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gW1xuICAgICAgJzxkbCBjbGFzcz1cImlyaXMtcHJvZHVjdHMgdmVydGljYWxcIj4nLFxuICAgICAgICAnPGR0PicsXG4gICAgICAgICAgJzxhIGhyZWY9XCInLCBfaXJpc1dpbGJlclVybCwgZXZlbnRJZCwgJ1wiIHRhcmdldD1cIl9ibGFua1wiPicsXG4gICAgICAgICAgICAnSVJJUyBTZWlzbWljIFdhdmVmb3JtIERhdGEgKFdpbGJlciAzKScsXG4gICAgICAgICAgJzwvYT4nLFxuICAgICAgICAnPC9kdD4nLFxuICAgICAgICAnPGRkPicsXG4gICAgICAgICAgJ1dpbGJlciAzIGxvY2F0ZXMgc3RhdGlvbnMgaW4gb3BlcmF0aW9uIGF0IHRoZSB0aW1lIG9mIHRoZSBldmVudCwnLFxuICAgICAgICAgICcgYWxsb3dzIHVzZXJzIHRvIGZpbHRlciBzdGF0aW9ucywgcHJldmlldyB3YXZlZm9ybSBkYXRhLCBhbmQnLFxuICAgICAgICAgICcgdmlldyByZWNvcmQgc2VjdGlvbiBwbG90cy4gRGF0YSBjYW4gYmUgZG93bmxvYWRlZCBpbiBhJyxcbiAgICAgICAgICAnIG51bWJlciBvZiBmb3JtYXRzIGluY2x1ZGluZyA8YWJiciB0aXRsZT1cIlNlaXNtaWMgQW5hbHlzaXMnLFxuICAgICAgICAgICcgQ29kZVwiPlNBQzwvYWJicj4sIDxhYmJyIHRpdGxlPVwiU3RhbmRhcmQgZm9yIHRoZSBFeGNoYW5nZSBvZicsXG4gICAgICAgICAgJyBFYXJ0aHF1YWtlIERhdGFcIj5TRUVEPC9hYmJyPiwgbWluaVNFRUQgYW5kIEFTQ0lJLicsXG4gICAgICAgICc8L2RkPicsXG5cbiAgICAgICAgJzxkdD4nLFxuICAgICAgICAgICc8YSBocmVmPVwiJywgX2lyaXNTcHVkVXJsLCBldmVudElkLCAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JyxcbiAgICAgICAgICAgICdJUklTIFNlYXJjaGFibGUgUHJvZHVjdCBEZXBvc2l0b3J5IChTUFVEKSBFdmVudCBQYWdlJyxcbiAgICAgICAgICAnPC9hPicsXG4gICAgICAgICc8L2R0PicsXG4gICAgICAgICc8ZGQ+JyxcbiAgICAgICAgICAnU1BVRCBpcyB0aGUgSVJJUyBETUMmcnNxdW87cyBwcmltYXJ5IGRhdGEgcHJvZHVjdCBtYW5hZ2VtZW50IHN5c3RlbS4nLFxuICAgICAgICAgICcgQ29tcGxlbWVudGluZyB0aGUgRE1DJnJzcXVvO3MgU0VFRCBhbmQgYXNzZW1ibGVkIGRhdGEgYXJjaGl2ZXMsJyxcbiAgICAgICAgICAnIHdoaWNoIGNvbnRhaW4gdGltZSBzZXJpZXMgcmVjb3JkaW5ncywgdGhlIFNQVUQgc3lzdGVtJyxcbiAgICAgICAgICAnIHByaW1hcmlseSBjb250YWlucyBkZXJpdmF0aXZlIGRhdGEgcHJvZHVjdHMgb2Ygb3RoZXIgdHlwZXMnLFxuICAgICAgICAgICcgKGltYWdlcywgbW92aWVzLCBldGMuKSBjcmVhdGVkIGVpdGhlciBhdCB0aGUgRE1DIG9yIGJ5IG1lbWJlcnMnLFxuICAgICAgICAgICcgb2YgdGhlIGNvbW11bml0eS4nLFxuICAgICAgICAnPC9kZD4nLFxuICAgICAgJzwvZGw+J1xuICAgIF0uam9pbignJyk7XG4gIH07XG5cbiAgX2luaXRpYWxpemUob3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBudWxsO1xuICByZXR1cm4gX3RoaXM7XG59O1xuXG5XYXZlZm9ybU1vZHVsZS5JRCA9IF9JRDtcbldhdmVmb3JtTW9kdWxlLlRJVExFID0gX1RJVExFO1xuV2F2ZWZvcm1Nb2R1bGUuaGFzQ29udGVudCA9IF9oYXNDb250ZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdhdmVmb3JtTW9kdWxlO1xuIl19
